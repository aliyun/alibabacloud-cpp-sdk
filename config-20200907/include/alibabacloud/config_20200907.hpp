// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CONFIG20200907_H_
#define ALIBABACLOUD_CONFIG20200907_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Config20200907 {
class ResourceDirectoryFolderNode : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<vector<ResourceDirectoryFolderNode>> children{};
  shared_ptr<string> displayName{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderName{};
  shared_ptr<string> parentFolderId{};

  ResourceDirectoryFolderNode() {}

  explicit ResourceDirectoryFolderNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (parentFolderId) {
      res["ParentFolderId"] = boost::any(*parentFolderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<ResourceDirectoryFolderNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResourceDirectoryFolderNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<ResourceDirectoryFolderNode>>(expect1);
      }
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ParentFolderId") != m.end() && !m["ParentFolderId"].empty()) {
      parentFolderId = make_shared<string>(boost::any_cast<string>(m["ParentFolderId"]));
    }
  }


  virtual ~ResourceDirectoryFolderNode() = default;
};
class ActiveAggregateConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  ActiveAggregateConfigRulesRequest() {}

  explicit ActiveAggregateConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~ActiveAggregateConfigRulesRequest() = default;
};
class ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class ActiveAggregateConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  ActiveAggregateConfigRulesResponseBodyOperateRuleResult() {}

  explicit ActiveAggregateConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~ActiveAggregateConfigRulesResponseBodyOperateRuleResult() = default;
};
class ActiveAggregateConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ActiveAggregateConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  ActiveAggregateConfigRulesResponseBody() {}

  explicit ActiveAggregateConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        ActiveAggregateConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<ActiveAggregateConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActiveAggregateConfigRulesResponseBody() = default;
};
class ActiveAggregateConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActiveAggregateConfigRulesResponseBody> body{};

  ActiveAggregateConfigRulesResponse() {}

  explicit ActiveAggregateConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActiveAggregateConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActiveAggregateConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ActiveAggregateConfigRulesResponse() = default;
};
class ActiveConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};

  ActiveConfigRulesRequest() {}

  explicit ActiveConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~ActiveConfigRulesRequest() = default;
};
class ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class ActiveConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  ActiveConfigRulesResponseBodyOperateRuleResult() {}

  explicit ActiveConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~ActiveConfigRulesResponseBodyOperateRuleResult() = default;
};
class ActiveConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ActiveConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  ActiveConfigRulesResponseBody() {}

  explicit ActiveConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        ActiveConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<ActiveConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActiveConfigRulesResponseBody() = default;
};
class ActiveConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActiveConfigRulesResponseBody> body{};

  ActiveConfigRulesResponse() {}

  explicit ActiveConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActiveConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActiveConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ActiveConfigRulesResponse() = default;
};
class AttachAggregateConfigRuleToCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleIds{};

  AttachAggregateConfigRuleToCompliancePackRequest() {}

  explicit AttachAggregateConfigRuleToCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~AttachAggregateConfigRuleToCompliancePackRequest() = default;
};
class AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult() {}

  explicit AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult() = default;
};
class AttachAggregateConfigRuleToCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  AttachAggregateConfigRuleToCompliancePackResponseBody() {}

  explicit AttachAggregateConfigRuleToCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachAggregateConfigRuleToCompliancePackResponseBody() = default;
};
class AttachAggregateConfigRuleToCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachAggregateConfigRuleToCompliancePackResponseBody> body{};

  AttachAggregateConfigRuleToCompliancePackResponse() {}

  explicit AttachAggregateConfigRuleToCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachAggregateConfigRuleToCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachAggregateConfigRuleToCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~AttachAggregateConfigRuleToCompliancePackResponse() = default;
};
class AttachConfigRuleToCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleIds{};

  AttachConfigRuleToCompliancePackRequest() {}

  explicit AttachConfigRuleToCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~AttachConfigRuleToCompliancePackRequest() = default;
};
class AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult() {}

  explicit AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult() = default;
};
class AttachConfigRuleToCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  AttachConfigRuleToCompliancePackResponseBody() {}

  explicit AttachConfigRuleToCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachConfigRuleToCompliancePackResponseBody() = default;
};
class AttachConfigRuleToCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachConfigRuleToCompliancePackResponseBody> body{};

  AttachConfigRuleToCompliancePackResponse() {}

  explicit AttachConfigRuleToCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachConfigRuleToCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachConfigRuleToCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~AttachConfigRuleToCompliancePackResponse() = default;
};
class CopyCompliancePacksRequest : public Darabonba::Model {
public:
  shared_ptr<string> desAggregatorIds{};
  shared_ptr<string> srcAggregatorId{};
  shared_ptr<string> srcCompliancePackIds{};

  CopyCompliancePacksRequest() {}

  explicit CopyCompliancePacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desAggregatorIds) {
      res["DesAggregatorIds"] = boost::any(*desAggregatorIds);
    }
    if (srcAggregatorId) {
      res["SrcAggregatorId"] = boost::any(*srcAggregatorId);
    }
    if (srcCompliancePackIds) {
      res["SrcCompliancePackIds"] = boost::any(*srcCompliancePackIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesAggregatorIds") != m.end() && !m["DesAggregatorIds"].empty()) {
      desAggregatorIds = make_shared<string>(boost::any_cast<string>(m["DesAggregatorIds"]));
    }
    if (m.find("SrcAggregatorId") != m.end() && !m["SrcAggregatorId"].empty()) {
      srcAggregatorId = make_shared<string>(boost::any_cast<string>(m["SrcAggregatorId"]));
    }
    if (m.find("SrcCompliancePackIds") != m.end() && !m["SrcCompliancePackIds"].empty()) {
      srcCompliancePackIds = make_shared<string>(boost::any_cast<string>(m["SrcCompliancePackIds"]));
    }
  }


  virtual ~CopyCompliancePacksRequest() = default;
};
class CopyCompliancePacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> copyRulesResult{};
  shared_ptr<string> requestId{};

  CopyCompliancePacksResponseBody() {}

  explicit CopyCompliancePacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copyRulesResult) {
      res["CopyRulesResult"] = boost::any(*copyRulesResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CopyRulesResult") != m.end() && !m["CopyRulesResult"].empty()) {
      copyRulesResult = make_shared<bool>(boost::any_cast<bool>(m["CopyRulesResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyCompliancePacksResponseBody() = default;
};
class CopyCompliancePacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyCompliancePacksResponseBody> body{};

  CopyCompliancePacksResponse() {}

  explicit CopyCompliancePacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyCompliancePacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyCompliancePacksResponseBody>(model1);
      }
    }
  }


  virtual ~CopyCompliancePacksResponse() = default;
};
class CopyConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> desAggregatorIds{};
  shared_ptr<string> srcAggregatorId{};
  shared_ptr<string> srcConfigRuleIds{};

  CopyConfigRulesRequest() {}

  explicit CopyConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desAggregatorIds) {
      res["DesAggregatorIds"] = boost::any(*desAggregatorIds);
    }
    if (srcAggregatorId) {
      res["SrcAggregatorId"] = boost::any(*srcAggregatorId);
    }
    if (srcConfigRuleIds) {
      res["SrcConfigRuleIds"] = boost::any(*srcConfigRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesAggregatorIds") != m.end() && !m["DesAggregatorIds"].empty()) {
      desAggregatorIds = make_shared<string>(boost::any_cast<string>(m["DesAggregatorIds"]));
    }
    if (m.find("SrcAggregatorId") != m.end() && !m["SrcAggregatorId"].empty()) {
      srcAggregatorId = make_shared<string>(boost::any_cast<string>(m["SrcAggregatorId"]));
    }
    if (m.find("SrcConfigRuleIds") != m.end() && !m["SrcConfigRuleIds"].empty()) {
      srcConfigRuleIds = make_shared<string>(boost::any_cast<string>(m["SrcConfigRuleIds"]));
    }
  }


  virtual ~CopyConfigRulesRequest() = default;
};
class CopyConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> copyRulesResult{};
  shared_ptr<string> requestId{};

  CopyConfigRulesResponseBody() {}

  explicit CopyConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copyRulesResult) {
      res["CopyRulesResult"] = boost::any(*copyRulesResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CopyRulesResult") != m.end() && !m["CopyRulesResult"].empty()) {
      copyRulesResult = make_shared<bool>(boost::any_cast<bool>(m["CopyRulesResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CopyConfigRulesResponseBody() = default;
};
class CopyConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyConfigRulesResponseBody> body{};

  CopyConfigRulesResponse() {}

  explicit CopyConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~CopyConfigRulesResponse() = default;
};
class CreateAdvancedSearchFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> sql{};

  CreateAdvancedSearchFileRequest() {}

  explicit CreateAdvancedSearchFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
  }


  virtual ~CreateAdvancedSearchFileRequest() = default;
};
class CreateAdvancedSearchFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAdvancedSearchFileResponseBody() {}

  explicit CreateAdvancedSearchFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAdvancedSearchFileResponseBody() = default;
};
class CreateAdvancedSearchFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAdvancedSearchFileResponseBody> body{};

  CreateAdvancedSearchFileResponse() {}

  explicit CreateAdvancedSearchFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAdvancedSearchFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAdvancedSearchFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAdvancedSearchFileResponse() = default;
};
class CreateAggregateAdvancedSearchFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> sql{};

  CreateAggregateAdvancedSearchFileRequest() {}

  explicit CreateAggregateAdvancedSearchFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
  }


  virtual ~CreateAggregateAdvancedSearchFileRequest() = default;
};
class CreateAggregateAdvancedSearchFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAggregateAdvancedSearchFileResponseBody() {}

  explicit CreateAggregateAdvancedSearchFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregateAdvancedSearchFileResponseBody() = default;
};
class CreateAggregateAdvancedSearchFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregateAdvancedSearchFileResponseBody> body{};

  CreateAggregateAdvancedSearchFileResponse() {}

  explicit CreateAggregateAdvancedSearchFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregateAdvancedSearchFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregateAdvancedSearchFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregateAdvancedSearchFileResponse() = default;
};
class CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters() {}

  explicit CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters() = default;
};
class CreateAggregateCompliancePackRequestConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<long> riskLevel{};

  CreateAggregateCompliancePackRequestConfigRules() {}

  explicit CreateAggregateCompliancePackRequestConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~CreateAggregateCompliancePackRequestConfigRules() = default;
};
class CreateAggregateCompliancePackRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateCompliancePackRequestExcludeTagsScope() {}

  explicit CreateAggregateCompliancePackRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateCompliancePackRequestExcludeTagsScope() = default;
};
class CreateAggregateCompliancePackRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateCompliancePackRequestTagsScope() {}

  explicit CreateAggregateCompliancePackRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateCompliancePackRequestTagsScope() = default;
};
class CreateAggregateCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<vector<CreateAggregateCompliancePackRequestConfigRules>> configRules{};
  shared_ptr<bool> defaultEnable{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateAggregateCompliancePackRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateAggregateCompliancePackRequestTagsScope>> tagsScope{};
  shared_ptr<string> templateContent{};

  CreateAggregateCompliancePackRequest() {}

  explicit CreateAggregateCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (defaultEnable) {
      res["DefaultEnable"] = boost::any(*defaultEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<CreateAggregateCompliancePackRequestConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackRequestConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<CreateAggregateCompliancePackRequestConfigRules>>(expect1);
      }
    }
    if (m.find("DefaultEnable") != m.end() && !m["DefaultEnable"].empty()) {
      defaultEnable = make_shared<bool>(boost::any_cast<bool>(m["DefaultEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateAggregateCompliancePackRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateAggregateCompliancePackRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateAggregateCompliancePackRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateAggregateCompliancePackRequestTagsScope>>(expect1);
      }
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~CreateAggregateCompliancePackRequest() = default;
};
class CreateAggregateCompliancePackShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateCompliancePackShrinkRequestExcludeTagsScope() {}

  explicit CreateAggregateCompliancePackShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateCompliancePackShrinkRequestExcludeTagsScope() = default;
};
class CreateAggregateCompliancePackShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateCompliancePackShrinkRequestTagsScope() {}

  explicit CreateAggregateCompliancePackShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateCompliancePackShrinkRequestTagsScope() = default;
};
class CreateAggregateCompliancePackShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<string> configRulesShrink{};
  shared_ptr<bool> defaultEnable{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateAggregateCompliancePackShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateAggregateCompliancePackShrinkRequestTagsScope>> tagsScope{};
  shared_ptr<string> templateContent{};

  CreateAggregateCompliancePackShrinkRequest() {}

  explicit CreateAggregateCompliancePackShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRulesShrink) {
      res["ConfigRules"] = boost::any(*configRulesShrink);
    }
    if (defaultEnable) {
      res["DefaultEnable"] = boost::any(*defaultEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      configRulesShrink = make_shared<string>(boost::any_cast<string>(m["ConfigRules"]));
    }
    if (m.find("DefaultEnable") != m.end() && !m["DefaultEnable"].empty()) {
      defaultEnable = make_shared<bool>(boost::any_cast<bool>(m["DefaultEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateAggregateCompliancePackShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateAggregateCompliancePackShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateAggregateCompliancePackShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateCompliancePackShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateAggregateCompliancePackShrinkRequestTagsScope>>(expect1);
      }
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~CreateAggregateCompliancePackShrinkRequest() = default;
};
class CreateAggregateCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  CreateAggregateCompliancePackResponseBody() {}

  explicit CreateAggregateCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregateCompliancePackResponseBody() = default;
};
class CreateAggregateCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregateCompliancePackResponseBody> body{};

  CreateAggregateCompliancePackResponse() {}

  explicit CreateAggregateCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregateCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregateCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregateCompliancePackResponse() = default;
};
class CreateAggregateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};

  CreateAggregateConfigDeliveryChannelRequest() {}

  explicit CreateAggregateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
  }


  virtual ~CreateAggregateConfigDeliveryChannelRequest() = default;
};
class CreateAggregateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  CreateAggregateConfigDeliveryChannelResponseBody() {}

  explicit CreateAggregateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregateConfigDeliveryChannelResponseBody() = default;
};
class CreateAggregateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregateConfigDeliveryChannelResponseBody> body{};

  CreateAggregateConfigDeliveryChannelResponse() {}

  explicit CreateAggregateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregateConfigDeliveryChannelResponse() = default;
};
class CreateAggregateConfigRuleRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateConfigRuleRequestExcludeTagsScope() {}

  explicit CreateAggregateConfigRuleRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateConfigRuleRequestExcludeTagsScope() = default;
};
class CreateAggregateConfigRuleRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateConfigRuleRequestTagsScope() {}

  explicit CreateAggregateConfigRuleRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateConfigRuleRequestTagsScope() = default;
};
class CreateAggregateConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountIdsScope{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeAccountIdsScope{};
  shared_ptr<string> excludeFolderIdsScope{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateAggregateConfigRuleRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> folderIdsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<vector<string>> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateAggregateConfigRuleRequestTagsScope>> tagsScope{};

  CreateAggregateConfigRuleRequest() {}

  explicit CreateAggregateConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountIdsScope) {
      res["AccountIdsScope"] = boost::any(*accountIdsScope);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeAccountIdsScope) {
      res["ExcludeAccountIdsScope"] = boost::any(*excludeAccountIdsScope);
    }
    if (excludeFolderIdsScope) {
      res["ExcludeFolderIdsScope"] = boost::any(*excludeFolderIdsScope);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (folderIdsScope) {
      res["FolderIdsScope"] = boost::any(*folderIdsScope);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountIdsScope") != m.end() && !m["AccountIdsScope"].empty()) {
      accountIdsScope = make_shared<string>(boost::any_cast<string>(m["AccountIdsScope"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeAccountIdsScope") != m.end() && !m["ExcludeAccountIdsScope"].empty()) {
      excludeAccountIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeAccountIdsScope"]));
    }
    if (m.find("ExcludeFolderIdsScope") != m.end() && !m["ExcludeFolderIdsScope"].empty()) {
      excludeFolderIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeFolderIdsScope"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateAggregateConfigRuleRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateConfigRuleRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateAggregateConfigRuleRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("FolderIdsScope") != m.end() && !m["FolderIdsScope"].empty()) {
      folderIdsScope = make_shared<string>(boost::any_cast<string>(m["FolderIdsScope"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypesScope"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypesScope"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypesScope = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateAggregateConfigRuleRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateConfigRuleRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateAggregateConfigRuleRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~CreateAggregateConfigRuleRequest() = default;
};
class CreateAggregateConfigRuleShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateConfigRuleShrinkRequestExcludeTagsScope() {}

  explicit CreateAggregateConfigRuleShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateConfigRuleShrinkRequestExcludeTagsScope() = default;
};
class CreateAggregateConfigRuleShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateAggregateConfigRuleShrinkRequestTagsScope() {}

  explicit CreateAggregateConfigRuleShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateAggregateConfigRuleShrinkRequestTagsScope() = default;
};
class CreateAggregateConfigRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountIdsScope{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeAccountIdsScope{};
  shared_ptr<string> excludeFolderIdsScope{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateAggregateConfigRuleShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> folderIdsScope{};
  shared_ptr<string> inputParametersShrink{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScopeShrink{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateAggregateConfigRuleShrinkRequestTagsScope>> tagsScope{};

  CreateAggregateConfigRuleShrinkRequest() {}

  explicit CreateAggregateConfigRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountIdsScope) {
      res["AccountIdsScope"] = boost::any(*accountIdsScope);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeAccountIdsScope) {
      res["ExcludeAccountIdsScope"] = boost::any(*excludeAccountIdsScope);
    }
    if (excludeFolderIdsScope) {
      res["ExcludeFolderIdsScope"] = boost::any(*excludeFolderIdsScope);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (folderIdsScope) {
      res["FolderIdsScope"] = boost::any(*folderIdsScope);
    }
    if (inputParametersShrink) {
      res["InputParameters"] = boost::any(*inputParametersShrink);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScopeShrink) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScopeShrink);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountIdsScope") != m.end() && !m["AccountIdsScope"].empty()) {
      accountIdsScope = make_shared<string>(boost::any_cast<string>(m["AccountIdsScope"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeAccountIdsScope") != m.end() && !m["ExcludeAccountIdsScope"].empty()) {
      excludeAccountIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeAccountIdsScope"]));
    }
    if (m.find("ExcludeFolderIdsScope") != m.end() && !m["ExcludeFolderIdsScope"].empty()) {
      excludeFolderIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeFolderIdsScope"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateAggregateConfigRuleShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateConfigRuleShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateAggregateConfigRuleShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("FolderIdsScope") != m.end() && !m["FolderIdsScope"].empty()) {
      folderIdsScope = make_shared<string>(boost::any_cast<string>(m["FolderIdsScope"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParametersShrink = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScopeShrink = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateAggregateConfigRuleShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregateConfigRuleShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateAggregateConfigRuleShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~CreateAggregateConfigRuleShrinkRequest() = default;
};
class CreateAggregateConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> requestId{};

  CreateAggregateConfigRuleResponseBody() {}

  explicit CreateAggregateConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregateConfigRuleResponseBody() = default;
};
class CreateAggregateConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregateConfigRuleResponseBody> body{};

  CreateAggregateConfigRuleResponse() {}

  explicit CreateAggregateConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregateConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregateConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregateConfigRuleResponse() = default;
};
class CreateAggregateRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> params{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};
  shared_ptr<string> sourceType{};

  CreateAggregateRemediationRequest() {}

  explicit CreateAggregateRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~CreateAggregateRemediationRequest() = default;
};
class CreateAggregateRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> remediationId{};
  shared_ptr<string> requestId{};

  CreateAggregateRemediationResponseBody() {}

  explicit CreateAggregateRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregateRemediationResponseBody() = default;
};
class CreateAggregateRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregateRemediationResponseBody> body{};

  CreateAggregateRemediationResponse() {}

  explicit CreateAggregateRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregateRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregateRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregateRemediationResponse() = default;
};
class CreateAggregatorRequestAggregatorAccounts : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountType{};

  CreateAggregatorRequestAggregatorAccounts() {}

  explicit CreateAggregatorRequestAggregatorAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
  }


  virtual ~CreateAggregatorRequestAggregatorAccounts() = default;
};
class CreateAggregatorRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAggregatorRequestAggregatorAccounts>> aggregatorAccounts{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> aggregatorType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> folderId{};

  CreateAggregatorRequest() {}

  explicit CreateAggregatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*aggregatorAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AggregatorAccounts"] = boost::any(temp1);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (aggregatorType) {
      res["AggregatorType"] = boost::any(*aggregatorType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorAccounts") != m.end() && !m["AggregatorAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["AggregatorAccounts"].type()) {
        vector<CreateAggregatorRequestAggregatorAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AggregatorAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAggregatorRequestAggregatorAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregatorAccounts = make_shared<vector<CreateAggregatorRequestAggregatorAccounts>>(expect1);
      }
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("AggregatorType") != m.end() && !m["AggregatorType"].empty()) {
      aggregatorType = make_shared<string>(boost::any_cast<string>(m["AggregatorType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~CreateAggregatorRequest() = default;
};
class CreateAggregatorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorAccountsShrink{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> aggregatorType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> folderId{};

  CreateAggregatorShrinkRequest() {}

  explicit CreateAggregatorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorAccountsShrink) {
      res["AggregatorAccounts"] = boost::any(*aggregatorAccountsShrink);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (aggregatorType) {
      res["AggregatorType"] = boost::any(*aggregatorType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorAccounts") != m.end() && !m["AggregatorAccounts"].empty()) {
      aggregatorAccountsShrink = make_shared<string>(boost::any_cast<string>(m["AggregatorAccounts"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("AggregatorType") != m.end() && !m["AggregatorType"].empty()) {
      aggregatorType = make_shared<string>(boost::any_cast<string>(m["AggregatorType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~CreateAggregatorShrinkRequest() = default;
};
class CreateAggregatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> requestId{};

  CreateAggregatorResponseBody() {}

  explicit CreateAggregatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAggregatorResponseBody() = default;
};
class CreateAggregatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAggregatorResponseBody> body{};

  CreateAggregatorResponse() {}

  explicit CreateAggregatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAggregatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAggregatorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAggregatorResponse() = default;
};
class CreateCompliancePackRequestConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  CreateCompliancePackRequestConfigRulesConfigRuleParameters() {}

  explicit CreateCompliancePackRequestConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~CreateCompliancePackRequestConfigRulesConfigRuleParameters() = default;
};
class CreateCompliancePackRequestConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<CreateCompliancePackRequestConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<long> riskLevel{};

  CreateCompliancePackRequestConfigRules() {}

  explicit CreateCompliancePackRequestConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<CreateCompliancePackRequestConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackRequestConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<CreateCompliancePackRequestConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~CreateCompliancePackRequestConfigRules() = default;
};
class CreateCompliancePackRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateCompliancePackRequestExcludeTagsScope() {}

  explicit CreateCompliancePackRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateCompliancePackRequestExcludeTagsScope() = default;
};
class CreateCompliancePackRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateCompliancePackRequestTagsScope() {}

  explicit CreateCompliancePackRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateCompliancePackRequestTagsScope() = default;
};
class CreateCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<vector<CreateCompliancePackRequestConfigRules>> configRules{};
  shared_ptr<bool> defaultEnable{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateCompliancePackRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateCompliancePackRequestTagsScope>> tagsScope{};
  shared_ptr<string> templateContent{};

  CreateCompliancePackRequest() {}

  explicit CreateCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (defaultEnable) {
      res["DefaultEnable"] = boost::any(*defaultEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<CreateCompliancePackRequestConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackRequestConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<CreateCompliancePackRequestConfigRules>>(expect1);
      }
    }
    if (m.find("DefaultEnable") != m.end() && !m["DefaultEnable"].empty()) {
      defaultEnable = make_shared<bool>(boost::any_cast<bool>(m["DefaultEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateCompliancePackRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateCompliancePackRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateCompliancePackRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateCompliancePackRequestTagsScope>>(expect1);
      }
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~CreateCompliancePackRequest() = default;
};
class CreateCompliancePackShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateCompliancePackShrinkRequestExcludeTagsScope() {}

  explicit CreateCompliancePackShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateCompliancePackShrinkRequestExcludeTagsScope() = default;
};
class CreateCompliancePackShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateCompliancePackShrinkRequestTagsScope() {}

  explicit CreateCompliancePackShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateCompliancePackShrinkRequestTagsScope() = default;
};
class CreateCompliancePackShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<string> configRulesShrink{};
  shared_ptr<bool> defaultEnable{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateCompliancePackShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateCompliancePackShrinkRequestTagsScope>> tagsScope{};
  shared_ptr<string> templateContent{};

  CreateCompliancePackShrinkRequest() {}

  explicit CreateCompliancePackShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRulesShrink) {
      res["ConfigRules"] = boost::any(*configRulesShrink);
    }
    if (defaultEnable) {
      res["DefaultEnable"] = boost::any(*defaultEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      configRulesShrink = make_shared<string>(boost::any_cast<string>(m["ConfigRules"]));
    }
    if (m.find("DefaultEnable") != m.end() && !m["DefaultEnable"].empty()) {
      defaultEnable = make_shared<bool>(boost::any_cast<bool>(m["DefaultEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateCompliancePackShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateCompliancePackShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateCompliancePackShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCompliancePackShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateCompliancePackShrinkRequestTagsScope>>(expect1);
      }
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~CreateCompliancePackShrinkRequest() = default;
};
class CreateCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  CreateCompliancePackResponseBody() {}

  explicit CreateCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCompliancePackResponseBody() = default;
};
class CreateCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCompliancePackResponseBody> body{};

  CreateCompliancePackResponse() {}

  explicit CreateCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCompliancePackResponse() = default;
};
class CreateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};

  CreateConfigDeliveryChannelRequest() {}

  explicit CreateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
  }


  virtual ~CreateConfigDeliveryChannelRequest() = default;
};
class CreateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  CreateConfigDeliveryChannelResponseBody() {}

  explicit CreateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigDeliveryChannelResponseBody() = default;
};
class CreateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigDeliveryChannelResponseBody> body{};

  CreateConfigDeliveryChannelResponse() {}

  explicit CreateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigDeliveryChannelResponse() = default;
};
class CreateConfigRuleRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateConfigRuleRequestExcludeTagsScope() {}

  explicit CreateConfigRuleRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateConfigRuleRequestExcludeTagsScope() = default;
};
class CreateConfigRuleRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateConfigRuleRequestTagsScope() {}

  explicit CreateConfigRuleRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateConfigRuleRequestTagsScope() = default;
};
class CreateConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateConfigRuleRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<vector<string>> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateConfigRuleRequestTagsScope>> tagsScope{};

  CreateConfigRuleRequest() {}

  explicit CreateConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateConfigRuleRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConfigRuleRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateConfigRuleRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypesScope"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypesScope"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypesScope = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateConfigRuleRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConfigRuleRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateConfigRuleRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~CreateConfigRuleRequest() = default;
};
class CreateConfigRuleShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateConfigRuleShrinkRequestExcludeTagsScope() {}

  explicit CreateConfigRuleShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateConfigRuleShrinkRequestExcludeTagsScope() = default;
};
class CreateConfigRuleShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  CreateConfigRuleShrinkRequestTagsScope() {}

  explicit CreateConfigRuleShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~CreateConfigRuleShrinkRequestTagsScope() = default;
};
class CreateConfigRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<CreateConfigRuleShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> inputParametersShrink{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScopeShrink{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<CreateConfigRuleShrinkRequestTagsScope>> tagsScope{};

  CreateConfigRuleShrinkRequest() {}

  explicit CreateConfigRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (inputParametersShrink) {
      res["InputParameters"] = boost::any(*inputParametersShrink);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScopeShrink) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScopeShrink);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<CreateConfigRuleShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConfigRuleShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<CreateConfigRuleShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParametersShrink = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScopeShrink = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<CreateConfigRuleShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConfigRuleShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<CreateConfigRuleShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~CreateConfigRuleShrinkRequest() = default;
};
class CreateConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> requestId{};

  CreateConfigRuleResponseBody() {}

  explicit CreateConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConfigRuleResponseBody() = default;
};
class CreateConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConfigRuleResponseBody> body{};

  CreateConfigRuleResponse() {}

  explicit CreateConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConfigRuleResponse() = default;
};
class CreateDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};

  CreateDeliveryChannelRequest() {}

  explicit CreateDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
  }


  virtual ~CreateDeliveryChannelRequest() = default;
};
class CreateDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  CreateDeliveryChannelResponseBody() {}

  explicit CreateDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDeliveryChannelResponseBody() = default;
};
class CreateDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDeliveryChannelResponseBody> body{};

  CreateDeliveryChannelResponse() {}

  explicit CreateDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeliveryChannelResponse() = default;
};
class CreateRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> params{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};
  shared_ptr<string> sourceType{};

  CreateRemediationRequest() {}

  explicit CreateRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~CreateRemediationRequest() = default;
};
class CreateRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> remediationId{};
  shared_ptr<string> requestId{};

  CreateRemediationResponseBody() {}

  explicit CreateRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRemediationResponseBody() = default;
};
class CreateRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRemediationResponseBody> body{};

  CreateRemediationResponse() {}

  explicit CreateRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRemediationResponse() = default;
};
class DeactiveAggregateConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  DeactiveAggregateConfigRulesRequest() {}

  explicit DeactiveAggregateConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DeactiveAggregateConfigRulesRequest() = default;
};
class DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DeactiveAggregateConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DeactiveAggregateConfigRulesResponseBodyOperateRuleResult() {}

  explicit DeactiveAggregateConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DeactiveAggregateConfigRulesResponseBodyOperateRuleResult() = default;
};
class DeactiveAggregateConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeactiveAggregateConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DeactiveAggregateConfigRulesResponseBody() {}

  explicit DeactiveAggregateConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DeactiveAggregateConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DeactiveAggregateConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactiveAggregateConfigRulesResponseBody() = default;
};
class DeactiveAggregateConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactiveAggregateConfigRulesResponseBody> body{};

  DeactiveAggregateConfigRulesResponse() {}

  explicit DeactiveAggregateConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactiveAggregateConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactiveAggregateConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeactiveAggregateConfigRulesResponse() = default;
};
class DeactiveConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};

  DeactiveConfigRulesRequest() {}

  explicit DeactiveConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DeactiveConfigRulesRequest() = default;
};
class DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DeactiveConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DeactiveConfigRulesResponseBodyOperateRuleResult() {}

  explicit DeactiveConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DeactiveConfigRulesResponseBodyOperateRuleResult() = default;
};
class DeactiveConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeactiveConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DeactiveConfigRulesResponseBody() {}

  explicit DeactiveConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DeactiveConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DeactiveConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactiveConfigRulesResponseBody() = default;
};
class DeactiveConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactiveConfigRulesResponseBody> body{};

  DeactiveConfigRulesResponse() {}

  explicit DeactiveConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactiveConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactiveConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeactiveConfigRulesResponse() = default;
};
class DeleteAggregateCompliancePacksRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackIds{};
  shared_ptr<bool> deleteRule{};

  DeleteAggregateCompliancePacksRequest() {}

  explicit DeleteAggregateCompliancePacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackIds) {
      res["CompliancePackIds"] = boost::any(*compliancePackIds);
    }
    if (deleteRule) {
      res["DeleteRule"] = boost::any(*deleteRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackIds") != m.end() && !m["CompliancePackIds"].empty()) {
      compliancePackIds = make_shared<string>(boost::any_cast<string>(m["CompliancePackIds"]));
    }
    if (m.find("DeleteRule") != m.end() && !m["DeleteRule"].empty()) {
      deleteRule = make_shared<bool>(boost::any_cast<bool>(m["DeleteRule"]));
    }
  }


  virtual ~DeleteAggregateCompliancePacksRequest() = default;
};
class DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks() {}

  explicit DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks() = default;
};
class DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks>> operateCompliancePacks{};

  DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult() {}

  explicit DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCompliancePacks) {
      vector<boost::any> temp1;
      for(auto item1:*operateCompliancePacks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateCompliancePacks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCompliancePacks") != m.end() && !m["OperateCompliancePacks"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateCompliancePacks"].type()) {
        vector<DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateCompliancePacks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateCompliancePacks = make_shared<vector<DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks>>(expect1);
      }
    }
  }


  virtual ~DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult() = default;
};
class DeleteAggregateCompliancePacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult> operateCompliancePacksResult{};
  shared_ptr<string> requestId{};

  DeleteAggregateCompliancePacksResponseBody() {}

  explicit DeleteAggregateCompliancePacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCompliancePacksResult) {
      res["OperateCompliancePacksResult"] = operateCompliancePacksResult ? boost::any(operateCompliancePacksResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCompliancePacksResult") != m.end() && !m["OperateCompliancePacksResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateCompliancePacksResult"].type()) {
        DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateCompliancePacksResult"]));
        operateCompliancePacksResult = make_shared<DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAggregateCompliancePacksResponseBody() = default;
};
class DeleteAggregateCompliancePacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAggregateCompliancePacksResponseBody> body{};

  DeleteAggregateCompliancePacksResponse() {}

  explicit DeleteAggregateCompliancePacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAggregateCompliancePacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAggregateCompliancePacksResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAggregateCompliancePacksResponse() = default;
};
class DeleteAggregateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> deliveryChannelId{};

  DeleteAggregateConfigDeliveryChannelRequest() {}

  explicit DeleteAggregateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
  }


  virtual ~DeleteAggregateConfigDeliveryChannelRequest() = default;
};
class DeleteAggregateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  DeleteAggregateConfigDeliveryChannelResponseBody() {}

  explicit DeleteAggregateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAggregateConfigDeliveryChannelResponseBody() = default;
};
class DeleteAggregateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAggregateConfigDeliveryChannelResponseBody> body{};

  DeleteAggregateConfigDeliveryChannelResponse() {}

  explicit DeleteAggregateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAggregateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAggregateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAggregateConfigDeliveryChannelResponse() = default;
};
class DeleteAggregateConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  DeleteAggregateConfigRulesRequest() {}

  explicit DeleteAggregateConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DeleteAggregateConfigRulesRequest() = default;
};
class DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DeleteAggregateConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DeleteAggregateConfigRulesResponseBodyOperateRuleResult() {}

  explicit DeleteAggregateConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DeleteAggregateConfigRulesResponseBodyOperateRuleResult() = default;
};
class DeleteAggregateConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteAggregateConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DeleteAggregateConfigRulesResponseBody() {}

  explicit DeleteAggregateConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DeleteAggregateConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DeleteAggregateConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAggregateConfigRulesResponseBody() = default;
};
class DeleteAggregateConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAggregateConfigRulesResponseBody> body{};

  DeleteAggregateConfigRulesResponse() {}

  explicit DeleteAggregateConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAggregateConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAggregateConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAggregateConfigRulesResponse() = default;
};
class DeleteAggregateRemediationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> remediationIds{};

  DeleteAggregateRemediationsRequest() {}

  explicit DeleteAggregateRemediationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (remediationIds) {
      res["RemediationIds"] = boost::any(*remediationIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("RemediationIds") != m.end() && !m["RemediationIds"].empty()) {
      remediationIds = make_shared<string>(boost::any_cast<string>(m["RemediationIds"]));
    }
  }


  virtual ~DeleteAggregateRemediationsRequest() = default;
};
class DeleteAggregateRemediationsResponseBodyRemediationDeleteResults : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> remediationId{};
  shared_ptr<bool> success{};

  DeleteAggregateRemediationsResponseBodyRemediationDeleteResults() {}

  explicit DeleteAggregateRemediationsResponseBodyRemediationDeleteResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAggregateRemediationsResponseBodyRemediationDeleteResults() = default;
};
class DeleteAggregateRemediationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteAggregateRemediationsResponseBodyRemediationDeleteResults>> remediationDeleteResults{};
  shared_ptr<string> requestId{};

  DeleteAggregateRemediationsResponseBody() {}

  explicit DeleteAggregateRemediationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationDeleteResults) {
      vector<boost::any> temp1;
      for(auto item1:*remediationDeleteResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationDeleteResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationDeleteResults") != m.end() && !m["RemediationDeleteResults"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationDeleteResults"].type()) {
        vector<DeleteAggregateRemediationsResponseBodyRemediationDeleteResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationDeleteResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAggregateRemediationsResponseBodyRemediationDeleteResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationDeleteResults = make_shared<vector<DeleteAggregateRemediationsResponseBodyRemediationDeleteResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAggregateRemediationsResponseBody() = default;
};
class DeleteAggregateRemediationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAggregateRemediationsResponseBody> body{};

  DeleteAggregateRemediationsResponse() {}

  explicit DeleteAggregateRemediationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAggregateRemediationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAggregateRemediationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAggregateRemediationsResponse() = default;
};
class DeleteAggregatorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorIds{};
  shared_ptr<string> clientToken{};

  DeleteAggregatorsRequest() {}

  explicit DeleteAggregatorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorIds) {
      res["AggregatorIds"] = boost::any(*aggregatorIds);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorIds") != m.end() && !m["AggregatorIds"].empty()) {
      aggregatorIds = make_shared<string>(boost::any_cast<string>(m["AggregatorIds"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteAggregatorsRequest() = default;
};
class DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators() {}

  explicit DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators() = default;
};
class DeleteAggregatorsResponseBodyOperateAggregatorsResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators>> operateAggregators{};

  DeleteAggregatorsResponseBodyOperateAggregatorsResult() {}

  explicit DeleteAggregatorsResponseBodyOperateAggregatorsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateAggregators) {
      vector<boost::any> temp1;
      for(auto item1:*operateAggregators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateAggregators"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateAggregators") != m.end() && !m["OperateAggregators"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateAggregators"].type()) {
        vector<DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateAggregators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateAggregators = make_shared<vector<DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators>>(expect1);
      }
    }
  }


  virtual ~DeleteAggregatorsResponseBodyOperateAggregatorsResult() = default;
};
class DeleteAggregatorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteAggregatorsResponseBodyOperateAggregatorsResult> operateAggregatorsResult{};
  shared_ptr<string> requestId{};

  DeleteAggregatorsResponseBody() {}

  explicit DeleteAggregatorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateAggregatorsResult) {
      res["OperateAggregatorsResult"] = operateAggregatorsResult ? boost::any(operateAggregatorsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateAggregatorsResult") != m.end() && !m["OperateAggregatorsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateAggregatorsResult"].type()) {
        DeleteAggregatorsResponseBodyOperateAggregatorsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateAggregatorsResult"]));
        operateAggregatorsResult = make_shared<DeleteAggregatorsResponseBodyOperateAggregatorsResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAggregatorsResponseBody() = default;
};
class DeleteAggregatorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAggregatorsResponseBody> body{};

  DeleteAggregatorsResponse() {}

  explicit DeleteAggregatorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAggregatorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAggregatorsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAggregatorsResponse() = default;
};
class DeleteCompliancePacksRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackIds{};
  shared_ptr<bool> deleteRule{};

  DeleteCompliancePacksRequest() {}

  explicit DeleteCompliancePacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackIds) {
      res["CompliancePackIds"] = boost::any(*compliancePackIds);
    }
    if (deleteRule) {
      res["DeleteRule"] = boost::any(*deleteRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackIds") != m.end() && !m["CompliancePackIds"].empty()) {
      compliancePackIds = make_shared<string>(boost::any_cast<string>(m["CompliancePackIds"]));
    }
    if (m.find("DeleteRule") != m.end() && !m["DeleteRule"].empty()) {
      deleteRule = make_shared<bool>(boost::any_cast<bool>(m["DeleteRule"]));
    }
  }


  virtual ~DeleteCompliancePacksRequest() = default;
};
class DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks() {}

  explicit DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks() = default;
};
class DeleteCompliancePacksResponseBodyOperateCompliancePacksResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks>> operateCompliancePacks{};

  DeleteCompliancePacksResponseBodyOperateCompliancePacksResult() {}

  explicit DeleteCompliancePacksResponseBodyOperateCompliancePacksResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCompliancePacks) {
      vector<boost::any> temp1;
      for(auto item1:*operateCompliancePacks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateCompliancePacks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCompliancePacks") != m.end() && !m["OperateCompliancePacks"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateCompliancePacks"].type()) {
        vector<DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateCompliancePacks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateCompliancePacks = make_shared<vector<DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks>>(expect1);
      }
    }
  }


  virtual ~DeleteCompliancePacksResponseBodyOperateCompliancePacksResult() = default;
};
class DeleteCompliancePacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteCompliancePacksResponseBodyOperateCompliancePacksResult> operateCompliancePacksResult{};
  shared_ptr<string> requestId{};

  DeleteCompliancePacksResponseBody() {}

  explicit DeleteCompliancePacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCompliancePacksResult) {
      res["OperateCompliancePacksResult"] = operateCompliancePacksResult ? boost::any(operateCompliancePacksResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCompliancePacksResult") != m.end() && !m["OperateCompliancePacksResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateCompliancePacksResult"].type()) {
        DeleteCompliancePacksResponseBodyOperateCompliancePacksResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateCompliancePacksResult"]));
        operateCompliancePacksResult = make_shared<DeleteCompliancePacksResponseBodyOperateCompliancePacksResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCompliancePacksResponseBody() = default;
};
class DeleteCompliancePacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCompliancePacksResponseBody> body{};

  DeleteCompliancePacksResponse() {}

  explicit DeleteCompliancePacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCompliancePacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCompliancePacksResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCompliancePacksResponse() = default;
};
class DeleteConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};

  DeleteConfigDeliveryChannelRequest() {}

  explicit DeleteConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
  }


  virtual ~DeleteConfigDeliveryChannelRequest() = default;
};
class DeleteConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  DeleteConfigDeliveryChannelResponseBody() {}

  explicit DeleteConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigDeliveryChannelResponseBody() = default;
};
class DeleteConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigDeliveryChannelResponseBody> body{};

  DeleteConfigDeliveryChannelResponse() {}

  explicit DeleteConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigDeliveryChannelResponse() = default;
};
class DeleteConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};

  DeleteConfigRulesRequest() {}

  explicit DeleteConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DeleteConfigRulesRequest() = default;
};
class DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DeleteConfigRulesResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DeleteConfigRulesResponseBodyOperateRuleResult() {}

  explicit DeleteConfigRulesResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DeleteConfigRulesResponseBodyOperateRuleResult() = default;
};
class DeleteConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteConfigRulesResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DeleteConfigRulesResponseBody() {}

  explicit DeleteConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DeleteConfigRulesResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DeleteConfigRulesResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConfigRulesResponseBody() = default;
};
class DeleteConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConfigRulesResponseBody> body{};

  DeleteConfigRulesResponse() {}

  explicit DeleteConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConfigRulesResponse() = default;
};
class DeleteRemediationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> remediationIds{};

  DeleteRemediationsRequest() {}

  explicit DeleteRemediationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationIds) {
      res["RemediationIds"] = boost::any(*remediationIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationIds") != m.end() && !m["RemediationIds"].empty()) {
      remediationIds = make_shared<string>(boost::any_cast<string>(m["RemediationIds"]));
    }
  }


  virtual ~DeleteRemediationsRequest() = default;
};
class DeleteRemediationsResponseBodyRemediationDeleteResults : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> remediationId{};
  shared_ptr<bool> success{};

  DeleteRemediationsResponseBodyRemediationDeleteResults() {}

  explicit DeleteRemediationsResponseBodyRemediationDeleteResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRemediationsResponseBodyRemediationDeleteResults() = default;
};
class DeleteRemediationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteRemediationsResponseBodyRemediationDeleteResults>> remediationDeleteResults{};
  shared_ptr<string> requestId{};

  DeleteRemediationsResponseBody() {}

  explicit DeleteRemediationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationDeleteResults) {
      vector<boost::any> temp1;
      for(auto item1:*remediationDeleteResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationDeleteResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationDeleteResults") != m.end() && !m["RemediationDeleteResults"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationDeleteResults"].type()) {
        vector<DeleteRemediationsResponseBodyRemediationDeleteResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationDeleteResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteRemediationsResponseBodyRemediationDeleteResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationDeleteResults = make_shared<vector<DeleteRemediationsResponseBodyRemediationDeleteResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRemediationsResponseBody() = default;
};
class DeleteRemediationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRemediationsResponseBody> body{};

  DeleteRemediationsResponse() {}

  explicit DeleteRemediationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRemediationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRemediationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRemediationsResponse() = default;
};
class DescribeRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> remediationId{};

  DescribeRemediationRequest() {}

  explicit DescribeRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
  }


  virtual ~DescribeRemediationRequest() = default;
};
class DescribeRemediationResponseBodyRemediation : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> lastSuccessfulInvocationId{};
  shared_ptr<long> lastSuccessfulInvocationTime{};
  shared_ptr<string> lastSuccessfulInvocationType{};
  shared_ptr<string> remediationId{};
  shared_ptr<string> remediationOriginParams{};
  shared_ptr<string> remediationSourceType{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};

  DescribeRemediationResponseBodyRemediation() {}

  explicit DescribeRemediationResponseBodyRemediation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (lastSuccessfulInvocationId) {
      res["LastSuccessfulInvocationId"] = boost::any(*lastSuccessfulInvocationId);
    }
    if (lastSuccessfulInvocationTime) {
      res["LastSuccessfulInvocationTime"] = boost::any(*lastSuccessfulInvocationTime);
    }
    if (lastSuccessfulInvocationType) {
      res["LastSuccessfulInvocationType"] = boost::any(*lastSuccessfulInvocationType);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (remediationOriginParams) {
      res["RemediationOriginParams"] = boost::any(*remediationOriginParams);
    }
    if (remediationSourceType) {
      res["RemediationSourceType"] = boost::any(*remediationSourceType);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("LastSuccessfulInvocationId") != m.end() && !m["LastSuccessfulInvocationId"].empty()) {
      lastSuccessfulInvocationId = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationId"]));
    }
    if (m.find("LastSuccessfulInvocationTime") != m.end() && !m["LastSuccessfulInvocationTime"].empty()) {
      lastSuccessfulInvocationTime = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulInvocationTime"]));
    }
    if (m.find("LastSuccessfulInvocationType") != m.end() && !m["LastSuccessfulInvocationType"].empty()) {
      lastSuccessfulInvocationType = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationType"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RemediationOriginParams") != m.end() && !m["RemediationOriginParams"].empty()) {
      remediationOriginParams = make_shared<string>(boost::any_cast<string>(m["RemediationOriginParams"]));
    }
    if (m.find("RemediationSourceType") != m.end() && !m["RemediationSourceType"].empty()) {
      remediationSourceType = make_shared<string>(boost::any_cast<string>(m["RemediationSourceType"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
  }


  virtual ~DescribeRemediationResponseBodyRemediation() = default;
};
class DescribeRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRemediationResponseBodyRemediation> remediation{};
  shared_ptr<string> requestId{};

  DescribeRemediationResponseBody() {}

  explicit DescribeRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediation) {
      res["Remediation"] = remediation ? boost::any(remediation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remediation") != m.end() && !m["Remediation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Remediation"].type()) {
        DescribeRemediationResponseBodyRemediation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Remediation"]));
        remediation = make_shared<DescribeRemediationResponseBodyRemediation>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRemediationResponseBody() = default;
};
class DescribeRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRemediationResponseBody> body{};

  DescribeRemediationResponse() {}

  explicit DescribeRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRemediationResponse() = default;
};
class DetachAggregateConfigRuleToCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleIds{};

  DetachAggregateConfigRuleToCompliancePackRequest() {}

  explicit DetachAggregateConfigRuleToCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DetachAggregateConfigRuleToCompliancePackRequest() = default;
};
class DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult() {}

  explicit DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult() = default;
};
class DetachAggregateConfigRuleToCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DetachAggregateConfigRuleToCompliancePackResponseBody() {}

  explicit DetachAggregateConfigRuleToCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachAggregateConfigRuleToCompliancePackResponseBody() = default;
};
class DetachAggregateConfigRuleToCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachAggregateConfigRuleToCompliancePackResponseBody> body{};

  DetachAggregateConfigRuleToCompliancePackResponse() {}

  explicit DetachAggregateConfigRuleToCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachAggregateConfigRuleToCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachAggregateConfigRuleToCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~DetachAggregateConfigRuleToCompliancePackResponse() = default;
};
class DetachConfigRuleToCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleIds{};

  DetachConfigRuleToCompliancePackRequest() {}

  explicit DetachConfigRuleToCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~DetachConfigRuleToCompliancePackRequest() = default;
};
class DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() {}

  explicit DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList() = default;
};
class DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult : public Darabonba::Model {
public:
  shared_ptr<vector<DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>> operateRuleItemList{};

  DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult() {}

  explicit DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleItemList) {
      vector<boost::any> temp1;
      for(auto item1:*operateRuleItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperateRuleItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleItemList") != m.end() && !m["OperateRuleItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperateRuleItemList"].type()) {
        vector<DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperateRuleItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operateRuleItemList = make_shared<vector<DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList>>(expect1);
      }
    }
  }


  virtual ~DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult() = default;
};
class DetachConfigRuleToCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult> operateRuleResult{};
  shared_ptr<string> requestId{};

  DetachConfigRuleToCompliancePackResponseBody() {}

  explicit DetachConfigRuleToCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateRuleResult) {
      res["OperateRuleResult"] = operateRuleResult ? boost::any(operateRuleResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateRuleResult") != m.end() && !m["OperateRuleResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateRuleResult"].type()) {
        DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateRuleResult"]));
        operateRuleResult = make_shared<DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachConfigRuleToCompliancePackResponseBody() = default;
};
class DetachConfigRuleToCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachConfigRuleToCompliancePackResponseBody> body{};

  DetachConfigRuleToCompliancePackResponse() {}

  explicit DetachConfigRuleToCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachConfigRuleToCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachConfigRuleToCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~DetachConfigRuleToCompliancePackResponse() = default;
};
class EvaluatePreConfigRulesRequestResourceEvaluateItemsRules : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> inputParameters{};

  EvaluatePreConfigRulesRequestResourceEvaluateItemsRules() {}

  explicit EvaluatePreConfigRulesRequestResourceEvaluateItemsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParameters = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
  }


  virtual ~EvaluatePreConfigRulesRequestResourceEvaluateItemsRules() = default;
};
class EvaluatePreConfigRulesRequestResourceEvaluateItems : public Darabonba::Model {
public:
  shared_ptr<string> resourceLogicalId{};
  shared_ptr<string> resourceProperties{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<EvaluatePreConfigRulesRequestResourceEvaluateItemsRules>> rules{};

  EvaluatePreConfigRulesRequestResourceEvaluateItems() {}

  explicit EvaluatePreConfigRulesRequestResourceEvaluateItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceLogicalId) {
      res["ResourceLogicalId"] = boost::any(*resourceLogicalId);
    }
    if (resourceProperties) {
      res["ResourceProperties"] = boost::any(*resourceProperties);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceLogicalId") != m.end() && !m["ResourceLogicalId"].empty()) {
      resourceLogicalId = make_shared<string>(boost::any_cast<string>(m["ResourceLogicalId"]));
    }
    if (m.find("ResourceProperties") != m.end() && !m["ResourceProperties"].empty()) {
      resourceProperties = make_shared<string>(boost::any_cast<string>(m["ResourceProperties"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<EvaluatePreConfigRulesRequestResourceEvaluateItemsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EvaluatePreConfigRulesRequestResourceEvaluateItemsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<EvaluatePreConfigRulesRequestResourceEvaluateItemsRules>>(expect1);
      }
    }
  }


  virtual ~EvaluatePreConfigRulesRequestResourceEvaluateItems() = default;
};
class EvaluatePreConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableManagedRules{};
  shared_ptr<vector<EvaluatePreConfigRulesRequestResourceEvaluateItems>> resourceEvaluateItems{};

  EvaluatePreConfigRulesRequest() {}

  explicit EvaluatePreConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableManagedRules) {
      res["EnableManagedRules"] = boost::any(*enableManagedRules);
    }
    if (resourceEvaluateItems) {
      vector<boost::any> temp1;
      for(auto item1:*resourceEvaluateItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceEvaluateItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableManagedRules") != m.end() && !m["EnableManagedRules"].empty()) {
      enableManagedRules = make_shared<bool>(boost::any_cast<bool>(m["EnableManagedRules"]));
    }
    if (m.find("ResourceEvaluateItems") != m.end() && !m["ResourceEvaluateItems"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceEvaluateItems"].type()) {
        vector<EvaluatePreConfigRulesRequestResourceEvaluateItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceEvaluateItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EvaluatePreConfigRulesRequestResourceEvaluateItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceEvaluateItems = make_shared<vector<EvaluatePreConfigRulesRequestResourceEvaluateItems>>(expect1);
      }
    }
  }


  virtual ~EvaluatePreConfigRulesRequest() = default;
};
class EvaluatePreConfigRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableManagedRules{};
  shared_ptr<string> resourceEvaluateItemsShrink{};

  EvaluatePreConfigRulesShrinkRequest() {}

  explicit EvaluatePreConfigRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableManagedRules) {
      res["EnableManagedRules"] = boost::any(*enableManagedRules);
    }
    if (resourceEvaluateItemsShrink) {
      res["ResourceEvaluateItems"] = boost::any(*resourceEvaluateItemsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableManagedRules") != m.end() && !m["EnableManagedRules"].empty()) {
      enableManagedRules = make_shared<bool>(boost::any_cast<bool>(m["EnableManagedRules"]));
    }
    if (m.find("ResourceEvaluateItems") != m.end() && !m["ResourceEvaluateItems"].empty()) {
      resourceEvaluateItemsShrink = make_shared<string>(boost::any_cast<string>(m["ResourceEvaluateItems"]));
    }
  }


  virtual ~EvaluatePreConfigRulesShrinkRequest() = default;
};
class EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules : public Darabonba::Model {
public:
  shared_ptr<string> annotation{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> helpUrl{};
  shared_ptr<string> identifier{};

  EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules() {}

  explicit EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (helpUrl) {
      res["HelpUrl"] = boost::any(*helpUrl);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("HelpUrl") != m.end() && !m["HelpUrl"].empty()) {
      helpUrl = make_shared<string>(boost::any_cast<string>(m["HelpUrl"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
  }


  virtual ~EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules() = default;
};
class EvaluatePreConfigRulesResponseBodyResourceEvaluations : public Darabonba::Model {
public:
  shared_ptr<string> resourceLogicalId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules>> rules{};

  EvaluatePreConfigRulesResponseBodyResourceEvaluations() {}

  explicit EvaluatePreConfigRulesResponseBodyResourceEvaluations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceLogicalId) {
      res["ResourceLogicalId"] = boost::any(*resourceLogicalId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceLogicalId") != m.end() && !m["ResourceLogicalId"].empty()) {
      resourceLogicalId = make_shared<string>(boost::any_cast<string>(m["ResourceLogicalId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules>>(expect1);
      }
    }
  }


  virtual ~EvaluatePreConfigRulesResponseBodyResourceEvaluations() = default;
};
class EvaluatePreConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<EvaluatePreConfigRulesResponseBodyResourceEvaluations>> resourceEvaluations{};

  EvaluatePreConfigRulesResponseBody() {}

  explicit EvaluatePreConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceEvaluations) {
      vector<boost::any> temp1;
      for(auto item1:*resourceEvaluations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceEvaluations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceEvaluations") != m.end() && !m["ResourceEvaluations"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceEvaluations"].type()) {
        vector<EvaluatePreConfigRulesResponseBodyResourceEvaluations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceEvaluations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EvaluatePreConfigRulesResponseBodyResourceEvaluations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceEvaluations = make_shared<vector<EvaluatePreConfigRulesResponseBodyResourceEvaluations>>(expect1);
      }
    }
  }


  virtual ~EvaluatePreConfigRulesResponseBody() = default;
};
class EvaluatePreConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EvaluatePreConfigRulesResponseBody> body{};

  EvaluatePreConfigRulesResponse() {}

  explicit EvaluatePreConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EvaluatePreConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EvaluatePreConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~EvaluatePreConfigRulesResponse() = default;
};
class GenerateAggregateCompliancePackReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};

  GenerateAggregateCompliancePackReportRequest() {}

  explicit GenerateAggregateCompliancePackReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GenerateAggregateCompliancePackReportRequest() = default;
};
class GenerateAggregateCompliancePackReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  GenerateAggregateCompliancePackReportResponseBody() {}

  explicit GenerateAggregateCompliancePackReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateAggregateCompliancePackReportResponseBody() = default;
};
class GenerateAggregateCompliancePackReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateAggregateCompliancePackReportResponseBody> body{};

  GenerateAggregateCompliancePackReportResponse() {}

  explicit GenerateAggregateCompliancePackReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAggregateCompliancePackReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAggregateCompliancePackReportResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAggregateCompliancePackReportResponse() = default;
};
class GenerateAggregateConfigRulesReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleIds{};

  GenerateAggregateConfigRulesReportRequest() {}

  explicit GenerateAggregateConfigRulesReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GenerateAggregateConfigRulesReportRequest() = default;
};
class GenerateAggregateConfigRulesReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};

  GenerateAggregateConfigRulesReportResponseBody() {}

  explicit GenerateAggregateConfigRulesReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateAggregateConfigRulesReportResponseBody() = default;
};
class GenerateAggregateConfigRulesReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateAggregateConfigRulesReportResponseBody> body{};

  GenerateAggregateConfigRulesReportResponse() {}

  explicit GenerateAggregateConfigRulesReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAggregateConfigRulesReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAggregateConfigRulesReportResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAggregateConfigRulesReportResponse() = default;
};
class GenerateAggregateResourceInventoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountIds{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> regions{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceTypes{};

  GenerateAggregateResourceInventoryRequest() {}

  explicit GenerateAggregateResourceInventoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountIds) {
      res["AccountIds"] = boost::any(*accountIds);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountIds") != m.end() && !m["AccountIds"].empty()) {
      accountIds = make_shared<string>(boost::any_cast<string>(m["AccountIds"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~GenerateAggregateResourceInventoryRequest() = default;
};
class GenerateAggregateResourceInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GenerateAggregateResourceInventoryResponseBody() {}

  explicit GenerateAggregateResourceInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateAggregateResourceInventoryResponseBody() = default;
};
class GenerateAggregateResourceInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateAggregateResourceInventoryResponseBody> body{};

  GenerateAggregateResourceInventoryResponse() {}

  explicit GenerateAggregateResourceInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAggregateResourceInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAggregateResourceInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAggregateResourceInventoryResponse() = default;
};
class GenerateCompliancePackReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};

  GenerateCompliancePackReportRequest() {}

  explicit GenerateCompliancePackReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GenerateCompliancePackReportRequest() = default;
};
class GenerateCompliancePackReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  GenerateCompliancePackReportResponseBody() {}

  explicit GenerateCompliancePackReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateCompliancePackReportResponseBody() = default;
};
class GenerateCompliancePackReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateCompliancePackReportResponseBody> body{};

  GenerateCompliancePackReportResponse() {}

  explicit GenerateCompliancePackReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateCompliancePackReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateCompliancePackReportResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateCompliancePackReportResponse() = default;
};
class GenerateConfigRulesReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleIds{};

  GenerateConfigRulesReportRequest() {}

  explicit GenerateConfigRulesReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GenerateConfigRulesReportRequest() = default;
};
class GenerateConfigRulesReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};
  shared_ptr<string> requestId{};

  GenerateConfigRulesReportResponseBody() {}

  explicit GenerateConfigRulesReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateConfigRulesReportResponseBody() = default;
};
class GenerateConfigRulesReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateConfigRulesReportResponseBody> body{};

  GenerateConfigRulesReportResponse() {}

  explicit GenerateConfigRulesReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateConfigRulesReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateConfigRulesReportResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateConfigRulesReportResponse() = default;
};
class GenerateResourceInventoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> regions{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceTypes{};

  GenerateResourceInventoryRequest() {}

  explicit GenerateResourceInventoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~GenerateResourceInventoryRequest() = default;
};
class GenerateResourceInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GenerateResourceInventoryResponseBody() {}

  explicit GenerateResourceInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateResourceInventoryResponseBody() = default;
};
class GenerateResourceInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateResourceInventoryResponseBody> body{};

  GenerateResourceInventoryResponse() {}

  explicit GenerateResourceInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateResourceInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateResourceInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateResourceInventoryResponse() = default;
};
class GetAdvancedSearchFileResponseBodyResourceSearch : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> resourceInventoryGenerateTime{};
  shared_ptr<string> status{};

  GetAdvancedSearchFileResponseBodyResourceSearch() {}

  explicit GetAdvancedSearchFileResponseBodyResourceSearch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (resourceInventoryGenerateTime) {
      res["ResourceInventoryGenerateTime"] = boost::any(*resourceInventoryGenerateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ResourceInventoryGenerateTime") != m.end() && !m["ResourceInventoryGenerateTime"].empty()) {
      resourceInventoryGenerateTime = make_shared<long>(boost::any_cast<long>(m["ResourceInventoryGenerateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetAdvancedSearchFileResponseBodyResourceSearch() = default;
};
class GetAdvancedSearchFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAdvancedSearchFileResponseBodyResourceSearch> resourceSearch{};

  GetAdvancedSearchFileResponseBody() {}

  explicit GetAdvancedSearchFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceSearch) {
      res["ResourceSearch"] = resourceSearch ? boost::any(resourceSearch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceSearch") != m.end() && !m["ResourceSearch"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSearch"].type()) {
        GetAdvancedSearchFileResponseBodyResourceSearch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSearch"]));
        resourceSearch = make_shared<GetAdvancedSearchFileResponseBodyResourceSearch>(model1);
      }
    }
  }


  virtual ~GetAdvancedSearchFileResponseBody() = default;
};
class GetAdvancedSearchFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAdvancedSearchFileResponseBody> body{};

  GetAdvancedSearchFileResponse() {}

  explicit GetAdvancedSearchFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAdvancedSearchFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAdvancedSearchFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAdvancedSearchFileResponse() = default;
};
class GetAggregateAccountComplianceByPackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};

  GetAggregateAccountComplianceByPackRequest() {}

  explicit GetAggregateAccountComplianceByPackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetAggregateAccountComplianceByPackRequest() = default;
};
class GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> complianceType{};

  GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances() {}

  explicit GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
  }


  virtual ~GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances() = default;
};
class GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances>> accountCompliances{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult() {}

  explicit GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountCompliances) {
      vector<boost::any> temp1;
      for(auto item1:*accountCompliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountCompliances"] = boost::any(temp1);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountCompliances") != m.end() && !m["AccountCompliances"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountCompliances"].type()) {
        vector<GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountCompliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountCompliances = make_shared<vector<GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances>>(expect1);
      }
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult() = default;
};
class GetAggregateAccountComplianceByPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult> accountComplianceResult{};
  shared_ptr<string> requestId{};

  GetAggregateAccountComplianceByPackResponseBody() {}

  explicit GetAggregateAccountComplianceByPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountComplianceResult) {
      res["AccountComplianceResult"] = accountComplianceResult ? boost::any(accountComplianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountComplianceResult") != m.end() && !m["AccountComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AccountComplianceResult"].type()) {
        GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AccountComplianceResult"]));
        accountComplianceResult = make_shared<GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateAccountComplianceByPackResponseBody() = default;
};
class GetAggregateAccountComplianceByPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateAccountComplianceByPackResponseBody> body{};

  GetAggregateAccountComplianceByPackResponse() {}

  explicit GetAggregateAccountComplianceByPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateAccountComplianceByPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateAccountComplianceByPackResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateAccountComplianceByPackResponse() = default;
};
class GetAggregateAdvancedSearchFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  GetAggregateAdvancedSearchFileRequest() {}

  explicit GetAggregateAdvancedSearchFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~GetAggregateAdvancedSearchFileRequest() = default;
};
class GetAggregateAdvancedSearchFileResponseBodyResourceSearch : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> resourceInventoryGenerateTime{};
  shared_ptr<string> status{};

  GetAggregateAdvancedSearchFileResponseBodyResourceSearch() {}

  explicit GetAggregateAdvancedSearchFileResponseBodyResourceSearch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (resourceInventoryGenerateTime) {
      res["ResourceInventoryGenerateTime"] = boost::any(*resourceInventoryGenerateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ResourceInventoryGenerateTime") != m.end() && !m["ResourceInventoryGenerateTime"].empty()) {
      resourceInventoryGenerateTime = make_shared<long>(boost::any_cast<long>(m["ResourceInventoryGenerateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetAggregateAdvancedSearchFileResponseBodyResourceSearch() = default;
};
class GetAggregateAdvancedSearchFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAggregateAdvancedSearchFileResponseBodyResourceSearch> resourceSearch{};

  GetAggregateAdvancedSearchFileResponseBody() {}

  explicit GetAggregateAdvancedSearchFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceSearch) {
      res["ResourceSearch"] = resourceSearch ? boost::any(resourceSearch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceSearch") != m.end() && !m["ResourceSearch"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceSearch"].type()) {
        GetAggregateAdvancedSearchFileResponseBodyResourceSearch model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceSearch"]));
        resourceSearch = make_shared<GetAggregateAdvancedSearchFileResponseBodyResourceSearch>(model1);
      }
    }
  }


  virtual ~GetAggregateAdvancedSearchFileResponseBody() = default;
};
class GetAggregateAdvancedSearchFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateAdvancedSearchFileResponseBody> body{};

  GetAggregateAdvancedSearchFileResponse() {}

  explicit GetAggregateAdvancedSearchFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateAdvancedSearchFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateAdvancedSearchFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateAdvancedSearchFileResponse() = default;
};
class GetAggregateCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};

  GetAggregateCompliancePackRequest() {}

  explicit GetAggregateCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetAggregateCompliancePackRequest() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};
  shared_ptr<bool> required{};

  GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePackConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};

  GetAggregateCompliancePackResponseBodyCompliancePackConfigRules() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePackConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePackConfigRules() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePackScope : public Darabonba::Model {
public:
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope>> tagsScope{};

  GetAggregateCompliancePackResponseBodyCompliancePackScope() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePackScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<GetAggregateCompliancePackResponseBodyCompliancePackScopeTagsScope>>(expect1);
      }
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePackScope() = default;
};
class GetAggregateCompliancePackResponseBodyCompliancePack : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRules>> configRules{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<long> riskLevel{};
  shared_ptr<GetAggregateCompliancePackResponseBodyCompliancePackScope> scope{};
  shared_ptr<string> status{};
  shared_ptr<string> templateContent{};

  GetAggregateCompliancePackResponseBodyCompliancePack() {}

  explicit GetAggregateCompliancePackResponseBodyCompliancePack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scope) {
      res["Scope"] = scope ? boost::any(scope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateCompliancePackResponseBodyCompliancePackConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<GetAggregateCompliancePackResponseBodyCompliancePackConfigRules>>(expect1);
      }
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scope"].type()) {
        GetAggregateCompliancePackResponseBodyCompliancePackScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scope"]));
        scope = make_shared<GetAggregateCompliancePackResponseBodyCompliancePackScope>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBodyCompliancePack() = default;
};
class GetAggregateCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateCompliancePackResponseBodyCompliancePack> compliancePack{};
  shared_ptr<string> requestId{};

  GetAggregateCompliancePackResponseBody() {}

  explicit GetAggregateCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePack) {
      res["CompliancePack"] = compliancePack ? boost::any(compliancePack->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePack") != m.end() && !m["CompliancePack"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePack"].type()) {
        GetAggregateCompliancePackResponseBodyCompliancePack model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePack"]));
        compliancePack = make_shared<GetAggregateCompliancePackResponseBodyCompliancePack>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateCompliancePackResponseBody() = default;
};
class GetAggregateCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateCompliancePackResponseBody> body{};

  GetAggregateCompliancePackResponse() {}

  explicit GetAggregateCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateCompliancePackResponse() = default;
};
class GetAggregateCompliancePackReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};

  GetAggregateCompliancePackReportRequest() {}

  explicit GetAggregateCompliancePackReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetAggregateCompliancePackReportRequest() = default;
};
class GetAggregateCompliancePackReportResponseBodyCompliancePackReport : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<long> reportCreateTimestamp{};
  shared_ptr<string> reportStatus{};
  shared_ptr<string> reportUrl{};

  GetAggregateCompliancePackReportResponseBodyCompliancePackReport() {}

  explicit GetAggregateCompliancePackReportResponseBodyCompliancePackReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (reportCreateTimestamp) {
      res["ReportCreateTimestamp"] = boost::any(*reportCreateTimestamp);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (reportUrl) {
      res["ReportUrl"] = boost::any(*reportUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ReportCreateTimestamp") != m.end() && !m["ReportCreateTimestamp"].empty()) {
      reportCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportCreateTimestamp"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<string>(boost::any_cast<string>(m["ReportStatus"]));
    }
    if (m.find("ReportUrl") != m.end() && !m["ReportUrl"].empty()) {
      reportUrl = make_shared<string>(boost::any_cast<string>(m["ReportUrl"]));
    }
  }


  virtual ~GetAggregateCompliancePackReportResponseBodyCompliancePackReport() = default;
};
class GetAggregateCompliancePackReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateCompliancePackReportResponseBodyCompliancePackReport> compliancePackReport{};
  shared_ptr<string> requestId{};

  GetAggregateCompliancePackReportResponseBody() {}

  explicit GetAggregateCompliancePackReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackReport) {
      res["CompliancePackReport"] = compliancePackReport ? boost::any(compliancePackReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackReport") != m.end() && !m["CompliancePackReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePackReport"].type()) {
        GetAggregateCompliancePackReportResponseBodyCompliancePackReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePackReport"]));
        compliancePackReport = make_shared<GetAggregateCompliancePackReportResponseBodyCompliancePackReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateCompliancePackReportResponseBody() = default;
};
class GetAggregateCompliancePackReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateCompliancePackReportResponseBody> body{};

  GetAggregateCompliancePackReportResponse() {}

  explicit GetAggregateCompliancePackReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateCompliancePackReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateCompliancePackReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateCompliancePackReportResponse() = default;
};
class GetAggregateComplianceSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  GetAggregateComplianceSummaryRequest() {}

  explicit GetAggregateComplianceSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~GetAggregateComplianceSummaryRequest() = default;
};
class GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule : public Darabonba::Model {
public:
  shared_ptr<long> complianceSummaryTimestamp{};
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule() {}

  explicit GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryTimestamp) {
      res["ComplianceSummaryTimestamp"] = boost::any(*complianceSummaryTimestamp);
    }
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryTimestamp") != m.end() && !m["ComplianceSummaryTimestamp"].empty()) {
      complianceSummaryTimestamp = make_shared<long>(boost::any_cast<long>(m["ComplianceSummaryTimestamp"]));
    }
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule() = default;
};
class GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource : public Darabonba::Model {
public:
  shared_ptr<long> complianceSummaryTimestamp{};
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource() {}

  explicit GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryTimestamp) {
      res["ComplianceSummaryTimestamp"] = boost::any(*complianceSummaryTimestamp);
    }
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryTimestamp") != m.end() && !m["ComplianceSummaryTimestamp"].empty()) {
      complianceSummaryTimestamp = make_shared<long>(boost::any_cast<long>(m["ComplianceSummaryTimestamp"]));
    }
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource() = default;
};
class GetAggregateComplianceSummaryResponseBodyComplianceSummary : public Darabonba::Model {
public:
  shared_ptr<GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule> complianceSummaryByConfigRule{};
  shared_ptr<GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource> complianceSummaryByResource{};

  GetAggregateComplianceSummaryResponseBodyComplianceSummary() {}

  explicit GetAggregateComplianceSummaryResponseBodyComplianceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryByConfigRule) {
      res["ComplianceSummaryByConfigRule"] = complianceSummaryByConfigRule ? boost::any(complianceSummaryByConfigRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (complianceSummaryByResource) {
      res["ComplianceSummaryByResource"] = complianceSummaryByResource ? boost::any(complianceSummaryByResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryByConfigRule") != m.end() && !m["ComplianceSummaryByConfigRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummaryByConfigRule"].type()) {
        GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummaryByConfigRule"]));
        complianceSummaryByConfigRule = make_shared<GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule>(model1);
      }
    }
    if (m.find("ComplianceSummaryByResource") != m.end() && !m["ComplianceSummaryByResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummaryByResource"].type()) {
        GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummaryByResource"]));
        complianceSummaryByResource = make_shared<GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource>(model1);
      }
    }
  }


  virtual ~GetAggregateComplianceSummaryResponseBodyComplianceSummary() = default;
};
class GetAggregateComplianceSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateComplianceSummaryResponseBodyComplianceSummary> complianceSummary{};
  shared_ptr<string> requestId{};

  GetAggregateComplianceSummaryResponseBody() {}

  explicit GetAggregateComplianceSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummary) {
      res["ComplianceSummary"] = complianceSummary ? boost::any(complianceSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummary") != m.end() && !m["ComplianceSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummary"].type()) {
        GetAggregateComplianceSummaryResponseBodyComplianceSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummary"]));
        complianceSummary = make_shared<GetAggregateComplianceSummaryResponseBodyComplianceSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateComplianceSummaryResponseBody() = default;
};
class GetAggregateComplianceSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateComplianceSummaryResponseBody> body{};

  GetAggregateComplianceSummaryResponse() {}

  explicit GetAggregateComplianceSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateComplianceSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateComplianceSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateComplianceSummaryResponse() = default;
};
class GetAggregateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> deliveryChannelId{};

  GetAggregateConfigDeliveryChannelRequest() {}

  explicit GetAggregateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
  }


  virtual ~GetAggregateConfigDeliveryChannelRequest() = default;
};
class GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel() {}

  explicit GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel() = default;
};
class GetAggregateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel> deliveryChannel{};
  shared_ptr<string> requestId{};

  GetAggregateConfigDeliveryChannelResponseBody() {}

  explicit GetAggregateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannel) {
      res["DeliveryChannel"] = deliveryChannel ? boost::any(deliveryChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannel") != m.end() && !m["DeliveryChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeliveryChannel"].type()) {
        GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeliveryChannel"]));
        deliveryChannel = make_shared<GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateConfigDeliveryChannelResponseBody() = default;
};
class GetAggregateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateConfigDeliveryChannelResponseBody> body{};

  GetAggregateConfigDeliveryChannelResponse() {}

  explicit GetAggregateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateConfigDeliveryChannelResponse() = default;
};
class GetAggregateConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};

  GetAggregateConfigRuleRequest() {}

  explicit GetAggregateConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
  }


  virtual ~GetAggregateConfigRuleRequest() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleCompliance : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetAggregateConfigRuleResponseBodyConfigRuleCompliance() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleCompliance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleCompliance() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus : public Darabonba::Model {
public:
  shared_ptr<long> firstActivatedTimestamp{};
  shared_ptr<bool> firstEvaluationStarted{};
  shared_ptr<string> lastErrorCode{};
  shared_ptr<string> lastErrorMessage{};
  shared_ptr<long> lastFailedEvaluationTimestamp{};
  shared_ptr<long> lastFailedInvocationTimestamp{};
  shared_ptr<long> lastSuccessfulEvaluationTimestamp{};
  shared_ptr<long> lastSuccessfulInvocationTimestamp{};

  GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstActivatedTimestamp) {
      res["FirstActivatedTimestamp"] = boost::any(*firstActivatedTimestamp);
    }
    if (firstEvaluationStarted) {
      res["FirstEvaluationStarted"] = boost::any(*firstEvaluationStarted);
    }
    if (lastErrorCode) {
      res["LastErrorCode"] = boost::any(*lastErrorCode);
    }
    if (lastErrorMessage) {
      res["LastErrorMessage"] = boost::any(*lastErrorMessage);
    }
    if (lastFailedEvaluationTimestamp) {
      res["LastFailedEvaluationTimestamp"] = boost::any(*lastFailedEvaluationTimestamp);
    }
    if (lastFailedInvocationTimestamp) {
      res["LastFailedInvocationTimestamp"] = boost::any(*lastFailedInvocationTimestamp);
    }
    if (lastSuccessfulEvaluationTimestamp) {
      res["LastSuccessfulEvaluationTimestamp"] = boost::any(*lastSuccessfulEvaluationTimestamp);
    }
    if (lastSuccessfulInvocationTimestamp) {
      res["LastSuccessfulInvocationTimestamp"] = boost::any(*lastSuccessfulInvocationTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstActivatedTimestamp") != m.end() && !m["FirstActivatedTimestamp"].empty()) {
      firstActivatedTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstActivatedTimestamp"]));
    }
    if (m.find("FirstEvaluationStarted") != m.end() && !m["FirstEvaluationStarted"].empty()) {
      firstEvaluationStarted = make_shared<bool>(boost::any_cast<bool>(m["FirstEvaluationStarted"]));
    }
    if (m.find("LastErrorCode") != m.end() && !m["LastErrorCode"].empty()) {
      lastErrorCode = make_shared<string>(boost::any_cast<string>(m["LastErrorCode"]));
    }
    if (m.find("LastErrorMessage") != m.end() && !m["LastErrorMessage"].empty()) {
      lastErrorMessage = make_shared<string>(boost::any_cast<string>(m["LastErrorMessage"]));
    }
    if (m.find("LastFailedEvaluationTimestamp") != m.end() && !m["LastFailedEvaluationTimestamp"].empty()) {
      lastFailedEvaluationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastFailedEvaluationTimestamp"]));
    }
    if (m.find("LastFailedInvocationTimestamp") != m.end() && !m["LastFailedInvocationTimestamp"].empty()) {
      lastFailedInvocationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastFailedInvocationTimestamp"]));
    }
    if (m.find("LastSuccessfulEvaluationTimestamp") != m.end() && !m["LastSuccessfulEvaluationTimestamp"].empty()) {
      lastSuccessfulEvaluationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulEvaluationTimestamp"]));
    }
    if (m.find("LastSuccessfulInvocationTimestamp") != m.end() && !m["LastSuccessfulInvocationTimestamp"].empty()) {
      lastSuccessfulInvocationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulInvocationTimestamp"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleCreateBy : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> creatorType{};

  GetAggregateConfigRuleResponseBodyConfigRuleCreateBy() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleCreateBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (creatorType) {
      res["CreatorType"] = boost::any(*creatorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("CreatorType") != m.end() && !m["CreatorType"].empty()) {
      creatorType = make_shared<string>(boost::any_cast<string>(m["CreatorType"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleCreateBy() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails : public Darabonba::Model {
public:
  shared_ptr<string> eventSource{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> messageType{};

  GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleManagedRule : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> compulsoryInputParameterDetails{};
  shared_ptr<string> description{};
  shared_ptr<string> identifier{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> managedRuleName{};
  shared_ptr<map<string, boost::any>> optionalInputParameterDetails{};
  shared_ptr<vector<GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails>> sourceDetails{};

  GetAggregateConfigRuleResponseBodyConfigRuleManagedRule() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleManagedRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compulsoryInputParameterDetails) {
      res["CompulsoryInputParameterDetails"] = boost::any(*compulsoryInputParameterDetails);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (managedRuleName) {
      res["ManagedRuleName"] = boost::any(*managedRuleName);
    }
    if (optionalInputParameterDetails) {
      res["OptionalInputParameterDetails"] = boost::any(*optionalInputParameterDetails);
    }
    if (sourceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompulsoryInputParameterDetails") != m.end() && !m["CompulsoryInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CompulsoryInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      compulsoryInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ManagedRuleName") != m.end() && !m["ManagedRuleName"].empty()) {
      managedRuleName = make_shared<string>(boost::any_cast<string>(m["ManagedRuleName"]));
    }
    if (m.find("OptionalInputParameterDetails") != m.end() && !m["OptionalInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OptionalInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      optionalInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SourceDetails") != m.end() && !m["SourceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDetails"].type()) {
        vector<GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDetails = make_shared<vector<GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails>>(expect1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleManagedRule() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails : public Darabonba::Model {
public:
  shared_ptr<string> eventSource{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> messageType{};

  GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleSource : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> owner{};
  shared_ptr<vector<GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails>> sourceDetails{};

  GetAggregateConfigRuleResponseBodyConfigRuleSource() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (sourceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SourceDetails") != m.end() && !m["SourceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDetails"].type()) {
        vector<GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDetails = make_shared<vector<GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails>>(expect1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleSource() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRuleTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetAggregateConfigRuleResponseBodyConfigRuleTagsScope() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRuleTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRuleTagsScope() = default;
};
class GetAggregateConfigRuleResponseBodyConfigRule : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountIdsScope{};
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRuleCompliance> compliance{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus> configRuleEvaluationStatus{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRuleCreateBy> createBy{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeAccountIdsScope{};
  shared_ptr<string> excludeFolderIdsScope{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> folderIdsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRuleManagedRule> managedRule{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<long> modifiedTimestamp{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRuleSource> source{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<GetAggregateConfigRuleResponseBodyConfigRuleTagsScope>> tagsScope{};

  GetAggregateConfigRuleResponseBodyConfigRule() {}

  explicit GetAggregateConfigRuleResponseBodyConfigRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountIdsScope) {
      res["AccountIdsScope"] = boost::any(*accountIdsScope);
    }
    if (compliance) {
      res["Compliance"] = compliance ? boost::any(compliance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleEvaluationStatus) {
      res["ConfigRuleEvaluationStatus"] = configRuleEvaluationStatus ? boost::any(configRuleEvaluationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (createBy) {
      res["CreateBy"] = createBy ? boost::any(createBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeAccountIdsScope) {
      res["ExcludeAccountIdsScope"] = boost::any(*excludeAccountIdsScope);
    }
    if (excludeFolderIdsScope) {
      res["ExcludeFolderIdsScope"] = boost::any(*excludeFolderIdsScope);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (folderIdsScope) {
      res["FolderIdsScope"] = boost::any(*folderIdsScope);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (managedRule) {
      res["ManagedRule"] = managedRule ? boost::any(managedRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (modifiedTimestamp) {
      res["ModifiedTimestamp"] = boost::any(*modifiedTimestamp);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AccountIdsScope") != m.end() && !m["AccountIdsScope"].empty()) {
      accountIdsScope = make_shared<string>(boost::any_cast<string>(m["AccountIdsScope"]));
    }
    if (m.find("Compliance") != m.end() && !m["Compliance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Compliance"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRuleCompliance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Compliance"]));
        compliance = make_shared<GetAggregateConfigRuleResponseBodyConfigRuleCompliance>(model1);
      }
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleEvaluationStatus") != m.end() && !m["ConfigRuleEvaluationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRuleEvaluationStatus"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRuleEvaluationStatus"]));
        configRuleEvaluationStatus = make_shared<GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus>(model1);
      }
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("CreateBy") != m.end() && !m["CreateBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateBy"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRuleCreateBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateBy"]));
        createBy = make_shared<GetAggregateConfigRuleResponseBodyConfigRuleCreateBy>(model1);
      }
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeAccountIdsScope") != m.end() && !m["ExcludeAccountIdsScope"].empty()) {
      excludeAccountIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeAccountIdsScope"]));
    }
    if (m.find("ExcludeFolderIdsScope") != m.end() && !m["ExcludeFolderIdsScope"].empty()) {
      excludeFolderIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeFolderIdsScope"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<GetAggregateConfigRuleResponseBodyConfigRuleExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("FolderIdsScope") != m.end() && !m["FolderIdsScope"].empty()) {
      folderIdsScope = make_shared<string>(boost::any_cast<string>(m["FolderIdsScope"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ManagedRule") != m.end() && !m["ManagedRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManagedRule"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRuleManagedRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManagedRule"]));
        managedRule = make_shared<GetAggregateConfigRuleResponseBodyConfigRuleManagedRule>(model1);
      }
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("ModifiedTimestamp") != m.end() && !m["ModifiedTimestamp"].empty()) {
      modifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["ModifiedTimestamp"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRuleSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<GetAggregateConfigRuleResponseBodyConfigRuleSource>(model1);
      }
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<GetAggregateConfigRuleResponseBodyConfigRuleTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleResponseBodyConfigRuleTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<GetAggregateConfigRuleResponseBodyConfigRuleTagsScope>>(expect1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleResponseBodyConfigRule() = default;
};
class GetAggregateConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateConfigRuleResponseBodyConfigRule> configRule{};
  shared_ptr<string> requestId{};

  GetAggregateConfigRuleResponseBody() {}

  explicit GetAggregateConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRule) {
      res["ConfigRule"] = configRule ? boost::any(configRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRule") != m.end() && !m["ConfigRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRule"].type()) {
        GetAggregateConfigRuleResponseBodyConfigRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRule"]));
        configRule = make_shared<GetAggregateConfigRuleResponseBodyConfigRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateConfigRuleResponseBody() = default;
};
class GetAggregateConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateConfigRuleResponseBody> body{};

  GetAggregateConfigRuleResponse() {}

  explicit GetAggregateConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleResponse() = default;
};
class GetAggregateConfigRuleComplianceByPackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};

  GetAggregateConfigRuleComplianceByPackRequest() {}

  explicit GetAggregateConfigRuleComplianceByPackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetAggregateConfigRuleComplianceByPackRequest() = default;
};
class GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};

  GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances() {}

  explicit GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
  }


  virtual ~GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances() = default;
};
class GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<vector<GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances>> configRuleCompliances{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult() {}

  explicit GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleCompliances) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleCompliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleCompliances"] = boost::any(temp1);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleCompliances") != m.end() && !m["ConfigRuleCompliances"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleCompliances"].type()) {
        vector<GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleCompliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleCompliances = make_shared<vector<GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances>>(expect1);
      }
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult() = default;
};
class GetAggregateConfigRuleComplianceByPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult> configRuleComplianceResult{};
  shared_ptr<string> requestId{};

  GetAggregateConfigRuleComplianceByPackResponseBody() {}

  explicit GetAggregateConfigRuleComplianceByPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleComplianceResult) {
      res["ConfigRuleComplianceResult"] = configRuleComplianceResult ? boost::any(configRuleComplianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleComplianceResult") != m.end() && !m["ConfigRuleComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRuleComplianceResult"].type()) {
        GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRuleComplianceResult"]));
        configRuleComplianceResult = make_shared<GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateConfigRuleComplianceByPackResponseBody() = default;
};
class GetAggregateConfigRuleComplianceByPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateConfigRuleComplianceByPackResponseBody> body{};

  GetAggregateConfigRuleComplianceByPackResponse() {}

  explicit GetAggregateConfigRuleComplianceByPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateConfigRuleComplianceByPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateConfigRuleComplianceByPackResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleComplianceByPackResponse() = default;
};
class GetAggregateConfigRuleSummaryByRiskLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  GetAggregateConfigRuleSummaryByRiskLevelRequest() {}

  explicit GetAggregateConfigRuleSummaryByRiskLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~GetAggregateConfigRuleSummaryByRiskLevelRequest() = default;
};
class GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries : public Darabonba::Model {
public:
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> riskLevel{};

  GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries() {}

  explicit GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries() = default;
};
class GetAggregateConfigRuleSummaryByRiskLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries>> configRuleSummaries{};
  shared_ptr<string> requestId{};

  GetAggregateConfigRuleSummaryByRiskLevelResponseBody() {}

  explicit GetAggregateConfigRuleSummaryByRiskLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleSummaries) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleSummaries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleSummaries"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleSummaries") != m.end() && !m["ConfigRuleSummaries"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleSummaries"].type()) {
        vector<GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleSummaries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleSummaries = make_shared<vector<GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateConfigRuleSummaryByRiskLevelResponseBody() = default;
};
class GetAggregateConfigRuleSummaryByRiskLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateConfigRuleSummaryByRiskLevelResponseBody> body{};

  GetAggregateConfigRuleSummaryByRiskLevelResponse() {}

  explicit GetAggregateConfigRuleSummaryByRiskLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateConfigRuleSummaryByRiskLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateConfigRuleSummaryByRiskLevelResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateConfigRuleSummaryByRiskLevelResponse() = default;
};
class GetAggregateConfigRulesReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> reportId{};

  GetAggregateConfigRulesReportRequest() {}

  explicit GetAggregateConfigRulesReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
  }


  virtual ~GetAggregateConfigRulesReportRequest() = default;
};
class GetAggregateConfigRulesReportResponseBodyConfigRulesReport : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> reportCreateTimestamp{};
  shared_ptr<string> reportId{};
  shared_ptr<string> reportStatus{};
  shared_ptr<string> reportUrl{};

  GetAggregateConfigRulesReportResponseBodyConfigRulesReport() {}

  explicit GetAggregateConfigRulesReportResponseBodyConfigRulesReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (reportCreateTimestamp) {
      res["ReportCreateTimestamp"] = boost::any(*reportCreateTimestamp);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (reportUrl) {
      res["ReportUrl"] = boost::any(*reportUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ReportCreateTimestamp") != m.end() && !m["ReportCreateTimestamp"].empty()) {
      reportCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportCreateTimestamp"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<string>(boost::any_cast<string>(m["ReportStatus"]));
    }
    if (m.find("ReportUrl") != m.end() && !m["ReportUrl"].empty()) {
      reportUrl = make_shared<string>(boost::any_cast<string>(m["ReportUrl"]));
    }
  }


  virtual ~GetAggregateConfigRulesReportResponseBodyConfigRulesReport() = default;
};
class GetAggregateConfigRulesReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateConfigRulesReportResponseBodyConfigRulesReport> configRulesReport{};
  shared_ptr<string> requestId{};

  GetAggregateConfigRulesReportResponseBody() {}

  explicit GetAggregateConfigRulesReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRulesReport) {
      res["ConfigRulesReport"] = configRulesReport ? boost::any(configRulesReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRulesReport") != m.end() && !m["ConfigRulesReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRulesReport"].type()) {
        GetAggregateConfigRulesReportResponseBodyConfigRulesReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRulesReport"]));
        configRulesReport = make_shared<GetAggregateConfigRulesReportResponseBodyConfigRulesReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateConfigRulesReportResponseBody() = default;
};
class GetAggregateConfigRulesReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateConfigRulesReportResponseBody> body{};

  GetAggregateConfigRulesReportResponse() {}

  explicit GetAggregateConfigRulesReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateConfigRulesReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateConfigRulesReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateConfigRulesReportResponse() = default;
};
class GetAggregateDiscoveredResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> complianceOption{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  GetAggregateDiscoveredResourceRequest() {}

  explicit GetAggregateDiscoveredResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (complianceOption) {
      res["ComplianceOption"] = boost::any(*complianceOption);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ComplianceOption") != m.end() && !m["ComplianceOption"].empty()) {
      complianceOption = make_shared<long>(boost::any_cast<long>(m["ComplianceOption"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetAggregateDiscoveredResourceRequest() = default;
};
class GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configuration{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreationTime{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail() {}

  explicit GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreationTime) {
      res["ResourceCreationTime"] = boost::any(*resourceCreationTime);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreationTime") != m.end() && !m["ResourceCreationTime"].empty()) {
      resourceCreationTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreationTime"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail() = default;
};
class GetAggregateDiscoveredResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail> discoveredResourceDetail{};
  shared_ptr<string> requestId{};

  GetAggregateDiscoveredResourceResponseBody() {}

  explicit GetAggregateDiscoveredResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceDetail) {
      res["DiscoveredResourceDetail"] = discoveredResourceDetail ? boost::any(discoveredResourceDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceDetail") != m.end() && !m["DiscoveredResourceDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiscoveredResourceDetail"].type()) {
        GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiscoveredResourceDetail"]));
        discoveredResourceDetail = make_shared<GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateDiscoveredResourceResponseBody() = default;
};
class GetAggregateDiscoveredResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateDiscoveredResourceResponseBody> body{};

  GetAggregateDiscoveredResourceResponse() {}

  explicit GetAggregateDiscoveredResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateDiscoveredResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateDiscoveredResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateDiscoveredResourceResponse() = default;
};
class GetAggregateResourceComplianceByConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<long> resourceOwnerId{};

  GetAggregateResourceComplianceByConfigRuleRequest() {}

  explicit GetAggregateResourceComplianceByConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByConfigRuleRequest() = default;
};
class GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances() {}

  explicit GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances() = default;
};
class GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances>> compliances{};
  shared_ptr<long> totalCount{};

  GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult() {}

  explicit GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult() = default;
};
class GetAggregateResourceComplianceByConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetAggregateResourceComplianceByConfigRuleResponseBody() {}

  explicit GetAggregateResourceComplianceByConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByConfigRuleResponseBody() = default;
};
class GetAggregateResourceComplianceByConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceComplianceByConfigRuleResponseBody> body{};

  GetAggregateResourceComplianceByConfigRuleResponse() {}

  explicit GetAggregateResourceComplianceByConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceComplianceByConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceComplianceByConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceByConfigRuleResponse() = default;
};
class GetAggregateResourceComplianceByPackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};

  GetAggregateResourceComplianceByPackRequest() {}

  explicit GetAggregateResourceComplianceByPackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByPackRequest() = default;
};
class GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult() {}

  explicit GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult() = default;
};
class GetAggregateResourceComplianceByPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult> resourceComplianceResult{};

  GetAggregateResourceComplianceByPackResponseBody() {}

  explicit GetAggregateResourceComplianceByPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceComplianceResult) {
      res["ResourceComplianceResult"] = resourceComplianceResult ? boost::any(resourceComplianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceComplianceResult") != m.end() && !m["ResourceComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceComplianceResult"].type()) {
        GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceComplianceResult"]));
        resourceComplianceResult = make_shared<GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceByPackResponseBody() = default;
};
class GetAggregateResourceComplianceByPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceComplianceByPackResponseBody> body{};

  GetAggregateResourceComplianceByPackResponse() {}

  explicit GetAggregateResourceComplianceByPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceComplianceByPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceComplianceByPackResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceByPackResponse() = default;
};
class GetAggregateResourceComplianceGroupByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  GetAggregateResourceComplianceGroupByRegionRequest() {}

  explicit GetAggregateResourceComplianceGroupByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionRequest() = default;
};
class GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances() {}

  explicit GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances() = default;
};
class GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances>> compliances{};
  shared_ptr<string> regionId{};

  GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList() {}

  explicit GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList() = default;
};
class GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList>> complianceResultList{};

  GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult() {}

  explicit GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResultList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResultList") != m.end() && !m["ComplianceResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceResultList"].type()) {
        vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceResultList = make_shared<vector<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList>>(expect1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult() = default;
};
class GetAggregateResourceComplianceGroupByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetAggregateResourceComplianceGroupByRegionResponseBody() {}

  explicit GetAggregateResourceComplianceGroupByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionResponseBody() = default;
};
class GetAggregateResourceComplianceGroupByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceComplianceGroupByRegionResponseBody> body{};

  GetAggregateResourceComplianceGroupByRegionResponse() {}

  explicit GetAggregateResourceComplianceGroupByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceComplianceGroupByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceComplianceGroupByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByRegionResponse() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  GetAggregateResourceComplianceGroupByResourceTypeRequest() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeRequest() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances>> compliances{};
  shared_ptr<string> resourceType{};

  GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList>> complianceResultList{};

  GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResultList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResultList") != m.end() && !m["ComplianceResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceResultList"].type()) {
        vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceResultList = make_shared<vector<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList>>(expect1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetAggregateResourceComplianceGroupByResourceTypeResponseBody() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeResponseBody() = default;
};
class GetAggregateResourceComplianceGroupByResourceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceComplianceGroupByResourceTypeResponseBody> body{};

  GetAggregateResourceComplianceGroupByResourceTypeResponse() {}

  explicit GetAggregateResourceComplianceGroupByResourceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceComplianceGroupByResourceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceComplianceGroupByResourceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceGroupByResourceTypeResponse() = default;
};
class GetAggregateResourceComplianceTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> startTime{};

  GetAggregateResourceComplianceTimelineRequest() {}

  explicit GetAggregateResourceComplianceTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAggregateResourceComplianceTimelineRequest() = default;
};
class GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<long> captureTime{};
  shared_ptr<string> configuration{};
  shared_ptr<string> configurationDiff{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreateTime{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList() {}

  explicit GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (captureTime) {
      res["CaptureTime"] = boost::any(*captureTime);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (configurationDiff) {
      res["ConfigurationDiff"] = boost::any(*configurationDiff);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreateTime) {
      res["ResourceCreateTime"] = boost::any(*resourceCreateTime);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("CaptureTime") != m.end() && !m["CaptureTime"].empty()) {
      captureTime = make_shared<long>(boost::any_cast<long>(m["CaptureTime"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ConfigurationDiff") != m.end() && !m["ConfigurationDiff"].empty()) {
      configurationDiff = make_shared<string>(boost::any_cast<string>(m["ConfigurationDiff"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreateTime") != m.end() && !m["ResourceCreateTime"].empty()) {
      resourceCreateTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreateTime"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList() = default;
};
class GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList>> complianceList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline() {}

  explicit GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceList") != m.end() && !m["ComplianceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceList"].type()) {
        vector<GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceList = make_shared<vector<GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline() = default;
};
class GetAggregateResourceComplianceTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline> resourceComplianceTimeline{};

  GetAggregateResourceComplianceTimelineResponseBody() {}

  explicit GetAggregateResourceComplianceTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceComplianceTimeline) {
      res["ResourceComplianceTimeline"] = resourceComplianceTimeline ? boost::any(resourceComplianceTimeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceComplianceTimeline") != m.end() && !m["ResourceComplianceTimeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceComplianceTimeline"].type()) {
        GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceComplianceTimeline"]));
        resourceComplianceTimeline = make_shared<GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceTimelineResponseBody() = default;
};
class GetAggregateResourceComplianceTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceComplianceTimelineResponseBody> body{};

  GetAggregateResourceComplianceTimelineResponse() {}

  explicit GetAggregateResourceComplianceTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceComplianceTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceComplianceTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceComplianceTimelineResponse() = default;
};
class GetAggregateResourceConfigurationTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> startTime{};

  GetAggregateResourceConfigurationTimelineRequest() {}

  explicit GetAggregateResourceConfigurationTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAggregateResourceConfigurationTimelineRequest() = default;
};
class GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> captureTime{};
  shared_ptr<string> configurationDiff{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceCreateTime{};
  shared_ptr<string> resourceEventType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList() {}

  explicit GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (captureTime) {
      res["CaptureTime"] = boost::any(*captureTime);
    }
    if (configurationDiff) {
      res["ConfigurationDiff"] = boost::any(*configurationDiff);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreateTime) {
      res["ResourceCreateTime"] = boost::any(*resourceCreateTime);
    }
    if (resourceEventType) {
      res["ResourceEventType"] = boost::any(*resourceEventType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("CaptureTime") != m.end() && !m["CaptureTime"].empty()) {
      captureTime = make_shared<string>(boost::any_cast<string>(m["CaptureTime"]));
    }
    if (m.find("ConfigurationDiff") != m.end() && !m["ConfigurationDiff"].empty()) {
      configurationDiff = make_shared<string>(boost::any_cast<string>(m["ConfigurationDiff"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreateTime") != m.end() && !m["ResourceCreateTime"].empty()) {
      resourceCreateTime = make_shared<string>(boost::any_cast<string>(m["ResourceCreateTime"]));
    }
    if (m.find("ResourceEventType") != m.end() && !m["ResourceEventType"].empty()) {
      resourceEventType = make_shared<string>(boost::any_cast<string>(m["ResourceEventType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList() = default;
};
class GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList>> configurationList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline() {}

  explicit GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationList) {
      vector<boost::any> temp1;
      for(auto item1:*configurationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigurationList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationList") != m.end() && !m["ConfigurationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigurationList"].type()) {
        vector<GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigurationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configurationList = make_shared<vector<GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline() = default;
};
class GetAggregateResourceConfigurationTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline> resourceConfigurationTimeline{};

  GetAggregateResourceConfigurationTimelineResponseBody() {}

  explicit GetAggregateResourceConfigurationTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceConfigurationTimeline) {
      res["ResourceConfigurationTimeline"] = resourceConfigurationTimeline ? boost::any(resourceConfigurationTimeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceConfigurationTimeline") != m.end() && !m["ResourceConfigurationTimeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceConfigurationTimeline"].type()) {
        GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceConfigurationTimeline"]));
        resourceConfigurationTimeline = make_shared<GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceConfigurationTimelineResponseBody() = default;
};
class GetAggregateResourceConfigurationTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceConfigurationTimelineResponseBody> body{};

  GetAggregateResourceConfigurationTimelineResponse() {}

  explicit GetAggregateResourceConfigurationTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceConfigurationTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceConfigurationTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceConfigurationTimelineResponse() = default;
};
class GetAggregateResourceCountsGroupByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> folderId{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  GetAggregateResourceCountsGroupByRegionRequest() {}

  explicit GetAggregateResourceCountsGroupByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByRegionRequest() = default;
};
class GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCount{};

  GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary() {}

  explicit GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary() = default;
};
class GetAggregateResourceCountsGroupByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary>> discoveredResourceCountsSummary{};
  shared_ptr<string> requestId{};

  GetAggregateResourceCountsGroupByRegionResponseBody() {}

  explicit GetAggregateResourceCountsGroupByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceCountsSummary) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceCountsSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceCountsSummary"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceCountsSummary") != m.end() && !m["DiscoveredResourceCountsSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceCountsSummary"].type()) {
        vector<GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceCountsSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceCountsSummary = make_shared<vector<GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByRegionResponseBody() = default;
};
class GetAggregateResourceCountsGroupByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceCountsGroupByRegionResponseBody> body{};

  GetAggregateResourceCountsGroupByRegionResponse() {}

  explicit GetAggregateResourceCountsGroupByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceCountsGroupByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceCountsGroupByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceCountsGroupByRegionResponse() = default;
};
class GetAggregateResourceCountsGroupByResourceTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> folderId{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<long> resourceOwnerId{};

  GetAggregateResourceCountsGroupByResourceTypeRequest() {}

  explicit GetAggregateResourceCountsGroupByResourceTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByResourceTypeRequest() = default;
};
class GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> resourceCount{};
  shared_ptr<string> resourceType{};

  GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary() {}

  explicit GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary() = default;
};
class GetAggregateResourceCountsGroupByResourceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary>> discoveredResourceCountsSummary{};
  shared_ptr<string> requestId{};

  GetAggregateResourceCountsGroupByResourceTypeResponseBody() {}

  explicit GetAggregateResourceCountsGroupByResourceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceCountsSummary) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceCountsSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceCountsSummary"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceCountsSummary") != m.end() && !m["DiscoveredResourceCountsSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceCountsSummary"].type()) {
        vector<GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceCountsSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceCountsSummary = make_shared<vector<GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregateResourceCountsGroupByResourceTypeResponseBody() = default;
};
class GetAggregateResourceCountsGroupByResourceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceCountsGroupByResourceTypeResponseBody> body{};

  GetAggregateResourceCountsGroupByResourceTypeResponse() {}

  explicit GetAggregateResourceCountsGroupByResourceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceCountsGroupByResourceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceCountsGroupByResourceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceCountsGroupByResourceTypeResponse() = default;
};
class GetAggregateResourceInventoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  GetAggregateResourceInventoryRequest() {}

  explicit GetAggregateResourceInventoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~GetAggregateResourceInventoryRequest() = default;
};
class GetAggregateResourceInventoryResponseBodyResourceInventory : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> resourceInventoryGenerateTime{};
  shared_ptr<string> status{};

  GetAggregateResourceInventoryResponseBodyResourceInventory() {}

  explicit GetAggregateResourceInventoryResponseBodyResourceInventory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (resourceInventoryGenerateTime) {
      res["ResourceInventoryGenerateTime"] = boost::any(*resourceInventoryGenerateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ResourceInventoryGenerateTime") != m.end() && !m["ResourceInventoryGenerateTime"].empty()) {
      resourceInventoryGenerateTime = make_shared<long>(boost::any_cast<long>(m["ResourceInventoryGenerateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetAggregateResourceInventoryResponseBodyResourceInventory() = default;
};
class GetAggregateResourceInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAggregateResourceInventoryResponseBodyResourceInventory> resourceInventory{};

  GetAggregateResourceInventoryResponseBody() {}

  explicit GetAggregateResourceInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceInventory) {
      res["ResourceInventory"] = resourceInventory ? boost::any(resourceInventory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceInventory") != m.end() && !m["ResourceInventory"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInventory"].type()) {
        GetAggregateResourceInventoryResponseBodyResourceInventory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInventory"]));
        resourceInventory = make_shared<GetAggregateResourceInventoryResponseBodyResourceInventory>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceInventoryResponseBody() = default;
};
class GetAggregateResourceInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregateResourceInventoryResponseBody> body{};

  GetAggregateResourceInventoryResponse() {}

  explicit GetAggregateResourceInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregateResourceInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregateResourceInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregateResourceInventoryResponse() = default;
};
class GetAggregatorRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  GetAggregatorRequest() {}

  explicit GetAggregatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~GetAggregatorRequest() = default;
};
class GetAggregatorResponseBodyAggregatorAggregatorAccounts : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountType{};
  shared_ptr<string> recorderStatus{};

  GetAggregatorResponseBodyAggregatorAggregatorAccounts() {}

  explicit GetAggregatorResponseBodyAggregatorAggregatorAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (recorderStatus) {
      res["RecorderStatus"] = boost::any(*recorderStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("RecorderStatus") != m.end() && !m["RecorderStatus"].empty()) {
      recorderStatus = make_shared<string>(boost::any_cast<string>(m["RecorderStatus"]));
    }
  }


  virtual ~GetAggregatorResponseBodyAggregatorAggregatorAccounts() = default;
};
class GetAggregatorResponseBodyAggregator : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<long> aggregatorAccountCount{};
  shared_ptr<vector<GetAggregatorResponseBodyAggregatorAggregatorAccounts>> aggregatorAccounts{};
  shared_ptr<string> aggregatorCreateTimestamp{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<long> aggregatorStatus{};
  shared_ptr<string> aggregatorType{};
  shared_ptr<string> description{};
  shared_ptr<string> folderId{};

  GetAggregatorResponseBodyAggregator() {}

  explicit GetAggregatorResponseBodyAggregator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorAccountCount) {
      res["AggregatorAccountCount"] = boost::any(*aggregatorAccountCount);
    }
    if (aggregatorAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*aggregatorAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AggregatorAccounts"] = boost::any(temp1);
    }
    if (aggregatorCreateTimestamp) {
      res["AggregatorCreateTimestamp"] = boost::any(*aggregatorCreateTimestamp);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (aggregatorStatus) {
      res["AggregatorStatus"] = boost::any(*aggregatorStatus);
    }
    if (aggregatorType) {
      res["AggregatorType"] = boost::any(*aggregatorType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorAccountCount") != m.end() && !m["AggregatorAccountCount"].empty()) {
      aggregatorAccountCount = make_shared<long>(boost::any_cast<long>(m["AggregatorAccountCount"]));
    }
    if (m.find("AggregatorAccounts") != m.end() && !m["AggregatorAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["AggregatorAccounts"].type()) {
        vector<GetAggregatorResponseBodyAggregatorAggregatorAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AggregatorAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAggregatorResponseBodyAggregatorAggregatorAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregatorAccounts = make_shared<vector<GetAggregatorResponseBodyAggregatorAggregatorAccounts>>(expect1);
      }
    }
    if (m.find("AggregatorCreateTimestamp") != m.end() && !m["AggregatorCreateTimestamp"].empty()) {
      aggregatorCreateTimestamp = make_shared<string>(boost::any_cast<string>(m["AggregatorCreateTimestamp"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("AggregatorStatus") != m.end() && !m["AggregatorStatus"].empty()) {
      aggregatorStatus = make_shared<long>(boost::any_cast<long>(m["AggregatorStatus"]));
    }
    if (m.find("AggregatorType") != m.end() && !m["AggregatorType"].empty()) {
      aggregatorType = make_shared<string>(boost::any_cast<string>(m["AggregatorType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~GetAggregatorResponseBodyAggregator() = default;
};
class GetAggregatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAggregatorResponseBodyAggregator> aggregator{};
  shared_ptr<string> requestId{};

  GetAggregatorResponseBody() {}

  explicit GetAggregatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregator) {
      res["Aggregator"] = aggregator ? boost::any(aggregator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregator") != m.end() && !m["Aggregator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Aggregator"].type()) {
        GetAggregatorResponseBodyAggregator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Aggregator"]));
        aggregator = make_shared<GetAggregatorResponseBodyAggregator>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAggregatorResponseBody() = default;
};
class GetAggregatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAggregatorResponseBody> body{};

  GetAggregatorResponse() {}

  explicit GetAggregatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAggregatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAggregatorResponseBody>(model1);
      }
    }
  }


  virtual ~GetAggregatorResponse() = default;
};
class GetCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};

  GetCompliancePackRequest() {}

  explicit GetCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetCompliancePackRequest() = default;
};
class GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};
  shared_ptr<bool> required{};

  GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters() {}

  explicit GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters() = default;
};
class GetCompliancePackResponseBodyCompliancePackConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};

  GetCompliancePackResponseBodyCompliancePackConfigRules() {}

  explicit GetCompliancePackResponseBodyCompliancePackConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePackConfigRules() = default;
};
class GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope() {}

  explicit GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope() = default;
};
class GetCompliancePackResponseBodyCompliancePackScopeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetCompliancePackResponseBodyCompliancePackScopeTagsScope() {}

  explicit GetCompliancePackResponseBodyCompliancePackScopeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePackScopeTagsScope() = default;
};
class GetCompliancePackResponseBodyCompliancePackScope : public Darabonba::Model {
public:
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<GetCompliancePackResponseBodyCompliancePackScopeTagsScope>> tagsScope{};

  GetCompliancePackResponseBodyCompliancePackScope() {}

  explicit GetCompliancePackResponseBodyCompliancePackScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<GetCompliancePackResponseBodyCompliancePackScopeExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<GetCompliancePackResponseBodyCompliancePackScopeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompliancePackResponseBodyCompliancePackScopeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<GetCompliancePackResponseBodyCompliancePackScopeTagsScope>>(expect1);
      }
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePackScope() = default;
};
class GetCompliancePackResponseBodyCompliancePack : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<vector<GetCompliancePackResponseBodyCompliancePackConfigRules>> configRules{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<long> riskLevel{};
  shared_ptr<GetCompliancePackResponseBodyCompliancePackScope> scope{};
  shared_ptr<string> status{};
  shared_ptr<string> templateContent{};

  GetCompliancePackResponseBodyCompliancePack() {}

  explicit GetCompliancePackResponseBodyCompliancePack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scope) {
      res["Scope"] = scope ? boost::any(scope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateContent) {
      res["TemplateContent"] = boost::any(*templateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<GetCompliancePackResponseBodyCompliancePackConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCompliancePackResponseBodyCompliancePackConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<GetCompliancePackResponseBodyCompliancePackConfigRules>>(expect1);
      }
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scope"].type()) {
        GetCompliancePackResponseBodyCompliancePackScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scope"]));
        scope = make_shared<GetCompliancePackResponseBodyCompliancePackScope>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["TemplateContent"]));
    }
  }


  virtual ~GetCompliancePackResponseBodyCompliancePack() = default;
};
class GetCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCompliancePackResponseBodyCompliancePack> compliancePack{};
  shared_ptr<string> requestId{};

  GetCompliancePackResponseBody() {}

  explicit GetCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePack) {
      res["CompliancePack"] = compliancePack ? boost::any(compliancePack->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePack") != m.end() && !m["CompliancePack"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePack"].type()) {
        GetCompliancePackResponseBodyCompliancePack model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePack"]));
        compliancePack = make_shared<GetCompliancePackResponseBodyCompliancePack>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCompliancePackResponseBody() = default;
};
class GetCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCompliancePackResponseBody> body{};

  GetCompliancePackResponse() {}

  explicit GetCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~GetCompliancePackResponse() = default;
};
class GetCompliancePackReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};

  GetCompliancePackReportRequest() {}

  explicit GetCompliancePackReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetCompliancePackReportRequest() = default;
};
class GetCompliancePackReportResponseBodyCompliancePackReport : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<long> reportCreateTimestamp{};
  shared_ptr<string> reportStatus{};
  shared_ptr<string> reportUrl{};

  GetCompliancePackReportResponseBodyCompliancePackReport() {}

  explicit GetCompliancePackReportResponseBodyCompliancePackReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (reportCreateTimestamp) {
      res["ReportCreateTimestamp"] = boost::any(*reportCreateTimestamp);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (reportUrl) {
      res["ReportUrl"] = boost::any(*reportUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ReportCreateTimestamp") != m.end() && !m["ReportCreateTimestamp"].empty()) {
      reportCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportCreateTimestamp"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<string>(boost::any_cast<string>(m["ReportStatus"]));
    }
    if (m.find("ReportUrl") != m.end() && !m["ReportUrl"].empty()) {
      reportUrl = make_shared<string>(boost::any_cast<string>(m["ReportUrl"]));
    }
  }


  virtual ~GetCompliancePackReportResponseBodyCompliancePackReport() = default;
};
class GetCompliancePackReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCompliancePackReportResponseBodyCompliancePackReport> compliancePackReport{};
  shared_ptr<string> requestId{};

  GetCompliancePackReportResponseBody() {}

  explicit GetCompliancePackReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackReport) {
      res["CompliancePackReport"] = compliancePackReport ? boost::any(compliancePackReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackReport") != m.end() && !m["CompliancePackReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePackReport"].type()) {
        GetCompliancePackReportResponseBodyCompliancePackReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePackReport"]));
        compliancePackReport = make_shared<GetCompliancePackReportResponseBodyCompliancePackReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCompliancePackReportResponseBody() = default;
};
class GetCompliancePackReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCompliancePackReportResponseBody> body{};

  GetCompliancePackReportResponse() {}

  explicit GetCompliancePackReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCompliancePackReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCompliancePackReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetCompliancePackReportResponse() = default;
};
class GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule : public Darabonba::Model {
public:
  shared_ptr<long> complianceSummaryTimestamp{};
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule() {}

  explicit GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryTimestamp) {
      res["ComplianceSummaryTimestamp"] = boost::any(*complianceSummaryTimestamp);
    }
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryTimestamp") != m.end() && !m["ComplianceSummaryTimestamp"].empty()) {
      complianceSummaryTimestamp = make_shared<long>(boost::any_cast<long>(m["ComplianceSummaryTimestamp"]));
    }
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule() = default;
};
class GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource : public Darabonba::Model {
public:
  shared_ptr<long> complianceSummaryTimestamp{};
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource() {}

  explicit GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryTimestamp) {
      res["ComplianceSummaryTimestamp"] = boost::any(*complianceSummaryTimestamp);
    }
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryTimestamp") != m.end() && !m["ComplianceSummaryTimestamp"].empty()) {
      complianceSummaryTimestamp = make_shared<long>(boost::any_cast<long>(m["ComplianceSummaryTimestamp"]));
    }
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource() = default;
};
class GetComplianceSummaryResponseBodyComplianceSummary : public Darabonba::Model {
public:
  shared_ptr<GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule> complianceSummaryByConfigRule{};
  shared_ptr<GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource> complianceSummaryByResource{};

  GetComplianceSummaryResponseBodyComplianceSummary() {}

  explicit GetComplianceSummaryResponseBodyComplianceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummaryByConfigRule) {
      res["ComplianceSummaryByConfigRule"] = complianceSummaryByConfigRule ? boost::any(complianceSummaryByConfigRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (complianceSummaryByResource) {
      res["ComplianceSummaryByResource"] = complianceSummaryByResource ? boost::any(complianceSummaryByResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummaryByConfigRule") != m.end() && !m["ComplianceSummaryByConfigRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummaryByConfigRule"].type()) {
        GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummaryByConfigRule"]));
        complianceSummaryByConfigRule = make_shared<GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule>(model1);
      }
    }
    if (m.find("ComplianceSummaryByResource") != m.end() && !m["ComplianceSummaryByResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummaryByResource"].type()) {
        GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummaryByResource"]));
        complianceSummaryByResource = make_shared<GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource>(model1);
      }
    }
  }


  virtual ~GetComplianceSummaryResponseBodyComplianceSummary() = default;
};
class GetComplianceSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetComplianceSummaryResponseBodyComplianceSummary> complianceSummary{};
  shared_ptr<string> requestId{};

  GetComplianceSummaryResponseBody() {}

  explicit GetComplianceSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceSummary) {
      res["ComplianceSummary"] = complianceSummary ? boost::any(complianceSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceSummary") != m.end() && !m["ComplianceSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceSummary"].type()) {
        GetComplianceSummaryResponseBodyComplianceSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceSummary"]));
        complianceSummary = make_shared<GetComplianceSummaryResponseBodyComplianceSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetComplianceSummaryResponseBody() = default;
};
class GetComplianceSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetComplianceSummaryResponseBody> body{};

  GetComplianceSummaryResponse() {}

  explicit GetComplianceSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetComplianceSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetComplianceSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetComplianceSummaryResponse() = default;
};
class GetConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};

  GetConfigDeliveryChannelRequest() {}

  explicit GetConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
  }


  virtual ~GetConfigDeliveryChannelRequest() = default;
};
class GetConfigDeliveryChannelResponseBodyDeliveryChannel : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  GetConfigDeliveryChannelResponseBodyDeliveryChannel() {}

  explicit GetConfigDeliveryChannelResponseBodyDeliveryChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetConfigDeliveryChannelResponseBodyDeliveryChannel() = default;
};
class GetConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigDeliveryChannelResponseBodyDeliveryChannel> deliveryChannel{};
  shared_ptr<string> requestId{};

  GetConfigDeliveryChannelResponseBody() {}

  explicit GetConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannel) {
      res["DeliveryChannel"] = deliveryChannel ? boost::any(deliveryChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannel") != m.end() && !m["DeliveryChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeliveryChannel"].type()) {
        GetConfigDeliveryChannelResponseBodyDeliveryChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeliveryChannel"]));
        deliveryChannel = make_shared<GetConfigDeliveryChannelResponseBodyDeliveryChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigDeliveryChannelResponseBody() = default;
};
class GetConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigDeliveryChannelResponseBody> body{};

  GetConfigDeliveryChannelResponse() {}

  explicit GetConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigDeliveryChannelResponse() = default;
};
class GetConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};

  GetConfigRuleRequest() {}

  explicit GetConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
  }


  virtual ~GetConfigRuleRequest() = default;
};
class GetConfigRuleResponseBodyConfigRuleCompliance : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetConfigRuleResponseBodyConfigRuleCompliance() {}

  explicit GetConfigRuleResponseBodyConfigRuleCompliance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleCompliance() = default;
};
class GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus : public Darabonba::Model {
public:
  shared_ptr<long> firstActivatedTimestamp{};
  shared_ptr<bool> firstEvaluationStarted{};
  shared_ptr<string> lastErrorCode{};
  shared_ptr<string> lastErrorMessage{};
  shared_ptr<long> lastFailedEvaluationTimestamp{};
  shared_ptr<long> lastFailedInvocationTimestamp{};
  shared_ptr<long> lastSuccessfulEvaluationTimestamp{};
  shared_ptr<long> lastSuccessfulInvocationTimestamp{};

  GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus() {}

  explicit GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstActivatedTimestamp) {
      res["FirstActivatedTimestamp"] = boost::any(*firstActivatedTimestamp);
    }
    if (firstEvaluationStarted) {
      res["FirstEvaluationStarted"] = boost::any(*firstEvaluationStarted);
    }
    if (lastErrorCode) {
      res["LastErrorCode"] = boost::any(*lastErrorCode);
    }
    if (lastErrorMessage) {
      res["LastErrorMessage"] = boost::any(*lastErrorMessage);
    }
    if (lastFailedEvaluationTimestamp) {
      res["LastFailedEvaluationTimestamp"] = boost::any(*lastFailedEvaluationTimestamp);
    }
    if (lastFailedInvocationTimestamp) {
      res["LastFailedInvocationTimestamp"] = boost::any(*lastFailedInvocationTimestamp);
    }
    if (lastSuccessfulEvaluationTimestamp) {
      res["LastSuccessfulEvaluationTimestamp"] = boost::any(*lastSuccessfulEvaluationTimestamp);
    }
    if (lastSuccessfulInvocationTimestamp) {
      res["LastSuccessfulInvocationTimestamp"] = boost::any(*lastSuccessfulInvocationTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstActivatedTimestamp") != m.end() && !m["FirstActivatedTimestamp"].empty()) {
      firstActivatedTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstActivatedTimestamp"]));
    }
    if (m.find("FirstEvaluationStarted") != m.end() && !m["FirstEvaluationStarted"].empty()) {
      firstEvaluationStarted = make_shared<bool>(boost::any_cast<bool>(m["FirstEvaluationStarted"]));
    }
    if (m.find("LastErrorCode") != m.end() && !m["LastErrorCode"].empty()) {
      lastErrorCode = make_shared<string>(boost::any_cast<string>(m["LastErrorCode"]));
    }
    if (m.find("LastErrorMessage") != m.end() && !m["LastErrorMessage"].empty()) {
      lastErrorMessage = make_shared<string>(boost::any_cast<string>(m["LastErrorMessage"]));
    }
    if (m.find("LastFailedEvaluationTimestamp") != m.end() && !m["LastFailedEvaluationTimestamp"].empty()) {
      lastFailedEvaluationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastFailedEvaluationTimestamp"]));
    }
    if (m.find("LastFailedInvocationTimestamp") != m.end() && !m["LastFailedInvocationTimestamp"].empty()) {
      lastFailedInvocationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastFailedInvocationTimestamp"]));
    }
    if (m.find("LastSuccessfulEvaluationTimestamp") != m.end() && !m["LastSuccessfulEvaluationTimestamp"].empty()) {
      lastSuccessfulEvaluationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulEvaluationTimestamp"]));
    }
    if (m.find("LastSuccessfulInvocationTimestamp") != m.end() && !m["LastSuccessfulInvocationTimestamp"].empty()) {
      lastSuccessfulInvocationTimestamp = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulInvocationTimestamp"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus() = default;
};
class GetConfigRuleResponseBodyConfigRuleCreateBy : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};

  GetConfigRuleResponseBodyConfigRuleCreateBy() {}

  explicit GetConfigRuleResponseBodyConfigRuleCreateBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleCreateBy() = default;
};
class GetConfigRuleResponseBodyConfigRuleExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetConfigRuleResponseBodyConfigRuleExcludeTagsScope() {}

  explicit GetConfigRuleResponseBodyConfigRuleExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleExcludeTagsScope() = default;
};
class GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails : public Darabonba::Model {
public:
  shared_ptr<string> eventSource{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> messageType{};

  GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails() {}

  explicit GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails() = default;
};
class GetConfigRuleResponseBodyConfigRuleManagedRule : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> compulsoryInputParameterDetails{};
  shared_ptr<string> description{};
  shared_ptr<string> identifier{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> managedRuleName{};
  shared_ptr<map<string, boost::any>> optionalInputParameterDetails{};
  shared_ptr<vector<GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails>> sourceDetails{};

  GetConfigRuleResponseBodyConfigRuleManagedRule() {}

  explicit GetConfigRuleResponseBodyConfigRuleManagedRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compulsoryInputParameterDetails) {
      res["CompulsoryInputParameterDetails"] = boost::any(*compulsoryInputParameterDetails);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (managedRuleName) {
      res["ManagedRuleName"] = boost::any(*managedRuleName);
    }
    if (optionalInputParameterDetails) {
      res["OptionalInputParameterDetails"] = boost::any(*optionalInputParameterDetails);
    }
    if (sourceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompulsoryInputParameterDetails") != m.end() && !m["CompulsoryInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CompulsoryInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      compulsoryInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ManagedRuleName") != m.end() && !m["ManagedRuleName"].empty()) {
      managedRuleName = make_shared<string>(boost::any_cast<string>(m["ManagedRuleName"]));
    }
    if (m.find("OptionalInputParameterDetails") != m.end() && !m["OptionalInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OptionalInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      optionalInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SourceDetails") != m.end() && !m["SourceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDetails"].type()) {
        vector<GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDetails = make_shared<vector<GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails>>(expect1);
      }
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleManagedRule() = default;
};
class GetConfigRuleResponseBodyConfigRuleScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> complianceResourceTypes{};

  GetConfigRuleResponseBodyConfigRuleScope() {}

  explicit GetConfigRuleResponseBodyConfigRuleScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResourceTypes) {
      res["ComplianceResourceTypes"] = boost::any(*complianceResourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResourceTypes") != m.end() && !m["ComplianceResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComplianceResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComplianceResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      complianceResourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleScope() = default;
};
class GetConfigRuleResponseBodyConfigRuleSourceSourceDetails : public Darabonba::Model {
public:
  shared_ptr<string> eventSource{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> messageType{};

  GetConfigRuleResponseBodyConfigRuleSourceSourceDetails() {}

  explicit GetConfigRuleResponseBodyConfigRuleSourceSourceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleSourceSourceDetails() = default;
};
class GetConfigRuleResponseBodyConfigRuleSource : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> owner{};
  shared_ptr<vector<GetConfigRuleResponseBodyConfigRuleSourceSourceDetails>> sourceDetails{};

  GetConfigRuleResponseBodyConfigRuleSource() {}

  explicit GetConfigRuleResponseBodyConfigRuleSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (sourceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SourceDetails") != m.end() && !m["SourceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDetails"].type()) {
        vector<GetConfigRuleResponseBodyConfigRuleSourceSourceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleResponseBodyConfigRuleSourceSourceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDetails = make_shared<vector<GetConfigRuleResponseBodyConfigRuleSourceSourceDetails>>(expect1);
      }
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleSource() = default;
};
class GetConfigRuleResponseBodyConfigRuleTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  GetConfigRuleResponseBodyConfigRuleTagsScope() {}

  explicit GetConfigRuleResponseBodyConfigRuleTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRuleTagsScope() = default;
};
class GetConfigRuleResponseBodyConfigRule : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleCompliance> compliance{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus> configRuleEvaluationStatus{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleCreateBy> createBy{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<GetConfigRuleResponseBodyConfigRuleExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleManagedRule> managedRule{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<long> modifiedTimestamp{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleScope> scope{};
  shared_ptr<GetConfigRuleResponseBodyConfigRuleSource> source{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<GetConfigRuleResponseBodyConfigRuleTagsScope>> tagsScope{};

  GetConfigRuleResponseBodyConfigRule() {}

  explicit GetConfigRuleResponseBodyConfigRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliance) {
      res["Compliance"] = compliance ? boost::any(compliance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleEvaluationStatus) {
      res["ConfigRuleEvaluationStatus"] = configRuleEvaluationStatus ? boost::any(configRuleEvaluationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (createBy) {
      res["CreateBy"] = createBy ? boost::any(createBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (managedRule) {
      res["ManagedRule"] = managedRule ? boost::any(managedRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (modifiedTimestamp) {
      res["ModifiedTimestamp"] = boost::any(*modifiedTimestamp);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scope) {
      res["Scope"] = scope ? boost::any(scope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("Compliance") != m.end() && !m["Compliance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Compliance"].type()) {
        GetConfigRuleResponseBodyConfigRuleCompliance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Compliance"]));
        compliance = make_shared<GetConfigRuleResponseBodyConfigRuleCompliance>(model1);
      }
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleEvaluationStatus") != m.end() && !m["ConfigRuleEvaluationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRuleEvaluationStatus"].type()) {
        GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRuleEvaluationStatus"]));
        configRuleEvaluationStatus = make_shared<GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus>(model1);
      }
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("CreateBy") != m.end() && !m["CreateBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateBy"].type()) {
        GetConfigRuleResponseBodyConfigRuleCreateBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateBy"]));
        createBy = make_shared<GetConfigRuleResponseBodyConfigRuleCreateBy>(model1);
      }
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<GetConfigRuleResponseBodyConfigRuleExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleResponseBodyConfigRuleExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<GetConfigRuleResponseBodyConfigRuleExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ManagedRule") != m.end() && !m["ManagedRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManagedRule"].type()) {
        GetConfigRuleResponseBodyConfigRuleManagedRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManagedRule"]));
        managedRule = make_shared<GetConfigRuleResponseBodyConfigRuleManagedRule>(model1);
      }
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("ModifiedTimestamp") != m.end() && !m["ModifiedTimestamp"].empty()) {
      modifiedTimestamp = make_shared<long>(boost::any_cast<long>(m["ModifiedTimestamp"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scope"].type()) {
        GetConfigRuleResponseBodyConfigRuleScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scope"]));
        scope = make_shared<GetConfigRuleResponseBodyConfigRuleScope>(model1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        GetConfigRuleResponseBodyConfigRuleSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<GetConfigRuleResponseBodyConfigRuleSource>(model1);
      }
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<GetConfigRuleResponseBodyConfigRuleTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleResponseBodyConfigRuleTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<GetConfigRuleResponseBodyConfigRuleTagsScope>>(expect1);
      }
    }
  }


  virtual ~GetConfigRuleResponseBodyConfigRule() = default;
};
class GetConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigRuleResponseBodyConfigRule> configRule{};
  shared_ptr<string> requestId{};

  GetConfigRuleResponseBody() {}

  explicit GetConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRule) {
      res["ConfigRule"] = configRule ? boost::any(configRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRule") != m.end() && !m["ConfigRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRule"].type()) {
        GetConfigRuleResponseBodyConfigRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRule"]));
        configRule = make_shared<GetConfigRuleResponseBodyConfigRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigRuleResponseBody() = default;
};
class GetConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigRuleResponseBody> body{};

  GetConfigRuleResponse() {}

  explicit GetConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigRuleResponse() = default;
};
class GetConfigRuleComplianceByPackRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};

  GetConfigRuleComplianceByPackRequest() {}

  explicit GetConfigRuleComplianceByPackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetConfigRuleComplianceByPackRequest() = default;
};
class GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};

  GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances() {}

  explicit GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
  }


  virtual ~GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances() = default;
};
class GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<vector<GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances>> configRuleCompliances{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult() {}

  explicit GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleCompliances) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleCompliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleCompliances"] = boost::any(temp1);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleCompliances") != m.end() && !m["ConfigRuleCompliances"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleCompliances"].type()) {
        vector<GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleCompliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleCompliances = make_shared<vector<GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances>>(expect1);
      }
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult() = default;
};
class GetConfigRuleComplianceByPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult> configRuleComplianceResult{};
  shared_ptr<string> requestId{};

  GetConfigRuleComplianceByPackResponseBody() {}

  explicit GetConfigRuleComplianceByPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleComplianceResult) {
      res["ConfigRuleComplianceResult"] = configRuleComplianceResult ? boost::any(configRuleComplianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleComplianceResult") != m.end() && !m["ConfigRuleComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRuleComplianceResult"].type()) {
        GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRuleComplianceResult"]));
        configRuleComplianceResult = make_shared<GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigRuleComplianceByPackResponseBody() = default;
};
class GetConfigRuleComplianceByPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigRuleComplianceByPackResponseBody> body{};

  GetConfigRuleComplianceByPackResponse() {}

  explicit GetConfigRuleComplianceByPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigRuleComplianceByPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigRuleComplianceByPackResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigRuleComplianceByPackResponse() = default;
};
class GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries : public Darabonba::Model {
public:
  shared_ptr<long> compliantCount{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> riskLevel{};

  GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries() {}

  explicit GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliantCount) {
      res["CompliantCount"] = boost::any(*compliantCount);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliantCount") != m.end() && !m["CompliantCount"].empty()) {
      compliantCount = make_shared<long>(boost::any_cast<long>(m["CompliantCount"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries() = default;
};
class GetConfigRuleSummaryByRiskLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries>> configRuleSummaries{};
  shared_ptr<string> requestId{};

  GetConfigRuleSummaryByRiskLevelResponseBody() {}

  explicit GetConfigRuleSummaryByRiskLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleSummaries) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleSummaries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleSummaries"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleSummaries") != m.end() && !m["ConfigRuleSummaries"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleSummaries"].type()) {
        vector<GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleSummaries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleSummaries = make_shared<vector<GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigRuleSummaryByRiskLevelResponseBody() = default;
};
class GetConfigRuleSummaryByRiskLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigRuleSummaryByRiskLevelResponseBody> body{};

  GetConfigRuleSummaryByRiskLevelResponse() {}

  explicit GetConfigRuleSummaryByRiskLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigRuleSummaryByRiskLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigRuleSummaryByRiskLevelResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigRuleSummaryByRiskLevelResponse() = default;
};
class GetConfigRulesReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> reportId{};

  GetConfigRulesReportRequest() {}

  explicit GetConfigRulesReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
  }


  virtual ~GetConfigRulesReportRequest() = default;
};
class GetConfigRulesReportResponseBodyConfigRulesReport : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<long> reportCreateTimestamp{};
  shared_ptr<string> reportId{};
  shared_ptr<string> reportStatus{};
  shared_ptr<string> reportUrl{};

  GetConfigRulesReportResponseBodyConfigRulesReport() {}

  explicit GetConfigRulesReportResponseBodyConfigRulesReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (reportCreateTimestamp) {
      res["ReportCreateTimestamp"] = boost::any(*reportCreateTimestamp);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (reportUrl) {
      res["ReportUrl"] = boost::any(*reportUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("ReportCreateTimestamp") != m.end() && !m["ReportCreateTimestamp"].empty()) {
      reportCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportCreateTimestamp"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["ReportId"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<string>(boost::any_cast<string>(m["ReportStatus"]));
    }
    if (m.find("ReportUrl") != m.end() && !m["ReportUrl"].empty()) {
      reportUrl = make_shared<string>(boost::any_cast<string>(m["ReportUrl"]));
    }
  }


  virtual ~GetConfigRulesReportResponseBodyConfigRulesReport() = default;
};
class GetConfigRulesReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigRulesReportResponseBodyConfigRulesReport> configRulesReport{};
  shared_ptr<string> requestId{};

  GetConfigRulesReportResponseBody() {}

  explicit GetConfigRulesReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRulesReport) {
      res["ConfigRulesReport"] = configRulesReport ? boost::any(configRulesReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRulesReport") != m.end() && !m["ConfigRulesReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRulesReport"].type()) {
        GetConfigRulesReportResponseBodyConfigRulesReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRulesReport"]));
        configRulesReport = make_shared<GetConfigRulesReportResponseBodyConfigRulesReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigRulesReportResponseBody() = default;
};
class GetConfigRulesReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigRulesReportResponseBody> body{};

  GetConfigRulesReportResponse() {}

  explicit GetConfigRulesReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigRulesReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigRulesReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigRulesReportResponse() = default;
};
class GetConfigurationRecorderResponseBodyConfigurationRecorder : public Darabonba::Model {
public:
  shared_ptr<string> configurationRecorderStatus{};
  shared_ptr<vector<string>> resourceTypes{};

  GetConfigurationRecorderResponseBodyConfigurationRecorder() {}

  explicit GetConfigurationRecorderResponseBodyConfigurationRecorder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorderStatus) {
      res["ConfigurationRecorderStatus"] = boost::any(*configurationRecorderStatus);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorderStatus") != m.end() && !m["ConfigurationRecorderStatus"].empty()) {
      configurationRecorderStatus = make_shared<string>(boost::any_cast<string>(m["ConfigurationRecorderStatus"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetConfigurationRecorderResponseBodyConfigurationRecorder() = default;
};
class GetConfigurationRecorderResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConfigurationRecorderResponseBodyConfigurationRecorder> configurationRecorder{};
  shared_ptr<string> requestId{};

  GetConfigurationRecorderResponseBody() {}

  explicit GetConfigurationRecorderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorder) {
      res["ConfigurationRecorder"] = configurationRecorder ? boost::any(configurationRecorder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorder") != m.end() && !m["ConfigurationRecorder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigurationRecorder"].type()) {
        GetConfigurationRecorderResponseBodyConfigurationRecorder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigurationRecorder"]));
        configurationRecorder = make_shared<GetConfigurationRecorderResponseBodyConfigurationRecorder>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConfigurationRecorderResponseBody() = default;
};
class GetConfigurationRecorderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConfigurationRecorderResponseBody> body{};

  GetConfigurationRecorderResponse() {}

  explicit GetConfigurationRecorderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigurationRecorderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigurationRecorderResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigurationRecorderResponse() = default;
};
class GetDiscoveredResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> complianceOption{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  GetDiscoveredResourceRequest() {}

  explicit GetDiscoveredResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceOption) {
      res["ComplianceOption"] = boost::any(*complianceOption);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceOption") != m.end() && !m["ComplianceOption"].empty()) {
      complianceOption = make_shared<long>(boost::any_cast<long>(m["ComplianceOption"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetDiscoveredResourceRequest() = default;
};
class GetDiscoveredResourceResponseBodyDiscoveredResourceDetail : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configuration{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreationTime{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetDiscoveredResourceResponseBodyDiscoveredResourceDetail() {}

  explicit GetDiscoveredResourceResponseBodyDiscoveredResourceDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreationTime) {
      res["ResourceCreationTime"] = boost::any(*resourceCreationTime);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreationTime") != m.end() && !m["ResourceCreationTime"].empty()) {
      resourceCreationTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreationTime"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetDiscoveredResourceResponseBodyDiscoveredResourceDetail() = default;
};
class GetDiscoveredResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDiscoveredResourceResponseBodyDiscoveredResourceDetail> discoveredResourceDetail{};
  shared_ptr<string> requestId{};

  GetDiscoveredResourceResponseBody() {}

  explicit GetDiscoveredResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceDetail) {
      res["DiscoveredResourceDetail"] = discoveredResourceDetail ? boost::any(discoveredResourceDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceDetail") != m.end() && !m["DiscoveredResourceDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiscoveredResourceDetail"].type()) {
        GetDiscoveredResourceResponseBodyDiscoveredResourceDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiscoveredResourceDetail"]));
        discoveredResourceDetail = make_shared<GetDiscoveredResourceResponseBodyDiscoveredResourceDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDiscoveredResourceResponseBody() = default;
};
class GetDiscoveredResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDiscoveredResourceResponseBody> body{};

  GetDiscoveredResourceResponse() {}

  explicit GetDiscoveredResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDiscoveredResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDiscoveredResourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetDiscoveredResourceResponse() = default;
};
class GetDiscoveredResourceCountsGroupByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};

  GetDiscoveredResourceCountsGroupByRegionRequest() {}

  explicit GetDiscoveredResourceCountsGroupByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByRegionRequest() = default;
};
class GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCount{};

  GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary() {}

  explicit GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary() = default;
};
class GetDiscoveredResourceCountsGroupByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary>> discoveredResourceCountsSummary{};
  shared_ptr<string> requestId{};

  GetDiscoveredResourceCountsGroupByRegionResponseBody() {}

  explicit GetDiscoveredResourceCountsGroupByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceCountsSummary) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceCountsSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceCountsSummary"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceCountsSummary") != m.end() && !m["DiscoveredResourceCountsSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceCountsSummary"].type()) {
        vector<GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceCountsSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceCountsSummary = make_shared<vector<GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByRegionResponseBody() = default;
};
class GetDiscoveredResourceCountsGroupByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDiscoveredResourceCountsGroupByRegionResponseBody> body{};

  GetDiscoveredResourceCountsGroupByRegionResponse() {}

  explicit GetDiscoveredResourceCountsGroupByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDiscoveredResourceCountsGroupByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDiscoveredResourceCountsGroupByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByRegionResponse() = default;
};
class GetDiscoveredResourceCountsGroupByResourceTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> region{};

  GetDiscoveredResourceCountsGroupByResourceTypeRequest() {}

  explicit GetDiscoveredResourceCountsGroupByResourceTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByResourceTypeRequest() = default;
};
class GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<long> resourceCount{};
  shared_ptr<string> resourceType{};

  GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary() {}

  explicit GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (resourceCount) {
      res["ResourceCount"] = boost::any(*resourceCount);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      resourceCount = make_shared<long>(boost::any_cast<long>(m["ResourceCount"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary() = default;
};
class GetDiscoveredResourceCountsGroupByResourceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary>> discoveredResourceCountsSummary{};
  shared_ptr<string> requestId{};

  GetDiscoveredResourceCountsGroupByResourceTypeResponseBody() {}

  explicit GetDiscoveredResourceCountsGroupByResourceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceCountsSummary) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceCountsSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceCountsSummary"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceCountsSummary") != m.end() && !m["DiscoveredResourceCountsSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceCountsSummary"].type()) {
        vector<GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceCountsSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceCountsSummary = make_shared<vector<GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByResourceTypeResponseBody() = default;
};
class GetDiscoveredResourceCountsGroupByResourceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDiscoveredResourceCountsGroupByResourceTypeResponseBody> body{};

  GetDiscoveredResourceCountsGroupByResourceTypeResponse() {}

  explicit GetDiscoveredResourceCountsGroupByResourceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDiscoveredResourceCountsGroupByResourceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDiscoveredResourceCountsGroupByResourceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~GetDiscoveredResourceCountsGroupByResourceTypeResponse() = default;
};
class GetIntegratedServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceCode{};

  GetIntegratedServiceStatusRequest() {}

  explicit GetIntegratedServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
  }


  virtual ~GetIntegratedServiceStatusRequest() = default;
};
class GetIntegratedServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> integratedTypes{};
  shared_ptr<string> requestId{};

  GetIntegratedServiceStatusResponseBody() {}

  explicit GetIntegratedServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (integratedTypes) {
      res["IntegratedTypes"] = boost::any(*integratedTypes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("IntegratedTypes") != m.end() && !m["IntegratedTypes"].empty()) {
      integratedTypes = make_shared<string>(boost::any_cast<string>(m["IntegratedTypes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIntegratedServiceStatusResponseBody() = default;
};
class GetIntegratedServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIntegratedServiceStatusResponseBody> body{};

  GetIntegratedServiceStatusResponse() {}

  explicit GetIntegratedServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIntegratedServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIntegratedServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetIntegratedServiceStatusResponse() = default;
};
class GetManagedRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};

  GetManagedRuleRequest() {}

  explicit GetManagedRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
  }


  virtual ~GetManagedRuleRequest() = default;
};
class GetManagedRuleResponseBodyManagedRuleScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> complianceResourceTypes{};

  GetManagedRuleResponseBodyManagedRuleScope() {}

  explicit GetManagedRuleResponseBodyManagedRuleScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResourceTypes) {
      res["ComplianceResourceTypes"] = boost::any(*complianceResourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResourceTypes") != m.end() && !m["ComplianceResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComplianceResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComplianceResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      complianceResourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetManagedRuleResponseBodyManagedRuleScope() = default;
};
class GetManagedRuleResponseBodyManagedRuleSourceDetails : public Darabonba::Model {
public:
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> messageType{};

  GetManagedRuleResponseBodyManagedRuleSourceDetails() {}

  explicit GetManagedRuleResponseBodyManagedRuleSourceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
  }


  virtual ~GetManagedRuleResponseBodyManagedRuleSourceDetails() = default;
};
class GetManagedRuleResponseBodyManagedRule : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> compulsoryInputParameterDetails{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> description{};
  shared_ptr<string> helpUrls{};
  shared_ptr<string> identifier{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<map<string, boost::any>> optionalInputParameterDetails{};
  shared_ptr<long> riskLevel{};
  shared_ptr<GetManagedRuleResponseBodyManagedRuleScope> scope{};
  shared_ptr<vector<GetManagedRuleResponseBodyManagedRuleSourceDetails>> sourceDetails{};

  GetManagedRuleResponseBodyManagedRule() {}

  explicit GetManagedRuleResponseBodyManagedRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compulsoryInputParameterDetails) {
      res["CompulsoryInputParameterDetails"] = boost::any(*compulsoryInputParameterDetails);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (helpUrls) {
      res["HelpUrls"] = boost::any(*helpUrls);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (optionalInputParameterDetails) {
      res["OptionalInputParameterDetails"] = boost::any(*optionalInputParameterDetails);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scope) {
      res["Scope"] = scope ? boost::any(scope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceDetails) {
      vector<boost::any> temp1;
      for(auto item1:*sourceDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompulsoryInputParameterDetails") != m.end() && !m["CompulsoryInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CompulsoryInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      compulsoryInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HelpUrls") != m.end() && !m["HelpUrls"].empty()) {
      helpUrls = make_shared<string>(boost::any_cast<string>(m["HelpUrls"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OptionalInputParameterDetails") != m.end() && !m["OptionalInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OptionalInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      optionalInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scope"].type()) {
        GetManagedRuleResponseBodyManagedRuleScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scope"]));
        scope = make_shared<GetManagedRuleResponseBodyManagedRuleScope>(model1);
      }
    }
    if (m.find("SourceDetails") != m.end() && !m["SourceDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceDetails"].type()) {
        vector<GetManagedRuleResponseBodyManagedRuleSourceDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetManagedRuleResponseBodyManagedRuleSourceDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceDetails = make_shared<vector<GetManagedRuleResponseBodyManagedRuleSourceDetails>>(expect1);
      }
    }
  }


  virtual ~GetManagedRuleResponseBodyManagedRule() = default;
};
class GetManagedRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetManagedRuleResponseBodyManagedRule> managedRule{};
  shared_ptr<string> requestId{};

  GetManagedRuleResponseBody() {}

  explicit GetManagedRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRule) {
      res["ManagedRule"] = managedRule ? boost::any(managedRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRule") != m.end() && !m["ManagedRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManagedRule"].type()) {
        GetManagedRuleResponseBodyManagedRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManagedRule"]));
        managedRule = make_shared<GetManagedRuleResponseBodyManagedRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetManagedRuleResponseBody() = default;
};
class GetManagedRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetManagedRuleResponseBody> body{};

  GetManagedRuleResponse() {}

  explicit GetManagedRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetManagedRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetManagedRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetManagedRuleResponse() = default;
};
class GetRemediationTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateIdentifier{};

  GetRemediationTemplateRequest() {}

  explicit GetRemediationTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateIdentifier) {
      res["TemplateIdentifier"] = boost::any(*templateIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateIdentifier") != m.end() && !m["TemplateIdentifier"].empty()) {
      templateIdentifier = make_shared<string>(boost::any_cast<string>(m["TemplateIdentifier"]));
    }
  }


  virtual ~GetRemediationTemplateRequest() = default;
};
class GetRemediationTemplateResponseBodyRemediationTemplates : public Darabonba::Model {
public:
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<string> remediationType{};
  shared_ptr<string> templateDefinition{};
  shared_ptr<string> templateDescription{};
  shared_ptr<string> templateIdentifier{};
  shared_ptr<string> templateName{};

  GetRemediationTemplateResponseBodyRemediationTemplates() {}

  explicit GetRemediationTemplateResponseBodyRemediationTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (templateDefinition) {
      res["TemplateDefinition"] = boost::any(*templateDefinition);
    }
    if (templateDescription) {
      res["TemplateDescription"] = boost::any(*templateDescription);
    }
    if (templateIdentifier) {
      res["TemplateIdentifier"] = boost::any(*templateIdentifier);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("TemplateDefinition") != m.end() && !m["TemplateDefinition"].empty()) {
      templateDefinition = make_shared<string>(boost::any_cast<string>(m["TemplateDefinition"]));
    }
    if (m.find("TemplateDescription") != m.end() && !m["TemplateDescription"].empty()) {
      templateDescription = make_shared<string>(boost::any_cast<string>(m["TemplateDescription"]));
    }
    if (m.find("TemplateIdentifier") != m.end() && !m["TemplateIdentifier"].empty()) {
      templateIdentifier = make_shared<string>(boost::any_cast<string>(m["TemplateIdentifier"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~GetRemediationTemplateResponseBodyRemediationTemplates() = default;
};
class GetRemediationTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetRemediationTemplateResponseBodyRemediationTemplates>> remediationTemplates{};
  shared_ptr<string> requestId{};

  GetRemediationTemplateResponseBody() {}

  explicit GetRemediationTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*remediationTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationTemplates"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationTemplates") != m.end() && !m["RemediationTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationTemplates"].type()) {
        vector<GetRemediationTemplateResponseBodyRemediationTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemediationTemplateResponseBodyRemediationTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationTemplates = make_shared<vector<GetRemediationTemplateResponseBodyRemediationTemplates>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRemediationTemplateResponseBody() = default;
};
class GetRemediationTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRemediationTemplateResponseBody> body{};

  GetRemediationTemplateResponse() {}

  explicit GetRemediationTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRemediationTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRemediationTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetRemediationTemplateResponse() = default;
};
class GetResourceComplianceByConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};

  GetResourceComplianceByConfigRuleRequest() {}

  explicit GetResourceComplianceByConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
  }


  virtual ~GetResourceComplianceByConfigRuleRequest() = default;
};
class GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances() {}

  explicit GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances() = default;
};
class GetResourceComplianceByConfigRuleResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances>> compliances{};
  shared_ptr<long> totalCount{};

  GetResourceComplianceByConfigRuleResponseBodyComplianceResult() {}

  explicit GetResourceComplianceByConfigRuleResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetResourceComplianceByConfigRuleResponseBodyComplianceResult() = default;
};
class GetResourceComplianceByConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetResourceComplianceByConfigRuleResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetResourceComplianceByConfigRuleResponseBody() {}

  explicit GetResourceComplianceByConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetResourceComplianceByConfigRuleResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetResourceComplianceByConfigRuleResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetResourceComplianceByConfigRuleResponseBody() = default;
};
class GetResourceComplianceByConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceComplianceByConfigRuleResponseBody> body{};

  GetResourceComplianceByConfigRuleResponse() {}

  explicit GetResourceComplianceByConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceComplianceByConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceComplianceByConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceByConfigRuleResponse() = default;
};
class GetResourceComplianceByPackRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};

  GetResourceComplianceByPackRequest() {}

  explicit GetResourceComplianceByPackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
  }


  virtual ~GetResourceComplianceByPackRequest() = default;
};
class GetResourceComplianceByPackResponseBodyResourceComplianceResult : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<long> nonCompliantCount{};
  shared_ptr<long> totalCount{};

  GetResourceComplianceByPackResponseBodyResourceComplianceResult() {}

  explicit GetResourceComplianceByPackResponseBodyResourceComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (nonCompliantCount) {
      res["NonCompliantCount"] = boost::any(*nonCompliantCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("NonCompliantCount") != m.end() && !m["NonCompliantCount"].empty()) {
      nonCompliantCount = make_shared<long>(boost::any_cast<long>(m["NonCompliantCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetResourceComplianceByPackResponseBodyResourceComplianceResult() = default;
};
class GetResourceComplianceByPackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceComplianceByPackResponseBodyResourceComplianceResult> resourceComplianceResult{};

  GetResourceComplianceByPackResponseBody() {}

  explicit GetResourceComplianceByPackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceComplianceResult) {
      res["ResourceComplianceResult"] = resourceComplianceResult ? boost::any(resourceComplianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceComplianceResult") != m.end() && !m["ResourceComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceComplianceResult"].type()) {
        GetResourceComplianceByPackResponseBodyResourceComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceComplianceResult"]));
        resourceComplianceResult = make_shared<GetResourceComplianceByPackResponseBodyResourceComplianceResult>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceByPackResponseBody() = default;
};
class GetResourceComplianceByPackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceComplianceByPackResponseBody> body{};

  GetResourceComplianceByPackResponse() {}

  explicit GetResourceComplianceByPackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceComplianceByPackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceComplianceByPackResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceByPackResponse() = default;
};
class GetResourceComplianceGroupByRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};

  GetResourceComplianceGroupByRegionRequest() {}

  explicit GetResourceComplianceGroupByRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GetResourceComplianceGroupByRegionRequest() = default;
};
class GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances() {}

  explicit GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances() = default;
};
class GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances>> compliances{};
  shared_ptr<string> regionId{};

  GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList() {}

  explicit GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList() = default;
};
class GetResourceComplianceGroupByRegionResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList>> complianceResultList{};

  GetResourceComplianceGroupByRegionResponseBodyComplianceResult() {}

  explicit GetResourceComplianceGroupByRegionResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResultList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResultList") != m.end() && !m["ComplianceResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceResultList"].type()) {
        vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceResultList = make_shared<vector<GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList>>(expect1);
      }
    }
  }


  virtual ~GetResourceComplianceGroupByRegionResponseBodyComplianceResult() = default;
};
class GetResourceComplianceGroupByRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetResourceComplianceGroupByRegionResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetResourceComplianceGroupByRegionResponseBody() {}

  explicit GetResourceComplianceGroupByRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetResourceComplianceGroupByRegionResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetResourceComplianceGroupByRegionResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetResourceComplianceGroupByRegionResponseBody() = default;
};
class GetResourceComplianceGroupByRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceComplianceGroupByRegionResponseBody> body{};

  GetResourceComplianceGroupByRegionResponse() {}

  explicit GetResourceComplianceGroupByRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceComplianceGroupByRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceComplianceGroupByRegionResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceGroupByRegionResponse() = default;
};
class GetResourceComplianceGroupByResourceTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};

  GetResourceComplianceGroupByResourceTypeRequest() {}

  explicit GetResourceComplianceGroupByResourceTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeRequest() = default;
};
class GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances() {}

  explicit GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances() = default;
};
class GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances>> compliances{};
  shared_ptr<string> resourceType{};

  GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList() {}

  explicit GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliances) {
      vector<boost::any> temp1;
      for(auto item1:*compliances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Compliances"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Compliances") != m.end() && !m["Compliances"].empty()) {
      if (typeid(vector<boost::any>) == m["Compliances"].type()) {
        vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Compliances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliances = make_shared<vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList() = default;
};
class GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList>> complianceResultList{};

  GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult() {}

  explicit GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResultList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResultList") != m.end() && !m["ComplianceResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceResultList"].type()) {
        vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceResultList = make_shared<vector<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList>>(expect1);
      }
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult() = default;
};
class GetResourceComplianceGroupByResourceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult> complianceResult{};
  shared_ptr<string> requestId{};

  GetResourceComplianceGroupByResourceTypeResponseBody() {}

  explicit GetResourceComplianceGroupByResourceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResult) {
      res["ComplianceResult"] = complianceResult ? boost::any(complianceResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResult") != m.end() && !m["ComplianceResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ComplianceResult"].type()) {
        GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ComplianceResult"]));
        complianceResult = make_shared<GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeResponseBody() = default;
};
class GetResourceComplianceGroupByResourceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceComplianceGroupByResourceTypeResponseBody> body{};

  GetResourceComplianceGroupByResourceTypeResponse() {}

  explicit GetResourceComplianceGroupByResourceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceComplianceGroupByResourceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceComplianceGroupByResourceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceGroupByResourceTypeResponse() = default;
};
class GetResourceComplianceTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> startTime{};

  GetResourceComplianceTimelineRequest() {}

  explicit GetResourceComplianceTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetResourceComplianceTimelineRequest() = default;
};
class GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<long> captureTime{};
  shared_ptr<string> configuration{};
  shared_ptr<string> configurationDiff{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreateTime{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList() {}

  explicit GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (captureTime) {
      res["CaptureTime"] = boost::any(*captureTime);
    }
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (configurationDiff) {
      res["ConfigurationDiff"] = boost::any(*configurationDiff);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreateTime) {
      res["ResourceCreateTime"] = boost::any(*resourceCreateTime);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("CaptureTime") != m.end() && !m["CaptureTime"].empty()) {
      captureTime = make_shared<long>(boost::any_cast<long>(m["CaptureTime"]));
    }
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("ConfigurationDiff") != m.end() && !m["ConfigurationDiff"].empty()) {
      configurationDiff = make_shared<string>(boost::any_cast<string>(m["ConfigurationDiff"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreateTime") != m.end() && !m["ResourceCreateTime"].empty()) {
      resourceCreateTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreateTime"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList() = default;
};
class GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList>> complianceList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline() {}

  explicit GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceList) {
      vector<boost::any> temp1;
      for(auto item1:*complianceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ComplianceList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceList") != m.end() && !m["ComplianceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ComplianceList"].type()) {
        vector<GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ComplianceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        complianceList = make_shared<vector<GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline() = default;
};
class GetResourceComplianceTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline> resourceComplianceTimeline{};

  GetResourceComplianceTimelineResponseBody() {}

  explicit GetResourceComplianceTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceComplianceTimeline) {
      res["ResourceComplianceTimeline"] = resourceComplianceTimeline ? boost::any(resourceComplianceTimeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceComplianceTimeline") != m.end() && !m["ResourceComplianceTimeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceComplianceTimeline"].type()) {
        GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceComplianceTimeline"]));
        resourceComplianceTimeline = make_shared<GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceTimelineResponseBody() = default;
};
class GetResourceComplianceTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceComplianceTimelineResponseBody> body{};

  GetResourceComplianceTimelineResponse() {}

  explicit GetResourceComplianceTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceComplianceTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceComplianceTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceComplianceTimelineResponse() = default;
};
class GetResourceConfigurationTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> startTime{};

  GetResourceConfigurationTimelineRequest() {}

  explicit GetResourceConfigurationTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetResourceConfigurationTimelineRequest() = default;
};
class GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> captureTime{};
  shared_ptr<string> configurationDiff{};
  shared_ptr<string> region{};
  shared_ptr<string> relationship{};
  shared_ptr<string> relationshipDiff{};
  shared_ptr<string> resourceCreateTime{};
  shared_ptr<string> resourceEventType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};

  GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList() {}

  explicit GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (captureTime) {
      res["CaptureTime"] = boost::any(*captureTime);
    }
    if (configurationDiff) {
      res["ConfigurationDiff"] = boost::any(*configurationDiff);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (relationship) {
      res["Relationship"] = boost::any(*relationship);
    }
    if (relationshipDiff) {
      res["RelationshipDiff"] = boost::any(*relationshipDiff);
    }
    if (resourceCreateTime) {
      res["ResourceCreateTime"] = boost::any(*resourceCreateTime);
    }
    if (resourceEventType) {
      res["ResourceEventType"] = boost::any(*resourceEventType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("CaptureTime") != m.end() && !m["CaptureTime"].empty()) {
      captureTime = make_shared<string>(boost::any_cast<string>(m["CaptureTime"]));
    }
    if (m.find("ConfigurationDiff") != m.end() && !m["ConfigurationDiff"].empty()) {
      configurationDiff = make_shared<string>(boost::any_cast<string>(m["ConfigurationDiff"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Relationship") != m.end() && !m["Relationship"].empty()) {
      relationship = make_shared<string>(boost::any_cast<string>(m["Relationship"]));
    }
    if (m.find("RelationshipDiff") != m.end() && !m["RelationshipDiff"].empty()) {
      relationshipDiff = make_shared<string>(boost::any_cast<string>(m["RelationshipDiff"]));
    }
    if (m.find("ResourceCreateTime") != m.end() && !m["ResourceCreateTime"].empty()) {
      resourceCreateTime = make_shared<string>(boost::any_cast<string>(m["ResourceCreateTime"]));
    }
    if (m.find("ResourceEventType") != m.end() && !m["ResourceEventType"].empty()) {
      resourceEventType = make_shared<string>(boost::any_cast<string>(m["ResourceEventType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList() = default;
};
class GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline : public Darabonba::Model {
public:
  shared_ptr<vector<GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList>> configurationList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline() {}

  explicit GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationList) {
      vector<boost::any> temp1;
      for(auto item1:*configurationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigurationList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationList") != m.end() && !m["ConfigurationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigurationList"].type()) {
        vector<GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigurationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configurationList = make_shared<vector<GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline() = default;
};
class GetResourceConfigurationTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline> resourceConfigurationTimeline{};

  GetResourceConfigurationTimelineResponseBody() {}

  explicit GetResourceConfigurationTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceConfigurationTimeline) {
      res["ResourceConfigurationTimeline"] = resourceConfigurationTimeline ? boost::any(resourceConfigurationTimeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceConfigurationTimeline") != m.end() && !m["ResourceConfigurationTimeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceConfigurationTimeline"].type()) {
        GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceConfigurationTimeline"]));
        resourceConfigurationTimeline = make_shared<GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline>(model1);
      }
    }
  }


  virtual ~GetResourceConfigurationTimelineResponseBody() = default;
};
class GetResourceConfigurationTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceConfigurationTimelineResponseBody> body{};

  GetResourceConfigurationTimelineResponse() {}

  explicit GetResourceConfigurationTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceConfigurationTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceConfigurationTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceConfigurationTimelineResponse() = default;
};
class GetResourceInventoryResponseBodyResourceInventory : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> resourceInventoryGenerateTime{};
  shared_ptr<string> status{};

  GetResourceInventoryResponseBodyResourceInventory() {}

  explicit GetResourceInventoryResponseBodyResourceInventory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (resourceInventoryGenerateTime) {
      res["ResourceInventoryGenerateTime"] = boost::any(*resourceInventoryGenerateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("ResourceInventoryGenerateTime") != m.end() && !m["ResourceInventoryGenerateTime"].empty()) {
      resourceInventoryGenerateTime = make_shared<long>(boost::any_cast<long>(m["ResourceInventoryGenerateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetResourceInventoryResponseBodyResourceInventory() = default;
};
class GetResourceInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetResourceInventoryResponseBodyResourceInventory> resourceInventory{};

  GetResourceInventoryResponseBody() {}

  explicit GetResourceInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceInventory) {
      res["ResourceInventory"] = resourceInventory ? boost::any(resourceInventory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceInventory") != m.end() && !m["ResourceInventory"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInventory"].type()) {
        GetResourceInventoryResponseBodyResourceInventory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInventory"]));
        resourceInventory = make_shared<GetResourceInventoryResponseBodyResourceInventory>(model1);
      }
    }
  }


  virtual ~GetResourceInventoryResponseBody() = default;
};
class GetResourceInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceInventoryResponseBody> body{};

  GetResourceInventoryResponse() {}

  explicit GetResourceInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceInventoryResponse() = default;
};
class GetSupportedResourceRelationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};

  GetSupportedResourceRelationConfigRequest() {}

  explicit GetSupportedResourceRelationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~GetSupportedResourceRelationConfigRequest() = default;
};
class GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList : public Darabonba::Model {
public:
  shared_ptr<string> relationType{};
  shared_ptr<string> targetResourceType{};

  GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList() {}

  explicit GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relationType) {
      res["RelationType"] = boost::any(*relationType);
    }
    if (targetResourceType) {
      res["TargetResourceType"] = boost::any(*targetResourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelationType") != m.end() && !m["RelationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["RelationType"]));
    }
    if (m.find("TargetResourceType") != m.end() && !m["TargetResourceType"].empty()) {
      targetResourceType = make_shared<string>(boost::any_cast<string>(m["TargetResourceType"]));
    }
  }


  virtual ~GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList() = default;
};
class GetSupportedResourceRelationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList>> resourceRelationConfigList{};

  GetSupportedResourceRelationConfigResponseBody() {}

  explicit GetSupportedResourceRelationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceRelationConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceRelationConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceRelationConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceRelationConfigList") != m.end() && !m["ResourceRelationConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceRelationConfigList"].type()) {
        vector<GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceRelationConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceRelationConfigList = make_shared<vector<GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList>>(expect1);
      }
    }
  }


  virtual ~GetSupportedResourceRelationConfigResponseBody() = default;
};
class GetSupportedResourceRelationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSupportedResourceRelationConfigResponseBody> body{};

  GetSupportedResourceRelationConfigResponse() {}

  explicit GetSupportedResourceRelationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSupportedResourceRelationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSupportedResourceRelationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetSupportedResourceRelationConfigResponse() = default;
};
class IgnoreAggregateEvaluationResultsRequestResources : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  IgnoreAggregateEvaluationResultsRequestResources() {}

  explicit IgnoreAggregateEvaluationResultsRequestResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~IgnoreAggregateEvaluationResultsRequestResources() = default;
};
class IgnoreAggregateEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> reason{};
  shared_ptr<vector<IgnoreAggregateEvaluationResultsRequestResources>> resources{};

  IgnoreAggregateEvaluationResultsRequest() {}

  explicit IgnoreAggregateEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<IgnoreAggregateEvaluationResultsRequestResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IgnoreAggregateEvaluationResultsRequestResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<IgnoreAggregateEvaluationResultsRequestResources>>(expect1);
      }
    }
  }


  virtual ~IgnoreAggregateEvaluationResultsRequest() = default;
};
class IgnoreAggregateEvaluationResultsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> reason{};
  shared_ptr<string> resourcesShrink{};

  IgnoreAggregateEvaluationResultsShrinkRequest() {}

  explicit IgnoreAggregateEvaluationResultsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourcesShrink) {
      res["Resources"] = boost::any(*resourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resourcesShrink = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~IgnoreAggregateEvaluationResultsShrinkRequest() = default;
};
class IgnoreAggregateEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  IgnoreAggregateEvaluationResultsResponseBody() {}

  explicit IgnoreAggregateEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IgnoreAggregateEvaluationResultsResponseBody() = default;
};
class IgnoreAggregateEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IgnoreAggregateEvaluationResultsResponseBody> body{};

  IgnoreAggregateEvaluationResultsResponse() {}

  explicit IgnoreAggregateEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IgnoreAggregateEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IgnoreAggregateEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~IgnoreAggregateEvaluationResultsResponse() = default;
};
class IgnoreEvaluationResultsRequestResources : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  IgnoreEvaluationResultsRequestResources() {}

  explicit IgnoreEvaluationResultsRequestResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~IgnoreEvaluationResultsRequestResources() = default;
};
class IgnoreEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> reason{};
  shared_ptr<vector<IgnoreEvaluationResultsRequestResources>> resources{};

  IgnoreEvaluationResultsRequest() {}

  explicit IgnoreEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<IgnoreEvaluationResultsRequestResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IgnoreEvaluationResultsRequestResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<IgnoreEvaluationResultsRequestResources>>(expect1);
      }
    }
  }


  virtual ~IgnoreEvaluationResultsRequest() = default;
};
class IgnoreEvaluationResultsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> reason{};
  shared_ptr<string> resourcesShrink{};

  IgnoreEvaluationResultsShrinkRequest() {}

  explicit IgnoreEvaluationResultsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourcesShrink) {
      res["Resources"] = boost::any(*resourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resourcesShrink = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~IgnoreEvaluationResultsShrinkRequest() = default;
};
class IgnoreEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  IgnoreEvaluationResultsResponseBody() {}

  explicit IgnoreEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IgnoreEvaluationResultsResponseBody() = default;
};
class IgnoreEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IgnoreEvaluationResultsResponseBody> body{};

  IgnoreEvaluationResultsResponse() {}

  explicit IgnoreEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IgnoreEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IgnoreEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~IgnoreEvaluationResultsResponse() = default;
};
class ListAggregateCompliancePacksRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListAggregateCompliancePacksRequest() {}

  explicit ListAggregateCompliancePacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAggregateCompliancePacksRequest() = default;
};
class ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> status{};

  ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks() {}

  explicit ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks() = default;
};
class ListAggregateCompliancePacksResponseBodyCompliancePacksResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks>> compliancePacks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAggregateCompliancePacksResponseBodyCompliancePacksResult() {}

  explicit ListAggregateCompliancePacksResponseBodyCompliancePacksResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePacks) {
      vector<boost::any> temp1;
      for(auto item1:*compliancePacks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompliancePacks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePacks") != m.end() && !m["CompliancePacks"].empty()) {
      if (typeid(vector<boost::any>) == m["CompliancePacks"].type()) {
        vector<ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompliancePacks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliancePacks = make_shared<vector<ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAggregateCompliancePacksResponseBodyCompliancePacksResult() = default;
};
class ListAggregateCompliancePacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateCompliancePacksResponseBodyCompliancePacksResult> compliancePacksResult{};
  shared_ptr<string> requestId{};

  ListAggregateCompliancePacksResponseBody() {}

  explicit ListAggregateCompliancePacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePacksResult) {
      res["CompliancePacksResult"] = compliancePacksResult ? boost::any(compliancePacksResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePacksResult") != m.end() && !m["CompliancePacksResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePacksResult"].type()) {
        ListAggregateCompliancePacksResponseBodyCompliancePacksResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePacksResult"]));
        compliancePacksResult = make_shared<ListAggregateCompliancePacksResponseBodyCompliancePacksResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateCompliancePacksResponseBody() = default;
};
class ListAggregateCompliancePacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateCompliancePacksResponseBody> body{};

  ListAggregateCompliancePacksResponse() {}

  explicit ListAggregateCompliancePacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateCompliancePacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateCompliancePacksResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateCompliancePacksResponse() = default;
};
class ListAggregateConfigDeliveryChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> deliveryChannelIds{};

  ListAggregateConfigDeliveryChannelsRequest() {}

  explicit ListAggregateConfigDeliveryChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (deliveryChannelIds) {
      res["DeliveryChannelIds"] = boost::any(*deliveryChannelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("DeliveryChannelIds") != m.end() && !m["DeliveryChannelIds"].empty()) {
      deliveryChannelIds = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelIds"]));
    }
  }


  virtual ~ListAggregateConfigDeliveryChannelsRequest() = default;
};
class ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels() {}

  explicit ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels() = default;
};
class ListAggregateConfigDeliveryChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels>> deliveryChannels{};
  shared_ptr<string> requestId{};

  ListAggregateConfigDeliveryChannelsResponseBody() {}

  explicit ListAggregateConfigDeliveryChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannels) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryChannels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannels") != m.end() && !m["DeliveryChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryChannels"].type()) {
        vector<ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryChannels = make_shared<vector<ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateConfigDeliveryChannelsResponseBody() = default;
};
class ListAggregateConfigDeliveryChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateConfigDeliveryChannelsResponseBody> body{};

  ListAggregateConfigDeliveryChannelsResponse() {}

  explicit ListAggregateConfigDeliveryChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateConfigDeliveryChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateConfigDeliveryChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateConfigDeliveryChannelsResponse() = default;
};
class ListAggregateConfigRuleEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regions{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceGroupIds{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceTypes{};

  ListAggregateConfigRuleEvaluationResultsRequest() {}

  explicit ListAggregateConfigRuleEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceGroupIds) {
      res["ResourceGroupIds"] = boost::any(*resourceGroupIds);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceGroupIds") != m.end() && !m["ResourceGroupIds"].empty()) {
      resourceGroupIds = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIds"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsRequest() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier : public Darabonba::Model {
public:
  shared_ptr<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier> evaluationResultQualifier{};
  shared_ptr<long> orderingTimestamp{};

  ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultQualifier) {
      res["EvaluationResultQualifier"] = evaluationResultQualifier ? boost::any(evaluationResultQualifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderingTimestamp) {
      res["OrderingTimestamp"] = boost::any(*orderingTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultQualifier") != m.end() && !m["EvaluationResultQualifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultQualifier"].type()) {
        ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultQualifier"]));
        evaluationResultQualifier = make_shared<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier>(model1);
      }
    }
    if (m.find("OrderingTimestamp") != m.end() && !m["OrderingTimestamp"].empty()) {
      orderingTimestamp = make_shared<long>(boost::any_cast<long>(m["OrderingTimestamp"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList : public Darabonba::Model {
public:
  shared_ptr<string> annotation{};
  shared_ptr<string> complianceType{};
  shared_ptr<long> configRuleInvokedTimestamp{};
  shared_ptr<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier> evaluationResultIdentifier{};
  shared_ptr<string> invokingEventMessageType{};
  shared_ptr<bool> remediationEnabled{};
  shared_ptr<long> resultRecordedTimestamp{};
  shared_ptr<long> riskLevel{};

  ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleInvokedTimestamp) {
      res["ConfigRuleInvokedTimestamp"] = boost::any(*configRuleInvokedTimestamp);
    }
    if (evaluationResultIdentifier) {
      res["EvaluationResultIdentifier"] = evaluationResultIdentifier ? boost::any(evaluationResultIdentifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invokingEventMessageType) {
      res["InvokingEventMessageType"] = boost::any(*invokingEventMessageType);
    }
    if (remediationEnabled) {
      res["RemediationEnabled"] = boost::any(*remediationEnabled);
    }
    if (resultRecordedTimestamp) {
      res["ResultRecordedTimestamp"] = boost::any(*resultRecordedTimestamp);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleInvokedTimestamp") != m.end() && !m["ConfigRuleInvokedTimestamp"].empty()) {
      configRuleInvokedTimestamp = make_shared<long>(boost::any_cast<long>(m["ConfigRuleInvokedTimestamp"]));
    }
    if (m.find("EvaluationResultIdentifier") != m.end() && !m["EvaluationResultIdentifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultIdentifier"].type()) {
        ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultIdentifier"]));
        evaluationResultIdentifier = make_shared<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier>(model1);
      }
    }
    if (m.find("InvokingEventMessageType") != m.end() && !m["InvokingEventMessageType"].empty()) {
      invokingEventMessageType = make_shared<string>(boost::any_cast<string>(m["InvokingEventMessageType"]));
    }
    if (m.find("RemediationEnabled") != m.end() && !m["RemediationEnabled"].empty()) {
      remediationEnabled = make_shared<bool>(boost::any_cast<bool>(m["RemediationEnabled"]));
    }
    if (m.find("ResultRecordedTimestamp") != m.end() && !m["ResultRecordedTimestamp"].empty()) {
      resultRecordedTimestamp = make_shared<long>(boost::any_cast<long>(m["ResultRecordedTimestamp"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>> evaluationResultList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultList) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResultList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultList") != m.end() && !m["EvaluationResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResultList"].type()) {
        vector<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResultList = make_shared<vector<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults> evaluationResults{};
  shared_ptr<string> requestId{};

  ListAggregateConfigRuleEvaluationResultsResponseBody() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      res["EvaluationResults"] = evaluationResults ? boost::any(evaluationResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResults"].type()) {
        ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResults"]));
        evaluationResults = make_shared<ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponseBody() = default;
};
class ListAggregateConfigRuleEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateConfigRuleEvaluationResultsResponseBody> body{};

  ListAggregateConfigRuleEvaluationResultsResponse() {}

  explicit ListAggregateConfigRuleEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateConfigRuleEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateConfigRuleEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationResultsResponse() = default;
};
class ListAggregateConfigRuleEvaluationStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};

  ListAggregateConfigRuleEvaluationStatisticsRequest() {}

  explicit ListAggregateConfigRuleEvaluationStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationStatisticsRequest() = default;
};
class ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> nonCompliantResourceCnt{};
  shared_ptr<long> nonCompliantRuleCnt{};
  shared_ptr<string> statisticDate{};
  shared_ptr<long> totalResourceCnt{};
  shared_ptr<long> totalRuleCnt{};

  ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults() {}

  explicit ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (nonCompliantResourceCnt) {
      res["NonCompliantResourceCnt"] = boost::any(*nonCompliantResourceCnt);
    }
    if (nonCompliantRuleCnt) {
      res["NonCompliantRuleCnt"] = boost::any(*nonCompliantRuleCnt);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (totalResourceCnt) {
      res["TotalResourceCnt"] = boost::any(*totalResourceCnt);
    }
    if (totalRuleCnt) {
      res["TotalRuleCnt"] = boost::any(*totalRuleCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("NonCompliantResourceCnt") != m.end() && !m["NonCompliantResourceCnt"].empty()) {
      nonCompliantResourceCnt = make_shared<long>(boost::any_cast<long>(m["NonCompliantResourceCnt"]));
    }
    if (m.find("NonCompliantRuleCnt") != m.end() && !m["NonCompliantRuleCnt"].empty()) {
      nonCompliantRuleCnt = make_shared<long>(boost::any_cast<long>(m["NonCompliantRuleCnt"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TotalResourceCnt") != m.end() && !m["TotalResourceCnt"].empty()) {
      totalResourceCnt = make_shared<long>(boost::any_cast<long>(m["TotalResourceCnt"]));
    }
    if (m.find("TotalRuleCnt") != m.end() && !m["TotalRuleCnt"].empty()) {
      totalRuleCnt = make_shared<long>(boost::any_cast<long>(m["TotalRuleCnt"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults() = default;
};
class ListAggregateConfigRuleEvaluationStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults>> evaluationResults{};
  shared_ptr<string> requestId{};

  ListAggregateConfigRuleEvaluationStatisticsResponseBody() {}

  explicit ListAggregateConfigRuleEvaluationStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResults"].type()) {
        vector<ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResults = make_shared<vector<ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationStatisticsResponseBody() = default;
};
class ListAggregateConfigRuleEvaluationStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateConfigRuleEvaluationStatisticsResponseBody> body{};

  ListAggregateConfigRuleEvaluationStatisticsResponse() {}

  explicit ListAggregateConfigRuleEvaluationStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateConfigRuleEvaluationStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateConfigRuleEvaluationStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateConfigRuleEvaluationStatisticsResponse() = default;
};
class ListAggregateConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<long> riskLevel{};

  ListAggregateConfigRulesRequest() {}

  explicit ListAggregateConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListAggregateConfigRulesRequest() = default;
};
class ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance() {}

  explicit ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance() = default;
};
class ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> creatorType{};

  ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy() {}

  explicit ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (creatorType) {
      res["CreatorType"] = boost::any(*creatorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("CreatorType") != m.end() && !m["CreatorType"].empty()) {
      creatorType = make_shared<string>(boost::any_cast<string>(m["CreatorType"]));
    }
  }


  virtual ~ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy() = default;
};
class ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags() {}

  explicit ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags() = default;
};
class ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> automationType{};
  shared_ptr<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance> compliance{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy> createBy{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags>> tags{};

  ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList() {}

  explicit ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (automationType) {
      res["AutomationType"] = boost::any(*automationType);
    }
    if (compliance) {
      res["Compliance"] = compliance ? boost::any(compliance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (createBy) {
      res["CreateBy"] = createBy ? boost::any(createBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AutomationType") != m.end() && !m["AutomationType"].empty()) {
      automationType = make_shared<string>(boost::any_cast<string>(m["AutomationType"]));
    }
    if (m.find("Compliance") != m.end() && !m["Compliance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Compliance"].type()) {
        ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Compliance"]));
        compliance = make_shared<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance>(model1);
      }
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("CreateBy") != m.end() && !m["CreateBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateBy"].type()) {
        ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateBy"]));
        createBy = make_shared<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags>>(expect1);
      }
    }
  }


  virtual ~ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList() = default;
};
class ListAggregateConfigRulesResponseBodyConfigRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList>> configRuleList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAggregateConfigRulesResponseBodyConfigRules() {}

  explicit ListAggregateConfigRulesResponseBodyConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleList") != m.end() && !m["ConfigRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleList"].type()) {
        vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleList = make_shared<vector<ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAggregateConfigRulesResponseBodyConfigRules() = default;
};
class ListAggregateConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateConfigRulesResponseBodyConfigRules> configRules{};
  shared_ptr<string> requestId{};

  ListAggregateConfigRulesResponseBody() {}

  explicit ListAggregateConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRules) {
      res["ConfigRules"] = configRules ? boost::any(configRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRules"].type()) {
        ListAggregateConfigRulesResponseBodyConfigRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRules"]));
        configRules = make_shared<ListAggregateConfigRulesResponseBodyConfigRules>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateConfigRulesResponseBody() = default;
};
class ListAggregateConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateConfigRulesResponseBody> body{};

  ListAggregateConfigRulesResponse() {}

  explicit ListAggregateConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateConfigRulesResponse() = default;
};
class ListAggregateDiscoveredResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> endUpdateTimestamp{};
  shared_ptr<string> excludeResourceTypes{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regions{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<long> startUpdateTimestamp{};

  ListAggregateDiscoveredResourcesRequest() {}

  explicit ListAggregateDiscoveredResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (endUpdateTimestamp) {
      res["EndUpdateTimestamp"] = boost::any(*endUpdateTimestamp);
    }
    if (excludeResourceTypes) {
      res["ExcludeResourceTypes"] = boost::any(*excludeResourceTypes);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (startUpdateTimestamp) {
      res["StartUpdateTimestamp"] = boost::any(*startUpdateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("EndUpdateTimestamp") != m.end() && !m["EndUpdateTimestamp"].empty()) {
      endUpdateTimestamp = make_shared<long>(boost::any_cast<long>(m["EndUpdateTimestamp"]));
    }
    if (m.find("ExcludeResourceTypes") != m.end() && !m["ExcludeResourceTypes"].empty()) {
      excludeResourceTypes = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceTypes"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("StartUpdateTimestamp") != m.end() && !m["StartUpdateTimestamp"].empty()) {
      startUpdateTimestamp = make_shared<long>(boost::any_cast<long>(m["StartUpdateTimestamp"]));
    }
  }


  virtual ~ListAggregateDiscoveredResourcesRequest() = default;
};
class ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreationTime{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList() {}

  explicit ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreationTime) {
      res["ResourceCreationTime"] = boost::any(*resourceCreationTime);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreationTime") != m.end() && !m["ResourceCreationTime"].empty()) {
      resourceCreationTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreationTime"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList() = default;
};
class ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList>> discoveredResourceProfileList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> totalCount{};

  ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles() {}

  explicit ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceProfileList) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceProfileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceProfileList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceProfileList") != m.end() && !m["DiscoveredResourceProfileList"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceProfileList"].type()) {
        vector<ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceProfileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceProfileList = make_shared<vector<ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles() = default;
};
class ListAggregateDiscoveredResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles> discoveredResourceProfiles{};
  shared_ptr<string> requestId{};

  ListAggregateDiscoveredResourcesResponseBody() {}

  explicit ListAggregateDiscoveredResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceProfiles) {
      res["DiscoveredResourceProfiles"] = discoveredResourceProfiles ? boost::any(discoveredResourceProfiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceProfiles") != m.end() && !m["DiscoveredResourceProfiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiscoveredResourceProfiles"].type()) {
        ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiscoveredResourceProfiles"]));
        discoveredResourceProfiles = make_shared<ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateDiscoveredResourcesResponseBody() = default;
};
class ListAggregateDiscoveredResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateDiscoveredResourcesResponseBody> body{};

  ListAggregateDiscoveredResourcesResponse() {}

  explicit ListAggregateDiscoveredResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateDiscoveredResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateDiscoveredResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateDiscoveredResourcesResponse() = default;
};
class ListAggregateRemediationExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> executionStatus{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> resourceAccountId{};

  ListAggregateRemediationExecutionsRequest() {}

  explicit ListAggregateRemediationExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (executionStatus) {
      res["ExecutionStatus"] = boost::any(*executionStatus);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ExecutionStatus") != m.end() && !m["ExecutionStatus"].empty()) {
      executionStatus = make_shared<string>(boost::any_cast<string>(m["ExecutionStatus"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
  }


  virtual ~ListAggregateRemediationExecutionsRequest() = default;
};
class ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions : public Darabonba::Model {
public:
  shared_ptr<string> executionCreateDate{};
  shared_ptr<string> executionInvocationId{};
  shared_ptr<string> executionResourceIds{};
  shared_ptr<string> executionResourceType{};
  shared_ptr<string> executionStatus{};
  shared_ptr<string> executionStatusMessage{};

  ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions() {}

  explicit ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionCreateDate) {
      res["ExecutionCreateDate"] = boost::any(*executionCreateDate);
    }
    if (executionInvocationId) {
      res["ExecutionInvocationId"] = boost::any(*executionInvocationId);
    }
    if (executionResourceIds) {
      res["ExecutionResourceIds"] = boost::any(*executionResourceIds);
    }
    if (executionResourceType) {
      res["ExecutionResourceType"] = boost::any(*executionResourceType);
    }
    if (executionStatus) {
      res["ExecutionStatus"] = boost::any(*executionStatus);
    }
    if (executionStatusMessage) {
      res["ExecutionStatusMessage"] = boost::any(*executionStatusMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionCreateDate") != m.end() && !m["ExecutionCreateDate"].empty()) {
      executionCreateDate = make_shared<string>(boost::any_cast<string>(m["ExecutionCreateDate"]));
    }
    if (m.find("ExecutionInvocationId") != m.end() && !m["ExecutionInvocationId"].empty()) {
      executionInvocationId = make_shared<string>(boost::any_cast<string>(m["ExecutionInvocationId"]));
    }
    if (m.find("ExecutionResourceIds") != m.end() && !m["ExecutionResourceIds"].empty()) {
      executionResourceIds = make_shared<string>(boost::any_cast<string>(m["ExecutionResourceIds"]));
    }
    if (m.find("ExecutionResourceType") != m.end() && !m["ExecutionResourceType"].empty()) {
      executionResourceType = make_shared<string>(boost::any_cast<string>(m["ExecutionResourceType"]));
    }
    if (m.find("ExecutionStatus") != m.end() && !m["ExecutionStatus"].empty()) {
      executionStatus = make_shared<string>(boost::any_cast<string>(m["ExecutionStatus"]));
    }
    if (m.find("ExecutionStatusMessage") != m.end() && !m["ExecutionStatusMessage"].empty()) {
      executionStatusMessage = make_shared<string>(boost::any_cast<string>(m["ExecutionStatusMessage"]));
    }
  }


  virtual ~ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions() = default;
};
class ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions>> remediationExecutions{};

  ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData() {}

  explicit ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (remediationExecutions) {
      vector<boost::any> temp1;
      for(auto item1:*remediationExecutions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationExecutions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RemediationExecutions") != m.end() && !m["RemediationExecutions"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationExecutions"].type()) {
        vector<ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationExecutions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationExecutions = make_shared<vector<ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions>>(expect1);
      }
    }
  }


  virtual ~ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData() = default;
};
class ListAggregateRemediationExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData> remediationExecutionData{};
  shared_ptr<string> requestId{};

  ListAggregateRemediationExecutionsResponseBody() {}

  explicit ListAggregateRemediationExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationExecutionData) {
      res["RemediationExecutionData"] = remediationExecutionData ? boost::any(remediationExecutionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationExecutionData") != m.end() && !m["RemediationExecutionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemediationExecutionData"].type()) {
        ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemediationExecutionData"]));
        remediationExecutionData = make_shared<ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateRemediationExecutionsResponseBody() = default;
};
class ListAggregateRemediationExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateRemediationExecutionsResponseBody> body{};

  ListAggregateRemediationExecutionsResponse() {}

  explicit ListAggregateRemediationExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateRemediationExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateRemediationExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateRemediationExecutionsResponse() = default;
};
class ListAggregateRemediationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleIds{};

  ListAggregateRemediationsRequest() {}

  explicit ListAggregateRemediationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
  }


  virtual ~ListAggregateRemediationsRequest() = default;
};
class ListAggregateRemediationsResponseBodyRemediations : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> lastSuccessfulInvocationId{};
  shared_ptr<long> lastSuccessfulInvocationTime{};
  shared_ptr<string> lastSuccessfulInvocationType{};
  shared_ptr<string> remediaitonOriginParams{};
  shared_ptr<string> remediationId{};
  shared_ptr<string> remediationSourceType{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};

  ListAggregateRemediationsResponseBodyRemediations() {}

  explicit ListAggregateRemediationsResponseBodyRemediations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (lastSuccessfulInvocationId) {
      res["LastSuccessfulInvocationId"] = boost::any(*lastSuccessfulInvocationId);
    }
    if (lastSuccessfulInvocationTime) {
      res["LastSuccessfulInvocationTime"] = boost::any(*lastSuccessfulInvocationTime);
    }
    if (lastSuccessfulInvocationType) {
      res["LastSuccessfulInvocationType"] = boost::any(*lastSuccessfulInvocationType);
    }
    if (remediaitonOriginParams) {
      res["RemediaitonOriginParams"] = boost::any(*remediaitonOriginParams);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (remediationSourceType) {
      res["RemediationSourceType"] = boost::any(*remediationSourceType);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("LastSuccessfulInvocationId") != m.end() && !m["LastSuccessfulInvocationId"].empty()) {
      lastSuccessfulInvocationId = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationId"]));
    }
    if (m.find("LastSuccessfulInvocationTime") != m.end() && !m["LastSuccessfulInvocationTime"].empty()) {
      lastSuccessfulInvocationTime = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulInvocationTime"]));
    }
    if (m.find("LastSuccessfulInvocationType") != m.end() && !m["LastSuccessfulInvocationType"].empty()) {
      lastSuccessfulInvocationType = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationType"]));
    }
    if (m.find("RemediaitonOriginParams") != m.end() && !m["RemediaitonOriginParams"].empty()) {
      remediaitonOriginParams = make_shared<string>(boost::any_cast<string>(m["RemediaitonOriginParams"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RemediationSourceType") != m.end() && !m["RemediationSourceType"].empty()) {
      remediationSourceType = make_shared<string>(boost::any_cast<string>(m["RemediationSourceType"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
  }


  virtual ~ListAggregateRemediationsResponseBodyRemediations() = default;
};
class ListAggregateRemediationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateRemediationsResponseBodyRemediations>> remediations{};
  shared_ptr<string> requestId{};

  ListAggregateRemediationsResponseBody() {}

  explicit ListAggregateRemediationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediations) {
      vector<boost::any> temp1;
      for(auto item1:*remediations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Remediations"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remediations") != m.end() && !m["Remediations"].empty()) {
      if (typeid(vector<boost::any>) == m["Remediations"].type()) {
        vector<ListAggregateRemediationsResponseBodyRemediations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Remediations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateRemediationsResponseBodyRemediations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediations = make_shared<vector<ListAggregateRemediationsResponseBodyRemediations>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateRemediationsResponseBody() = default;
};
class ListAggregateRemediationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateRemediationsResponseBody> body{};

  ListAggregateRemediationsResponse() {}

  explicit ListAggregateRemediationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateRemediationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateRemediationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateRemediationsResponse() = default;
};
class ListAggregateResourceEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> complianceType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ListAggregateResourceEvaluationResultsRequest() {}

  explicit ListAggregateResourceEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsRequest() = default;
};
class ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier : public Darabonba::Model {
public:
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};

  ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() {}

  explicit ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() = default;
};
class ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier : public Darabonba::Model {
public:
  shared_ptr<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier> evaluationResultQualifier{};
  shared_ptr<long> orderingTimestamp{};

  ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() {}

  explicit ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultQualifier) {
      res["EvaluationResultQualifier"] = evaluationResultQualifier ? boost::any(evaluationResultQualifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderingTimestamp) {
      res["OrderingTimestamp"] = boost::any(*orderingTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultQualifier") != m.end() && !m["EvaluationResultQualifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultQualifier"].type()) {
        ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultQualifier"]));
        evaluationResultQualifier = make_shared<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier>(model1);
      }
    }
    if (m.find("OrderingTimestamp") != m.end() && !m["OrderingTimestamp"].empty()) {
      orderingTimestamp = make_shared<long>(boost::any_cast<long>(m["OrderingTimestamp"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() = default;
};
class ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList : public Darabonba::Model {
public:
  shared_ptr<string> annotation{};
  shared_ptr<string> complianceType{};
  shared_ptr<long> configRuleInvokedTimestamp{};
  shared_ptr<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier> evaluationResultIdentifier{};
  shared_ptr<string> invokingEventMessageType{};
  shared_ptr<bool> remediationEnabled{};
  shared_ptr<long> resultRecordedTimestamp{};
  shared_ptr<long> riskLevel{};

  ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() {}

  explicit ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleInvokedTimestamp) {
      res["ConfigRuleInvokedTimestamp"] = boost::any(*configRuleInvokedTimestamp);
    }
    if (evaluationResultIdentifier) {
      res["EvaluationResultIdentifier"] = evaluationResultIdentifier ? boost::any(evaluationResultIdentifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invokingEventMessageType) {
      res["InvokingEventMessageType"] = boost::any(*invokingEventMessageType);
    }
    if (remediationEnabled) {
      res["RemediationEnabled"] = boost::any(*remediationEnabled);
    }
    if (resultRecordedTimestamp) {
      res["ResultRecordedTimestamp"] = boost::any(*resultRecordedTimestamp);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleInvokedTimestamp") != m.end() && !m["ConfigRuleInvokedTimestamp"].empty()) {
      configRuleInvokedTimestamp = make_shared<long>(boost::any_cast<long>(m["ConfigRuleInvokedTimestamp"]));
    }
    if (m.find("EvaluationResultIdentifier") != m.end() && !m["EvaluationResultIdentifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultIdentifier"].type()) {
        ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultIdentifier"]));
        evaluationResultIdentifier = make_shared<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier>(model1);
      }
    }
    if (m.find("InvokingEventMessageType") != m.end() && !m["InvokingEventMessageType"].empty()) {
      invokingEventMessageType = make_shared<string>(boost::any_cast<string>(m["InvokingEventMessageType"]));
    }
    if (m.find("RemediationEnabled") != m.end() && !m["RemediationEnabled"].empty()) {
      remediationEnabled = make_shared<bool>(boost::any_cast<bool>(m["RemediationEnabled"]));
    }
    if (m.find("ResultRecordedTimestamp") != m.end() && !m["ResultRecordedTimestamp"].empty()) {
      resultRecordedTimestamp = make_shared<long>(boost::any_cast<long>(m["ResultRecordedTimestamp"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() = default;
};
class ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>> evaluationResultList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults() {}

  explicit ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultList) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResultList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultList") != m.end() && !m["EvaluationResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResultList"].type()) {
        vector<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResultList = make_shared<vector<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults() = default;
};
class ListAggregateResourceEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults> evaluationResults{};
  shared_ptr<string> requestId{};

  ListAggregateResourceEvaluationResultsResponseBody() {}

  explicit ListAggregateResourceEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      res["EvaluationResults"] = evaluationResults ? boost::any(evaluationResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResults"].type()) {
        ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResults"]));
        evaluationResults = make_shared<ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponseBody() = default;
};
class ListAggregateResourceEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateResourceEvaluationResultsResponseBody> body{};

  ListAggregateResourceEvaluationResultsResponse() {}

  explicit ListAggregateResourceEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateResourceEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateResourceEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateResourceEvaluationResultsResponse() = default;
};
class ListAggregateResourceRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> relationType{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> targetResourceId{};
  shared_ptr<string> targetResourceType{};

  ListAggregateResourceRelationsRequest() {}

  explicit ListAggregateResourceRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (relationType) {
      res["RelationType"] = boost::any(*relationType);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (targetResourceId) {
      res["TargetResourceId"] = boost::any(*targetResourceId);
    }
    if (targetResourceType) {
      res["TargetResourceType"] = boost::any(*targetResourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RelationType") != m.end() && !m["RelationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["RelationType"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TargetResourceId") != m.end() && !m["TargetResourceId"].empty()) {
      targetResourceId = make_shared<string>(boost::any_cast<string>(m["TargetResourceId"]));
    }
    if (m.find("TargetResourceType") != m.end() && !m["TargetResourceType"].empty()) {
      targetResourceType = make_shared<string>(boost::any_cast<string>(m["TargetResourceType"]));
    }
  }


  virtual ~ListAggregateResourceRelationsRequest() = default;
};
class ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> relationType{};
  shared_ptr<string> sourceResourceId{};
  shared_ptr<string> sourceResourceRegionId{};
  shared_ptr<string> sourceResourceType{};
  shared_ptr<string> targetResourceId{};
  shared_ptr<string> targetResourceType{};

  ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList() {}

  explicit ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (relationType) {
      res["RelationType"] = boost::any(*relationType);
    }
    if (sourceResourceId) {
      res["SourceResourceId"] = boost::any(*sourceResourceId);
    }
    if (sourceResourceRegionId) {
      res["SourceResourceRegionId"] = boost::any(*sourceResourceRegionId);
    }
    if (sourceResourceType) {
      res["SourceResourceType"] = boost::any(*sourceResourceType);
    }
    if (targetResourceId) {
      res["TargetResourceId"] = boost::any(*targetResourceId);
    }
    if (targetResourceType) {
      res["TargetResourceType"] = boost::any(*targetResourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("RelationType") != m.end() && !m["RelationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["RelationType"]));
    }
    if (m.find("SourceResourceId") != m.end() && !m["SourceResourceId"].empty()) {
      sourceResourceId = make_shared<string>(boost::any_cast<string>(m["SourceResourceId"]));
    }
    if (m.find("SourceResourceRegionId") != m.end() && !m["SourceResourceRegionId"].empty()) {
      sourceResourceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceResourceRegionId"]));
    }
    if (m.find("SourceResourceType") != m.end() && !m["SourceResourceType"].empty()) {
      sourceResourceType = make_shared<string>(boost::any_cast<string>(m["SourceResourceType"]));
    }
    if (m.find("TargetResourceId") != m.end() && !m["TargetResourceId"].empty()) {
      targetResourceId = make_shared<string>(boost::any_cast<string>(m["TargetResourceId"]));
    }
    if (m.find("TargetResourceType") != m.end() && !m["TargetResourceType"].empty()) {
      targetResourceType = make_shared<string>(boost::any_cast<string>(m["TargetResourceType"]));
    }
  }


  virtual ~ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList() = default;
};
class ListAggregateResourceRelationsResponseBodyResourceRelations : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList>> resourceRelationList{};

  ListAggregateResourceRelationsResponseBodyResourceRelations() {}

  explicit ListAggregateResourceRelationsResponseBodyResourceRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceRelationList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceRelationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceRelationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceRelationList") != m.end() && !m["ResourceRelationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceRelationList"].type()) {
        vector<ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceRelationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceRelationList = make_shared<vector<ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList>>(expect1);
      }
    }
  }


  virtual ~ListAggregateResourceRelationsResponseBodyResourceRelations() = default;
};
class ListAggregateResourceRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListAggregateResourceRelationsResponseBodyResourceRelations> resourceRelations{};

  ListAggregateResourceRelationsResponseBody() {}

  explicit ListAggregateResourceRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceRelations) {
      res["ResourceRelations"] = resourceRelations ? boost::any(resourceRelations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceRelations") != m.end() && !m["ResourceRelations"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceRelations"].type()) {
        ListAggregateResourceRelationsResponseBodyResourceRelations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceRelations"]));
        resourceRelations = make_shared<ListAggregateResourceRelationsResponseBodyResourceRelations>(model1);
      }
    }
  }


  virtual ~ListAggregateResourceRelationsResponseBody() = default;
};
class ListAggregateResourceRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateResourceRelationsResponseBody> body{};

  ListAggregateResourceRelationsResponse() {}

  explicit ListAggregateResourceRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateResourceRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateResourceRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateResourceRelationsResponse() = default;
};
class ListAggregateResourcesByAdvancedSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> sql{};

  ListAggregateResourcesByAdvancedSearchRequest() {}

  explicit ListAggregateResourcesByAdvancedSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
  }


  virtual ~ListAggregateResourcesByAdvancedSearchRequest() = default;
};
class ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<vector<boost::any>> values{};

  ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList() {}

  explicit ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      values = make_shared<vector<boost::any>>(toVec1);
    }
  }


  virtual ~ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList() = default;
};
class ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults : public Darabonba::Model {
public:
  shared_ptr<ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList> queryResultList{};

  ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults() {}

  explicit ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryResultList) {
      res["QueryResultList"] = queryResultList ? boost::any(queryResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryResultList") != m.end() && !m["QueryResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryResultList"].type()) {
        ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryResultList"]));
        queryResultList = make_shared<ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList>(model1);
      }
    }
  }


  virtual ~ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults() = default;
};
class ListAggregateResourcesByAdvancedSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults> queryResults{};
  shared_ptr<string> requestId{};

  ListAggregateResourcesByAdvancedSearchResponseBody() {}

  explicit ListAggregateResourcesByAdvancedSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryResults) {
      res["QueryResults"] = queryResults ? boost::any(queryResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryResults") != m.end() && !m["QueryResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryResults"].type()) {
        ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryResults"]));
        queryResults = make_shared<ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregateResourcesByAdvancedSearchResponseBody() = default;
};
class ListAggregateResourcesByAdvancedSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregateResourcesByAdvancedSearchResponseBody> body{};

  ListAggregateResourcesByAdvancedSearchResponse() {}

  explicit ListAggregateResourcesByAdvancedSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregateResourcesByAdvancedSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregateResourcesByAdvancedSearchResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregateResourcesByAdvancedSearchResponse() = default;
};
class ListAggregatorsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListAggregatorsRequest() {}

  explicit ListAggregatorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListAggregatorsRequest() = default;
};
class ListAggregatorsResponseBodyAggregatorsResultAggregators : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<long> aggregatorAccountCount{};
  shared_ptr<long> aggregatorCreateTimestamp{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<long> aggregatorStatus{};
  shared_ptr<string> aggregatorType{};
  shared_ptr<string> description{};
  shared_ptr<string> folderId{};

  ListAggregatorsResponseBodyAggregatorsResultAggregators() {}

  explicit ListAggregatorsResponseBodyAggregatorsResultAggregators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (aggregatorAccountCount) {
      res["AggregatorAccountCount"] = boost::any(*aggregatorAccountCount);
    }
    if (aggregatorCreateTimestamp) {
      res["AggregatorCreateTimestamp"] = boost::any(*aggregatorCreateTimestamp);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (aggregatorStatus) {
      res["AggregatorStatus"] = boost::any(*aggregatorStatus);
    }
    if (aggregatorType) {
      res["AggregatorType"] = boost::any(*aggregatorType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AggregatorAccountCount") != m.end() && !m["AggregatorAccountCount"].empty()) {
      aggregatorAccountCount = make_shared<long>(boost::any_cast<long>(m["AggregatorAccountCount"]));
    }
    if (m.find("AggregatorCreateTimestamp") != m.end() && !m["AggregatorCreateTimestamp"].empty()) {
      aggregatorCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["AggregatorCreateTimestamp"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("AggregatorStatus") != m.end() && !m["AggregatorStatus"].empty()) {
      aggregatorStatus = make_shared<long>(boost::any_cast<long>(m["AggregatorStatus"]));
    }
    if (m.find("AggregatorType") != m.end() && !m["AggregatorType"].empty()) {
      aggregatorType = make_shared<string>(boost::any_cast<string>(m["AggregatorType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~ListAggregatorsResponseBodyAggregatorsResultAggregators() = default;
};
class ListAggregatorsResponseBodyAggregatorsResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListAggregatorsResponseBodyAggregatorsResultAggregators>> aggregators{};
  shared_ptr<string> nextToken{};

  ListAggregatorsResponseBodyAggregatorsResult() {}

  explicit ListAggregatorsResponseBodyAggregatorsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregators) {
      vector<boost::any> temp1;
      for(auto item1:*aggregators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregators"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregators") != m.end() && !m["Aggregators"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregators"].type()) {
        vector<ListAggregatorsResponseBodyAggregatorsResultAggregators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAggregatorsResponseBodyAggregatorsResultAggregators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregators = make_shared<vector<ListAggregatorsResponseBodyAggregatorsResultAggregators>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListAggregatorsResponseBodyAggregatorsResult() = default;
};
class ListAggregatorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAggregatorsResponseBodyAggregatorsResult> aggregatorsResult{};
  shared_ptr<string> requestId{};

  ListAggregatorsResponseBody() {}

  explicit ListAggregatorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorsResult) {
      res["AggregatorsResult"] = aggregatorsResult ? boost::any(aggregatorsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorsResult") != m.end() && !m["AggregatorsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AggregatorsResult"].type()) {
        ListAggregatorsResponseBodyAggregatorsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AggregatorsResult"]));
        aggregatorsResult = make_shared<ListAggregatorsResponseBodyAggregatorsResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAggregatorsResponseBody() = default;
};
class ListAggregatorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAggregatorsResponseBody> body{};

  ListAggregatorsResponse() {}

  explicit ListAggregatorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAggregatorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAggregatorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAggregatorsResponse() = default;
};
class ListCompliancePackTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceTypes{};

  ListCompliancePackTemplatesRequest() {}

  explicit ListCompliancePackTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~ListCompliancePackTemplatesRequest() = default;
};
class ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};
  shared_ptr<bool> required{};

  ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters() {}

  explicit ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<bool>(boost::any_cast<bool>(m["Required"]));
    }
  }


  virtual ~ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters() = default;
};
class ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> controlDescription{};
  shared_ptr<string> controlId{};
  shared_ptr<bool> defaultEnable{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<string> managedRuleName{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};

  ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules() {}

  explicit ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (controlDescription) {
      res["ControlDescription"] = boost::any(*controlDescription);
    }
    if (controlId) {
      res["ControlId"] = boost::any(*controlId);
    }
    if (defaultEnable) {
      res["DefaultEnable"] = boost::any(*defaultEnable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (managedRuleName) {
      res["ManagedRuleName"] = boost::any(*managedRuleName);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("ControlDescription") != m.end() && !m["ControlDescription"].empty()) {
      controlDescription = make_shared<string>(boost::any_cast<string>(m["ControlDescription"]));
    }
    if (m.find("ControlId") != m.end() && !m["ControlId"].empty()) {
      controlId = make_shared<string>(boost::any_cast<string>(m["ControlId"]));
    }
    if (m.find("DefaultEnable") != m.end() && !m["DefaultEnable"].empty()) {
      defaultEnable = make_shared<bool>(boost::any_cast<bool>(m["DefaultEnable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("ManagedRuleName") != m.end() && !m["ManagedRuleName"].empty()) {
      managedRuleName = make_shared<string>(boost::any_cast<string>(m["ManagedRuleName"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules() = default;
};
class ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<string> compliancePackTemplateName{};
  shared_ptr<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules>> configRules{};
  shared_ptr<string> description{};
  shared_ptr<string> labels{};
  shared_ptr<long> lastUpdate{};
  shared_ptr<long> riskLevel{};

  ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates() {}

  explicit ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (compliancePackTemplateName) {
      res["CompliancePackTemplateName"] = boost::any(*compliancePackTemplateName);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (lastUpdate) {
      res["LastUpdate"] = boost::any(*lastUpdate);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("CompliancePackTemplateName") != m.end() && !m["CompliancePackTemplateName"].empty()) {
      compliancePackTemplateName = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateName"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("LastUpdate") != m.end() && !m["LastUpdate"].empty()) {
      lastUpdate = make_shared<long>(boost::any_cast<long>(m["LastUpdate"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates() = default;
};
class ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates>> compliancePackTemplates{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult() {}

  explicit ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*compliancePackTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompliancePackTemplates"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackTemplates") != m.end() && !m["CompliancePackTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["CompliancePackTemplates"].type()) {
        vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompliancePackTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliancePackTemplates = make_shared<vector<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult() = default;
};
class ListCompliancePackTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult> compliancePackTemplatesResult{};
  shared_ptr<string> requestId{};

  ListCompliancePackTemplatesResponseBody() {}

  explicit ListCompliancePackTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackTemplatesResult) {
      res["CompliancePackTemplatesResult"] = compliancePackTemplatesResult ? boost::any(compliancePackTemplatesResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackTemplatesResult") != m.end() && !m["CompliancePackTemplatesResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePackTemplatesResult"].type()) {
        ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePackTemplatesResult"]));
        compliancePackTemplatesResult = make_shared<ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCompliancePackTemplatesResponseBody() = default;
};
class ListCompliancePackTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCompliancePackTemplatesResponseBody> body{};

  ListCompliancePackTemplatesResponse() {}

  explicit ListCompliancePackTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCompliancePackTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCompliancePackTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCompliancePackTemplatesResponse() = default;
};
class ListCompliancePacksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListCompliancePacksRequest() {}

  explicit ListCompliancePacksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCompliancePacksRequest() = default;
};
class ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> compliancePackTemplateId{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> description{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> status{};

  ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks() {}

  explicit ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (compliancePackTemplateId) {
      res["CompliancePackTemplateId"] = boost::any(*compliancePackTemplateId);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("CompliancePackTemplateId") != m.end() && !m["CompliancePackTemplateId"].empty()) {
      compliancePackTemplateId = make_shared<string>(boost::any_cast<string>(m["CompliancePackTemplateId"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks() = default;
};
class ListCompliancePacksResponseBodyCompliancePacksResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks>> compliancePacks{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCompliancePacksResponseBodyCompliancePacksResult() {}

  explicit ListCompliancePacksResponseBodyCompliancePacksResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePacks) {
      vector<boost::any> temp1;
      for(auto item1:*compliancePacks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CompliancePacks"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePacks") != m.end() && !m["CompliancePacks"].empty()) {
      if (typeid(vector<boost::any>) == m["CompliancePacks"].type()) {
        vector<ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CompliancePacks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        compliancePacks = make_shared<vector<ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCompliancePacksResponseBodyCompliancePacksResult() = default;
};
class ListCompliancePacksResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCompliancePacksResponseBodyCompliancePacksResult> compliancePacksResult{};
  shared_ptr<string> requestId{};

  ListCompliancePacksResponseBody() {}

  explicit ListCompliancePacksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePacksResult) {
      res["CompliancePacksResult"] = compliancePacksResult ? boost::any(compliancePacksResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePacksResult") != m.end() && !m["CompliancePacksResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompliancePacksResult"].type()) {
        ListCompliancePacksResponseBodyCompliancePacksResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompliancePacksResult"]));
        compliancePacksResult = make_shared<ListCompliancePacksResponseBodyCompliancePacksResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCompliancePacksResponseBody() = default;
};
class ListCompliancePacksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCompliancePacksResponseBody> body{};

  ListCompliancePacksResponse() {}

  explicit ListCompliancePacksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCompliancePacksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCompliancePacksResponseBody>(model1);
      }
    }
  }


  virtual ~ListCompliancePacksResponse() = default;
};
class ListConfigDeliveryChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelIds{};

  ListConfigDeliveryChannelsRequest() {}

  explicit ListConfigDeliveryChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelIds) {
      res["DeliveryChannelIds"] = boost::any(*deliveryChannelIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelIds") != m.end() && !m["DeliveryChannelIds"].empty()) {
      deliveryChannelIds = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelIds"]));
    }
  }


  virtual ~ListConfigDeliveryChannelsRequest() = default;
};
class ListConfigDeliveryChannelsResponseBodyDeliveryChannels : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliveryChannelType{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  ListConfigDeliveryChannelsResponseBodyDeliveryChannels() {}

  explicit ListConfigDeliveryChannelsResponseBodyDeliveryChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliveryChannelType) {
      res["DeliveryChannelType"] = boost::any(*deliveryChannelType);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliveryChannelType") != m.end() && !m["DeliveryChannelType"].empty()) {
      deliveryChannelType = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelType"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListConfigDeliveryChannelsResponseBodyDeliveryChannels() = default;
};
class ListConfigDeliveryChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigDeliveryChannelsResponseBodyDeliveryChannels>> deliveryChannels{};
  shared_ptr<string> requestId{};

  ListConfigDeliveryChannelsResponseBody() {}

  explicit ListConfigDeliveryChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannels) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryChannels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannels") != m.end() && !m["DeliveryChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryChannels"].type()) {
        vector<ListConfigDeliveryChannelsResponseBodyDeliveryChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigDeliveryChannelsResponseBodyDeliveryChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryChannels = make_shared<vector<ListConfigDeliveryChannelsResponseBodyDeliveryChannels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigDeliveryChannelsResponseBody() = default;
};
class ListConfigDeliveryChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigDeliveryChannelsResponseBody> body{};

  ListConfigDeliveryChannelsResponse() {}

  explicit ListConfigDeliveryChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigDeliveryChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigDeliveryChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigDeliveryChannelsResponse() = default;
};
class ListConfigRuleEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regions{};
  shared_ptr<string> resourceGroupIds{};
  shared_ptr<string> resourceTypes{};

  ListConfigRuleEvaluationResultsRequest() {}

  explicit ListConfigRuleEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceGroupIds) {
      res["ResourceGroupIds"] = boost::any(*resourceGroupIds);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceGroupIds") != m.end() && !m["ResourceGroupIds"].empty()) {
      resourceGroupIds = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIds"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsRequest() = default;
};
class ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceType{};

  ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() {}

  explicit ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() = default;
};
class ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier : public Darabonba::Model {
public:
  shared_ptr<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier> evaluationResultQualifier{};
  shared_ptr<long> orderingTimestamp{};

  ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() {}

  explicit ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultQualifier) {
      res["EvaluationResultQualifier"] = evaluationResultQualifier ? boost::any(evaluationResultQualifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderingTimestamp) {
      res["OrderingTimestamp"] = boost::any(*orderingTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultQualifier") != m.end() && !m["EvaluationResultQualifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultQualifier"].type()) {
        ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultQualifier"]));
        evaluationResultQualifier = make_shared<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier>(model1);
      }
    }
    if (m.find("OrderingTimestamp") != m.end() && !m["OrderingTimestamp"].empty()) {
      orderingTimestamp = make_shared<long>(boost::any_cast<long>(m["OrderingTimestamp"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() = default;
};
class ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList : public Darabonba::Model {
public:
  shared_ptr<string> annotation{};
  shared_ptr<string> complianceType{};
  shared_ptr<long> configRuleInvokedTimestamp{};
  shared_ptr<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier> evaluationResultIdentifier{};
  shared_ptr<string> invokingEventMessageType{};
  shared_ptr<bool> remediationEnabled{};
  shared_ptr<long> resultRecordedTimestamp{};
  shared_ptr<long> riskLevel{};

  ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() {}

  explicit ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleInvokedTimestamp) {
      res["ConfigRuleInvokedTimestamp"] = boost::any(*configRuleInvokedTimestamp);
    }
    if (evaluationResultIdentifier) {
      res["EvaluationResultIdentifier"] = evaluationResultIdentifier ? boost::any(evaluationResultIdentifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invokingEventMessageType) {
      res["InvokingEventMessageType"] = boost::any(*invokingEventMessageType);
    }
    if (remediationEnabled) {
      res["RemediationEnabled"] = boost::any(*remediationEnabled);
    }
    if (resultRecordedTimestamp) {
      res["ResultRecordedTimestamp"] = boost::any(*resultRecordedTimestamp);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleInvokedTimestamp") != m.end() && !m["ConfigRuleInvokedTimestamp"].empty()) {
      configRuleInvokedTimestamp = make_shared<long>(boost::any_cast<long>(m["ConfigRuleInvokedTimestamp"]));
    }
    if (m.find("EvaluationResultIdentifier") != m.end() && !m["EvaluationResultIdentifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultIdentifier"].type()) {
        ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultIdentifier"]));
        evaluationResultIdentifier = make_shared<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier>(model1);
      }
    }
    if (m.find("InvokingEventMessageType") != m.end() && !m["InvokingEventMessageType"].empty()) {
      invokingEventMessageType = make_shared<string>(boost::any_cast<string>(m["InvokingEventMessageType"]));
    }
    if (m.find("RemediationEnabled") != m.end() && !m["RemediationEnabled"].empty()) {
      remediationEnabled = make_shared<bool>(boost::any_cast<bool>(m["RemediationEnabled"]));
    }
    if (m.find("ResultRecordedTimestamp") != m.end() && !m["ResultRecordedTimestamp"].empty()) {
      resultRecordedTimestamp = make_shared<long>(boost::any_cast<long>(m["ResultRecordedTimestamp"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() = default;
};
class ListConfigRuleEvaluationResultsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>> evaluationResultList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListConfigRuleEvaluationResultsResponseBodyEvaluationResults() {}

  explicit ListConfigRuleEvaluationResultsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultList) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResultList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultList") != m.end() && !m["EvaluationResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResultList"].type()) {
        vector<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResultList = make_shared<vector<ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponseBodyEvaluationResults() = default;
};
class ListConfigRuleEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListConfigRuleEvaluationResultsResponseBodyEvaluationResults> evaluationResults{};
  shared_ptr<string> requestId{};

  ListConfigRuleEvaluationResultsResponseBody() {}

  explicit ListConfigRuleEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      res["EvaluationResults"] = evaluationResults ? boost::any(evaluationResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResults"].type()) {
        ListConfigRuleEvaluationResultsResponseBodyEvaluationResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResults"]));
        evaluationResults = make_shared<ListConfigRuleEvaluationResultsResponseBodyEvaluationResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponseBody() = default;
};
class ListConfigRuleEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigRuleEvaluationResultsResponseBody> body{};

  ListConfigRuleEvaluationResultsResponse() {}

  explicit ListConfigRuleEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigRuleEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigRuleEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigRuleEvaluationResultsResponse() = default;
};
class ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<long> nonCompliantResourceCnt{};
  shared_ptr<long> nonCompliantRuleCnt{};
  shared_ptr<string> statisticDate{};
  shared_ptr<long> totalResourceCnt{};
  shared_ptr<long> totalRuleCnt{};

  ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults() {}

  explicit ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonCompliantResourceCnt) {
      res["NonCompliantResourceCnt"] = boost::any(*nonCompliantResourceCnt);
    }
    if (nonCompliantRuleCnt) {
      res["NonCompliantRuleCnt"] = boost::any(*nonCompliantRuleCnt);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (totalResourceCnt) {
      res["TotalResourceCnt"] = boost::any(*totalResourceCnt);
    }
    if (totalRuleCnt) {
      res["TotalRuleCnt"] = boost::any(*totalRuleCnt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonCompliantResourceCnt") != m.end() && !m["NonCompliantResourceCnt"].empty()) {
      nonCompliantResourceCnt = make_shared<long>(boost::any_cast<long>(m["NonCompliantResourceCnt"]));
    }
    if (m.find("NonCompliantRuleCnt") != m.end() && !m["NonCompliantRuleCnt"].empty()) {
      nonCompliantRuleCnt = make_shared<long>(boost::any_cast<long>(m["NonCompliantRuleCnt"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TotalResourceCnt") != m.end() && !m["TotalResourceCnt"].empty()) {
      totalResourceCnt = make_shared<long>(boost::any_cast<long>(m["TotalResourceCnt"]));
    }
    if (m.find("TotalRuleCnt") != m.end() && !m["TotalRuleCnt"].empty()) {
      totalRuleCnt = make_shared<long>(boost::any_cast<long>(m["TotalRuleCnt"]));
    }
  }


  virtual ~ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults() = default;
};
class ListConfigRuleEvaluationStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults>> evaluationResults{};
  shared_ptr<string> requestId{};

  ListConfigRuleEvaluationStatisticsResponseBody() {}

  explicit ListConfigRuleEvaluationStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResults"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResults"].type()) {
        vector<ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResults = make_shared<vector<ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigRuleEvaluationStatisticsResponseBody() = default;
};
class ListConfigRuleEvaluationStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigRuleEvaluationStatisticsResponseBody> body{};

  ListConfigRuleEvaluationStatisticsResponse() {}

  explicit ListConfigRuleEvaluationStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigRuleEvaluationStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigRuleEvaluationStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigRuleEvaluationStatisticsResponse() = default;
};
class ListConfigRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<long> riskLevel{};

  ListConfigRulesRequest() {}

  explicit ListConfigRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListConfigRulesRequest() = default;
};
class ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> count{};

  ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance() {}

  explicit ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance() = default;
};
class ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};

  ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy() {}

  explicit ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
  }


  virtual ~ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy() = default;
};
class ListConfigRulesResponseBodyConfigRulesConfigRuleListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListConfigRulesResponseBodyConfigRulesConfigRuleListTags() {}

  explicit ListConfigRulesResponseBodyConfigRulesConfigRuleListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListConfigRulesResponseBodyConfigRulesConfigRuleListTags() = default;
};
class ListConfigRulesResponseBodyConfigRulesConfigRuleList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> automationType{};
  shared_ptr<ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance> compliance{};
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleState{};
  shared_ptr<ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy> createBy{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> sourceIdentifier{};
  shared_ptr<string> sourceOwner{};
  shared_ptr<vector<ListConfigRulesResponseBodyConfigRulesConfigRuleListTags>> tags{};

  ListConfigRulesResponseBodyConfigRulesConfigRuleList() {}

  explicit ListConfigRulesResponseBodyConfigRulesConfigRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (automationType) {
      res["AutomationType"] = boost::any(*automationType);
    }
    if (compliance) {
      res["Compliance"] = compliance ? boost::any(compliance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleState) {
      res["ConfigRuleState"] = boost::any(*configRuleState);
    }
    if (createBy) {
      res["CreateBy"] = createBy ? boost::any(createBy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIdentifier) {
      res["SourceIdentifier"] = boost::any(*sourceIdentifier);
    }
    if (sourceOwner) {
      res["SourceOwner"] = boost::any(*sourceOwner);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AutomationType") != m.end() && !m["AutomationType"].empty()) {
      automationType = make_shared<string>(boost::any_cast<string>(m["AutomationType"]));
    }
    if (m.find("Compliance") != m.end() && !m["Compliance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Compliance"].type()) {
        ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Compliance"]));
        compliance = make_shared<ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance>(model1);
      }
    }
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleState") != m.end() && !m["ConfigRuleState"].empty()) {
      configRuleState = make_shared<string>(boost::any_cast<string>(m["ConfigRuleState"]));
    }
    if (m.find("CreateBy") != m.end() && !m["CreateBy"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateBy"].type()) {
        ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateBy"]));
        createBy = make_shared<ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScope = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("SourceIdentifier") != m.end() && !m["SourceIdentifier"].empty()) {
      sourceIdentifier = make_shared<string>(boost::any_cast<string>(m["SourceIdentifier"]));
    }
    if (m.find("SourceOwner") != m.end() && !m["SourceOwner"].empty()) {
      sourceOwner = make_shared<string>(boost::any_cast<string>(m["SourceOwner"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListConfigRulesResponseBodyConfigRulesConfigRuleListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigRulesResponseBodyConfigRulesConfigRuleListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListConfigRulesResponseBodyConfigRulesConfigRuleListTags>>(expect1);
      }
    }
  }


  virtual ~ListConfigRulesResponseBodyConfigRulesConfigRuleList() = default;
};
class ListConfigRulesResponseBodyConfigRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigRulesResponseBodyConfigRulesConfigRuleList>> configRuleList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListConfigRulesResponseBodyConfigRules() {}

  explicit ListConfigRulesResponseBodyConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleList") != m.end() && !m["ConfigRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleList"].type()) {
        vector<ListConfigRulesResponseBodyConfigRulesConfigRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigRulesResponseBodyConfigRulesConfigRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleList = make_shared<vector<ListConfigRulesResponseBodyConfigRulesConfigRuleList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConfigRulesResponseBodyConfigRules() = default;
};
class ListConfigRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListConfigRulesResponseBodyConfigRules> configRules{};
  shared_ptr<string> requestId{};

  ListConfigRulesResponseBody() {}

  explicit ListConfigRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRules) {
      res["ConfigRules"] = configRules ? boost::any(configRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigRules"].type()) {
        ListConfigRulesResponseBodyConfigRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigRules"]));
        configRules = make_shared<ListConfigRulesResponseBodyConfigRules>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigRulesResponseBody() = default;
};
class ListConfigRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigRulesResponseBody> body{};

  ListConfigRulesResponse() {}

  explicit ListConfigRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigRulesResponse() = default;
};
class ListDiscoveredResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endUpdateTimestamp{};
  shared_ptr<string> excludeResourceTypes{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regions{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<long> startUpdateTimestamp{};

  ListDiscoveredResourcesRequest() {}

  explicit ListDiscoveredResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endUpdateTimestamp) {
      res["EndUpdateTimestamp"] = boost::any(*endUpdateTimestamp);
    }
    if (excludeResourceTypes) {
      res["ExcludeResourceTypes"] = boost::any(*excludeResourceTypes);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regions) {
      res["Regions"] = boost::any(*regions);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (startUpdateTimestamp) {
      res["StartUpdateTimestamp"] = boost::any(*startUpdateTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndUpdateTimestamp") != m.end() && !m["EndUpdateTimestamp"].empty()) {
      endUpdateTimestamp = make_shared<long>(boost::any_cast<long>(m["EndUpdateTimestamp"]));
    }
    if (m.find("ExcludeResourceTypes") != m.end() && !m["ExcludeResourceTypes"].empty()) {
      excludeResourceTypes = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceTypes"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      regions = make_shared<string>(boost::any_cast<string>(m["Regions"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("StartUpdateTimestamp") != m.end() && !m["StartUpdateTimestamp"].empty()) {
      startUpdateTimestamp = make_shared<long>(boost::any_cast<long>(m["StartUpdateTimestamp"]));
    }
  }


  virtual ~ListDiscoveredResourcesRequest() = default;
};
class ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> region{};
  shared_ptr<long> resourceCreationTime{};
  shared_ptr<long> resourceDeleted{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceStatus{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tags{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList() {}

  explicit ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceCreationTime) {
      res["ResourceCreationTime"] = boost::any(*resourceCreationTime);
    }
    if (resourceDeleted) {
      res["ResourceDeleted"] = boost::any(*resourceDeleted);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceCreationTime") != m.end() && !m["ResourceCreationTime"].empty()) {
      resourceCreationTime = make_shared<long>(boost::any_cast<long>(m["ResourceCreationTime"]));
    }
    if (m.find("ResourceDeleted") != m.end() && !m["ResourceDeleted"].empty()) {
      resourceDeleted = make_shared<long>(boost::any_cast<long>(m["ResourceDeleted"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<string>(boost::any_cast<string>(m["ResourceStatus"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList() = default;
};
class ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles : public Darabonba::Model {
public:
  shared_ptr<vector<ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList>> discoveredResourceProfileList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> totalCount{};

  ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles() {}

  explicit ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceProfileList) {
      vector<boost::any> temp1;
      for(auto item1:*discoveredResourceProfileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiscoveredResourceProfileList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceProfileList") != m.end() && !m["DiscoveredResourceProfileList"].empty()) {
      if (typeid(vector<boost::any>) == m["DiscoveredResourceProfileList"].type()) {
        vector<ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiscoveredResourceProfileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        discoveredResourceProfileList = make_shared<vector<ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles() = default;
};
class ListDiscoveredResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles> discoveredResourceProfiles{};
  shared_ptr<string> requestId{};

  ListDiscoveredResourcesResponseBody() {}

  explicit ListDiscoveredResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveredResourceProfiles) {
      res["DiscoveredResourceProfiles"] = discoveredResourceProfiles ? boost::any(discoveredResourceProfiles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveredResourceProfiles") != m.end() && !m["DiscoveredResourceProfiles"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiscoveredResourceProfiles"].type()) {
        ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiscoveredResourceProfiles"]));
        discoveredResourceProfiles = make_shared<ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDiscoveredResourcesResponseBody() = default;
};
class ListDiscoveredResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDiscoveredResourcesResponseBody> body{};

  ListDiscoveredResourcesResponse() {}

  explicit ListDiscoveredResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDiscoveredResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDiscoveredResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDiscoveredResourcesResponse() = default;
};
class ListIntegratedServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> integratedTypes{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceName{};
  shared_ptr<bool> status{};

  ListIntegratedServiceResponseBodyData() {}

  explicit ListIntegratedServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedTypes) {
      res["IntegratedTypes"] = boost::any(*integratedTypes);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedTypes") != m.end() && !m["IntegratedTypes"].empty()) {
      integratedTypes = make_shared<string>(boost::any_cast<string>(m["IntegratedTypes"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~ListIntegratedServiceResponseBodyData() = default;
};
class ListIntegratedServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntegratedServiceResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListIntegratedServiceResponseBody() {}

  explicit ListIntegratedServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntegratedServiceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntegratedServiceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntegratedServiceResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntegratedServiceResponseBody() = default;
};
class ListIntegratedServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntegratedServiceResponseBody> body{};

  ListIntegratedServiceResponse() {}

  explicit ListIntegratedServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntegratedServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntegratedServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntegratedServiceResponse() = default;
};
class ListManagedRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceTypes{};
  shared_ptr<long> riskLevel{};

  ListManagedRulesRequest() {}

  explicit ListManagedRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListManagedRulesRequest() = default;
};
class ListManagedRulesResponseBodyManagedRulesManagedRuleListScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> complianceResourceTypes{};

  ListManagedRulesResponseBodyManagedRulesManagedRuleListScope() {}

  explicit ListManagedRulesResponseBodyManagedRulesManagedRuleListScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceResourceTypes) {
      res["ComplianceResourceTypes"] = boost::any(*complianceResourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceResourceTypes") != m.end() && !m["ComplianceResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ComplianceResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ComplianceResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      complianceResourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListManagedRulesResponseBodyManagedRulesManagedRuleListScope() = default;
};
class ListManagedRulesResponseBodyManagedRulesManagedRuleList : public Darabonba::Model {
public:
  shared_ptr<string> configRuleName{};
  shared_ptr<string> description{};
  shared_ptr<string> helpUrls{};
  shared_ptr<string> identifier{};
  shared_ptr<vector<string>> labels{};
  shared_ptr<string> remediationTemplateIdentifier{};
  shared_ptr<string> remediationTemplateName{};
  shared_ptr<long> riskLevel{};
  shared_ptr<ListManagedRulesResponseBodyManagedRulesManagedRuleListScope> scope{};
  shared_ptr<bool> supportPreviewManagedRule{};

  ListManagedRulesResponseBodyManagedRulesManagedRuleList() {}

  explicit ListManagedRulesResponseBodyManagedRulesManagedRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (helpUrls) {
      res["HelpUrls"] = boost::any(*helpUrls);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (remediationTemplateIdentifier) {
      res["RemediationTemplateIdentifier"] = boost::any(*remediationTemplateIdentifier);
    }
    if (remediationTemplateName) {
      res["RemediationTemplateName"] = boost::any(*remediationTemplateName);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scope) {
      res["Scope"] = scope ? boost::any(scope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportPreviewManagedRule) {
      res["SupportPreviewManagedRule"] = boost::any(*supportPreviewManagedRule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HelpUrls") != m.end() && !m["HelpUrls"].empty()) {
      helpUrls = make_shared<string>(boost::any_cast<string>(m["HelpUrls"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Labels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemediationTemplateIdentifier") != m.end() && !m["RemediationTemplateIdentifier"].empty()) {
      remediationTemplateIdentifier = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateIdentifier"]));
    }
    if (m.find("RemediationTemplateName") != m.end() && !m["RemediationTemplateName"].empty()) {
      remediationTemplateName = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateName"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scope"].type()) {
        ListManagedRulesResponseBodyManagedRulesManagedRuleListScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scope"]));
        scope = make_shared<ListManagedRulesResponseBodyManagedRulesManagedRuleListScope>(model1);
      }
    }
    if (m.find("SupportPreviewManagedRule") != m.end() && !m["SupportPreviewManagedRule"].empty()) {
      supportPreviewManagedRule = make_shared<bool>(boost::any_cast<bool>(m["SupportPreviewManagedRule"]));
    }
  }


  virtual ~ListManagedRulesResponseBodyManagedRulesManagedRuleList() = default;
};
class ListManagedRulesResponseBodyManagedRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListManagedRulesResponseBodyManagedRulesManagedRuleList>> managedRuleList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListManagedRulesResponseBodyManagedRules() {}

  explicit ListManagedRulesResponseBodyManagedRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*managedRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedRuleList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRuleList") != m.end() && !m["ManagedRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedRuleList"].type()) {
        vector<ListManagedRulesResponseBodyManagedRulesManagedRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListManagedRulesResponseBodyManagedRulesManagedRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedRuleList = make_shared<vector<ListManagedRulesResponseBodyManagedRulesManagedRuleList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListManagedRulesResponseBodyManagedRules() = default;
};
class ListManagedRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListManagedRulesResponseBodyManagedRules> managedRules{};
  shared_ptr<string> requestId{};

  ListManagedRulesResponseBody() {}

  explicit ListManagedRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRules) {
      res["ManagedRules"] = managedRules ? boost::any(managedRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRules") != m.end() && !m["ManagedRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManagedRules"].type()) {
        ListManagedRulesResponseBodyManagedRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManagedRules"]));
        managedRules = make_shared<ListManagedRulesResponseBodyManagedRules>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListManagedRulesResponseBody() = default;
};
class ListManagedRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListManagedRulesResponseBody> body{};

  ListManagedRulesResponse() {}

  explicit ListManagedRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListManagedRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListManagedRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListManagedRulesResponse() = default;
};
class ListPreManagedRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> resourceTypes{};

  ListPreManagedRulesRequest() {}

  explicit ListPreManagedRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPreManagedRulesRequest() = default;
};
class ListPreManagedRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceTypesShrink{};

  ListPreManagedRulesShrinkRequest() {}

  explicit ListPreManagedRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceTypesShrink) {
      res["ResourceTypes"] = boost::any(*resourceTypesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypesShrink = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~ListPreManagedRulesShrinkRequest() = default;
};
class ListPreManagedRulesResponseBodyManagedRules : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> compulsoryInputParameterDetails{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> description{};
  shared_ptr<string> helpUrls{};
  shared_ptr<string> identifier{};
  shared_ptr<map<string, boost::any>> optionalInputParameterDetails{};
  shared_ptr<string> resourceType{};

  ListPreManagedRulesResponseBodyManagedRules() {}

  explicit ListPreManagedRulesResponseBodyManagedRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compulsoryInputParameterDetails) {
      res["CompulsoryInputParameterDetails"] = boost::any(*compulsoryInputParameterDetails);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (helpUrls) {
      res["HelpUrls"] = boost::any(*helpUrls);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (optionalInputParameterDetails) {
      res["OptionalInputParameterDetails"] = boost::any(*optionalInputParameterDetails);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompulsoryInputParameterDetails") != m.end() && !m["CompulsoryInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CompulsoryInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      compulsoryInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HelpUrls") != m.end() && !m["HelpUrls"].empty()) {
      helpUrls = make_shared<string>(boost::any_cast<string>(m["HelpUrls"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("OptionalInputParameterDetails") != m.end() && !m["OptionalInputParameterDetails"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OptionalInputParameterDetails"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      optionalInputParameterDetails = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListPreManagedRulesResponseBodyManagedRules() = default;
};
class ListPreManagedRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPreManagedRulesResponseBodyManagedRules>> managedRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};

  ListPreManagedRulesResponseBody() {}

  explicit ListPreManagedRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRules) {
      vector<boost::any> temp1;
      for(auto item1:*managedRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ManagedRules"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRules") != m.end() && !m["ManagedRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ManagedRules"].type()) {
        vector<ListPreManagedRulesResponseBodyManagedRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ManagedRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPreManagedRulesResponseBodyManagedRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        managedRules = make_shared<vector<ListPreManagedRulesResponseBodyManagedRules>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPreManagedRulesResponseBody() = default;
};
class ListPreManagedRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPreManagedRulesResponseBody> body{};

  ListPreManagedRulesResponse() {}

  explicit ListPreManagedRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPreManagedRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPreManagedRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPreManagedRulesResponse() = default;
};
class ListRemediationExecutionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> executionStatus{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListRemediationExecutionsRequest() {}

  explicit ListRemediationExecutionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (executionStatus) {
      res["ExecutionStatus"] = boost::any(*executionStatus);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ExecutionStatus") != m.end() && !m["ExecutionStatus"].empty()) {
      executionStatus = make_shared<string>(boost::any_cast<string>(m["ExecutionStatus"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListRemediationExecutionsRequest() = default;
};
class ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions : public Darabonba::Model {
public:
  shared_ptr<string> executionCreateDate{};
  shared_ptr<string> executionInvocationId{};
  shared_ptr<string> executionResourceIds{};
  shared_ptr<string> executionResourceType{};
  shared_ptr<string> executionStatus{};
  shared_ptr<string> executionStatusMessage{};

  ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions() {}

  explicit ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionCreateDate) {
      res["ExecutionCreateDate"] = boost::any(*executionCreateDate);
    }
    if (executionInvocationId) {
      res["ExecutionInvocationId"] = boost::any(*executionInvocationId);
    }
    if (executionResourceIds) {
      res["ExecutionResourceIds"] = boost::any(*executionResourceIds);
    }
    if (executionResourceType) {
      res["ExecutionResourceType"] = boost::any(*executionResourceType);
    }
    if (executionStatus) {
      res["ExecutionStatus"] = boost::any(*executionStatus);
    }
    if (executionStatusMessage) {
      res["ExecutionStatusMessage"] = boost::any(*executionStatusMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionCreateDate") != m.end() && !m["ExecutionCreateDate"].empty()) {
      executionCreateDate = make_shared<string>(boost::any_cast<string>(m["ExecutionCreateDate"]));
    }
    if (m.find("ExecutionInvocationId") != m.end() && !m["ExecutionInvocationId"].empty()) {
      executionInvocationId = make_shared<string>(boost::any_cast<string>(m["ExecutionInvocationId"]));
    }
    if (m.find("ExecutionResourceIds") != m.end() && !m["ExecutionResourceIds"].empty()) {
      executionResourceIds = make_shared<string>(boost::any_cast<string>(m["ExecutionResourceIds"]));
    }
    if (m.find("ExecutionResourceType") != m.end() && !m["ExecutionResourceType"].empty()) {
      executionResourceType = make_shared<string>(boost::any_cast<string>(m["ExecutionResourceType"]));
    }
    if (m.find("ExecutionStatus") != m.end() && !m["ExecutionStatus"].empty()) {
      executionStatus = make_shared<string>(boost::any_cast<string>(m["ExecutionStatus"]));
    }
    if (m.find("ExecutionStatusMessage") != m.end() && !m["ExecutionStatusMessage"].empty()) {
      executionStatusMessage = make_shared<string>(boost::any_cast<string>(m["ExecutionStatusMessage"]));
    }
  }


  virtual ~ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions() = default;
};
class ListRemediationExecutionsResponseBodyRemediationExecutionData : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions>> remediationExecutions{};

  ListRemediationExecutionsResponseBodyRemediationExecutionData() {}

  explicit ListRemediationExecutionsResponseBodyRemediationExecutionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (remediationExecutions) {
      vector<boost::any> temp1;
      for(auto item1:*remediationExecutions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationExecutions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RemediationExecutions") != m.end() && !m["RemediationExecutions"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationExecutions"].type()) {
        vector<ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationExecutions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationExecutions = make_shared<vector<ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions>>(expect1);
      }
    }
  }


  virtual ~ListRemediationExecutionsResponseBodyRemediationExecutionData() = default;
};
class ListRemediationExecutionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRemediationExecutionsResponseBodyRemediationExecutionData> remediationExecutionData{};
  shared_ptr<string> requestId{};

  ListRemediationExecutionsResponseBody() {}

  explicit ListRemediationExecutionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationExecutionData) {
      res["RemediationExecutionData"] = remediationExecutionData ? boost::any(remediationExecutionData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationExecutionData") != m.end() && !m["RemediationExecutionData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemediationExecutionData"].type()) {
        ListRemediationExecutionsResponseBodyRemediationExecutionData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemediationExecutionData"]));
        remediationExecutionData = make_shared<ListRemediationExecutionsResponseBodyRemediationExecutionData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRemediationExecutionsResponseBody() = default;
};
class ListRemediationExecutionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRemediationExecutionsResponseBody> body{};

  ListRemediationExecutionsResponse() {}

  explicit ListRemediationExecutionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRemediationExecutionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRemediationExecutionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRemediationExecutionsResponse() = default;
};
class ListRemediationTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remediationType{};

  ListRemediationTemplatesRequest() {}

  explicit ListRemediationTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
  }


  virtual ~ListRemediationTemplatesRequest() = default;
};
class ListRemediationTemplatesResponseBodyRemediationTemplates : public Darabonba::Model {
public:
  shared_ptr<string> remediationType{};
  shared_ptr<string> templateDefinition{};
  shared_ptr<string> templateDescription{};
  shared_ptr<string> templateIdentifier{};
  shared_ptr<string> templateName{};

  ListRemediationTemplatesResponseBodyRemediationTemplates() {}

  explicit ListRemediationTemplatesResponseBodyRemediationTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (templateDefinition) {
      res["TemplateDefinition"] = boost::any(*templateDefinition);
    }
    if (templateDescription) {
      res["TemplateDescription"] = boost::any(*templateDescription);
    }
    if (templateIdentifier) {
      res["TemplateIdentifier"] = boost::any(*templateIdentifier);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("TemplateDefinition") != m.end() && !m["TemplateDefinition"].empty()) {
      templateDefinition = make_shared<string>(boost::any_cast<string>(m["TemplateDefinition"]));
    }
    if (m.find("TemplateDescription") != m.end() && !m["TemplateDescription"].empty()) {
      templateDescription = make_shared<string>(boost::any_cast<string>(m["TemplateDescription"]));
    }
    if (m.find("TemplateIdentifier") != m.end() && !m["TemplateIdentifier"].empty()) {
      templateIdentifier = make_shared<string>(boost::any_cast<string>(m["TemplateIdentifier"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListRemediationTemplatesResponseBodyRemediationTemplates() = default;
};
class ListRemediationTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListRemediationTemplatesResponseBodyRemediationTemplates>> remediationTemplates{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListRemediationTemplatesResponseBody() {}

  explicit ListRemediationTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remediationTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*remediationTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemediationTemplates"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RemediationTemplates") != m.end() && !m["RemediationTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["RemediationTemplates"].type()) {
        vector<ListRemediationTemplatesResponseBodyRemediationTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemediationTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRemediationTemplatesResponseBodyRemediationTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediationTemplates = make_shared<vector<ListRemediationTemplatesResponseBodyRemediationTemplates>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListRemediationTemplatesResponseBody() = default;
};
class ListRemediationTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRemediationTemplatesResponseBody> body{};

  ListRemediationTemplatesResponse() {}

  explicit ListRemediationTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRemediationTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRemediationTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRemediationTemplatesResponse() = default;
};
class ListRemediationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListRemediationsRequest() {}

  explicit ListRemediationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleIds) {
      res["ConfigRuleIds"] = boost::any(*configRuleIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleIds") != m.end() && !m["ConfigRuleIds"].empty()) {
      configRuleIds = make_shared<string>(boost::any_cast<string>(m["ConfigRuleIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRemediationsRequest() = default;
};
class ListRemediationsResponseBodyRemediations : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> lastSuccessfulInvocationId{};
  shared_ptr<long> lastSuccessfulInvocationTime{};
  shared_ptr<string> lastSuccessfulInvocationType{};
  shared_ptr<string> remediationId{};
  shared_ptr<string> remediationOriginParams{};
  shared_ptr<string> remediationSourceType{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};

  ListRemediationsResponseBodyRemediations() {}

  explicit ListRemediationsResponseBodyRemediations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (lastSuccessfulInvocationId) {
      res["LastSuccessfulInvocationId"] = boost::any(*lastSuccessfulInvocationId);
    }
    if (lastSuccessfulInvocationTime) {
      res["LastSuccessfulInvocationTime"] = boost::any(*lastSuccessfulInvocationTime);
    }
    if (lastSuccessfulInvocationType) {
      res["LastSuccessfulInvocationType"] = boost::any(*lastSuccessfulInvocationType);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (remediationOriginParams) {
      res["RemediationOriginParams"] = boost::any(*remediationOriginParams);
    }
    if (remediationSourceType) {
      res["RemediationSourceType"] = boost::any(*remediationSourceType);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("LastSuccessfulInvocationId") != m.end() && !m["LastSuccessfulInvocationId"].empty()) {
      lastSuccessfulInvocationId = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationId"]));
    }
    if (m.find("LastSuccessfulInvocationTime") != m.end() && !m["LastSuccessfulInvocationTime"].empty()) {
      lastSuccessfulInvocationTime = make_shared<long>(boost::any_cast<long>(m["LastSuccessfulInvocationTime"]));
    }
    if (m.find("LastSuccessfulInvocationType") != m.end() && !m["LastSuccessfulInvocationType"].empty()) {
      lastSuccessfulInvocationType = make_shared<string>(boost::any_cast<string>(m["LastSuccessfulInvocationType"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RemediationOriginParams") != m.end() && !m["RemediationOriginParams"].empty()) {
      remediationOriginParams = make_shared<string>(boost::any_cast<string>(m["RemediationOriginParams"]));
    }
    if (m.find("RemediationSourceType") != m.end() && !m["RemediationSourceType"].empty()) {
      remediationSourceType = make_shared<string>(boost::any_cast<string>(m["RemediationSourceType"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
  }


  virtual ~ListRemediationsResponseBodyRemediations() = default;
};
class ListRemediationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListRemediationsResponseBodyRemediations>> remediations{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListRemediationsResponseBody() {}

  explicit ListRemediationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remediations) {
      vector<boost::any> temp1;
      for(auto item1:*remediations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Remediations"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remediations") != m.end() && !m["Remediations"].empty()) {
      if (typeid(vector<boost::any>) == m["Remediations"].type()) {
        vector<ListRemediationsResponseBodyRemediations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Remediations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRemediationsResponseBodyRemediations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remediations = make_shared<vector<ListRemediationsResponseBodyRemediations>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListRemediationsResponseBody() = default;
};
class ListRemediationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRemediationsResponseBody> body{};

  ListRemediationsResponse() {}

  explicit ListRemediationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRemediationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRemediationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRemediationsResponse() = default;
};
class ListResourceEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> complianceType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ListResourceEvaluationResultsRequest() {}

  explicit ListResourceEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceEvaluationResultsRequest() = default;
};
class ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier : public Darabonba::Model {
public:
  shared_ptr<string> configRuleArn{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> ignoreDate{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceType{};

  ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() {}

  explicit ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleArn) {
      res["ConfigRuleArn"] = boost::any(*configRuleArn);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (ignoreDate) {
      res["IgnoreDate"] = boost::any(*ignoreDate);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleArn") != m.end() && !m["ConfigRuleArn"].empty()) {
      configRuleArn = make_shared<string>(boost::any_cast<string>(m["ConfigRuleArn"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("IgnoreDate") != m.end() && !m["IgnoreDate"].empty()) {
      ignoreDate = make_shared<string>(boost::any_cast<string>(m["IgnoreDate"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier() = default;
};
class ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier : public Darabonba::Model {
public:
  shared_ptr<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier> evaluationResultQualifier{};
  shared_ptr<long> orderingTimestamp{};

  ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() {}

  explicit ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultQualifier) {
      res["EvaluationResultQualifier"] = evaluationResultQualifier ? boost::any(evaluationResultQualifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderingTimestamp) {
      res["OrderingTimestamp"] = boost::any(*orderingTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultQualifier") != m.end() && !m["EvaluationResultQualifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultQualifier"].type()) {
        ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultQualifier"]));
        evaluationResultQualifier = make_shared<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier>(model1);
      }
    }
    if (m.find("OrderingTimestamp") != m.end() && !m["OrderingTimestamp"].empty()) {
      orderingTimestamp = make_shared<long>(boost::any_cast<long>(m["OrderingTimestamp"]));
    }
  }


  virtual ~ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier() = default;
};
class ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList : public Darabonba::Model {
public:
  shared_ptr<string> annotation{};
  shared_ptr<string> complianceType{};
  shared_ptr<long> configRuleInvokedTimestamp{};
  shared_ptr<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier> evaluationResultIdentifier{};
  shared_ptr<string> invokingEventMessageType{};
  shared_ptr<bool> remediationEnabled{};
  shared_ptr<long> resultRecordedTimestamp{};
  shared_ptr<long> riskLevel{};

  ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() {}

  explicit ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (complianceType) {
      res["ComplianceType"] = boost::any(*complianceType);
    }
    if (configRuleInvokedTimestamp) {
      res["ConfigRuleInvokedTimestamp"] = boost::any(*configRuleInvokedTimestamp);
    }
    if (evaluationResultIdentifier) {
      res["EvaluationResultIdentifier"] = evaluationResultIdentifier ? boost::any(evaluationResultIdentifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invokingEventMessageType) {
      res["InvokingEventMessageType"] = boost::any(*invokingEventMessageType);
    }
    if (remediationEnabled) {
      res["RemediationEnabled"] = boost::any(*remediationEnabled);
    }
    if (resultRecordedTimestamp) {
      res["ResultRecordedTimestamp"] = boost::any(*resultRecordedTimestamp);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("ComplianceType") != m.end() && !m["ComplianceType"].empty()) {
      complianceType = make_shared<string>(boost::any_cast<string>(m["ComplianceType"]));
    }
    if (m.find("ConfigRuleInvokedTimestamp") != m.end() && !m["ConfigRuleInvokedTimestamp"].empty()) {
      configRuleInvokedTimestamp = make_shared<long>(boost::any_cast<long>(m["ConfigRuleInvokedTimestamp"]));
    }
    if (m.find("EvaluationResultIdentifier") != m.end() && !m["EvaluationResultIdentifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResultIdentifier"].type()) {
        ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResultIdentifier"]));
        evaluationResultIdentifier = make_shared<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier>(model1);
      }
    }
    if (m.find("InvokingEventMessageType") != m.end() && !m["InvokingEventMessageType"].empty()) {
      invokingEventMessageType = make_shared<string>(boost::any_cast<string>(m["InvokingEventMessageType"]));
    }
    if (m.find("RemediationEnabled") != m.end() && !m["RemediationEnabled"].empty()) {
      remediationEnabled = make_shared<bool>(boost::any_cast<bool>(m["RemediationEnabled"]));
    }
    if (m.find("ResultRecordedTimestamp") != m.end() && !m["ResultRecordedTimestamp"].empty()) {
      resultRecordedTimestamp = make_shared<long>(boost::any_cast<long>(m["ResultRecordedTimestamp"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList() = default;
};
class ListResourceEvaluationResultsResponseBodyEvaluationResults : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>> evaluationResultList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListResourceEvaluationResultsResponseBodyEvaluationResults() {}

  explicit ListResourceEvaluationResultsResponseBodyEvaluationResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResultList) {
      vector<boost::any> temp1;
      for(auto item1:*evaluationResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EvaluationResultList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResultList") != m.end() && !m["EvaluationResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["EvaluationResultList"].type()) {
        vector<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EvaluationResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        evaluationResultList = make_shared<vector<ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListResourceEvaluationResultsResponseBodyEvaluationResults() = default;
};
class ListResourceEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourceEvaluationResultsResponseBodyEvaluationResults> evaluationResults{};
  shared_ptr<string> requestId{};

  ListResourceEvaluationResultsResponseBody() {}

  explicit ListResourceEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (evaluationResults) {
      res["EvaluationResults"] = evaluationResults ? boost::any(evaluationResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EvaluationResults") != m.end() && !m["EvaluationResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["EvaluationResults"].type()) {
        ListResourceEvaluationResultsResponseBodyEvaluationResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EvaluationResults"]));
        evaluationResults = make_shared<ListResourceEvaluationResultsResponseBodyEvaluationResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListResourceEvaluationResultsResponseBody() = default;
};
class ListResourceEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceEvaluationResultsResponseBody> body{};

  ListResourceEvaluationResultsResponse() {}

  explicit ListResourceEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceEvaluationResultsResponse() = default;
};
class ListResourceRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> region{};
  shared_ptr<string> relationType{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> targetResourceId{};
  shared_ptr<string> targetResourceType{};

  ListResourceRelationsRequest() {}

  explicit ListResourceRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (relationType) {
      res["RelationType"] = boost::any(*relationType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (targetResourceId) {
      res["TargetResourceId"] = boost::any(*targetResourceId);
    }
    if (targetResourceType) {
      res["TargetResourceType"] = boost::any(*targetResourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RelationType") != m.end() && !m["RelationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["RelationType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TargetResourceId") != m.end() && !m["TargetResourceId"].empty()) {
      targetResourceId = make_shared<string>(boost::any_cast<string>(m["TargetResourceId"]));
    }
    if (m.find("TargetResourceType") != m.end() && !m["TargetResourceType"].empty()) {
      targetResourceType = make_shared<string>(boost::any_cast<string>(m["TargetResourceType"]));
    }
  }


  virtual ~ListResourceRelationsRequest() = default;
};
class ListResourceRelationsResponseBodyResourceRelationsResourceRelationList : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> relationType{};
  shared_ptr<string> sourceResourceId{};
  shared_ptr<string> sourceResourceRegionId{};
  shared_ptr<string> sourceResourceType{};
  shared_ptr<string> targetResourceId{};
  shared_ptr<string> targetResourceType{};

  ListResourceRelationsResponseBodyResourceRelationsResourceRelationList() {}

  explicit ListResourceRelationsResponseBodyResourceRelationsResourceRelationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (relationType) {
      res["RelationType"] = boost::any(*relationType);
    }
    if (sourceResourceId) {
      res["SourceResourceId"] = boost::any(*sourceResourceId);
    }
    if (sourceResourceRegionId) {
      res["SourceResourceRegionId"] = boost::any(*sourceResourceRegionId);
    }
    if (sourceResourceType) {
      res["SourceResourceType"] = boost::any(*sourceResourceType);
    }
    if (targetResourceId) {
      res["TargetResourceId"] = boost::any(*targetResourceId);
    }
    if (targetResourceType) {
      res["TargetResourceType"] = boost::any(*targetResourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("RelationType") != m.end() && !m["RelationType"].empty()) {
      relationType = make_shared<string>(boost::any_cast<string>(m["RelationType"]));
    }
    if (m.find("SourceResourceId") != m.end() && !m["SourceResourceId"].empty()) {
      sourceResourceId = make_shared<string>(boost::any_cast<string>(m["SourceResourceId"]));
    }
    if (m.find("SourceResourceRegionId") != m.end() && !m["SourceResourceRegionId"].empty()) {
      sourceResourceRegionId = make_shared<string>(boost::any_cast<string>(m["SourceResourceRegionId"]));
    }
    if (m.find("SourceResourceType") != m.end() && !m["SourceResourceType"].empty()) {
      sourceResourceType = make_shared<string>(boost::any_cast<string>(m["SourceResourceType"]));
    }
    if (m.find("TargetResourceId") != m.end() && !m["TargetResourceId"].empty()) {
      targetResourceId = make_shared<string>(boost::any_cast<string>(m["TargetResourceId"]));
    }
    if (m.find("TargetResourceType") != m.end() && !m["TargetResourceType"].empty()) {
      targetResourceType = make_shared<string>(boost::any_cast<string>(m["TargetResourceType"]));
    }
  }


  virtual ~ListResourceRelationsResponseBodyResourceRelationsResourceRelationList() = default;
};
class ListResourceRelationsResponseBodyResourceRelations : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListResourceRelationsResponseBodyResourceRelationsResourceRelationList>> resourceRelationList{};

  ListResourceRelationsResponseBodyResourceRelations() {}

  explicit ListResourceRelationsResponseBodyResourceRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceRelationList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceRelationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceRelationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceRelationList") != m.end() && !m["ResourceRelationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceRelationList"].type()) {
        vector<ListResourceRelationsResponseBodyResourceRelationsResourceRelationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceRelationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceRelationsResponseBodyResourceRelationsResourceRelationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceRelationList = make_shared<vector<ListResourceRelationsResponseBodyResourceRelationsResourceRelationList>>(expect1);
      }
    }
  }


  virtual ~ListResourceRelationsResponseBodyResourceRelations() = default;
};
class ListResourceRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListResourceRelationsResponseBodyResourceRelations> resourceRelations{};

  ListResourceRelationsResponseBody() {}

  explicit ListResourceRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceRelations) {
      res["ResourceRelations"] = resourceRelations ? boost::any(resourceRelations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceRelations") != m.end() && !m["ResourceRelations"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceRelations"].type()) {
        ListResourceRelationsResponseBodyResourceRelations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceRelations"]));
        resourceRelations = make_shared<ListResourceRelationsResponseBodyResourceRelations>(model1);
      }
    }
  }


  virtual ~ListResourceRelationsResponseBody() = default;
};
class ListResourceRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourceRelationsResponseBody> body{};

  ListResourceRelationsResponse() {}

  explicit ListResourceRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceRelationsResponse() = default;
};
class ListResourcesByAdvancedSearchRequest : public Darabonba::Model {
public:
  shared_ptr<string> sql{};

  ListResourcesByAdvancedSearchRequest() {}

  explicit ListResourcesByAdvancedSearchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<string>(boost::any_cast<string>(m["Sql"]));
    }
  }


  virtual ~ListResourcesByAdvancedSearchRequest() = default;
};
class ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columns{};
  shared_ptr<vector<boost::any>> values{};

  ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList() {}

  explicit ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Columns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      values = make_shared<vector<boost::any>>(toVec1);
    }
  }


  virtual ~ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList() = default;
};
class ListResourcesByAdvancedSearchResponseBodyQueryResults : public Darabonba::Model {
public:
  shared_ptr<ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList> queryResultList{};

  ListResourcesByAdvancedSearchResponseBodyQueryResults() {}

  explicit ListResourcesByAdvancedSearchResponseBodyQueryResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryResultList) {
      res["QueryResultList"] = queryResultList ? boost::any(queryResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryResultList") != m.end() && !m["QueryResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryResultList"].type()) {
        ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryResultList"]));
        queryResultList = make_shared<ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList>(model1);
      }
    }
  }


  virtual ~ListResourcesByAdvancedSearchResponseBodyQueryResults() = default;
};
class ListResourcesByAdvancedSearchResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListResourcesByAdvancedSearchResponseBodyQueryResults> queryResults{};
  shared_ptr<string> requestId{};

  ListResourcesByAdvancedSearchResponseBody() {}

  explicit ListResourcesByAdvancedSearchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryResults) {
      res["QueryResults"] = queryResults ? boost::any(queryResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryResults") != m.end() && !m["QueryResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryResults"].type()) {
        ListResourcesByAdvancedSearchResponseBodyQueryResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryResults"]));
        queryResults = make_shared<ListResourcesByAdvancedSearchResponseBodyQueryResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListResourcesByAdvancedSearchResponseBody() = default;
};
class ListResourcesByAdvancedSearchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcesByAdvancedSearchResponseBody> body{};

  ListResourcesByAdvancedSearchResponse() {}

  explicit ListResourcesByAdvancedSearchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcesByAdvancedSearchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcesByAdvancedSearchResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcesByAdvancedSearchResponse() = default;
};
class ListSupportedProductsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListSupportedProductsRequest() {}

  explicit ListSupportedProductsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListSupportedProductsRequest() = default;
};
class ListSupportedProductsResponseBodyProductsResourceTypeList : public Darabonba::Model {
public:
  shared_ptr<string> resourceType{};
  shared_ptr<string> typeNameEn{};
  shared_ptr<string> typeNameZh{};
  shared_ptr<string> typePageLink{};

  ListSupportedProductsResponseBodyProductsResourceTypeList() {}

  explicit ListSupportedProductsResponseBodyProductsResourceTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (typeNameEn) {
      res["TypeNameEn"] = boost::any(*typeNameEn);
    }
    if (typeNameZh) {
      res["TypeNameZh"] = boost::any(*typeNameZh);
    }
    if (typePageLink) {
      res["TypePageLink"] = boost::any(*typePageLink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TypeNameEn") != m.end() && !m["TypeNameEn"].empty()) {
      typeNameEn = make_shared<string>(boost::any_cast<string>(m["TypeNameEn"]));
    }
    if (m.find("TypeNameZh") != m.end() && !m["TypeNameZh"].empty()) {
      typeNameZh = make_shared<string>(boost::any_cast<string>(m["TypeNameZh"]));
    }
    if (m.find("TypePageLink") != m.end() && !m["TypePageLink"].empty()) {
      typePageLink = make_shared<string>(boost::any_cast<string>(m["TypePageLink"]));
    }
  }


  virtual ~ListSupportedProductsResponseBodyProductsResourceTypeList() = default;
};
class ListSupportedProductsResponseBodyProducts : public Darabonba::Model {
public:
  shared_ptr<string> productNameEn{};
  shared_ptr<string> productNameZh{};
  shared_ptr<vector<ListSupportedProductsResponseBodyProductsResourceTypeList>> resourceTypeList{};

  ListSupportedProductsResponseBodyProducts() {}

  explicit ListSupportedProductsResponseBodyProducts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productNameEn) {
      res["ProductNameEn"] = boost::any(*productNameEn);
    }
    if (productNameZh) {
      res["ProductNameZh"] = boost::any(*productNameZh);
    }
    if (resourceTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceTypeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductNameEn") != m.end() && !m["ProductNameEn"].empty()) {
      productNameEn = make_shared<string>(boost::any_cast<string>(m["ProductNameEn"]));
    }
    if (m.find("ProductNameZh") != m.end() && !m["ProductNameZh"].empty()) {
      productNameZh = make_shared<string>(boost::any_cast<string>(m["ProductNameZh"]));
    }
    if (m.find("ResourceTypeList") != m.end() && !m["ResourceTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceTypeList"].type()) {
        vector<ListSupportedProductsResponseBodyProductsResourceTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSupportedProductsResponseBodyProductsResourceTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceTypeList = make_shared<vector<ListSupportedProductsResponseBodyProductsResourceTypeList>>(expect1);
      }
    }
  }


  virtual ~ListSupportedProductsResponseBodyProducts() = default;
};
class ListSupportedProductsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListSupportedProductsResponseBodyProducts>> products{};
  shared_ptr<string> requestId{};

  ListSupportedProductsResponseBody() {}

  explicit ListSupportedProductsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (products) {
      vector<boost::any> temp1;
      for(auto item1:*products){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Products"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Products") != m.end() && !m["Products"].empty()) {
      if (typeid(vector<boost::any>) == m["Products"].type()) {
        vector<ListSupportedProductsResponseBodyProducts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Products"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSupportedProductsResponseBodyProducts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        products = make_shared<vector<ListSupportedProductsResponseBodyProducts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSupportedProductsResponseBody() = default;
};
class ListSupportedProductsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSupportedProductsResponseBody> body{};

  ListSupportedProductsResponse() {}

  explicit ListSupportedProductsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSupportedProductsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSupportedProductsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSupportedProductsResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagShrink{};

  ListTagResourcesShrinkRequest() {}

  explicit ListTagResourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListTagResourcesShrinkRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class PutEvaluationsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deleteMode{};
  shared_ptr<string> evaluations{};
  shared_ptr<string> resultToken{};

  PutEvaluationsRequest() {}

  explicit PutEvaluationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteMode) {
      res["DeleteMode"] = boost::any(*deleteMode);
    }
    if (evaluations) {
      res["Evaluations"] = boost::any(*evaluations);
    }
    if (resultToken) {
      res["ResultToken"] = boost::any(*resultToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteMode") != m.end() && !m["DeleteMode"].empty()) {
      deleteMode = make_shared<bool>(boost::any_cast<bool>(m["DeleteMode"]));
    }
    if (m.find("Evaluations") != m.end() && !m["Evaluations"].empty()) {
      evaluations = make_shared<string>(boost::any_cast<string>(m["Evaluations"]));
    }
    if (m.find("ResultToken") != m.end() && !m["ResultToken"].empty()) {
      resultToken = make_shared<string>(boost::any_cast<string>(m["ResultToken"]));
    }
  }


  virtual ~PutEvaluationsRequest() = default;
};
class PutEvaluationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  PutEvaluationsResponseBody() {}

  explicit PutEvaluationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~PutEvaluationsResponseBody() = default;
};
class PutEvaluationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutEvaluationsResponseBody> body{};

  PutEvaluationsResponse() {}

  explicit PutEvaluationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutEvaluationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutEvaluationsResponseBody>(model1);
      }
    }
  }


  virtual ~PutEvaluationsResponse() = default;
};
class RevertAggregateEvaluationResultsRequestResources : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  RevertAggregateEvaluationResultsRequestResources() {}

  explicit RevertAggregateEvaluationResultsRequestResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~RevertAggregateEvaluationResultsRequestResources() = default;
};
class RevertAggregateEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<vector<RevertAggregateEvaluationResultsRequestResources>> resources{};

  RevertAggregateEvaluationResultsRequest() {}

  explicit RevertAggregateEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<RevertAggregateEvaluationResultsRequestResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RevertAggregateEvaluationResultsRequestResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<RevertAggregateEvaluationResultsRequestResources>>(expect1);
      }
    }
  }


  virtual ~RevertAggregateEvaluationResultsRequest() = default;
};
class RevertAggregateEvaluationResultsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> resourcesShrink{};

  RevertAggregateEvaluationResultsShrinkRequest() {}

  explicit RevertAggregateEvaluationResultsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resourcesShrink) {
      res["Resources"] = boost::any(*resourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resourcesShrink = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~RevertAggregateEvaluationResultsShrinkRequest() = default;
};
class RevertAggregateEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevertAggregateEvaluationResultsResponseBody() {}

  explicit RevertAggregateEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevertAggregateEvaluationResultsResponseBody() = default;
};
class RevertAggregateEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevertAggregateEvaluationResultsResponseBody> body{};

  RevertAggregateEvaluationResultsResponse() {}

  explicit RevertAggregateEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevertAggregateEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevertAggregateEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~RevertAggregateEvaluationResultsResponse() = default;
};
class RevertEvaluationResultsRequestResources : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<long> resourceAccountId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  RevertEvaluationResultsRequestResources() {}

  explicit RevertEvaluationResultsRequestResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~RevertEvaluationResultsRequestResources() = default;
};
class RevertEvaluationResultsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<vector<RevertEvaluationResultsRequestResources>> resources{};

  RevertEvaluationResultsRequest() {}

  explicit RevertEvaluationResultsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<RevertEvaluationResultsRequestResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RevertEvaluationResultsRequestResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<RevertEvaluationResultsRequestResources>>(expect1);
      }
    }
  }


  virtual ~RevertEvaluationResultsRequest() = default;
};
class RevertEvaluationResultsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> resourcesShrink{};

  RevertEvaluationResultsShrinkRequest() {}

  explicit RevertEvaluationResultsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resourcesShrink) {
      res["Resources"] = boost::any(*resourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resourcesShrink = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~RevertEvaluationResultsShrinkRequest() = default;
};
class RevertEvaluationResultsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevertEvaluationResultsResponseBody() {}

  explicit RevertEvaluationResultsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevertEvaluationResultsResponseBody() = default;
};
class RevertEvaluationResultsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevertEvaluationResultsResponseBody> body{};

  RevertEvaluationResultsResponse() {}

  explicit RevertEvaluationResultsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevertEvaluationResultsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevertEvaluationResultsResponseBody>(model1);
      }
    }
  }


  virtual ~RevertEvaluationResultsResponse() = default;
};
class StartAggregateConfigRuleEvaluationRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<bool> revertEvaluation{};

  StartAggregateConfigRuleEvaluationRequest() {}

  explicit StartAggregateConfigRuleEvaluationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (revertEvaluation) {
      res["RevertEvaluation"] = boost::any(*revertEvaluation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RevertEvaluation") != m.end() && !m["RevertEvaluation"].empty()) {
      revertEvaluation = make_shared<bool>(boost::any_cast<bool>(m["RevertEvaluation"]));
    }
  }


  virtual ~StartAggregateConfigRuleEvaluationRequest() = default;
};
class StartAggregateConfigRuleEvaluationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StartAggregateConfigRuleEvaluationResponseBody() {}

  explicit StartAggregateConfigRuleEvaluationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StartAggregateConfigRuleEvaluationResponseBody() = default;
};
class StartAggregateConfigRuleEvaluationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAggregateConfigRuleEvaluationResponseBody> body{};

  StartAggregateConfigRuleEvaluationResponse() {}

  explicit StartAggregateConfigRuleEvaluationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAggregateConfigRuleEvaluationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAggregateConfigRuleEvaluationResponseBody>(model1);
      }
    }
  }


  virtual ~StartAggregateConfigRuleEvaluationResponse() = default;
};
class StartAggregateRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<long> resourceAccountId{};

  StartAggregateRemediationRequest() {}

  explicit StartAggregateRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (resourceAccountId) {
      res["ResourceAccountId"] = boost::any(*resourceAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ResourceAccountId") != m.end() && !m["ResourceAccountId"].empty()) {
      resourceAccountId = make_shared<long>(boost::any_cast<long>(m["ResourceAccountId"]));
    }
  }


  virtual ~StartAggregateRemediationRequest() = default;
};
class StartAggregateRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  StartAggregateRemediationResponseBody() {}

  explicit StartAggregateRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartAggregateRemediationResponseBody() = default;
};
class StartAggregateRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAggregateRemediationResponseBody> body{};

  StartAggregateRemediationResponse() {}

  explicit StartAggregateRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAggregateRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAggregateRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~StartAggregateRemediationResponse() = default;
};
class StartConfigRuleEvaluationRequest : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> configRuleId{};
  shared_ptr<bool> revertEvaluation{};

  StartConfigRuleEvaluationRequest() {}

  explicit StartConfigRuleEvaluationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (revertEvaluation) {
      res["RevertEvaluation"] = boost::any(*revertEvaluation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RevertEvaluation") != m.end() && !m["RevertEvaluation"].empty()) {
      revertEvaluation = make_shared<bool>(boost::any_cast<bool>(m["RevertEvaluation"]));
    }
  }


  virtual ~StartConfigRuleEvaluationRequest() = default;
};
class StartConfigRuleEvaluationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StartConfigRuleEvaluationResponseBody() {}

  explicit StartConfigRuleEvaluationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StartConfigRuleEvaluationResponseBody() = default;
};
class StartConfigRuleEvaluationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartConfigRuleEvaluationResponseBody> body{};

  StartConfigRuleEvaluationResponse() {}

  explicit StartConfigRuleEvaluationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartConfigRuleEvaluationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartConfigRuleEvaluationResponseBody>(model1);
      }
    }
  }


  virtual ~StartConfigRuleEvaluationResponse() = default;
};
class StartConfigurationRecorderResponseBodyConfigurationRecorder : public Darabonba::Model {
public:
  shared_ptr<string> configurationRecorderStatus{};
  shared_ptr<vector<string>> resourceTypes{};

  StartConfigurationRecorderResponseBodyConfigurationRecorder() {}

  explicit StartConfigurationRecorderResponseBodyConfigurationRecorder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorderStatus) {
      res["ConfigurationRecorderStatus"] = boost::any(*configurationRecorderStatus);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorderStatus") != m.end() && !m["ConfigurationRecorderStatus"].empty()) {
      configurationRecorderStatus = make_shared<string>(boost::any_cast<string>(m["ConfigurationRecorderStatus"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartConfigurationRecorderResponseBodyConfigurationRecorder() = default;
};
class StartConfigurationRecorderResponseBody : public Darabonba::Model {
public:
  shared_ptr<StartConfigurationRecorderResponseBodyConfigurationRecorder> configurationRecorder{};
  shared_ptr<string> requestId{};

  StartConfigurationRecorderResponseBody() {}

  explicit StartConfigurationRecorderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorder) {
      res["ConfigurationRecorder"] = configurationRecorder ? boost::any(configurationRecorder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorder") != m.end() && !m["ConfigurationRecorder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigurationRecorder"].type()) {
        StartConfigurationRecorderResponseBodyConfigurationRecorder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigurationRecorder"]));
        configurationRecorder = make_shared<StartConfigurationRecorderResponseBodyConfigurationRecorder>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartConfigurationRecorderResponseBody() = default;
};
class StartConfigurationRecorderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartConfigurationRecorderResponseBody> body{};

  StartConfigurationRecorderResponse() {}

  explicit StartConfigurationRecorderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartConfigurationRecorderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartConfigurationRecorderResponseBody>(model1);
      }
    }
  }


  virtual ~StartConfigurationRecorderResponse() = default;
};
class StartRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};

  StartRemediationRequest() {}

  explicit StartRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
  }


  virtual ~StartRemediationRequest() = default;
};
class StartRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  StartRemediationResponseBody() {}

  explicit StartRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartRemediationResponseBody() = default;
};
class StartRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartRemediationResponseBody> body{};

  StartRemediationResponse() {}

  explicit StartRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~StartRemediationResponse() = default;
};
class StopConfigurationRecorderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> stopConfigurationRecorderResult{};

  StopConfigurationRecorderResponseBody() {}

  explicit StopConfigurationRecorderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stopConfigurationRecorderResult) {
      res["StopConfigurationRecorderResult"] = boost::any(*stopConfigurationRecorderResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StopConfigurationRecorderResult") != m.end() && !m["StopConfigurationRecorderResult"].empty()) {
      stopConfigurationRecorderResult = make_shared<bool>(boost::any_cast<bool>(m["StopConfigurationRecorderResult"]));
    }
  }


  virtual ~StopConfigurationRecorderResponseBody() = default;
};
class StopConfigurationRecorderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopConfigurationRecorderResponseBody> body{};

  StopConfigurationRecorderResponse() {}

  explicit StopConfigurationRecorderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopConfigurationRecorderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopConfigurationRecorderResponseBody>(model1);
      }
    }
  }


  virtual ~StopConfigurationRecorderResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagShrink{};

  TagResourcesShrinkRequest() {}

  explicit TagResourcesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~TagResourcesShrinkRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters() {}

  explicit UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters() = default;
};
class UpdateAggregateCompliancePackRequestConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<long> riskLevel{};

  UpdateAggregateCompliancePackRequestConfigRules() {}

  explicit UpdateAggregateCompliancePackRequestConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackRequestConfigRules() = default;
};
class UpdateAggregateCompliancePackRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateCompliancePackRequestExcludeTagsScope() {}

  explicit UpdateAggregateCompliancePackRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackRequestExcludeTagsScope() = default;
};
class UpdateAggregateCompliancePackRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateCompliancePackRequestTagsScope() {}

  explicit UpdateAggregateCompliancePackRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackRequestTagsScope() = default;
};
class UpdateAggregateCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<vector<UpdateAggregateCompliancePackRequestConfigRules>> configRules{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateAggregateCompliancePackRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateAggregateCompliancePackRequestTagsScope>> tagsScope{};

  UpdateAggregateCompliancePackRequest() {}

  explicit UpdateAggregateCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<UpdateAggregateCompliancePackRequestConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackRequestConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<UpdateAggregateCompliancePackRequestConfigRules>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateAggregateCompliancePackRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateAggregateCompliancePackRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateAggregateCompliancePackRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateAggregateCompliancePackRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateAggregateCompliancePackRequest() = default;
};
class UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope() {}

  explicit UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope() = default;
};
class UpdateAggregateCompliancePackShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateCompliancePackShrinkRequestTagsScope() {}

  explicit UpdateAggregateCompliancePackShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackShrinkRequestTagsScope() = default;
};
class UpdateAggregateCompliancePackShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> configRulesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateAggregateCompliancePackShrinkRequestTagsScope>> tagsScope{};

  UpdateAggregateCompliancePackShrinkRequest() {}

  explicit UpdateAggregateCompliancePackShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (configRulesShrink) {
      res["ConfigRules"] = boost::any(*configRulesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      configRulesShrink = make_shared<string>(boost::any_cast<string>(m["ConfigRules"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateAggregateCompliancePackShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateAggregateCompliancePackShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateCompliancePackShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateAggregateCompliancePackShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateAggregateCompliancePackShrinkRequest() = default;
};
class UpdateAggregateCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  UpdateAggregateCompliancePackResponseBody() {}

  explicit UpdateAggregateCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAggregateCompliancePackResponseBody() = default;
};
class UpdateAggregateCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAggregateCompliancePackResponseBody> body{};

  UpdateAggregateCompliancePackResponse() {}

  explicit UpdateAggregateCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAggregateCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAggregateCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAggregateCompliancePackResponse() = default;
};
class UpdateAggregateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  UpdateAggregateConfigDeliveryChannelRequest() {}

  explicit UpdateAggregateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UpdateAggregateConfigDeliveryChannelRequest() = default;
};
class UpdateAggregateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  UpdateAggregateConfigDeliveryChannelResponseBody() {}

  explicit UpdateAggregateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAggregateConfigDeliveryChannelResponseBody() = default;
};
class UpdateAggregateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAggregateConfigDeliveryChannelResponseBody> body{};

  UpdateAggregateConfigDeliveryChannelResponse() {}

  explicit UpdateAggregateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAggregateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAggregateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAggregateConfigDeliveryChannelResponse() = default;
};
class UpdateAggregateConfigRuleRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateConfigRuleRequestExcludeTagsScope() {}

  explicit UpdateAggregateConfigRuleRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateConfigRuleRequestExcludeTagsScope() = default;
};
class UpdateAggregateConfigRuleRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateConfigRuleRequestTagsScope() {}

  explicit UpdateAggregateConfigRuleRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateConfigRuleRequestTagsScope() = default;
};
class UpdateAggregateConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountIdsScope{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeAccountIdsScope{};
  shared_ptr<string> excludeFolderIdsScope{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateAggregateConfigRuleRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> folderIdsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<vector<string>> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateAggregateConfigRuleRequestTagsScope>> tagsScope{};

  UpdateAggregateConfigRuleRequest() {}

  explicit UpdateAggregateConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountIdsScope) {
      res["AccountIdsScope"] = boost::any(*accountIdsScope);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeAccountIdsScope) {
      res["ExcludeAccountIdsScope"] = boost::any(*excludeAccountIdsScope);
    }
    if (excludeFolderIdsScope) {
      res["ExcludeFolderIdsScope"] = boost::any(*excludeFolderIdsScope);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (folderIdsScope) {
      res["FolderIdsScope"] = boost::any(*folderIdsScope);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountIdsScope") != m.end() && !m["AccountIdsScope"].empty()) {
      accountIdsScope = make_shared<string>(boost::any_cast<string>(m["AccountIdsScope"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeAccountIdsScope") != m.end() && !m["ExcludeAccountIdsScope"].empty()) {
      excludeAccountIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeAccountIdsScope"]));
    }
    if (m.find("ExcludeFolderIdsScope") != m.end() && !m["ExcludeFolderIdsScope"].empty()) {
      excludeFolderIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeFolderIdsScope"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateAggregateConfigRuleRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateConfigRuleRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateAggregateConfigRuleRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("FolderIdsScope") != m.end() && !m["FolderIdsScope"].empty()) {
      folderIdsScope = make_shared<string>(boost::any_cast<string>(m["FolderIdsScope"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypesScope"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypesScope"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypesScope = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateAggregateConfigRuleRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateConfigRuleRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateAggregateConfigRuleRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateAggregateConfigRuleRequest() = default;
};
class UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope() {}

  explicit UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope() = default;
};
class UpdateAggregateConfigRuleShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateAggregateConfigRuleShrinkRequestTagsScope() {}

  explicit UpdateAggregateConfigRuleShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateAggregateConfigRuleShrinkRequestTagsScope() = default;
};
class UpdateAggregateConfigRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountIdsScope{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeAccountIdsScope{};
  shared_ptr<string> excludeFolderIdsScope{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> folderIdsScope{};
  shared_ptr<string> inputParametersShrink{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScopeShrink{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateAggregateConfigRuleShrinkRequestTagsScope>> tagsScope{};

  UpdateAggregateConfigRuleShrinkRequest() {}

  explicit UpdateAggregateConfigRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountIdsScope) {
      res["AccountIdsScope"] = boost::any(*accountIdsScope);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeAccountIdsScope) {
      res["ExcludeAccountIdsScope"] = boost::any(*excludeAccountIdsScope);
    }
    if (excludeFolderIdsScope) {
      res["ExcludeFolderIdsScope"] = boost::any(*excludeFolderIdsScope);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (folderIdsScope) {
      res["FolderIdsScope"] = boost::any(*folderIdsScope);
    }
    if (inputParametersShrink) {
      res["InputParameters"] = boost::any(*inputParametersShrink);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScopeShrink) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScopeShrink);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountIdsScope") != m.end() && !m["AccountIdsScope"].empty()) {
      accountIdsScope = make_shared<string>(boost::any_cast<string>(m["AccountIdsScope"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeAccountIdsScope") != m.end() && !m["ExcludeAccountIdsScope"].empty()) {
      excludeAccountIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeAccountIdsScope"]));
    }
    if (m.find("ExcludeFolderIdsScope") != m.end() && !m["ExcludeFolderIdsScope"].empty()) {
      excludeFolderIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeFolderIdsScope"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateAggregateConfigRuleShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("FolderIdsScope") != m.end() && !m["FolderIdsScope"].empty()) {
      folderIdsScope = make_shared<string>(boost::any_cast<string>(m["FolderIdsScope"]));
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParametersShrink = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScopeShrink = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateAggregateConfigRuleShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregateConfigRuleShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateAggregateConfigRuleShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateAggregateConfigRuleShrinkRequest() = default;
};
class UpdateAggregateConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> requestId{};

  UpdateAggregateConfigRuleResponseBody() {}

  explicit UpdateAggregateConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAggregateConfigRuleResponseBody() = default;
};
class UpdateAggregateConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAggregateConfigRuleResponseBody> body{};

  UpdateAggregateConfigRuleResponse() {}

  explicit UpdateAggregateConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAggregateConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAggregateConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAggregateConfigRuleResponse() = default;
};
class UpdateAggregateRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> params{};
  shared_ptr<string> remediationId{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};
  shared_ptr<string> sourceType{};

  UpdateAggregateRemediationRequest() {}

  explicit UpdateAggregateRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~UpdateAggregateRemediationRequest() = default;
};
class UpdateAggregateRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> remediationId{};
  shared_ptr<string> requestId{};

  UpdateAggregateRemediationResponseBody() {}

  explicit UpdateAggregateRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAggregateRemediationResponseBody() = default;
};
class UpdateAggregateRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAggregateRemediationResponseBody> body{};

  UpdateAggregateRemediationResponse() {}

  explicit UpdateAggregateRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAggregateRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAggregateRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAggregateRemediationResponse() = default;
};
class UpdateAggregatorRequestAggregatorAccounts : public Darabonba::Model {
public:
  shared_ptr<long> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountType{};

  UpdateAggregatorRequestAggregatorAccounts() {}

  explicit UpdateAggregatorRequestAggregatorAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<long>(boost::any_cast<long>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
  }


  virtual ~UpdateAggregatorRequestAggregatorAccounts() = default;
};
class UpdateAggregatorRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateAggregatorRequestAggregatorAccounts>> aggregatorAccounts{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  UpdateAggregatorRequest() {}

  explicit UpdateAggregatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*aggregatorAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AggregatorAccounts"] = boost::any(temp1);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorAccounts") != m.end() && !m["AggregatorAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["AggregatorAccounts"].type()) {
        vector<UpdateAggregatorRequestAggregatorAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AggregatorAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAggregatorRequestAggregatorAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregatorAccounts = make_shared<vector<UpdateAggregatorRequestAggregatorAccounts>>(expect1);
      }
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~UpdateAggregatorRequest() = default;
};
class UpdateAggregatorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorAccountsShrink{};
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> aggregatorName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};

  UpdateAggregatorShrinkRequest() {}

  explicit UpdateAggregatorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorAccountsShrink) {
      res["AggregatorAccounts"] = boost::any(*aggregatorAccountsShrink);
    }
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (aggregatorName) {
      res["AggregatorName"] = boost::any(*aggregatorName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorAccounts") != m.end() && !m["AggregatorAccounts"].empty()) {
      aggregatorAccountsShrink = make_shared<string>(boost::any_cast<string>(m["AggregatorAccounts"]));
    }
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("AggregatorName") != m.end() && !m["AggregatorName"].empty()) {
      aggregatorName = make_shared<string>(boost::any_cast<string>(m["AggregatorName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~UpdateAggregatorShrinkRequest() = default;
};
class UpdateAggregatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aggregatorId{};
  shared_ptr<string> requestId{};

  UpdateAggregatorResponseBody() {}

  explicit UpdateAggregatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregatorId) {
      res["AggregatorId"] = boost::any(*aggregatorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregatorId") != m.end() && !m["AggregatorId"].empty()) {
      aggregatorId = make_shared<string>(boost::any_cast<string>(m["AggregatorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAggregatorResponseBody() = default;
};
class UpdateAggregatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAggregatorResponseBody> body{};

  UpdateAggregatorResponse() {}

  explicit UpdateAggregatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAggregatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAggregatorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAggregatorResponse() = default;
};
class UpdateCompliancePackRequestConfigRulesConfigRuleParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValue{};

  UpdateCompliancePackRequestConfigRulesConfigRuleParameters() {}

  explicit UpdateCompliancePackRequestConfigRulesConfigRuleParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValue) {
      res["ParameterValue"] = boost::any(*parameterValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValue") != m.end() && !m["ParameterValue"].empty()) {
      parameterValue = make_shared<string>(boost::any_cast<string>(m["ParameterValue"]));
    }
  }


  virtual ~UpdateCompliancePackRequestConfigRulesConfigRuleParameters() = default;
};
class UpdateCompliancePackRequestConfigRules : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<vector<UpdateCompliancePackRequestConfigRulesConfigRuleParameters>> configRuleParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> managedRuleIdentifier{};
  shared_ptr<long> riskLevel{};

  UpdateCompliancePackRequestConfigRules() {}

  explicit UpdateCompliancePackRequestConfigRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleParameters) {
      vector<boost::any> temp1;
      for(auto item1:*configRuleParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRuleParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (managedRuleIdentifier) {
      res["ManagedRuleIdentifier"] = boost::any(*managedRuleIdentifier);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleParameters") != m.end() && !m["ConfigRuleParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRuleParameters"].type()) {
        vector<UpdateCompliancePackRequestConfigRulesConfigRuleParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRuleParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackRequestConfigRulesConfigRuleParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRuleParameters = make_shared<vector<UpdateCompliancePackRequestConfigRulesConfigRuleParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ManagedRuleIdentifier") != m.end() && !m["ManagedRuleIdentifier"].empty()) {
      managedRuleIdentifier = make_shared<string>(boost::any_cast<string>(m["ManagedRuleIdentifier"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~UpdateCompliancePackRequestConfigRules() = default;
};
class UpdateCompliancePackRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateCompliancePackRequestExcludeTagsScope() {}

  explicit UpdateCompliancePackRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateCompliancePackRequestExcludeTagsScope() = default;
};
class UpdateCompliancePackRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateCompliancePackRequestTagsScope() {}

  explicit UpdateCompliancePackRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateCompliancePackRequestTagsScope() = default;
};
class UpdateCompliancePackRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<vector<UpdateCompliancePackRequestConfigRules>> configRules{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateCompliancePackRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateCompliancePackRequestTagsScope>> tagsScope{};

  UpdateCompliancePackRequest() {}

  explicit UpdateCompliancePackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (configRules) {
      vector<boost::any> temp1;
      for(auto item1:*configRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigRules"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigRules"].type()) {
        vector<UpdateCompliancePackRequestConfigRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackRequestConfigRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configRules = make_shared<vector<UpdateCompliancePackRequestConfigRules>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateCompliancePackRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateCompliancePackRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateCompliancePackRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateCompliancePackRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateCompliancePackRequest() = default;
};
class UpdateCompliancePackShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateCompliancePackShrinkRequestExcludeTagsScope() {}

  explicit UpdateCompliancePackShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateCompliancePackShrinkRequestExcludeTagsScope() = default;
};
class UpdateCompliancePackShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateCompliancePackShrinkRequestTagsScope() {}

  explicit UpdateCompliancePackShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateCompliancePackShrinkRequestTagsScope() = default;
};
class UpdateCompliancePackShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> compliancePackName{};
  shared_ptr<string> configRulesShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateCompliancePackShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateCompliancePackShrinkRequestTagsScope>> tagsScope{};

  UpdateCompliancePackShrinkRequest() {}

  explicit UpdateCompliancePackShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (compliancePackName) {
      res["CompliancePackName"] = boost::any(*compliancePackName);
    }
    if (configRulesShrink) {
      res["ConfigRules"] = boost::any(*configRulesShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("CompliancePackName") != m.end() && !m["CompliancePackName"].empty()) {
      compliancePackName = make_shared<string>(boost::any_cast<string>(m["CompliancePackName"]));
    }
    if (m.find("ConfigRules") != m.end() && !m["ConfigRules"].empty()) {
      configRulesShrink = make_shared<string>(boost::any_cast<string>(m["ConfigRules"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateCompliancePackShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateCompliancePackShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateCompliancePackShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCompliancePackShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateCompliancePackShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateCompliancePackShrinkRequest() = default;
};
class UpdateCompliancePackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> compliancePackId{};
  shared_ptr<string> requestId{};

  UpdateCompliancePackResponseBody() {}

  explicit UpdateCompliancePackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compliancePackId) {
      res["CompliancePackId"] = boost::any(*compliancePackId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompliancePackId") != m.end() && !m["CompliancePackId"].empty()) {
      compliancePackId = make_shared<string>(boost::any_cast<string>(m["CompliancePackId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCompliancePackResponseBody() = default;
};
class UpdateCompliancePackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCompliancePackResponseBody> body{};

  UpdateCompliancePackResponse() {}

  explicit UpdateCompliancePackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCompliancePackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCompliancePackResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCompliancePackResponse() = default;
};
class UpdateConfigDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> compliantSnapshot{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> deliverySnapshotTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  UpdateConfigDeliveryChannelRequest() {}

  explicit UpdateConfigDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (compliantSnapshot) {
      res["CompliantSnapshot"] = boost::any(*compliantSnapshot);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (deliverySnapshotTime) {
      res["DeliverySnapshotTime"] = boost::any(*deliverySnapshotTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CompliantSnapshot") != m.end() && !m["CompliantSnapshot"].empty()) {
      compliantSnapshot = make_shared<bool>(boost::any_cast<bool>(m["CompliantSnapshot"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("DeliverySnapshotTime") != m.end() && !m["DeliverySnapshotTime"].empty()) {
      deliverySnapshotTime = make_shared<string>(boost::any_cast<string>(m["DeliverySnapshotTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UpdateConfigDeliveryChannelRequest() = default;
};
class UpdateConfigDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  UpdateConfigDeliveryChannelResponseBody() {}

  explicit UpdateConfigDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigDeliveryChannelResponseBody() = default;
};
class UpdateConfigDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigDeliveryChannelResponseBody> body{};

  UpdateConfigDeliveryChannelResponse() {}

  explicit UpdateConfigDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigDeliveryChannelResponse() = default;
};
class UpdateConfigRuleRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateConfigRuleRequestExcludeTagsScope() {}

  explicit UpdateConfigRuleRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateConfigRuleRequestExcludeTagsScope() = default;
};
class UpdateConfigRuleRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateConfigRuleRequestTagsScope() {}

  explicit UpdateConfigRuleRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateConfigRuleRequestTagsScope() = default;
};
class UpdateConfigRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateConfigRuleRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<map<string, boost::any>> inputParameters{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<vector<string>> resourceTypesScope{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateConfigRuleRequestTagsScope>> tagsScope{};

  UpdateConfigRuleRequest() {}

  explicit UpdateConfigRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (inputParameters) {
      res["InputParameters"] = boost::any(*inputParameters);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScope) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScope);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateConfigRuleRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateConfigRuleRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateConfigRuleRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["InputParameters"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      inputParameters = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypesScope"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypesScope"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypesScope = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateConfigRuleRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateConfigRuleRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateConfigRuleRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateConfigRuleRequest() = default;
};
class UpdateConfigRuleShrinkRequestExcludeTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateConfigRuleShrinkRequestExcludeTagsScope() {}

  explicit UpdateConfigRuleShrinkRequestExcludeTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateConfigRuleShrinkRequestExcludeTagsScope() = default;
};
class UpdateConfigRuleShrinkRequestTagsScope : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  UpdateConfigRuleShrinkRequestTagsScope() {}

  explicit UpdateConfigRuleShrinkRequestTagsScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~UpdateConfigRuleShrinkRequestTagsScope() = default;
};
class UpdateConfigRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> configRuleId{};
  shared_ptr<string> configRuleName{};
  shared_ptr<string> configRuleTriggerTypes{};
  shared_ptr<string> description{};
  shared_ptr<string> excludeRegionIdsScope{};
  shared_ptr<string> excludeResourceGroupIdsScope{};
  shared_ptr<string> excludeResourceIdsScope{};
  shared_ptr<vector<UpdateConfigRuleShrinkRequestExcludeTagsScope>> excludeTagsScope{};
  shared_ptr<string> inputParametersShrink{};
  shared_ptr<string> maximumExecutionFrequency{};
  shared_ptr<string> regionIdsScope{};
  shared_ptr<string> resourceGroupIdsScope{};
  shared_ptr<string> resourceIdsScope{};
  shared_ptr<string> resourceTypesScopeShrink{};
  shared_ptr<long> riskLevel{};
  shared_ptr<string> tagKeyLogicScope{};
  shared_ptr<string> tagKeyScope{};
  shared_ptr<string> tagValueScope{};
  shared_ptr<vector<UpdateConfigRuleShrinkRequestTagsScope>> tagsScope{};

  UpdateConfigRuleShrinkRequest() {}

  explicit UpdateConfigRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (configRuleName) {
      res["ConfigRuleName"] = boost::any(*configRuleName);
    }
    if (configRuleTriggerTypes) {
      res["ConfigRuleTriggerTypes"] = boost::any(*configRuleTriggerTypes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (excludeRegionIdsScope) {
      res["ExcludeRegionIdsScope"] = boost::any(*excludeRegionIdsScope);
    }
    if (excludeResourceGroupIdsScope) {
      res["ExcludeResourceGroupIdsScope"] = boost::any(*excludeResourceGroupIdsScope);
    }
    if (excludeResourceIdsScope) {
      res["ExcludeResourceIdsScope"] = boost::any(*excludeResourceIdsScope);
    }
    if (excludeTagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*excludeTagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludeTagsScope"] = boost::any(temp1);
    }
    if (inputParametersShrink) {
      res["InputParameters"] = boost::any(*inputParametersShrink);
    }
    if (maximumExecutionFrequency) {
      res["MaximumExecutionFrequency"] = boost::any(*maximumExecutionFrequency);
    }
    if (regionIdsScope) {
      res["RegionIdsScope"] = boost::any(*regionIdsScope);
    }
    if (resourceGroupIdsScope) {
      res["ResourceGroupIdsScope"] = boost::any(*resourceGroupIdsScope);
    }
    if (resourceIdsScope) {
      res["ResourceIdsScope"] = boost::any(*resourceIdsScope);
    }
    if (resourceTypesScopeShrink) {
      res["ResourceTypesScope"] = boost::any(*resourceTypesScopeShrink);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tagKeyLogicScope) {
      res["TagKeyLogicScope"] = boost::any(*tagKeyLogicScope);
    }
    if (tagKeyScope) {
      res["TagKeyScope"] = boost::any(*tagKeyScope);
    }
    if (tagValueScope) {
      res["TagValueScope"] = boost::any(*tagValueScope);
    }
    if (tagsScope) {
      vector<boost::any> temp1;
      for(auto item1:*tagsScope){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagsScope"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("ConfigRuleName") != m.end() && !m["ConfigRuleName"].empty()) {
      configRuleName = make_shared<string>(boost::any_cast<string>(m["ConfigRuleName"]));
    }
    if (m.find("ConfigRuleTriggerTypes") != m.end() && !m["ConfigRuleTriggerTypes"].empty()) {
      configRuleTriggerTypes = make_shared<string>(boost::any_cast<string>(m["ConfigRuleTriggerTypes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExcludeRegionIdsScope") != m.end() && !m["ExcludeRegionIdsScope"].empty()) {
      excludeRegionIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeRegionIdsScope"]));
    }
    if (m.find("ExcludeResourceGroupIdsScope") != m.end() && !m["ExcludeResourceGroupIdsScope"].empty()) {
      excludeResourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceGroupIdsScope"]));
    }
    if (m.find("ExcludeResourceIdsScope") != m.end() && !m["ExcludeResourceIdsScope"].empty()) {
      excludeResourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ExcludeResourceIdsScope"]));
    }
    if (m.find("ExcludeTagsScope") != m.end() && !m["ExcludeTagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludeTagsScope"].type()) {
        vector<UpdateConfigRuleShrinkRequestExcludeTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludeTagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateConfigRuleShrinkRequestExcludeTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludeTagsScope = make_shared<vector<UpdateConfigRuleShrinkRequestExcludeTagsScope>>(expect1);
      }
    }
    if (m.find("InputParameters") != m.end() && !m["InputParameters"].empty()) {
      inputParametersShrink = make_shared<string>(boost::any_cast<string>(m["InputParameters"]));
    }
    if (m.find("MaximumExecutionFrequency") != m.end() && !m["MaximumExecutionFrequency"].empty()) {
      maximumExecutionFrequency = make_shared<string>(boost::any_cast<string>(m["MaximumExecutionFrequency"]));
    }
    if (m.find("RegionIdsScope") != m.end() && !m["RegionIdsScope"].empty()) {
      regionIdsScope = make_shared<string>(boost::any_cast<string>(m["RegionIdsScope"]));
    }
    if (m.find("ResourceGroupIdsScope") != m.end() && !m["ResourceGroupIdsScope"].empty()) {
      resourceGroupIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdsScope"]));
    }
    if (m.find("ResourceIdsScope") != m.end() && !m["ResourceIdsScope"].empty()) {
      resourceIdsScope = make_shared<string>(boost::any_cast<string>(m["ResourceIdsScope"]));
    }
    if (m.find("ResourceTypesScope") != m.end() && !m["ResourceTypesScope"].empty()) {
      resourceTypesScopeShrink = make_shared<string>(boost::any_cast<string>(m["ResourceTypesScope"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("TagKeyLogicScope") != m.end() && !m["TagKeyLogicScope"].empty()) {
      tagKeyLogicScope = make_shared<string>(boost::any_cast<string>(m["TagKeyLogicScope"]));
    }
    if (m.find("TagKeyScope") != m.end() && !m["TagKeyScope"].empty()) {
      tagKeyScope = make_shared<string>(boost::any_cast<string>(m["TagKeyScope"]));
    }
    if (m.find("TagValueScope") != m.end() && !m["TagValueScope"].empty()) {
      tagValueScope = make_shared<string>(boost::any_cast<string>(m["TagValueScope"]));
    }
    if (m.find("TagsScope") != m.end() && !m["TagsScope"].empty()) {
      if (typeid(vector<boost::any>) == m["TagsScope"].type()) {
        vector<UpdateConfigRuleShrinkRequestTagsScope> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagsScope"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateConfigRuleShrinkRequestTagsScope model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagsScope = make_shared<vector<UpdateConfigRuleShrinkRequestTagsScope>>(expect1);
      }
    }
  }


  virtual ~UpdateConfigRuleShrinkRequest() = default;
};
class UpdateConfigRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configRuleId{};
  shared_ptr<string> requestId{};

  UpdateConfigRuleResponseBody() {}

  explicit UpdateConfigRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configRuleId) {
      res["ConfigRuleId"] = boost::any(*configRuleId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigRuleId") != m.end() && !m["ConfigRuleId"].empty()) {
      configRuleId = make_shared<string>(boost::any_cast<string>(m["ConfigRuleId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigRuleResponseBody() = default;
};
class UpdateConfigRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigRuleResponseBody> body{};

  UpdateConfigRuleResponse() {}

  explicit UpdateConfigRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigRuleResponse() = default;
};
class UpdateConfigurationRecorderRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceTypes{};

  UpdateConfigurationRecorderRequest() {}

  explicit UpdateConfigurationRecorderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      resourceTypes = make_shared<string>(boost::any_cast<string>(m["ResourceTypes"]));
    }
  }


  virtual ~UpdateConfigurationRecorderRequest() = default;
};
class UpdateConfigurationRecorderResponseBodyConfigurationRecorder : public Darabonba::Model {
public:
  shared_ptr<string> configurationRecorderStatus{};
  shared_ptr<vector<string>> resourceTypes{};

  UpdateConfigurationRecorderResponseBodyConfigurationRecorder() {}

  explicit UpdateConfigurationRecorderResponseBodyConfigurationRecorder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorderStatus) {
      res["ConfigurationRecorderStatus"] = boost::any(*configurationRecorderStatus);
    }
    if (resourceTypes) {
      res["ResourceTypes"] = boost::any(*resourceTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorderStatus") != m.end() && !m["ConfigurationRecorderStatus"].empty()) {
      configurationRecorderStatus = make_shared<string>(boost::any_cast<string>(m["ConfigurationRecorderStatus"]));
    }
    if (m.find("ResourceTypes") != m.end() && !m["ResourceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateConfigurationRecorderResponseBodyConfigurationRecorder() = default;
};
class UpdateConfigurationRecorderResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateConfigurationRecorderResponseBodyConfigurationRecorder> configurationRecorder{};
  shared_ptr<string> requestId{};

  UpdateConfigurationRecorderResponseBody() {}

  explicit UpdateConfigurationRecorderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationRecorder) {
      res["ConfigurationRecorder"] = configurationRecorder ? boost::any(configurationRecorder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationRecorder") != m.end() && !m["ConfigurationRecorder"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigurationRecorder"].type()) {
        UpdateConfigurationRecorderResponseBodyConfigurationRecorder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigurationRecorder"]));
        configurationRecorder = make_shared<UpdateConfigurationRecorderResponseBodyConfigurationRecorder>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigurationRecorderResponseBody() = default;
};
class UpdateConfigurationRecorderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigurationRecorderResponseBody> body{};

  UpdateConfigurationRecorderResponse() {}

  explicit UpdateConfigurationRecorderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigurationRecorderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigurationRecorderResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigurationRecorderResponse() = default;
};
class UpdateDeliveryChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> configurationItemChangeNotification{};
  shared_ptr<bool> configurationSnapshot{};
  shared_ptr<string> deliveryChannelAssumeRoleArn{};
  shared_ptr<string> deliveryChannelCondition{};
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> deliveryChannelName{};
  shared_ptr<string> deliveryChannelTargetArn{};
  shared_ptr<string> description{};
  shared_ptr<bool> nonCompliantNotification{};
  shared_ptr<string> oversizedDataOSSTargetArn{};
  shared_ptr<long> status{};

  UpdateDeliveryChannelRequest() {}

  explicit UpdateDeliveryChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configurationItemChangeNotification) {
      res["ConfigurationItemChangeNotification"] = boost::any(*configurationItemChangeNotification);
    }
    if (configurationSnapshot) {
      res["ConfigurationSnapshot"] = boost::any(*configurationSnapshot);
    }
    if (deliveryChannelAssumeRoleArn) {
      res["DeliveryChannelAssumeRoleArn"] = boost::any(*deliveryChannelAssumeRoleArn);
    }
    if (deliveryChannelCondition) {
      res["DeliveryChannelCondition"] = boost::any(*deliveryChannelCondition);
    }
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (deliveryChannelName) {
      res["DeliveryChannelName"] = boost::any(*deliveryChannelName);
    }
    if (deliveryChannelTargetArn) {
      res["DeliveryChannelTargetArn"] = boost::any(*deliveryChannelTargetArn);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nonCompliantNotification) {
      res["NonCompliantNotification"] = boost::any(*nonCompliantNotification);
    }
    if (oversizedDataOSSTargetArn) {
      res["OversizedDataOSSTargetArn"] = boost::any(*oversizedDataOSSTargetArn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigurationItemChangeNotification") != m.end() && !m["ConfigurationItemChangeNotification"].empty()) {
      configurationItemChangeNotification = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationItemChangeNotification"]));
    }
    if (m.find("ConfigurationSnapshot") != m.end() && !m["ConfigurationSnapshot"].empty()) {
      configurationSnapshot = make_shared<bool>(boost::any_cast<bool>(m["ConfigurationSnapshot"]));
    }
    if (m.find("DeliveryChannelAssumeRoleArn") != m.end() && !m["DeliveryChannelAssumeRoleArn"].empty()) {
      deliveryChannelAssumeRoleArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelAssumeRoleArn"]));
    }
    if (m.find("DeliveryChannelCondition") != m.end() && !m["DeliveryChannelCondition"].empty()) {
      deliveryChannelCondition = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelCondition"]));
    }
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("DeliveryChannelName") != m.end() && !m["DeliveryChannelName"].empty()) {
      deliveryChannelName = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelName"]));
    }
    if (m.find("DeliveryChannelTargetArn") != m.end() && !m["DeliveryChannelTargetArn"].empty()) {
      deliveryChannelTargetArn = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelTargetArn"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NonCompliantNotification") != m.end() && !m["NonCompliantNotification"].empty()) {
      nonCompliantNotification = make_shared<bool>(boost::any_cast<bool>(m["NonCompliantNotification"]));
    }
    if (m.find("OversizedDataOSSTargetArn") != m.end() && !m["OversizedDataOSSTargetArn"].empty()) {
      oversizedDataOSSTargetArn = make_shared<string>(boost::any_cast<string>(m["OversizedDataOSSTargetArn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UpdateDeliveryChannelRequest() = default;
};
class UpdateDeliveryChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliveryChannelId{};
  shared_ptr<string> requestId{};

  UpdateDeliveryChannelResponseBody() {}

  explicit UpdateDeliveryChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryChannelId) {
      res["DeliveryChannelId"] = boost::any(*deliveryChannelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryChannelId") != m.end() && !m["DeliveryChannelId"].empty()) {
      deliveryChannelId = make_shared<string>(boost::any_cast<string>(m["DeliveryChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDeliveryChannelResponseBody() = default;
};
class UpdateDeliveryChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDeliveryChannelResponseBody> body{};

  UpdateDeliveryChannelResponse() {}

  explicit UpdateDeliveryChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeliveryChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeliveryChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeliveryChannelResponse() = default;
};
class UpdateIntegratedServiceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> integratedTypes{};
  shared_ptr<string> serviceCode{};
  shared_ptr<bool> status{};

  UpdateIntegratedServiceStatusRequest() {}

  explicit UpdateIntegratedServiceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedTypes) {
      res["IntegratedTypes"] = boost::any(*integratedTypes);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedTypes") != m.end() && !m["IntegratedTypes"].empty()) {
      integratedTypes = make_shared<string>(boost::any_cast<string>(m["IntegratedTypes"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~UpdateIntegratedServiceStatusRequest() = default;
};
class UpdateIntegratedServiceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIntegratedServiceStatusResponseBody() {}

  explicit UpdateIntegratedServiceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIntegratedServiceStatusResponseBody() = default;
};
class UpdateIntegratedServiceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIntegratedServiceStatusResponseBody> body{};

  UpdateIntegratedServiceStatusResponse() {}

  explicit UpdateIntegratedServiceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIntegratedServiceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIntegratedServiceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIntegratedServiceStatusResponse() = default;
};
class UpdateRemediationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> params{};
  shared_ptr<string> remediationId{};
  shared_ptr<string> remediationTemplateId{};
  shared_ptr<string> remediationType{};
  shared_ptr<string> sourceType{};

  UpdateRemediationRequest() {}

  explicit UpdateRemediationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (remediationTemplateId) {
      res["RemediationTemplateId"] = boost::any(*remediationTemplateId);
    }
    if (remediationType) {
      res["RemediationType"] = boost::any(*remediationType);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RemediationTemplateId") != m.end() && !m["RemediationTemplateId"].empty()) {
      remediationTemplateId = make_shared<string>(boost::any_cast<string>(m["RemediationTemplateId"]));
    }
    if (m.find("RemediationType") != m.end() && !m["RemediationType"].empty()) {
      remediationType = make_shared<string>(boost::any_cast<string>(m["RemediationType"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~UpdateRemediationRequest() = default;
};
class UpdateRemediationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> remediationId{};
  shared_ptr<string> requestId{};

  UpdateRemediationResponseBody() {}

  explicit UpdateRemediationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remediationId) {
      res["RemediationId"] = boost::any(*remediationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemediationId") != m.end() && !m["RemediationId"].empty()) {
      remediationId = make_shared<string>(boost::any_cast<string>(m["RemediationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRemediationResponseBody() = default;
};
class UpdateRemediationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRemediationResponseBody> body{};

  UpdateRemediationResponse() {}

  explicit UpdateRemediationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRemediationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRemediationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRemediationResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActiveAggregateConfigRulesResponse activeAggregateConfigRulesWithOptions(shared_ptr<ActiveAggregateConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActiveAggregateConfigRulesResponse activeAggregateConfigRules(shared_ptr<ActiveAggregateConfigRulesRequest> request);
  ActiveConfigRulesResponse activeConfigRulesWithOptions(shared_ptr<ActiveConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActiveConfigRulesResponse activeConfigRules(shared_ptr<ActiveConfigRulesRequest> request);
  AttachAggregateConfigRuleToCompliancePackResponse attachAggregateConfigRuleToCompliancePackWithOptions(shared_ptr<AttachAggregateConfigRuleToCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachAggregateConfigRuleToCompliancePackResponse attachAggregateConfigRuleToCompliancePack(shared_ptr<AttachAggregateConfigRuleToCompliancePackRequest> request);
  AttachConfigRuleToCompliancePackResponse attachConfigRuleToCompliancePackWithOptions(shared_ptr<AttachConfigRuleToCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachConfigRuleToCompliancePackResponse attachConfigRuleToCompliancePack(shared_ptr<AttachConfigRuleToCompliancePackRequest> request);
  CopyCompliancePacksResponse copyCompliancePacksWithOptions(shared_ptr<CopyCompliancePacksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyCompliancePacksResponse copyCompliancePacks(shared_ptr<CopyCompliancePacksRequest> request);
  CopyConfigRulesResponse copyConfigRulesWithOptions(shared_ptr<CopyConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyConfigRulesResponse copyConfigRules(shared_ptr<CopyConfigRulesRequest> request);
  CreateAdvancedSearchFileResponse createAdvancedSearchFileWithOptions(shared_ptr<CreateAdvancedSearchFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAdvancedSearchFileResponse createAdvancedSearchFile(shared_ptr<CreateAdvancedSearchFileRequest> request);
  CreateAggregateAdvancedSearchFileResponse createAggregateAdvancedSearchFileWithOptions(shared_ptr<CreateAggregateAdvancedSearchFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregateAdvancedSearchFileResponse createAggregateAdvancedSearchFile(shared_ptr<CreateAggregateAdvancedSearchFileRequest> request);
  CreateAggregateCompliancePackResponse createAggregateCompliancePackWithOptions(shared_ptr<CreateAggregateCompliancePackRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregateCompliancePackResponse createAggregateCompliancePack(shared_ptr<CreateAggregateCompliancePackRequest> request);
  CreateAggregateConfigDeliveryChannelResponse createAggregateConfigDeliveryChannelWithOptions(shared_ptr<CreateAggregateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregateConfigDeliveryChannelResponse createAggregateConfigDeliveryChannel(shared_ptr<CreateAggregateConfigDeliveryChannelRequest> request);
  CreateAggregateConfigRuleResponse createAggregateConfigRuleWithOptions(shared_ptr<CreateAggregateConfigRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregateConfigRuleResponse createAggregateConfigRule(shared_ptr<CreateAggregateConfigRuleRequest> request);
  CreateAggregateRemediationResponse createAggregateRemediationWithOptions(shared_ptr<CreateAggregateRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregateRemediationResponse createAggregateRemediation(shared_ptr<CreateAggregateRemediationRequest> request);
  CreateAggregatorResponse createAggregatorWithOptions(shared_ptr<CreateAggregatorRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAggregatorResponse createAggregator(shared_ptr<CreateAggregatorRequest> request);
  CreateCompliancePackResponse createCompliancePackWithOptions(shared_ptr<CreateCompliancePackRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCompliancePackResponse createCompliancePack(shared_ptr<CreateCompliancePackRequest> request);
  CreateConfigDeliveryChannelResponse createConfigDeliveryChannelWithOptions(shared_ptr<CreateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigDeliveryChannelResponse createConfigDeliveryChannel(shared_ptr<CreateConfigDeliveryChannelRequest> request);
  CreateConfigRuleResponse createConfigRuleWithOptions(shared_ptr<CreateConfigRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConfigRuleResponse createConfigRule(shared_ptr<CreateConfigRuleRequest> request);
  CreateDeliveryChannelResponse createDeliveryChannelWithOptions(shared_ptr<CreateDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeliveryChannelResponse createDeliveryChannel(shared_ptr<CreateDeliveryChannelRequest> request);
  CreateRemediationResponse createRemediationWithOptions(shared_ptr<CreateRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRemediationResponse createRemediation(shared_ptr<CreateRemediationRequest> request);
  DeactiveAggregateConfigRulesResponse deactiveAggregateConfigRulesWithOptions(shared_ptr<DeactiveAggregateConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactiveAggregateConfigRulesResponse deactiveAggregateConfigRules(shared_ptr<DeactiveAggregateConfigRulesRequest> request);
  DeactiveConfigRulesResponse deactiveConfigRulesWithOptions(shared_ptr<DeactiveConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactiveConfigRulesResponse deactiveConfigRules(shared_ptr<DeactiveConfigRulesRequest> request);
  DeleteAggregateCompliancePacksResponse deleteAggregateCompliancePacksWithOptions(shared_ptr<DeleteAggregateCompliancePacksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAggregateCompliancePacksResponse deleteAggregateCompliancePacks(shared_ptr<DeleteAggregateCompliancePacksRequest> request);
  DeleteAggregateConfigDeliveryChannelResponse deleteAggregateConfigDeliveryChannelWithOptions(shared_ptr<DeleteAggregateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAggregateConfigDeliveryChannelResponse deleteAggregateConfigDeliveryChannel(shared_ptr<DeleteAggregateConfigDeliveryChannelRequest> request);
  DeleteAggregateConfigRulesResponse deleteAggregateConfigRulesWithOptions(shared_ptr<DeleteAggregateConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAggregateConfigRulesResponse deleteAggregateConfigRules(shared_ptr<DeleteAggregateConfigRulesRequest> request);
  DeleteAggregateRemediationsResponse deleteAggregateRemediationsWithOptions(shared_ptr<DeleteAggregateRemediationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAggregateRemediationsResponse deleteAggregateRemediations(shared_ptr<DeleteAggregateRemediationsRequest> request);
  DeleteAggregatorsResponse deleteAggregatorsWithOptions(shared_ptr<DeleteAggregatorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAggregatorsResponse deleteAggregators(shared_ptr<DeleteAggregatorsRequest> request);
  DeleteCompliancePacksResponse deleteCompliancePacksWithOptions(shared_ptr<DeleteCompliancePacksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCompliancePacksResponse deleteCompliancePacks(shared_ptr<DeleteCompliancePacksRequest> request);
  DeleteConfigDeliveryChannelResponse deleteConfigDeliveryChannelWithOptions(shared_ptr<DeleteConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigDeliveryChannelResponse deleteConfigDeliveryChannel(shared_ptr<DeleteConfigDeliveryChannelRequest> request);
  DeleteConfigRulesResponse deleteConfigRulesWithOptions(shared_ptr<DeleteConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConfigRulesResponse deleteConfigRules(shared_ptr<DeleteConfigRulesRequest> request);
  DeleteRemediationsResponse deleteRemediationsWithOptions(shared_ptr<DeleteRemediationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRemediationsResponse deleteRemediations(shared_ptr<DeleteRemediationsRequest> request);
  DescribeRemediationResponse describeRemediationWithOptions(shared_ptr<DescribeRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRemediationResponse describeRemediation(shared_ptr<DescribeRemediationRequest> request);
  DetachAggregateConfigRuleToCompliancePackResponse detachAggregateConfigRuleToCompliancePackWithOptions(shared_ptr<DetachAggregateConfigRuleToCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachAggregateConfigRuleToCompliancePackResponse detachAggregateConfigRuleToCompliancePack(shared_ptr<DetachAggregateConfigRuleToCompliancePackRequest> request);
  DetachConfigRuleToCompliancePackResponse detachConfigRuleToCompliancePackWithOptions(shared_ptr<DetachConfigRuleToCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachConfigRuleToCompliancePackResponse detachConfigRuleToCompliancePack(shared_ptr<DetachConfigRuleToCompliancePackRequest> request);
  EvaluatePreConfigRulesResponse evaluatePreConfigRulesWithOptions(shared_ptr<EvaluatePreConfigRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EvaluatePreConfigRulesResponse evaluatePreConfigRules(shared_ptr<EvaluatePreConfigRulesRequest> request);
  GenerateAggregateCompliancePackReportResponse generateAggregateCompliancePackReportWithOptions(shared_ptr<GenerateAggregateCompliancePackReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAggregateCompliancePackReportResponse generateAggregateCompliancePackReport(shared_ptr<GenerateAggregateCompliancePackReportRequest> request);
  GenerateAggregateConfigRulesReportResponse generateAggregateConfigRulesReportWithOptions(shared_ptr<GenerateAggregateConfigRulesReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAggregateConfigRulesReportResponse generateAggregateConfigRulesReport(shared_ptr<GenerateAggregateConfigRulesReportRequest> request);
  GenerateAggregateResourceInventoryResponse generateAggregateResourceInventoryWithOptions(shared_ptr<GenerateAggregateResourceInventoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAggregateResourceInventoryResponse generateAggregateResourceInventory(shared_ptr<GenerateAggregateResourceInventoryRequest> request);
  GenerateCompliancePackReportResponse generateCompliancePackReportWithOptions(shared_ptr<GenerateCompliancePackReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateCompliancePackReportResponse generateCompliancePackReport(shared_ptr<GenerateCompliancePackReportRequest> request);
  GenerateConfigRulesReportResponse generateConfigRulesReportWithOptions(shared_ptr<GenerateConfigRulesReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateConfigRulesReportResponse generateConfigRulesReport(shared_ptr<GenerateConfigRulesReportRequest> request);
  GenerateResourceInventoryResponse generateResourceInventoryWithOptions(shared_ptr<GenerateResourceInventoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateResourceInventoryResponse generateResourceInventory(shared_ptr<GenerateResourceInventoryRequest> request);
  GetAdvancedSearchFileResponse getAdvancedSearchFileWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAdvancedSearchFileResponse getAdvancedSearchFile();
  GetAggregateAccountComplianceByPackResponse getAggregateAccountComplianceByPackWithOptions(shared_ptr<GetAggregateAccountComplianceByPackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateAccountComplianceByPackResponse getAggregateAccountComplianceByPack(shared_ptr<GetAggregateAccountComplianceByPackRequest> request);
  GetAggregateAdvancedSearchFileResponse getAggregateAdvancedSearchFileWithOptions(shared_ptr<GetAggregateAdvancedSearchFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateAdvancedSearchFileResponse getAggregateAdvancedSearchFile(shared_ptr<GetAggregateAdvancedSearchFileRequest> request);
  GetAggregateCompliancePackResponse getAggregateCompliancePackWithOptions(shared_ptr<GetAggregateCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateCompliancePackResponse getAggregateCompliancePack(shared_ptr<GetAggregateCompliancePackRequest> request);
  GetAggregateCompliancePackReportResponse getAggregateCompliancePackReportWithOptions(shared_ptr<GetAggregateCompliancePackReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateCompliancePackReportResponse getAggregateCompliancePackReport(shared_ptr<GetAggregateCompliancePackReportRequest> request);
  GetAggregateComplianceSummaryResponse getAggregateComplianceSummaryWithOptions(shared_ptr<GetAggregateComplianceSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateComplianceSummaryResponse getAggregateComplianceSummary(shared_ptr<GetAggregateComplianceSummaryRequest> request);
  GetAggregateConfigDeliveryChannelResponse getAggregateConfigDeliveryChannelWithOptions(shared_ptr<GetAggregateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateConfigDeliveryChannelResponse getAggregateConfigDeliveryChannel(shared_ptr<GetAggregateConfigDeliveryChannelRequest> request);
  GetAggregateConfigRuleResponse getAggregateConfigRuleWithOptions(shared_ptr<GetAggregateConfigRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateConfigRuleResponse getAggregateConfigRule(shared_ptr<GetAggregateConfigRuleRequest> request);
  GetAggregateConfigRuleComplianceByPackResponse getAggregateConfigRuleComplianceByPackWithOptions(shared_ptr<GetAggregateConfigRuleComplianceByPackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateConfigRuleComplianceByPackResponse getAggregateConfigRuleComplianceByPack(shared_ptr<GetAggregateConfigRuleComplianceByPackRequest> request);
  GetAggregateConfigRuleSummaryByRiskLevelResponse getAggregateConfigRuleSummaryByRiskLevelWithOptions(shared_ptr<GetAggregateConfigRuleSummaryByRiskLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateConfigRuleSummaryByRiskLevelResponse getAggregateConfigRuleSummaryByRiskLevel(shared_ptr<GetAggregateConfigRuleSummaryByRiskLevelRequest> request);
  GetAggregateConfigRulesReportResponse getAggregateConfigRulesReportWithOptions(shared_ptr<GetAggregateConfigRulesReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateConfigRulesReportResponse getAggregateConfigRulesReport(shared_ptr<GetAggregateConfigRulesReportRequest> request);
  GetAggregateDiscoveredResourceResponse getAggregateDiscoveredResourceWithOptions(shared_ptr<GetAggregateDiscoveredResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateDiscoveredResourceResponse getAggregateDiscoveredResource(shared_ptr<GetAggregateDiscoveredResourceRequest> request);
  GetAggregateResourceComplianceByConfigRuleResponse getAggregateResourceComplianceByConfigRuleWithOptions(shared_ptr<GetAggregateResourceComplianceByConfigRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceComplianceByConfigRuleResponse getAggregateResourceComplianceByConfigRule(shared_ptr<GetAggregateResourceComplianceByConfigRuleRequest> request);
  GetAggregateResourceComplianceByPackResponse getAggregateResourceComplianceByPackWithOptions(shared_ptr<GetAggregateResourceComplianceByPackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceComplianceByPackResponse getAggregateResourceComplianceByPack(shared_ptr<GetAggregateResourceComplianceByPackRequest> request);
  GetAggregateResourceComplianceGroupByRegionResponse getAggregateResourceComplianceGroupByRegionWithOptions(shared_ptr<GetAggregateResourceComplianceGroupByRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceComplianceGroupByRegionResponse getAggregateResourceComplianceGroupByRegion(shared_ptr<GetAggregateResourceComplianceGroupByRegionRequest> request);
  GetAggregateResourceComplianceGroupByResourceTypeResponse getAggregateResourceComplianceGroupByResourceTypeWithOptions(shared_ptr<GetAggregateResourceComplianceGroupByResourceTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceComplianceGroupByResourceTypeResponse getAggregateResourceComplianceGroupByResourceType(shared_ptr<GetAggregateResourceComplianceGroupByResourceTypeRequest> request);
  GetAggregateResourceComplianceTimelineResponse getAggregateResourceComplianceTimelineWithOptions(shared_ptr<GetAggregateResourceComplianceTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceComplianceTimelineResponse getAggregateResourceComplianceTimeline(shared_ptr<GetAggregateResourceComplianceTimelineRequest> request);
  GetAggregateResourceConfigurationTimelineResponse getAggregateResourceConfigurationTimelineWithOptions(shared_ptr<GetAggregateResourceConfigurationTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceConfigurationTimelineResponse getAggregateResourceConfigurationTimeline(shared_ptr<GetAggregateResourceConfigurationTimelineRequest> request);
  GetAggregateResourceCountsGroupByRegionResponse getAggregateResourceCountsGroupByRegionWithOptions(shared_ptr<GetAggregateResourceCountsGroupByRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceCountsGroupByRegionResponse getAggregateResourceCountsGroupByRegion(shared_ptr<GetAggregateResourceCountsGroupByRegionRequest> request);
  GetAggregateResourceCountsGroupByResourceTypeResponse getAggregateResourceCountsGroupByResourceTypeWithOptions(shared_ptr<GetAggregateResourceCountsGroupByResourceTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceCountsGroupByResourceTypeResponse getAggregateResourceCountsGroupByResourceType(shared_ptr<GetAggregateResourceCountsGroupByResourceTypeRequest> request);
  GetAggregateResourceInventoryResponse getAggregateResourceInventoryWithOptions(shared_ptr<GetAggregateResourceInventoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregateResourceInventoryResponse getAggregateResourceInventory(shared_ptr<GetAggregateResourceInventoryRequest> request);
  GetAggregatorResponse getAggregatorWithOptions(shared_ptr<GetAggregatorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAggregatorResponse getAggregator(shared_ptr<GetAggregatorRequest> request);
  GetCompliancePackResponse getCompliancePackWithOptions(shared_ptr<GetCompliancePackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCompliancePackResponse getCompliancePack(shared_ptr<GetCompliancePackRequest> request);
  GetCompliancePackReportResponse getCompliancePackReportWithOptions(shared_ptr<GetCompliancePackReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCompliancePackReportResponse getCompliancePackReport(shared_ptr<GetCompliancePackReportRequest> request);
  GetComplianceSummaryResponse getComplianceSummaryWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetComplianceSummaryResponse getComplianceSummary();
  GetConfigDeliveryChannelResponse getConfigDeliveryChannelWithOptions(shared_ptr<GetConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigDeliveryChannelResponse getConfigDeliveryChannel(shared_ptr<GetConfigDeliveryChannelRequest> request);
  GetConfigRuleResponse getConfigRuleWithOptions(shared_ptr<GetConfigRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigRuleResponse getConfigRule(shared_ptr<GetConfigRuleRequest> request);
  GetConfigRuleComplianceByPackResponse getConfigRuleComplianceByPackWithOptions(shared_ptr<GetConfigRuleComplianceByPackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigRuleComplianceByPackResponse getConfigRuleComplianceByPack(shared_ptr<GetConfigRuleComplianceByPackRequest> request);
  GetConfigRuleSummaryByRiskLevelResponse getConfigRuleSummaryByRiskLevelWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigRuleSummaryByRiskLevelResponse getConfigRuleSummaryByRiskLevel();
  GetConfigRulesReportResponse getConfigRulesReportWithOptions(shared_ptr<GetConfigRulesReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigRulesReportResponse getConfigRulesReport(shared_ptr<GetConfigRulesReportRequest> request);
  GetConfigurationRecorderResponse getConfigurationRecorderWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigurationRecorderResponse getConfigurationRecorder();
  GetDiscoveredResourceResponse getDiscoveredResourceWithOptions(shared_ptr<GetDiscoveredResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDiscoveredResourceResponse getDiscoveredResource(shared_ptr<GetDiscoveredResourceRequest> request);
  GetDiscoveredResourceCountsGroupByRegionResponse getDiscoveredResourceCountsGroupByRegionWithOptions(shared_ptr<GetDiscoveredResourceCountsGroupByRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDiscoveredResourceCountsGroupByRegionResponse getDiscoveredResourceCountsGroupByRegion(shared_ptr<GetDiscoveredResourceCountsGroupByRegionRequest> request);
  GetDiscoveredResourceCountsGroupByResourceTypeResponse getDiscoveredResourceCountsGroupByResourceTypeWithOptions(shared_ptr<GetDiscoveredResourceCountsGroupByResourceTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDiscoveredResourceCountsGroupByResourceTypeResponse getDiscoveredResourceCountsGroupByResourceType(shared_ptr<GetDiscoveredResourceCountsGroupByResourceTypeRequest> request);
  GetIntegratedServiceStatusResponse getIntegratedServiceStatusWithOptions(shared_ptr<GetIntegratedServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIntegratedServiceStatusResponse getIntegratedServiceStatus(shared_ptr<GetIntegratedServiceStatusRequest> request);
  GetManagedRuleResponse getManagedRuleWithOptions(shared_ptr<GetManagedRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetManagedRuleResponse getManagedRule(shared_ptr<GetManagedRuleRequest> request);
  GetRemediationTemplateResponse getRemediationTemplateWithOptions(shared_ptr<GetRemediationTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRemediationTemplateResponse getRemediationTemplate(shared_ptr<GetRemediationTemplateRequest> request);
  GetResourceComplianceByConfigRuleResponse getResourceComplianceByConfigRuleWithOptions(shared_ptr<GetResourceComplianceByConfigRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceComplianceByConfigRuleResponse getResourceComplianceByConfigRule(shared_ptr<GetResourceComplianceByConfigRuleRequest> request);
  GetResourceComplianceByPackResponse getResourceComplianceByPackWithOptions(shared_ptr<GetResourceComplianceByPackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceComplianceByPackResponse getResourceComplianceByPack(shared_ptr<GetResourceComplianceByPackRequest> request);
  GetResourceComplianceGroupByRegionResponse getResourceComplianceGroupByRegionWithOptions(shared_ptr<GetResourceComplianceGroupByRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceComplianceGroupByRegionResponse getResourceComplianceGroupByRegion(shared_ptr<GetResourceComplianceGroupByRegionRequest> request);
  GetResourceComplianceGroupByResourceTypeResponse getResourceComplianceGroupByResourceTypeWithOptions(shared_ptr<GetResourceComplianceGroupByResourceTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceComplianceGroupByResourceTypeResponse getResourceComplianceGroupByResourceType(shared_ptr<GetResourceComplianceGroupByResourceTypeRequest> request);
  GetResourceComplianceTimelineResponse getResourceComplianceTimelineWithOptions(shared_ptr<GetResourceComplianceTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceComplianceTimelineResponse getResourceComplianceTimeline(shared_ptr<GetResourceComplianceTimelineRequest> request);
  GetResourceConfigurationTimelineResponse getResourceConfigurationTimelineWithOptions(shared_ptr<GetResourceConfigurationTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceConfigurationTimelineResponse getResourceConfigurationTimeline(shared_ptr<GetResourceConfigurationTimelineRequest> request);
  GetResourceInventoryResponse getResourceInventoryWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceInventoryResponse getResourceInventory();
  GetSupportedResourceRelationConfigResponse getSupportedResourceRelationConfigWithOptions(shared_ptr<GetSupportedResourceRelationConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSupportedResourceRelationConfigResponse getSupportedResourceRelationConfig(shared_ptr<GetSupportedResourceRelationConfigRequest> request);
  IgnoreAggregateEvaluationResultsResponse ignoreAggregateEvaluationResultsWithOptions(shared_ptr<IgnoreAggregateEvaluationResultsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IgnoreAggregateEvaluationResultsResponse ignoreAggregateEvaluationResults(shared_ptr<IgnoreAggregateEvaluationResultsRequest> request);
  IgnoreEvaluationResultsResponse ignoreEvaluationResultsWithOptions(shared_ptr<IgnoreEvaluationResultsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IgnoreEvaluationResultsResponse ignoreEvaluationResults(shared_ptr<IgnoreEvaluationResultsRequest> request);
  ListAggregateCompliancePacksResponse listAggregateCompliancePacksWithOptions(shared_ptr<ListAggregateCompliancePacksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateCompliancePacksResponse listAggregateCompliancePacks(shared_ptr<ListAggregateCompliancePacksRequest> request);
  ListAggregateConfigDeliveryChannelsResponse listAggregateConfigDeliveryChannelsWithOptions(shared_ptr<ListAggregateConfigDeliveryChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateConfigDeliveryChannelsResponse listAggregateConfigDeliveryChannels(shared_ptr<ListAggregateConfigDeliveryChannelsRequest> request);
  ListAggregateConfigRuleEvaluationResultsResponse listAggregateConfigRuleEvaluationResultsWithOptions(shared_ptr<ListAggregateConfigRuleEvaluationResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateConfigRuleEvaluationResultsResponse listAggregateConfigRuleEvaluationResults(shared_ptr<ListAggregateConfigRuleEvaluationResultsRequest> request);
  ListAggregateConfigRuleEvaluationStatisticsResponse listAggregateConfigRuleEvaluationStatisticsWithOptions(shared_ptr<ListAggregateConfigRuleEvaluationStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateConfigRuleEvaluationStatisticsResponse listAggregateConfigRuleEvaluationStatistics(shared_ptr<ListAggregateConfigRuleEvaluationStatisticsRequest> request);
  ListAggregateConfigRulesResponse listAggregateConfigRulesWithOptions(shared_ptr<ListAggregateConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateConfigRulesResponse listAggregateConfigRules(shared_ptr<ListAggregateConfigRulesRequest> request);
  ListAggregateDiscoveredResourcesResponse listAggregateDiscoveredResourcesWithOptions(shared_ptr<ListAggregateDiscoveredResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateDiscoveredResourcesResponse listAggregateDiscoveredResources(shared_ptr<ListAggregateDiscoveredResourcesRequest> request);
  ListAggregateRemediationExecutionsResponse listAggregateRemediationExecutionsWithOptions(shared_ptr<ListAggregateRemediationExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateRemediationExecutionsResponse listAggregateRemediationExecutions(shared_ptr<ListAggregateRemediationExecutionsRequest> request);
  ListAggregateRemediationsResponse listAggregateRemediationsWithOptions(shared_ptr<ListAggregateRemediationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateRemediationsResponse listAggregateRemediations(shared_ptr<ListAggregateRemediationsRequest> request);
  ListAggregateResourceEvaluationResultsResponse listAggregateResourceEvaluationResultsWithOptions(shared_ptr<ListAggregateResourceEvaluationResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateResourceEvaluationResultsResponse listAggregateResourceEvaluationResults(shared_ptr<ListAggregateResourceEvaluationResultsRequest> request);
  ListAggregateResourceRelationsResponse listAggregateResourceRelationsWithOptions(shared_ptr<ListAggregateResourceRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateResourceRelationsResponse listAggregateResourceRelations(shared_ptr<ListAggregateResourceRelationsRequest> request);
  ListAggregateResourcesByAdvancedSearchResponse listAggregateResourcesByAdvancedSearchWithOptions(shared_ptr<ListAggregateResourcesByAdvancedSearchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregateResourcesByAdvancedSearchResponse listAggregateResourcesByAdvancedSearch(shared_ptr<ListAggregateResourcesByAdvancedSearchRequest> request);
  ListAggregatorsResponse listAggregatorsWithOptions(shared_ptr<ListAggregatorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAggregatorsResponse listAggregators(shared_ptr<ListAggregatorsRequest> request);
  ListCompliancePackTemplatesResponse listCompliancePackTemplatesWithOptions(shared_ptr<ListCompliancePackTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCompliancePackTemplatesResponse listCompliancePackTemplates(shared_ptr<ListCompliancePackTemplatesRequest> request);
  ListCompliancePacksResponse listCompliancePacksWithOptions(shared_ptr<ListCompliancePacksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCompliancePacksResponse listCompliancePacks(shared_ptr<ListCompliancePacksRequest> request);
  ListConfigDeliveryChannelsResponse listConfigDeliveryChannelsWithOptions(shared_ptr<ListConfigDeliveryChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigDeliveryChannelsResponse listConfigDeliveryChannels(shared_ptr<ListConfigDeliveryChannelsRequest> request);
  ListConfigRuleEvaluationResultsResponse listConfigRuleEvaluationResultsWithOptions(shared_ptr<ListConfigRuleEvaluationResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigRuleEvaluationResultsResponse listConfigRuleEvaluationResults(shared_ptr<ListConfigRuleEvaluationResultsRequest> request);
  ListConfigRuleEvaluationStatisticsResponse listConfigRuleEvaluationStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigRuleEvaluationStatisticsResponse listConfigRuleEvaluationStatistics();
  ListConfigRulesResponse listConfigRulesWithOptions(shared_ptr<ListConfigRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigRulesResponse listConfigRules(shared_ptr<ListConfigRulesRequest> request);
  ListDiscoveredResourcesResponse listDiscoveredResourcesWithOptions(shared_ptr<ListDiscoveredResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDiscoveredResourcesResponse listDiscoveredResources(shared_ptr<ListDiscoveredResourcesRequest> request);
  ListIntegratedServiceResponse listIntegratedServiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntegratedServiceResponse listIntegratedService();
  ListManagedRulesResponse listManagedRulesWithOptions(shared_ptr<ListManagedRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListManagedRulesResponse listManagedRules(shared_ptr<ListManagedRulesRequest> request);
  ListPreManagedRulesResponse listPreManagedRulesWithOptions(shared_ptr<ListPreManagedRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPreManagedRulesResponse listPreManagedRules(shared_ptr<ListPreManagedRulesRequest> request);
  ListRemediationExecutionsResponse listRemediationExecutionsWithOptions(shared_ptr<ListRemediationExecutionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRemediationExecutionsResponse listRemediationExecutions(shared_ptr<ListRemediationExecutionsRequest> request);
  ListRemediationTemplatesResponse listRemediationTemplatesWithOptions(shared_ptr<ListRemediationTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRemediationTemplatesResponse listRemediationTemplates(shared_ptr<ListRemediationTemplatesRequest> request);
  ListRemediationsResponse listRemediationsWithOptions(shared_ptr<ListRemediationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRemediationsResponse listRemediations(shared_ptr<ListRemediationsRequest> request);
  ListResourceEvaluationResultsResponse listResourceEvaluationResultsWithOptions(shared_ptr<ListResourceEvaluationResultsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceEvaluationResultsResponse listResourceEvaluationResults(shared_ptr<ListResourceEvaluationResultsRequest> request);
  ListResourceRelationsResponse listResourceRelationsWithOptions(shared_ptr<ListResourceRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceRelationsResponse listResourceRelations(shared_ptr<ListResourceRelationsRequest> request);
  ListResourcesByAdvancedSearchResponse listResourcesByAdvancedSearchWithOptions(shared_ptr<ListResourcesByAdvancedSearchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcesByAdvancedSearchResponse listResourcesByAdvancedSearch(shared_ptr<ListResourcesByAdvancedSearchRequest> request);
  ListSupportedProductsResponse listSupportedProductsWithOptions(shared_ptr<ListSupportedProductsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSupportedProductsResponse listSupportedProducts(shared_ptr<ListSupportedProductsRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  PutEvaluationsResponse putEvaluationsWithOptions(shared_ptr<PutEvaluationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutEvaluationsResponse putEvaluations(shared_ptr<PutEvaluationsRequest> request);
  RevertAggregateEvaluationResultsResponse revertAggregateEvaluationResultsWithOptions(shared_ptr<RevertAggregateEvaluationResultsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevertAggregateEvaluationResultsResponse revertAggregateEvaluationResults(shared_ptr<RevertAggregateEvaluationResultsRequest> request);
  RevertEvaluationResultsResponse revertEvaluationResultsWithOptions(shared_ptr<RevertEvaluationResultsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevertEvaluationResultsResponse revertEvaluationResults(shared_ptr<RevertEvaluationResultsRequest> request);
  StartAggregateConfigRuleEvaluationResponse startAggregateConfigRuleEvaluationWithOptions(shared_ptr<StartAggregateConfigRuleEvaluationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAggregateConfigRuleEvaluationResponse startAggregateConfigRuleEvaluation(shared_ptr<StartAggregateConfigRuleEvaluationRequest> request);
  StartAggregateRemediationResponse startAggregateRemediationWithOptions(shared_ptr<StartAggregateRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAggregateRemediationResponse startAggregateRemediation(shared_ptr<StartAggregateRemediationRequest> request);
  StartConfigRuleEvaluationResponse startConfigRuleEvaluationWithOptions(shared_ptr<StartConfigRuleEvaluationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartConfigRuleEvaluationResponse startConfigRuleEvaluation(shared_ptr<StartConfigRuleEvaluationRequest> request);
  StartConfigurationRecorderResponse startConfigurationRecorderWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartConfigurationRecorderResponse startConfigurationRecorder();
  StartRemediationResponse startRemediationWithOptions(shared_ptr<StartRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRemediationResponse startRemediation(shared_ptr<StartRemediationRequest> request);
  StopConfigurationRecorderResponse stopConfigurationRecorderWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopConfigurationRecorderResponse stopConfigurationRecorder();
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAggregateCompliancePackResponse updateAggregateCompliancePackWithOptions(shared_ptr<UpdateAggregateCompliancePackRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAggregateCompliancePackResponse updateAggregateCompliancePack(shared_ptr<UpdateAggregateCompliancePackRequest> request);
  UpdateAggregateConfigDeliveryChannelResponse updateAggregateConfigDeliveryChannelWithOptions(shared_ptr<UpdateAggregateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAggregateConfigDeliveryChannelResponse updateAggregateConfigDeliveryChannel(shared_ptr<UpdateAggregateConfigDeliveryChannelRequest> request);
  UpdateAggregateConfigRuleResponse updateAggregateConfigRuleWithOptions(shared_ptr<UpdateAggregateConfigRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAggregateConfigRuleResponse updateAggregateConfigRule(shared_ptr<UpdateAggregateConfigRuleRequest> request);
  UpdateAggregateRemediationResponse updateAggregateRemediationWithOptions(shared_ptr<UpdateAggregateRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAggregateRemediationResponse updateAggregateRemediation(shared_ptr<UpdateAggregateRemediationRequest> request);
  UpdateAggregatorResponse updateAggregatorWithOptions(shared_ptr<UpdateAggregatorRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAggregatorResponse updateAggregator(shared_ptr<UpdateAggregatorRequest> request);
  UpdateCompliancePackResponse updateCompliancePackWithOptions(shared_ptr<UpdateCompliancePackRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCompliancePackResponse updateCompliancePack(shared_ptr<UpdateCompliancePackRequest> request);
  UpdateConfigDeliveryChannelResponse updateConfigDeliveryChannelWithOptions(shared_ptr<UpdateConfigDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigDeliveryChannelResponse updateConfigDeliveryChannel(shared_ptr<UpdateConfigDeliveryChannelRequest> request);
  UpdateConfigRuleResponse updateConfigRuleWithOptions(shared_ptr<UpdateConfigRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigRuleResponse updateConfigRule(shared_ptr<UpdateConfigRuleRequest> request);
  UpdateConfigurationRecorderResponse updateConfigurationRecorderWithOptions(shared_ptr<UpdateConfigurationRecorderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigurationRecorderResponse updateConfigurationRecorder(shared_ptr<UpdateConfigurationRecorderRequest> request);
  UpdateDeliveryChannelResponse updateDeliveryChannelWithOptions(shared_ptr<UpdateDeliveryChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeliveryChannelResponse updateDeliveryChannel(shared_ptr<UpdateDeliveryChannelRequest> request);
  UpdateIntegratedServiceStatusResponse updateIntegratedServiceStatusWithOptions(shared_ptr<UpdateIntegratedServiceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIntegratedServiceStatusResponse updateIntegratedServiceStatus(shared_ptr<UpdateIntegratedServiceStatusRequest> request);
  UpdateRemediationResponse updateRemediationWithOptions(shared_ptr<UpdateRemediationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRemediationResponse updateRemediation(shared_ptr<UpdateRemediationRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Config20200907

#endif
