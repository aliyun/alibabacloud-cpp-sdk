// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_LINKEDMALL20180116_H_
#define ALIBABACLOUD_LINKEDMALL20180116_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Linkedmall20180116 {
class AddAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressInfo{};
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  AddAddressRequest() {}

  explicit AddAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfo) {
      res["AddressInfo"] = boost::any(*addressInfo);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfo") != m.end() && !m["AddressInfo"].empty()) {
      addressInfo = make_shared<string>(boost::any_cast<string>(m["AddressInfo"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~AddAddressRequest() = default;
};
class AddAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addressId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddAddressResponseBody() {}

  explicit AddAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<long>(boost::any_cast<long>(m["AddressId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAddressResponseBody() = default;
};
class AddAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAddressResponseBody> body{};

  AddAddressResponse() {}

  explicit AddAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAddressResponseBody>(model1);
      }
    }
  }


  virtual ~AddAddressResponse() = default;
};
class AddItemLimitRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> itemId{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> upperNum{};

  AddItemLimitRuleRequest() {}

  explicit AddItemLimitRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (upperNum) {
      res["UpperNum"] = boost::any(*upperNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("UpperNum") != m.end() && !m["UpperNum"].empty()) {
      upperNum = make_shared<long>(boost::any_cast<long>(m["UpperNum"]));
    }
  }


  virtual ~AddItemLimitRuleRequest() = default;
};
class AddItemLimitRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> model{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ruleId{};

  AddItemLimitRuleResponseBody() {}

  explicit AddItemLimitRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<long>(boost::any_cast<long>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~AddItemLimitRuleResponseBody() = default;
};
class AddItemLimitRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddItemLimitRuleResponseBody> body{};

  AddItemLimitRuleResponse() {}

  explicit AddItemLimitRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddItemLimitRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddItemLimitRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddItemLimitRuleResponse() = default;
};
class AddItemToSubBizsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<map<string, boost::any>> subBizIds{};

  AddItemToSubBizsRequest() {}

  explicit AddItemToSubBizsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (subBizIds) {
      res["SubBizIds"] = boost::any(*subBizIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SubBizIds") != m.end() && !m["SubBizIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubBizIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subBizIds = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~AddItemToSubBizsRequest() = default;
};
class AddItemToSubBizsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> subBizIdsShrink{};

  AddItemToSubBizsShrinkRequest() {}

  explicit AddItemToSubBizsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (subBizIdsShrink) {
      res["SubBizIds"] = boost::any(*subBizIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SubBizIds") != m.end() && !m["SubBizIds"].empty()) {
      subBizIdsShrink = make_shared<string>(boost::any_cast<string>(m["SubBizIds"]));
    }
  }


  virtual ~AddItemToSubBizsShrinkRequest() = default;
};
class AddItemToSubBizsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddItemToSubBizsResponseBody() {}

  explicit AddItemToSubBizsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddItemToSubBizsResponseBody() = default;
};
class AddItemToSubBizsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddItemToSubBizsResponseBody> body{};

  AddItemToSubBizsResponse() {}

  explicit AddItemToSubBizsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddItemToSubBizsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddItemToSubBizsResponseBody>(model1);
      }
    }
  }


  virtual ~AddItemToSubBizsResponse() = default;
};
class AddSupplierNewItemsRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<vector<int>> skuList{};

  AddSupplierNewItemsRequestItemList() {}

  explicit AddSupplierNewItemsRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuList) {
      res["SkuList"] = boost::any(*skuList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkuList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skuList = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~AddSupplierNewItemsRequestItemList() = default;
};
class AddSupplierNewItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<AddSupplierNewItemsRequestItemList>> itemList{};

  AddSupplierNewItemsRequest() {}

  explicit AddSupplierNewItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<AddSupplierNewItemsRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddSupplierNewItemsRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<AddSupplierNewItemsRequestItemList>>(expect1);
      }
    }
  }


  virtual ~AddSupplierNewItemsRequest() = default;
};
class AddSupplierNewItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddSupplierNewItemsResponseBody() {}

  explicit AddSupplierNewItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSupplierNewItemsResponseBody() = default;
};
class AddSupplierNewItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSupplierNewItemsResponseBody> body{};

  AddSupplierNewItemsResponse() {}

  explicit AddSupplierNewItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSupplierNewItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSupplierNewItemsResponseBody>(model1);
      }
    }
  }


  virtual ~AddSupplierNewItemsResponse() = default;
};
class ApplyRefundRequestLeavePictureList : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> picture{};

  ApplyRefundRequestLeavePictureList() {}

  explicit ApplyRefundRequestLeavePictureList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (picture) {
      res["Picture"] = boost::any(*picture);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Picture") != m.end() && !m["Picture"].empty()) {
      picture = make_shared<string>(boost::any_cast<string>(m["Picture"]));
    }
  }


  virtual ~ApplyRefundRequestLeavePictureList() = default;
};
class ApplyRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> applyReasonTextId{};
  shared_ptr<long> applyRefundCount{};
  shared_ptr<long> applyRefundFee{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> leaveMessage{};
  shared_ptr<vector<ApplyRefundRequestLeavePictureList>> leavePictureList{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  ApplyRefundRequest() {}

  explicit ApplyRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (applyReasonTextId) {
      res["ApplyReasonTextId"] = boost::any(*applyReasonTextId);
    }
    if (applyRefundCount) {
      res["ApplyRefundCount"] = boost::any(*applyRefundCount);
    }
    if (applyRefundFee) {
      res["ApplyRefundFee"] = boost::any(*applyRefundFee);
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (leaveMessage) {
      res["LeaveMessage"] = boost::any(*leaveMessage);
    }
    if (leavePictureList) {
      vector<boost::any> temp1;
      for(auto item1:*leavePictureList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LeavePictureList"] = boost::any(temp1);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ApplyReasonTextId") != m.end() && !m["ApplyReasonTextId"].empty()) {
      applyReasonTextId = make_shared<long>(boost::any_cast<long>(m["ApplyReasonTextId"]));
    }
    if (m.find("ApplyRefundCount") != m.end() && !m["ApplyRefundCount"].empty()) {
      applyRefundCount = make_shared<long>(boost::any_cast<long>(m["ApplyRefundCount"]));
    }
    if (m.find("ApplyRefundFee") != m.end() && !m["ApplyRefundFee"].empty()) {
      applyRefundFee = make_shared<long>(boost::any_cast<long>(m["ApplyRefundFee"]));
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("LeaveMessage") != m.end() && !m["LeaveMessage"].empty()) {
      leaveMessage = make_shared<string>(boost::any_cast<string>(m["LeaveMessage"]));
    }
    if (m.find("LeavePictureList") != m.end() && !m["LeavePictureList"].empty()) {
      if (typeid(vector<boost::any>) == m["LeavePictureList"].type()) {
        vector<ApplyRefundRequestLeavePictureList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LeavePictureList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyRefundRequestLeavePictureList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leavePictureList = make_shared<vector<ApplyRefundRequestLeavePictureList>>(expect1);
      }
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~ApplyRefundRequest() = default;
};
class ApplyRefundResponseBodyRefundApplicationData : public Darabonba::Model {
public:
  shared_ptr<long> disputeId{};
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> subLmOrderId{};

  ApplyRefundResponseBodyRefundApplicationData() {}

  explicit ApplyRefundResponseBodyRefundApplicationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~ApplyRefundResponseBodyRefundApplicationData() = default;
};
class ApplyRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ApplyRefundResponseBodyRefundApplicationData> refundApplicationData{};
  shared_ptr<string> requestId{};

  ApplyRefundResponseBody() {}

  explicit ApplyRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (refundApplicationData) {
      res["RefundApplicationData"] = refundApplicationData ? boost::any(refundApplicationData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RefundApplicationData") != m.end() && !m["RefundApplicationData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundApplicationData"].type()) {
        ApplyRefundResponseBodyRefundApplicationData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundApplicationData"]));
        refundApplicationData = make_shared<ApplyRefundResponseBodyRefundApplicationData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApplyRefundResponseBody() = default;
};
class ApplyRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyRefundResponseBody> body{};

  ApplyRefundResponse() {}

  explicit ApplyRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyRefundResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyRefundResponse() = default;
};
class ApplyRefundWithDesignatedTbUidRequestProofs : public Darabonba::Model {
public:
  shared_ptr<string> messagePic{};
  shared_ptr<string> messagePicDesc{};

  ApplyRefundWithDesignatedTbUidRequestProofs() {}

  explicit ApplyRefundWithDesignatedTbUidRequestProofs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messagePic) {
      res["MessagePic"] = boost::any(*messagePic);
    }
    if (messagePicDesc) {
      res["MessagePicDesc"] = boost::any(*messagePicDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessagePic") != m.end() && !m["MessagePic"].empty()) {
      messagePic = make_shared<string>(boost::any_cast<string>(m["MessagePic"]));
    }
    if (m.find("MessagePicDesc") != m.end() && !m["MessagePicDesc"].empty()) {
      messagePicDesc = make_shared<string>(boost::any_cast<string>(m["MessagePicDesc"]));
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidRequestProofs() = default;
};
class ApplyRefundWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> message{};
  shared_ptr<vector<ApplyRefundWithDesignatedTbUidRequestProofs>> proofs{};
  shared_ptr<long> reasonId{};
  shared_ptr<long> refundCode{};
  shared_ptr<long> refundCount{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  ApplyRefundWithDesignatedTbUidRequest() {}

  explicit ApplyRefundWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (proofs) {
      vector<boost::any> temp1;
      for(auto item1:*proofs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Proofs"] = boost::any(temp1);
    }
    if (reasonId) {
      res["ReasonId"] = boost::any(*reasonId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (refundCount) {
      res["RefundCount"] = boost::any(*refundCount);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Proofs") != m.end() && !m["Proofs"].empty()) {
      if (typeid(vector<boost::any>) == m["Proofs"].type()) {
        vector<ApplyRefundWithDesignatedTbUidRequestProofs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Proofs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyRefundWithDesignatedTbUidRequestProofs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proofs = make_shared<vector<ApplyRefundWithDesignatedTbUidRequestProofs>>(expect1);
      }
    }
    if (m.find("ReasonId") != m.end() && !m["ReasonId"].empty()) {
      reasonId = make_shared<long>(boost::any_cast<long>(m["ReasonId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("RefundCount") != m.end() && !m["RefundCount"].empty()) {
      refundCount = make_shared<long>(boost::any_cast<long>(m["RefundCount"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidRequest() = default;
};
class ApplyRefundWithDesignatedTbUidShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> message{};
  shared_ptr<string> proofsShrink{};
  shared_ptr<long> reasonId{};
  shared_ptr<long> refundCode{};
  shared_ptr<long> refundCount{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  ApplyRefundWithDesignatedTbUidShrinkRequest() {}

  explicit ApplyRefundWithDesignatedTbUidShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (proofsShrink) {
      res["Proofs"] = boost::any(*proofsShrink);
    }
    if (reasonId) {
      res["ReasonId"] = boost::any(*reasonId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (refundCount) {
      res["RefundCount"] = boost::any(*refundCount);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Proofs") != m.end() && !m["Proofs"].empty()) {
      proofsShrink = make_shared<string>(boost::any_cast<string>(m["Proofs"]));
    }
    if (m.find("ReasonId") != m.end() && !m["ReasonId"].empty()) {
      reasonId = make_shared<long>(boost::any_cast<long>(m["ReasonId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("RefundCount") != m.end() && !m["RefundCount"].empty()) {
      refundCount = make_shared<long>(boost::any_cast<long>(m["RefundCount"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidShrinkRequest() = default;
};
class ApplyRefundWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> disputeId{};
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> subLmOrderId{};

  ApplyRefundWithDesignatedTbUidResponseBodyModel() {}

  explicit ApplyRefundWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidResponseBodyModel() = default;
};
class ApplyRefundWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ApplyRefundWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ApplyRefundWithDesignatedTbUidResponseBody() {}

  explicit ApplyRefundWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ApplyRefundWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ApplyRefundWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidResponseBody() = default;
};
class ApplyRefundWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyRefundWithDesignatedTbUidResponseBody> body{};

  ApplyRefundWithDesignatedTbUidResponse() {}

  explicit ApplyRefundWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyRefundWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyRefundWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyRefundWithDesignatedTbUidResponse() = default;
};
class BatchRegistAnonymousTbAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> idJsonList{};

  BatchRegistAnonymousTbAccountRequest() {}

  explicit BatchRegistAnonymousTbAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (idJsonList) {
      res["IdJsonList"] = boost::any(*idJsonList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("IdJsonList") != m.end() && !m["IdJsonList"].empty()) {
      idJsonList = make_shared<string>(boost::any_cast<string>(m["IdJsonList"]));
    }
  }


  virtual ~BatchRegistAnonymousTbAccountRequest() = default;
};
class BatchRegistAnonymousTbAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> batchId{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  BatchRegistAnonymousTbAccountResponseBody() {}

  explicit BatchRegistAnonymousTbAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<string>(boost::any_cast<string>(m["BatchId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchRegistAnonymousTbAccountResponseBody() = default;
};
class BatchRegistAnonymousTbAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchRegistAnonymousTbAccountResponseBody> body{};

  BatchRegistAnonymousTbAccountResponse() {}

  explicit BatchRegistAnonymousTbAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchRegistAnonymousTbAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchRegistAnonymousTbAccountResponseBody>(model1);
      }
    }
  }


  virtual ~BatchRegistAnonymousTbAccountResponse() = default;
};
class CancelOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CancelOrderRequest() {}

  explicit CancelOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CancelOrderRequest() = default;
};
class CancelOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  CancelOrderResponseBody() {}

  explicit CancelOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelOrderResponseBody() = default;
};
class CancelOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOrderResponseBody> body{};

  CancelOrderResponse() {}

  explicit CancelOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOrderResponse() = default;
};
class CancelOrderWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  CancelOrderWithDesignatedTbUidRequest() {}

  explicit CancelOrderWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~CancelOrderWithDesignatedTbUidRequest() = default;
};
class CancelOrderWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<map<string, boost::any>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CancelOrderWithDesignatedTbUidResponseBody() {}

  explicit CancelOrderWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Model"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      model = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CancelOrderWithDesignatedTbUidResponseBody() = default;
};
class CancelOrderWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOrderWithDesignatedTbUidResponseBody> body{};

  CancelOrderWithDesignatedTbUidResponse() {}

  explicit CancelOrderWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOrderWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOrderWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOrderWithDesignatedTbUidResponse() = default;
};
class CancelRealTbAccountSupportRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  CancelRealTbAccountSupportRequest() {}

  explicit CancelRealTbAccountSupportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~CancelRealTbAccountSupportRequest() = default;
};
class CancelRealTbAccountSupportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<boost::any> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CancelRealTbAccountSupportResponseBody() {}

  explicit CancelRealTbAccountSupportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<boost::any>(boost::any_cast<boost::any>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CancelRealTbAccountSupportResponseBody() = default;
};
class CancelRealTbAccountSupportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelRealTbAccountSupportResponseBody> body{};

  CancelRealTbAccountSupportResponse() {}

  explicit CancelRealTbAccountSupportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelRealTbAccountSupportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelRealTbAccountSupportResponseBody>(model1);
      }
    }
  }


  virtual ~CancelRealTbAccountSupportResponse() = default;
};
class CancelRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> disputeId{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CancelRefundRequest() {}

  explicit CancelRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CancelRefundRequest() = default;
};
class CancelRefundResponseBodyRefundApplicationData : public Darabonba::Model {
public:
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> subLmOrderId{};

  CancelRefundResponseBodyRefundApplicationData() {}

  explicit CancelRefundResponseBodyRefundApplicationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~CancelRefundResponseBodyRefundApplicationData() = default;
};
class CancelRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CancelRefundResponseBodyRefundApplicationData> refundApplicationData{};
  shared_ptr<string> requestId{};

  CancelRefundResponseBody() {}

  explicit CancelRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (refundApplicationData) {
      res["RefundApplicationData"] = refundApplicationData ? boost::any(refundApplicationData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RefundApplicationData") != m.end() && !m["RefundApplicationData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundApplicationData"].type()) {
        CancelRefundResponseBodyRefundApplicationData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundApplicationData"]));
        refundApplicationData = make_shared<CancelRefundResponseBodyRefundApplicationData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelRefundResponseBody() = default;
};
class CancelRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelRefundResponseBody> body{};

  CancelRefundResponse() {}

  explicit CancelRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelRefundResponseBody>(model1);
      }
    }
  }


  virtual ~CancelRefundResponse() = default;
};
class CancelRefundWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  CancelRefundWithDesignatedTbUidRequest() {}

  explicit CancelRefundWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~CancelRefundWithDesignatedTbUidRequest() = default;
};
class CancelRefundWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<boost::any> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CancelRefundWithDesignatedTbUidResponseBody() {}

  explicit CancelRefundWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<boost::any>(boost::any_cast<boost::any>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CancelRefundWithDesignatedTbUidResponseBody() = default;
};
class CancelRefundWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelRefundWithDesignatedTbUidResponseBody> body{};

  CancelRefundWithDesignatedTbUidResponse() {}

  explicit CancelRefundWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelRefundWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelRefundWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~CancelRefundWithDesignatedTbUidResponse() = default;
};
class ConfirmDisburseRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  ConfirmDisburseRequest() {}

  explicit ConfirmDisburseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~ConfirmDisburseRequest() = default;
};
class ConfirmDisburseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ConfirmDisburseResponseBody() {}

  explicit ConfirmDisburseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfirmDisburseResponseBody() = default;
};
class ConfirmDisburseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmDisburseResponseBody> body{};

  ConfirmDisburseResponse() {}

  explicit ConfirmDisburseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmDisburseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmDisburseResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmDisburseResponse() = default;
};
class ConfirmDisburseWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  ConfirmDisburseWithDesignatedTbUidRequest() {}

  explicit ConfirmDisburseWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ConfirmDisburseWithDesignatedTbUidRequest() = default;
};
class ConfirmDisburseWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<boost::any> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ConfirmDisburseWithDesignatedTbUidResponseBody() {}

  explicit ConfirmDisburseWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<boost::any>(boost::any_cast<boost::any>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ConfirmDisburseWithDesignatedTbUidResponseBody() = default;
};
class ConfirmDisburseWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmDisburseWithDesignatedTbUidResponseBody> body{};

  ConfirmDisburseWithDesignatedTbUidResponse() {}

  explicit ConfirmDisburseWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmDisburseWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmDisburseWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmDisburseWithDesignatedTbUidResponse() = default;
};
class CreateMovieTicketOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> lockSeatAppKey{};
  shared_ptr<string> outTradeId{};

  CreateMovieTicketOrderRequest() {}

  explicit CreateMovieTicketOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lockSeatAppKey) {
      res["LockSeatAppKey"] = boost::any(*lockSeatAppKey);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LockSeatAppKey") != m.end() && !m["LockSeatAppKey"].empty()) {
      lockSeatAppKey = make_shared<string>(boost::any_cast<string>(m["LockSeatAppKey"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
  }


  virtual ~CreateMovieTicketOrderRequest() = default;
};
class CreateMovieTicketOrderResponseBodyModelOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  CreateMovieTicketOrderResponseBodyModelOrderIds() {}

  explicit CreateMovieTicketOrderResponseBodyModelOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateMovieTicketOrderResponseBodyModelOrderIds() = default;
};
class CreateMovieTicketOrderResponseBodyModelPayTradeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> payTradeIds{};

  CreateMovieTicketOrderResponseBodyModelPayTradeIds() {}

  explicit CreateMovieTicketOrderResponseBodyModelPayTradeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateMovieTicketOrderResponseBodyModelPayTradeIds() = default;
};
class CreateMovieTicketOrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<CreateMovieTicketOrderResponseBodyModelOrderIds> orderIds{};
  shared_ptr<CreateMovieTicketOrderResponseBodyModelPayTradeIds> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateMovieTicketOrderResponseBodyModel() {}

  explicit CreateMovieTicketOrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = orderIds ? boost::any(orderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payTradeIds) {
      res["PayTradeIds"] = payTradeIds ? boost::any(payTradeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderIds"].type()) {
        CreateMovieTicketOrderResponseBodyModelOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderIds"]));
        orderIds = make_shared<CreateMovieTicketOrderResponseBodyModelOrderIds>(model1);
      }
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayTradeIds"].type()) {
        CreateMovieTicketOrderResponseBodyModelPayTradeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayTradeIds"]));
        payTradeIds = make_shared<CreateMovieTicketOrderResponseBodyModelPayTradeIds>(model1);
      }
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateMovieTicketOrderResponseBodyModel() = default;
};
class CreateMovieTicketOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateMovieTicketOrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateMovieTicketOrderResponseBody() {}

  explicit CreateMovieTicketOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateMovieTicketOrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateMovieTicketOrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateMovieTicketOrderResponseBody() = default;
};
class CreateMovieTicketOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMovieTicketOrderResponseBody> body{};

  CreateMovieTicketOrderResponse() {}

  explicit CreateMovieTicketOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMovieTicketOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMovieTicketOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMovieTicketOrderResponse() = default;
};
class CreateOrderRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  CreateOrderRequestItemList() {}

  explicit CreateOrderRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~CreateOrderRequestItemList() = default;
};
class CreateOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> buyerMessageMap{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<vector<CreateOrderRequestItemList>> itemList{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> orderExpireTime{};
  shared_ptr<string> outTradeId{};
  shared_ptr<long> quantity{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<long> totalAmount{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CreateOrderRequest() {}

  explicit CreateOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (buyerMessageMap) {
      res["BuyerMessageMap"] = boost::any(*buyerMessageMap);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (orderExpireTime) {
      res["OrderExpireTime"] = boost::any(*orderExpireTime);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BuyerMessageMap") != m.end() && !m["BuyerMessageMap"].empty()) {
      buyerMessageMap = make_shared<string>(boost::any_cast<string>(m["BuyerMessageMap"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<CreateOrderRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrderRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<CreateOrderRequestItemList>>(expect1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("OrderExpireTime") != m.end() && !m["OrderExpireTime"].empty()) {
      orderExpireTime = make_shared<long>(boost::any_cast<long>(m["OrderExpireTime"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CreateOrderRequest() = default;
};
class CreateOrderResponseBodyModelLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> lmOrderId{};

  CreateOrderResponseBodyModelLmOrderListLmOrderList() {}

  explicit CreateOrderResponseBodyModelLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
  }


  virtual ~CreateOrderResponseBodyModelLmOrderListLmOrderList() = default;
};
class CreateOrderResponseBodyModelLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrderResponseBodyModelLmOrderListLmOrderList>> lmOrderList{};

  CreateOrderResponseBodyModelLmOrderList() {}

  explicit CreateOrderResponseBodyModelLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<CreateOrderResponseBodyModelLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrderResponseBodyModelLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<CreateOrderResponseBodyModelLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~CreateOrderResponseBodyModelLmOrderList() = default;
};
class CreateOrderResponseBodyModelOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  CreateOrderResponseBodyModelOrderIds() {}

  explicit CreateOrderResponseBodyModelOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyModelOrderIds() = default;
};
class CreateOrderResponseBodyModelPayTradeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> payTradeIds{};

  CreateOrderResponseBodyModelPayTradeIds() {}

  explicit CreateOrderResponseBodyModelPayTradeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderResponseBodyModelPayTradeIds() = default;
};
class CreateOrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<CreateOrderResponseBodyModelLmOrderList> lmOrderList{};
  shared_ptr<CreateOrderResponseBodyModelOrderIds> orderIds{};
  shared_ptr<CreateOrderResponseBodyModelPayTradeIds> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateOrderResponseBodyModel() {}

  explicit CreateOrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderIds) {
      res["OrderIds"] = orderIds ? boost::any(orderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payTradeIds) {
      res["PayTradeIds"] = payTradeIds ? boost::any(payTradeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        CreateOrderResponseBodyModelLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<CreateOrderResponseBodyModelLmOrderList>(model1);
      }
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderIds"].type()) {
        CreateOrderResponseBodyModelOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderIds"]));
        orderIds = make_shared<CreateOrderResponseBodyModelOrderIds>(model1);
      }
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayTradeIds"].type()) {
        CreateOrderResponseBodyModelPayTradeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayTradeIds"]));
        payTradeIds = make_shared<CreateOrderResponseBodyModelPayTradeIds>(model1);
      }
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateOrderResponseBodyModel() = default;
};
class CreateOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateOrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOrderResponseBody() {}

  explicit CreateOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateOrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateOrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOrderResponseBody() = default;
};
class CreateOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderResponseBody> body{};

  CreateOrderResponse() {}

  explicit CreateOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderResponse() = default;
};
class CreateOrderPayUrlForOutDiscountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> buyInfo{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CreateOrderPayUrlForOutDiscountRequest() {}

  explicit CreateOrderPayUrlForOutDiscountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (buyInfo) {
      res["BuyInfo"] = boost::any(*buyInfo);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BuyInfo") != m.end() && !m["BuyInfo"].empty()) {
      buyInfo = make_shared<string>(boost::any_cast<string>(m["BuyInfo"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CreateOrderPayUrlForOutDiscountRequest() = default;
};
class CreateOrderPayUrlForOutDiscountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<map<string, map<string, boost::any>>> allIdsMap{};
  shared_ptr<vector<string>> lmOrderList{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<vector<string>> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateOrderPayUrlForOutDiscountResponseBodyModel() {}

  explicit CreateOrderPayUrlForOutDiscountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allIdsMap) {
      res["AllIdsMap"] = boost::any(*allIdsMap);
    }
    if (lmOrderList) {
      res["LmOrderList"] = boost::any(*lmOrderList);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllIdsMap") != m.end() && !m["AllIdsMap"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["AllIdsMap"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      allIdsMap = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmOrderList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmOrderList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateOrderPayUrlForOutDiscountResponseBodyModel() = default;
};
class CreateOrderPayUrlForOutDiscountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CreateOrderPayUrlForOutDiscountResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOrderPayUrlForOutDiscountResponseBody() {}

  explicit CreateOrderPayUrlForOutDiscountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateOrderPayUrlForOutDiscountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateOrderPayUrlForOutDiscountResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrderPayUrlForOutDiscountResponseBody() = default;
};
class CreateOrderPayUrlForOutDiscountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderPayUrlForOutDiscountResponseBody> body{};

  CreateOrderPayUrlForOutDiscountResponse() {}

  explicit CreateOrderPayUrlForOutDiscountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderPayUrlForOutDiscountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderPayUrlForOutDiscountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderPayUrlForOutDiscountResponse() = default;
};
class CreateOrderTransactionDetailFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizName{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createEndTime{};
  shared_ptr<string> createStartTime{};
  shared_ptr<string> itemId{};
  shared_ptr<string> lmShopId{};
  shared_ptr<string> orderStatus{};
  shared_ptr<string> payStatus{};
  shared_ptr<string> paymentEndTime{};
  shared_ptr<string> paymentStartTime{};
  shared_ptr<string> poCode{};
  shared_ptr<string> refundEndTime{};
  shared_ptr<string> refundStartTime{};
  shared_ptr<string> sellerId{};
  shared_ptr<string> sellerName{};
  shared_ptr<string> settlementNode{};
  shared_ptr<string> shopName{};
  shared_ptr<string> tbMainOrderId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantName{};

  CreateOrderTransactionDetailFileRequest() {}

  explicit CreateOrderTransactionDetailFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createEndTime) {
      res["CreateEndTime"] = boost::any(*createEndTime);
    }
    if (createStartTime) {
      res["CreateStartTime"] = boost::any(*createStartTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (payStatus) {
      res["PayStatus"] = boost::any(*payStatus);
    }
    if (paymentEndTime) {
      res["PaymentEndTime"] = boost::any(*paymentEndTime);
    }
    if (paymentStartTime) {
      res["PaymentStartTime"] = boost::any(*paymentStartTime);
    }
    if (poCode) {
      res["PoCode"] = boost::any(*poCode);
    }
    if (refundEndTime) {
      res["RefundEndTime"] = boost::any(*refundEndTime);
    }
    if (refundStartTime) {
      res["RefundStartTime"] = boost::any(*refundStartTime);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerName) {
      res["SellerName"] = boost::any(*sellerName);
    }
    if (settlementNode) {
      res["SettlementNode"] = boost::any(*settlementNode);
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (tbMainOrderId) {
      res["TbMainOrderId"] = boost::any(*tbMainOrderId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateEndTime") != m.end() && !m["CreateEndTime"].empty()) {
      createEndTime = make_shared<string>(boost::any_cast<string>(m["CreateEndTime"]));
    }
    if (m.find("CreateStartTime") != m.end() && !m["CreateStartTime"].empty()) {
      createStartTime = make_shared<string>(boost::any_cast<string>(m["CreateStartTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<string>(boost::any_cast<string>(m["LmShopId"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<string>(boost::any_cast<string>(m["OrderStatus"]));
    }
    if (m.find("PayStatus") != m.end() && !m["PayStatus"].empty()) {
      payStatus = make_shared<string>(boost::any_cast<string>(m["PayStatus"]));
    }
    if (m.find("PaymentEndTime") != m.end() && !m["PaymentEndTime"].empty()) {
      paymentEndTime = make_shared<string>(boost::any_cast<string>(m["PaymentEndTime"]));
    }
    if (m.find("PaymentStartTime") != m.end() && !m["PaymentStartTime"].empty()) {
      paymentStartTime = make_shared<string>(boost::any_cast<string>(m["PaymentStartTime"]));
    }
    if (m.find("PoCode") != m.end() && !m["PoCode"].empty()) {
      poCode = make_shared<string>(boost::any_cast<string>(m["PoCode"]));
    }
    if (m.find("RefundEndTime") != m.end() && !m["RefundEndTime"].empty()) {
      refundEndTime = make_shared<string>(boost::any_cast<string>(m["RefundEndTime"]));
    }
    if (m.find("RefundStartTime") != m.end() && !m["RefundStartTime"].empty()) {
      refundStartTime = make_shared<string>(boost::any_cast<string>(m["RefundStartTime"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["SellerId"]));
    }
    if (m.find("SellerName") != m.end() && !m["SellerName"].empty()) {
      sellerName = make_shared<string>(boost::any_cast<string>(m["SellerName"]));
    }
    if (m.find("SettlementNode") != m.end() && !m["SettlementNode"].empty()) {
      settlementNode = make_shared<string>(boost::any_cast<string>(m["SettlementNode"]));
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("TbMainOrderId") != m.end() && !m["TbMainOrderId"].empty()) {
      tbMainOrderId = make_shared<string>(boost::any_cast<string>(m["TbMainOrderId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~CreateOrderTransactionDetailFileRequest() = default;
};
class CreateOrderTransactionDetailFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizViewData{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recordId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOrderTransactionDetailFileResponseBody() {}

  explicit CreateOrderTransactionDetailFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizViewData) {
      res["BizViewData"] = boost::any(*bizViewData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizViewData") != m.end() && !m["BizViewData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizViewData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizViewData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOrderTransactionDetailFileResponseBody() = default;
};
class CreateOrderTransactionDetailFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderTransactionDetailFileResponseBody> body{};

  CreateOrderTransactionDetailFileResponse() {}

  explicit CreateOrderTransactionDetailFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderTransactionDetailFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderTransactionDetailFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderTransactionDetailFileResponse() = default;
};
class CreateOrderV2RequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  CreateOrderV2RequestItemList() {}

  explicit CreateOrderV2RequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~CreateOrderV2RequestItemList() = default;
};
class CreateOrderV2Request : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> buyerMessageMap{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<vector<CreateOrderV2RequestItemList>> itemList{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> orderExpireTime{};
  shared_ptr<string> outTradeId{};
  shared_ptr<long> quantity{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<long> totalAmount{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CreateOrderV2Request() {}

  explicit CreateOrderV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (buyerMessageMap) {
      res["BuyerMessageMap"] = boost::any(*buyerMessageMap);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (orderExpireTime) {
      res["OrderExpireTime"] = boost::any(*orderExpireTime);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BuyerMessageMap") != m.end() && !m["BuyerMessageMap"].empty()) {
      buyerMessageMap = make_shared<string>(boost::any_cast<string>(m["BuyerMessageMap"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<CreateOrderV2RequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrderV2RequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<CreateOrderV2RequestItemList>>(expect1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("OrderExpireTime") != m.end() && !m["OrderExpireTime"].empty()) {
      orderExpireTime = make_shared<long>(boost::any_cast<long>(m["OrderExpireTime"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CreateOrderV2Request() = default;
};
class CreateOrderV2ResponseBodyModelLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> lmOrderId{};

  CreateOrderV2ResponseBodyModelLmOrderListLmOrderList() {}

  explicit CreateOrderV2ResponseBodyModelLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
  }


  virtual ~CreateOrderV2ResponseBodyModelLmOrderListLmOrderList() = default;
};
class CreateOrderV2ResponseBodyModelLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrderV2ResponseBodyModelLmOrderListLmOrderList>> lmOrderList{};

  CreateOrderV2ResponseBodyModelLmOrderList() {}

  explicit CreateOrderV2ResponseBodyModelLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<CreateOrderV2ResponseBodyModelLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrderV2ResponseBodyModelLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<CreateOrderV2ResponseBodyModelLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~CreateOrderV2ResponseBodyModelLmOrderList() = default;
};
class CreateOrderV2ResponseBodyModelOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  CreateOrderV2ResponseBodyModelOrderIds() {}

  explicit CreateOrderV2ResponseBodyModelOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderV2ResponseBodyModelOrderIds() = default;
};
class CreateOrderV2ResponseBodyModelPayTradeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> payTradeIds{};

  CreateOrderV2ResponseBodyModelPayTradeIds() {}

  explicit CreateOrderV2ResponseBodyModelPayTradeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateOrderV2ResponseBodyModelPayTradeIds() = default;
};
class CreateOrderV2ResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<CreateOrderV2ResponseBodyModelLmOrderList> lmOrderList{};
  shared_ptr<CreateOrderV2ResponseBodyModelOrderIds> orderIds{};
  shared_ptr<CreateOrderV2ResponseBodyModelPayTradeIds> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateOrderV2ResponseBodyModel() {}

  explicit CreateOrderV2ResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderIds) {
      res["OrderIds"] = orderIds ? boost::any(orderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payTradeIds) {
      res["PayTradeIds"] = payTradeIds ? boost::any(payTradeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        CreateOrderV2ResponseBodyModelLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<CreateOrderV2ResponseBodyModelLmOrderList>(model1);
      }
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderIds"].type()) {
        CreateOrderV2ResponseBodyModelOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderIds"]));
        orderIds = make_shared<CreateOrderV2ResponseBodyModelOrderIds>(model1);
      }
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayTradeIds"].type()) {
        CreateOrderV2ResponseBodyModelPayTradeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayTradeIds"]));
        payTradeIds = make_shared<CreateOrderV2ResponseBodyModelPayTradeIds>(model1);
      }
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateOrderV2ResponseBodyModel() = default;
};
class CreateOrderV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateOrderV2ResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOrderV2ResponseBody() {}

  explicit CreateOrderV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateOrderV2ResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateOrderV2ResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOrderV2ResponseBody() = default;
};
class CreateOrderV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderV2ResponseBody> body{};

  CreateOrderV2Response() {}

  explicit CreateOrderV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderV2ResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderV2Response() = default;
};
class CreateOrderWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> buyerMessages{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> deliveryInfo{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> orderExpireTime{};
  shared_ptr<string> orderItems{};
  shared_ptr<string> outTradeId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  CreateOrderWithDesignatedTbUidRequest() {}

  explicit CreateOrderWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerMessages) {
      res["BuyerMessages"] = boost::any(*buyerMessages);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (deliveryInfo) {
      res["DeliveryInfo"] = boost::any(*deliveryInfo);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (orderExpireTime) {
      res["OrderExpireTime"] = boost::any(*orderExpireTime);
    }
    if (orderItems) {
      res["OrderItems"] = boost::any(*orderItems);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerMessages") != m.end() && !m["BuyerMessages"].empty()) {
      buyerMessages = make_shared<string>(boost::any_cast<string>(m["BuyerMessages"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("DeliveryInfo") != m.end() && !m["DeliveryInfo"].empty()) {
      deliveryInfo = make_shared<string>(boost::any_cast<string>(m["DeliveryInfo"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("OrderExpireTime") != m.end() && !m["OrderExpireTime"].empty()) {
      orderExpireTime = make_shared<long>(boost::any_cast<long>(m["OrderExpireTime"]));
    }
    if (m.find("OrderItems") != m.end() && !m["OrderItems"].empty()) {
      orderItems = make_shared<string>(boost::any_cast<string>(m["OrderItems"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~CreateOrderWithDesignatedTbUidRequest() = default;
};
class CreateOrderWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<map<string, map<string, boost::any>>> allIdsMap{};
  shared_ptr<string> app{};
  shared_ptr<vector<string>> lmOrderIds{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<vector<string>> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateOrderWithDesignatedTbUidResponseBodyModel() {}

  explicit CreateOrderWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allIdsMap) {
      res["AllIdsMap"] = boost::any(*allIdsMap);
    }
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (lmOrderIds) {
      res["LmOrderIds"] = boost::any(*lmOrderIds);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllIdsMap") != m.end() && !m["AllIdsMap"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["AllIdsMap"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      allIdsMap = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("LmOrderIds") != m.end() && !m["LmOrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmOrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmOrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmOrderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateOrderWithDesignatedTbUidResponseBodyModel() = default;
};
class CreateOrderWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateOrderWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOrderWithDesignatedTbUidResponseBody() {}

  explicit CreateOrderWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateOrderWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateOrderWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOrderWithDesignatedTbUidResponseBody() = default;
};
class CreateOrderWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrderWithDesignatedTbUidResponseBody> body{};

  CreateOrderWithDesignatedTbUidResponse() {}

  explicit CreateOrderWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrderWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrderWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrderWithDesignatedTbUidResponse() = default;
};
class CreateOutDiscountOrderWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> buyerMessages{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> deliveryInfo{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> orderExpireTime{};
  shared_ptr<string> orderItems{};
  shared_ptr<string> outDiscountInfos{};
  shared_ptr<string> outTradeId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  CreateOutDiscountOrderWithDesignatedTbUidRequest() {}

  explicit CreateOutDiscountOrderWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (buyerMessages) {
      res["BuyerMessages"] = boost::any(*buyerMessages);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (deliveryInfo) {
      res["DeliveryInfo"] = boost::any(*deliveryInfo);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (orderExpireTime) {
      res["OrderExpireTime"] = boost::any(*orderExpireTime);
    }
    if (orderItems) {
      res["OrderItems"] = boost::any(*orderItems);
    }
    if (outDiscountInfos) {
      res["OutDiscountInfos"] = boost::any(*outDiscountInfos);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BuyerMessages") != m.end() && !m["BuyerMessages"].empty()) {
      buyerMessages = make_shared<string>(boost::any_cast<string>(m["BuyerMessages"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("DeliveryInfo") != m.end() && !m["DeliveryInfo"].empty()) {
      deliveryInfo = make_shared<string>(boost::any_cast<string>(m["DeliveryInfo"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("OrderExpireTime") != m.end() && !m["OrderExpireTime"].empty()) {
      orderExpireTime = make_shared<long>(boost::any_cast<long>(m["OrderExpireTime"]));
    }
    if (m.find("OrderItems") != m.end() && !m["OrderItems"].empty()) {
      orderItems = make_shared<string>(boost::any_cast<string>(m["OrderItems"]));
    }
    if (m.find("OutDiscountInfos") != m.end() && !m["OutDiscountInfos"].empty()) {
      outDiscountInfos = make_shared<string>(boost::any_cast<string>(m["OutDiscountInfos"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~CreateOutDiscountOrderWithDesignatedTbUidRequest() = default;
};
class CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<map<string, map<string, boost::any>>> allIdsMap{};
  shared_ptr<string> app{};
  shared_ptr<vector<string>> lmOrderIds{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<vector<string>> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel() {}

  explicit CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allIdsMap) {
      res["AllIdsMap"] = boost::any(*allIdsMap);
    }
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (lmOrderIds) {
      res["LmOrderIds"] = boost::any(*lmOrderIds);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllIdsMap") != m.end() && !m["AllIdsMap"].empty()) {
      map<string, map<string, boost::any>> map1 = boost::any_cast<map<string, map<string, boost::any>>>(m["AllIdsMap"]);
      map<string, map<string, boost::any>> toMap1;
      for (auto item:map1) {
        map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item.second);
        map<string, boost::any> toMap2;
        for (auto item:map2) {
           toMap2[item.first] = item.second;
        }
         toMap1[item.first] = toMap2;
      }
      allIdsMap = make_shared<map<string, map<string, boost::any>>>(toMap1);
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("LmOrderIds") != m.end() && !m["LmOrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmOrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmOrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmOrderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel() = default;
};
class CreateOutDiscountOrderWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOutDiscountOrderWithDesignatedTbUidResponseBody() {}

  explicit CreateOutDiscountOrderWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateOutDiscountOrderWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOutDiscountOrderWithDesignatedTbUidResponseBody() = default;
};
class CreateOutDiscountOrderWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOutDiscountOrderWithDesignatedTbUidResponseBody> body{};

  CreateOutDiscountOrderWithDesignatedTbUidResponse() {}

  explicit CreateOutDiscountOrderWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOutDiscountOrderWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOutDiscountOrderWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOutDiscountOrderWithDesignatedTbUidResponse() = default;
};
class CreatePayUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> buyInfo{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CreatePayUrlRequest() {}

  explicit CreatePayUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (buyInfo) {
      res["BuyInfo"] = boost::any(*buyInfo);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BuyInfo") != m.end() && !m["BuyInfo"].empty()) {
      buyInfo = make_shared<string>(boost::any_cast<string>(m["BuyInfo"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CreatePayUrlRequest() = default;
};
class CreatePayUrlResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<string>> lmOrderList{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<vector<string>> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreatePayUrlResponseBodyModel() {}

  explicit CreatePayUrlResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      res["LmOrderList"] = boost::any(*lmOrderList);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmOrderList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmOrderList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreatePayUrlResponseBodyModel() = default;
};
class CreatePayUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<CreatePayUrlResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePayUrlResponseBody() {}

  explicit CreatePayUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreatePayUrlResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreatePayUrlResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreatePayUrlResponseBody() = default;
};
class CreatePayUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePayUrlResponseBody> body{};

  CreatePayUrlResponse() {}

  explicit CreatePayUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePayUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePayUrlResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePayUrlResponse() = default;
};
class CreateSettleConfirmRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> settleInfo{};
  shared_ptr<string> tradeNo{};

  CreateSettleConfirmRequest() {}

  explicit CreateSettleConfirmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (settleInfo) {
      res["SettleInfo"] = boost::any(*settleInfo);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("SettleInfo") != m.end() && !m["SettleInfo"].empty()) {
      settleInfo = make_shared<string>(boost::any_cast<string>(m["SettleInfo"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~CreateSettleConfirmRequest() = default;
};
class CreateSettleConfirmResponseBodyTradeSettleConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> tradeNo{};

  CreateSettleConfirmResponseBodyTradeSettleConfirmResponse() {}

  explicit CreateSettleConfirmResponseBodyTradeSettleConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~CreateSettleConfirmResponseBodyTradeSettleConfirmResponse() = default;
};
class CreateSettleConfirmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateSettleConfirmResponseBodyTradeSettleConfirmResponse> tradeSettleConfirmResponse{};

  CreateSettleConfirmResponseBody() {}

  explicit CreateSettleConfirmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tradeSettleConfirmResponse) {
      res["TradeSettleConfirmResponse"] = tradeSettleConfirmResponse ? boost::any(tradeSettleConfirmResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TradeSettleConfirmResponse") != m.end() && !m["TradeSettleConfirmResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["TradeSettleConfirmResponse"].type()) {
        CreateSettleConfirmResponseBodyTradeSettleConfirmResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TradeSettleConfirmResponse"]));
        tradeSettleConfirmResponse = make_shared<CreateSettleConfirmResponseBodyTradeSettleConfirmResponse>(model1);
      }
    }
  }


  virtual ~CreateSettleConfirmResponseBody() = default;
};
class CreateSettleConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSettleConfirmResponseBody> body{};

  CreateSettleConfirmResponse() {}

  explicit CreateSettleConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSettleConfirmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSettleConfirmResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSettleConfirmResponse() = default;
};
class CreateVirtualProductOrderRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  CreateVirtualProductOrderRequestItemList() {}

  explicit CreateVirtualProductOrderRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~CreateVirtualProductOrderRequestItemList() = default;
};
class CreateVirtualProductOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<vector<CreateVirtualProductOrderRequestItemList>> itemList{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> orderExpireTime{};
  shared_ptr<string> outTradeId{};
  shared_ptr<long> quantity{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<long> totalAmount{};
  shared_ptr<bool> useAnonymousTbAccount{};

  CreateVirtualProductOrderRequest() {}

  explicit CreateVirtualProductOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (orderExpireTime) {
      res["OrderExpireTime"] = boost::any(*orderExpireTime);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<CreateVirtualProductOrderRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVirtualProductOrderRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<CreateVirtualProductOrderRequestItemList>>(expect1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("OrderExpireTime") != m.end() && !m["OrderExpireTime"].empty()) {
      orderExpireTime = make_shared<long>(boost::any_cast<long>(m["OrderExpireTime"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~CreateVirtualProductOrderRequest() = default;
};
class CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> lmOrderId{};

  CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList() {}

  explicit CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
  }


  virtual ~CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList() = default;
};
class CreateVirtualProductOrderResponseBodyModelLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList>> lmOrderList{};

  CreateVirtualProductOrderResponseBodyModelLmOrderList() {}

  explicit CreateVirtualProductOrderResponseBodyModelLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<CreateVirtualProductOrderResponseBodyModelLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~CreateVirtualProductOrderResponseBodyModelLmOrderList() = default;
};
class CreateVirtualProductOrderResponseBodyModelOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  CreateVirtualProductOrderResponseBodyModelOrderIds() {}

  explicit CreateVirtualProductOrderResponseBodyModelOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateVirtualProductOrderResponseBodyModelOrderIds() = default;
};
class CreateVirtualProductOrderResponseBodyModelPayTradeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> payTradeIds{};

  CreateVirtualProductOrderResponseBodyModelPayTradeIds() {}

  explicit CreateVirtualProductOrderResponseBodyModelPayTradeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateVirtualProductOrderResponseBodyModelPayTradeIds() = default;
};
class CreateVirtualProductOrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<CreateVirtualProductOrderResponseBodyModelLmOrderList> lmOrderList{};
  shared_ptr<CreateVirtualProductOrderResponseBodyModelOrderIds> orderIds{};
  shared_ptr<CreateVirtualProductOrderResponseBodyModelPayTradeIds> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  CreateVirtualProductOrderResponseBodyModel() {}

  explicit CreateVirtualProductOrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderIds) {
      res["OrderIds"] = orderIds ? boost::any(orderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payTradeIds) {
      res["PayTradeIds"] = payTradeIds ? boost::any(payTradeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        CreateVirtualProductOrderResponseBodyModelLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<CreateVirtualProductOrderResponseBodyModelLmOrderList>(model1);
      }
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderIds"].type()) {
        CreateVirtualProductOrderResponseBodyModelOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderIds"]));
        orderIds = make_shared<CreateVirtualProductOrderResponseBodyModelOrderIds>(model1);
      }
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayTradeIds"].type()) {
        CreateVirtualProductOrderResponseBodyModelPayTradeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayTradeIds"]));
        payTradeIds = make_shared<CreateVirtualProductOrderResponseBodyModelPayTradeIds>(model1);
      }
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~CreateVirtualProductOrderResponseBodyModel() = default;
};
class CreateVirtualProductOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<CreateVirtualProductOrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateVirtualProductOrderResponseBody() {}

  explicit CreateVirtualProductOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        CreateVirtualProductOrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<CreateVirtualProductOrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateVirtualProductOrderResponseBody() = default;
};
class CreateVirtualProductOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVirtualProductOrderResponseBody> body{};

  CreateVirtualProductOrderResponse() {}

  explicit CreateVirtualProductOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVirtualProductOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVirtualProductOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVirtualProductOrderResponse() = default;
};
class CreateWithholdTradeRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementNo{};
  shared_ptr<string> body{};
  shared_ptr<string> buyerId{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> goodsDetail{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> settleMode{};
  shared_ptr<string> subject{};
  shared_ptr<string> totalAmount{};

  CreateWithholdTradeRequest() {}

  explicit CreateWithholdTradeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementNo) {
      res["AgreementNo"] = boost::any(*agreementNo);
    }
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (buyerId) {
      res["BuyerId"] = boost::any(*buyerId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (goodsDetail) {
      res["GoodsDetail"] = boost::any(*goodsDetail);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (settleMode) {
      res["SettleMode"] = boost::any(*settleMode);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementNo") != m.end() && !m["AgreementNo"].empty()) {
      agreementNo = make_shared<string>(boost::any_cast<string>(m["AgreementNo"]));
    }
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("BuyerId") != m.end() && !m["BuyerId"].empty()) {
      buyerId = make_shared<string>(boost::any_cast<string>(m["BuyerId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GoodsDetail") != m.end() && !m["GoodsDetail"].empty()) {
      goodsDetail = make_shared<string>(boost::any_cast<string>(m["GoodsDetail"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("SettleMode") != m.end() && !m["SettleMode"].empty()) {
      settleMode = make_shared<string>(boost::any_cast<string>(m["SettleMode"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<string>(boost::any_cast<string>(m["TotalAmount"]));
    }
  }


  virtual ~CreateWithholdTradeRequest() = default;
};
class CreateWithholdTradeResponseBodyWithholdTradeResponse : public Darabonba::Model {
public:
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> paymentDate{};
  shared_ptr<string> tradeNo{};

  CreateWithholdTradeResponseBodyWithholdTradeResponse() {}

  explicit CreateWithholdTradeResponseBodyWithholdTradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (paymentDate) {
      res["PaymentDate"] = boost::any(*paymentDate);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("PaymentDate") != m.end() && !m["PaymentDate"].empty()) {
      paymentDate = make_shared<string>(boost::any_cast<string>(m["PaymentDate"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~CreateWithholdTradeResponseBodyWithholdTradeResponse() = default;
};
class CreateWithholdTradeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateWithholdTradeResponseBodyWithholdTradeResponse> withholdTradeResponse{};

  CreateWithholdTradeResponseBody() {}

  explicit CreateWithholdTradeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (withholdTradeResponse) {
      res["WithholdTradeResponse"] = withholdTradeResponse ? boost::any(withholdTradeResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WithholdTradeResponse") != m.end() && !m["WithholdTradeResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["WithholdTradeResponse"].type()) {
        CreateWithholdTradeResponseBodyWithholdTradeResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WithholdTradeResponse"]));
        withholdTradeResponse = make_shared<CreateWithholdTradeResponseBodyWithholdTradeResponse>(model1);
      }
    }
  }


  virtual ~CreateWithholdTradeResponseBody() = default;
};
class CreateWithholdTradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateWithholdTradeResponseBody> body{};

  CreateWithholdTradeResponse() {}

  explicit CreateWithholdTradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateWithholdTradeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateWithholdTradeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateWithholdTradeResponse() = default;
};
class DeductUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  DeductUserPointRequest() {}

  explicit DeductUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DeductUserPointRequest() = default;
};
class DeductUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  DeductUserPointShrinkRequest() {}

  explicit DeductUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DeductUserPointShrinkRequest() = default;
};
class DeductUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  DeductUserPointResponseBodyModel() {}

  explicit DeductUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DeductUserPointResponseBodyModel() = default;
};
class DeductUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DeductUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  DeductUserPointResponseBody() {}

  explicit DeductUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        DeductUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<DeductUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeductUserPointResponseBody() = default;
};
class DeductUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeductUserPointResponseBody> body{};

  DeductUserPointResponse() {}

  explicit DeductUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeductUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeductUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~DeductUserPointResponse() = default;
};
class DeleteBizItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<long>> itemIdList{};
  shared_ptr<string> subBizId{};

  DeleteBizItemsRequest() {}

  explicit DeleteBizItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdList) {
      res["ItemIdList"] = boost::any(*itemIdList);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIdList") != m.end() && !m["ItemIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      itemIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~DeleteBizItemsRequest() = default;
};
class DeleteBizItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteBizItemsResponseBody() {}

  explicit DeleteBizItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBizItemsResponseBody() = default;
};
class DeleteBizItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBizItemsResponseBody> body{};

  DeleteBizItemsResponse() {}

  explicit DeleteBizItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBizItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBizItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBizItemsResponse() = default;
};
class DeleteItemLimitRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> subBizCode{};

  DeleteItemLimitRuleRequest() {}

  explicit DeleteItemLimitRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~DeleteItemLimitRuleRequest() = default;
};
class DeleteItemLimitRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> model{};
  shared_ptr<string> requestId{};

  DeleteItemLimitRuleResponseBody() {}

  explicit DeleteItemLimitRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<bool>(boost::any_cast<bool>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteItemLimitRuleResponseBody() = default;
};
class DeleteItemLimitRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteItemLimitRuleResponseBody> body{};

  DeleteItemLimitRuleResponse() {}

  explicit DeleteItemLimitRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteItemLimitRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteItemLimitRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteItemLimitRuleResponse() = default;
};
class DownloadCpsBillFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> bizId{};

  DownloadCpsBillFileRequest() {}

  explicit DownloadCpsBillFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~DownloadCpsBillFileRequest() = default;
};
class DownloadCpsBillFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizViewData{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DownloadCpsBillFileResponseBody() {}

  explicit DownloadCpsBillFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizViewData) {
      res["BizViewData"] = boost::any(*bizViewData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizViewData") != m.end() && !m["BizViewData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizViewData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizViewData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DownloadCpsBillFileResponseBody() = default;
};
class DownloadCpsBillFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadCpsBillFileResponseBody> body{};

  DownloadCpsBillFileResponse() {}

  explicit DownloadCpsBillFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadCpsBillFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadCpsBillFileResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadCpsBillFileResponse() = default;
};
class DownloadItemBillFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> bizId{};

  DownloadItemBillFileRequest() {}

  explicit DownloadItemBillFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~DownloadItemBillFileRequest() = default;
};
class DownloadItemBillFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizViewData{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DownloadItemBillFileResponseBody() {}

  explicit DownloadItemBillFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizViewData) {
      res["BizViewData"] = boost::any(*bizViewData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizViewData") != m.end() && !m["BizViewData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizViewData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizViewData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DownloadItemBillFileResponseBody() = default;
};
class DownloadItemBillFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadItemBillFileResponseBody> body{};

  DownloadItemBillFileResponse() {}

  explicit DownloadItemBillFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadItemBillFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadItemBillFileResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadItemBillFileResponse() = default;
};
class DownloadOrderTransactionDetailFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> recordId{};

  DownloadOrderTransactionDetailFileRequest() {}

  explicit DownloadOrderTransactionDetailFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
  }


  virtual ~DownloadOrderTransactionDetailFileRequest() = default;
};
class DownloadOrderTransactionDetailFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> bizViewData{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> ossUrl{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DownloadOrderTransactionDetailFileResponseBody() {}

  explicit DownloadOrderTransactionDetailFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizViewData) {
      res["BizViewData"] = boost::any(*bizViewData);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizViewData") != m.end() && !m["BizViewData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["BizViewData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      bizViewData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DownloadOrderTransactionDetailFileResponseBody() = default;
};
class DownloadOrderTransactionDetailFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadOrderTransactionDetailFileResponseBody> body{};

  DownloadOrderTransactionDetailFileResponse() {}

  explicit DownloadOrderTransactionDetailFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadOrderTransactionDetailFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadOrderTransactionDetailFileResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadOrderTransactionDetailFileResponse() = default;
};
class EnableOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<string> outTradeId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  EnableOrderRequest() {}

  explicit EnableOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (outTradeId) {
      res["OutTradeId"] = boost::any(*outTradeId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("OutTradeId") != m.end() && !m["OutTradeId"].empty()) {
      outTradeId = make_shared<string>(boost::any_cast<string>(m["OutTradeId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~EnableOrderRequest() = default;
};
class EnableOrderResponseBodyModelLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> lmOrderId{};

  EnableOrderResponseBodyModelLmOrderListLmOrderList() {}

  explicit EnableOrderResponseBodyModelLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
  }


  virtual ~EnableOrderResponseBodyModelLmOrderListLmOrderList() = default;
};
class EnableOrderResponseBodyModelLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<EnableOrderResponseBodyModelLmOrderListLmOrderList>> lmOrderList{};

  EnableOrderResponseBodyModelLmOrderList() {}

  explicit EnableOrderResponseBodyModelLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<EnableOrderResponseBodyModelLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableOrderResponseBodyModelLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<EnableOrderResponseBodyModelLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~EnableOrderResponseBodyModelLmOrderList() = default;
};
class EnableOrderResponseBodyModelOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> orderIds{};

  EnableOrderResponseBodyModelOrderIds() {}

  explicit EnableOrderResponseBodyModelOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableOrderResponseBodyModelOrderIds() = default;
};
class EnableOrderResponseBodyModelPayTradeIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> payTradeIds{};

  EnableOrderResponseBodyModelPayTradeIds() {}

  explicit EnableOrderResponseBodyModelPayTradeIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableOrderResponseBodyModelPayTradeIds() = default;
};
class EnableOrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<EnableOrderResponseBodyModelLmOrderList> lmOrderList{};
  shared_ptr<EnableOrderResponseBodyModelOrderIds> orderIds{};
  shared_ptr<EnableOrderResponseBodyModelPayTradeIds> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  EnableOrderResponseBodyModel() {}

  explicit EnableOrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderIds) {
      res["OrderIds"] = orderIds ? boost::any(orderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payTradeIds) {
      res["PayTradeIds"] = payTradeIds ? boost::any(payTradeIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        EnableOrderResponseBodyModelLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<EnableOrderResponseBodyModelLmOrderList>(model1);
      }
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderIds"].type()) {
        EnableOrderResponseBodyModelOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderIds"]));
        orderIds = make_shared<EnableOrderResponseBodyModelOrderIds>(model1);
      }
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["PayTradeIds"].type()) {
        EnableOrderResponseBodyModelPayTradeIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PayTradeIds"]));
        payTradeIds = make_shared<EnableOrderResponseBodyModelPayTradeIds>(model1);
      }
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~EnableOrderResponseBodyModel() = default;
};
class EnableOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<EnableOrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  EnableOrderResponseBody() {}

  explicit EnableOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        EnableOrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<EnableOrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~EnableOrderResponseBody() = default;
};
class EnableOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableOrderResponseBody> body{};

  EnableOrderResponse() {}

  explicit EnableOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableOrderResponseBody>(model1);
      }
    }
  }


  virtual ~EnableOrderResponse() = default;
};
class EnableOrderWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  EnableOrderWithDesignatedTbUidRequest() {}

  explicit EnableOrderWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~EnableOrderWithDesignatedTbUidRequest() = default;
};
class EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> extJson{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<vector<string>> subLmOrderIdList{};

  EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList() {}

  explicit EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (subLmOrderIdList) {
      res["SubLmOrderIdList"] = boost::any(*subLmOrderIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtJson"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extJson = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("SubLmOrderIdList") != m.end() && !m["SubLmOrderIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubLmOrderIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubLmOrderIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subLmOrderIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList() = default;
};
class EnableOrderWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList>> lmOrderList{};
  shared_ptr<vector<string>> orderIds{};
  shared_ptr<vector<string>> payTradeIds{};
  shared_ptr<string> redirectUrl{};

  EnableOrderWithDesignatedTbUidResponseBodyModel() {}

  explicit EnableOrderWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    if (orderIds) {
      res["OrderIds"] = boost::any(*orderIds);
    }
    if (payTradeIds) {
      res["PayTradeIds"] = boost::any(*payTradeIds);
    }
    if (redirectUrl) {
      res["RedirectUrl"] = boost::any(*redirectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<EnableOrderWithDesignatedTbUidResponseBodyModelLmOrderList>>(expect1);
      }
    }
    if (m.find("OrderIds") != m.end() && !m["OrderIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrderIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrderIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      orderIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PayTradeIds") != m.end() && !m["PayTradeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PayTradeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PayTradeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      payTradeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUrl") != m.end() && !m["RedirectUrl"].empty()) {
      redirectUrl = make_shared<string>(boost::any_cast<string>(m["RedirectUrl"]));
    }
  }


  virtual ~EnableOrderWithDesignatedTbUidResponseBodyModel() = default;
};
class EnableOrderWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<EnableOrderWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  EnableOrderWithDesignatedTbUidResponseBody() {}

  explicit EnableOrderWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        EnableOrderWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<EnableOrderWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~EnableOrderWithDesignatedTbUidResponseBody() = default;
};
class EnableOrderWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableOrderWithDesignatedTbUidResponseBody> body{};

  EnableOrderWithDesignatedTbUidResponse() {}

  explicit EnableOrderWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableOrderWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableOrderWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~EnableOrderWithDesignatedTbUidResponse() = default;
};
class ExecuteNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> processId{};
  shared_ptr<string> processInstanceId{};
  shared_ptr<string> requestData{};

  ExecuteNodeRequest() {}

  explicit ExecuteNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (requestData) {
      res["RequestData"] = boost::any(*requestData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("RequestData") != m.end() && !m["RequestData"].empty()) {
      requestData = make_shared<string>(boost::any_cast<string>(m["RequestData"]));
    }
  }


  virtual ~ExecuteNodeRequest() = default;
};
class ExecuteNodeResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> processInstanceId{};
  shared_ptr<map<string, boost::any>> responseData{};

  ExecuteNodeResponseBodyModel() {}

  explicit ExecuteNodeResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processInstanceId) {
      res["ProcessInstanceId"] = boost::any(*processInstanceId);
    }
    if (responseData) {
      res["ResponseData"] = boost::any(*responseData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessInstanceId") != m.end() && !m["ProcessInstanceId"].empty()) {
      processInstanceId = make_shared<string>(boost::any_cast<string>(m["ProcessInstanceId"]));
    }
    if (m.find("ResponseData") != m.end() && !m["ResponseData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ResponseData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      responseData = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ExecuteNodeResponseBodyModel() = default;
};
class ExecuteNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ExecuteNodeResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ExecuteNodeResponseBody() {}

  explicit ExecuteNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ExecuteNodeResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ExecuteNodeResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ExecuteNodeResponseBody() = default;
};
class ExecuteNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteNodeResponseBody> body{};

  ExecuteNodeResponse() {}

  explicit ExecuteNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteNodeResponse() = default;
};
class FreezeUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  FreezeUserPointRequest() {}

  explicit FreezeUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~FreezeUserPointRequest() = default;
};
class FreezeUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  FreezeUserPointShrinkRequest() {}

  explicit FreezeUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~FreezeUserPointShrinkRequest() = default;
};
class FreezeUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  FreezeUserPointResponseBodyModel() {}

  explicit FreezeUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~FreezeUserPointResponseBodyModel() = default;
};
class FreezeUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<FreezeUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  FreezeUserPointResponseBody() {}

  explicit FreezeUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        FreezeUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<FreezeUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FreezeUserPointResponseBody() = default;
};
class FreezeUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FreezeUserPointResponseBody> body{};

  FreezeUserPointResponse() {}

  explicit FreezeUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FreezeUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FreezeUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~FreezeUserPointResponse() = default;
};
class GetActivityGameInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<string> thirdPartyUserId{};

  GetActivityGameInfoRequest() {}

  explicit GetActivityGameInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~GetActivityGameInfoRequest() = default;
};
class GetActivityGameInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> gameId{};
  shared_ptr<string> thirdPartyUserId{};

  GetActivityGameInfoShrinkRequest() {}

  explicit GetActivityGameInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~GetActivityGameInfoShrinkRequest() = default;
};
class GetActivityGameInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameDTO{};
  shared_ptr<string> gameShowInfo{};
  shared_ptr<string> userGameCoinInfos{};
  shared_ptr<string> userProcessDTO{};

  GetActivityGameInfoResponseBodyModel() {}

  explicit GetActivityGameInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameDTO) {
      res["GameDTO"] = boost::any(*gameDTO);
    }
    if (gameShowInfo) {
      res["GameShowInfo"] = boost::any(*gameShowInfo);
    }
    if (userGameCoinInfos) {
      res["UserGameCoinInfos"] = boost::any(*userGameCoinInfos);
    }
    if (userProcessDTO) {
      res["UserProcessDTO"] = boost::any(*userProcessDTO);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameDTO") != m.end() && !m["GameDTO"].empty()) {
      gameDTO = make_shared<string>(boost::any_cast<string>(m["GameDTO"]));
    }
    if (m.find("GameShowInfo") != m.end() && !m["GameShowInfo"].empty()) {
      gameShowInfo = make_shared<string>(boost::any_cast<string>(m["GameShowInfo"]));
    }
    if (m.find("UserGameCoinInfos") != m.end() && !m["UserGameCoinInfos"].empty()) {
      userGameCoinInfos = make_shared<string>(boost::any_cast<string>(m["UserGameCoinInfos"]));
    }
    if (m.find("UserProcessDTO") != m.end() && !m["UserProcessDTO"].empty()) {
      userProcessDTO = make_shared<string>(boost::any_cast<string>(m["UserProcessDTO"]));
    }
  }


  virtual ~GetActivityGameInfoResponseBodyModel() = default;
};
class GetActivityGameInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GetActivityGameInfoResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  GetActivityGameInfoResponseBody() {}

  explicit GetActivityGameInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        GetActivityGameInfoResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<GetActivityGameInfoResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetActivityGameInfoResponseBody() = default;
};
class GetActivityGameInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetActivityGameInfoResponseBody> body{};

  GetActivityGameInfoResponse() {}

  explicit GetActivityGameInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetActivityGameInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetActivityGameInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetActivityGameInfoResponse() = default;
};
class GetCategoryChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};

  GetCategoryChainRequest() {}

  explicit GetCategoryChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~GetCategoryChainRequest() = default;
};
class GetCategoryChainResponseBodyCategoryList : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> name{};

  GetCategoryChainResponseBodyCategoryList() {}

  explicit GetCategoryChainResponseBodyCategoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetCategoryChainResponseBodyCategoryList() = default;
};
class GetCategoryChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetCategoryChainResponseBodyCategoryList>> categoryList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCategoryChainResponseBody() {}

  explicit GetCategoryChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryList) {
      vector<boost::any> temp1;
      for(auto item1:*categoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CategoryList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryList") != m.end() && !m["CategoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["CategoryList"].type()) {
        vector<GetCategoryChainResponseBodyCategoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CategoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoryChainResponseBodyCategoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categoryList = make_shared<vector<GetCategoryChainResponseBodyCategoryList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCategoryChainResponseBody() = default;
};
class GetCategoryChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoryChainResponseBody> body{};

  GetCategoryChainResponse() {}

  explicit GetCategoryChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoryChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoryChainResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoryChainResponse() = default;
};
class GetCategoryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};

  GetCategoryListRequest() {}

  explicit GetCategoryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~GetCategoryListRequest() = default;
};
class GetCategoryListResponseBodyCategoryListCategory : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> name{};

  GetCategoryListResponseBodyCategoryListCategory() {}

  explicit GetCategoryListResponseBodyCategoryListCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetCategoryListResponseBodyCategoryListCategory() = default;
};
class GetCategoryListResponseBodyCategoryList : public Darabonba::Model {
public:
  shared_ptr<vector<GetCategoryListResponseBodyCategoryListCategory>> category{};

  GetCategoryListResponseBodyCategoryList() {}

  explicit GetCategoryListResponseBodyCategoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<GetCategoryListResponseBodyCategoryListCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoryListResponseBodyCategoryListCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<GetCategoryListResponseBodyCategoryListCategory>>(expect1);
      }
    }
  }


  virtual ~GetCategoryListResponseBodyCategoryList() = default;
};
class GetCategoryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCategoryListResponseBodyCategoryList> categoryList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCategoryListResponseBody() {}

  explicit GetCategoryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryList) {
      res["CategoryList"] = categoryList ? boost::any(categoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryList") != m.end() && !m["CategoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CategoryList"].type()) {
        GetCategoryListResponseBodyCategoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CategoryList"]));
        categoryList = make_shared<GetCategoryListResponseBodyCategoryList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCategoryListResponseBody() = default;
};
class GetCategoryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoryListResponseBody> body{};

  GetCategoryListResponse() {}

  explicit GetCategoryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoryListResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoryListResponse() = default;
};
class GetCustomServiceUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> cuid{};
  shared_ptr<string> nick{};
  shared_ptr<string> sellerId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  GetCustomServiceUrlRequest() {}

  explicit GetCustomServiceUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (cuid) {
      res["Cuid"] = boost::any(*cuid);
    }
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Cuid") != m.end() && !m["Cuid"].empty()) {
      cuid = make_shared<string>(boost::any_cast<string>(m["Cuid"]));
    }
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["SellerId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~GetCustomServiceUrlRequest() = default;
};
class GetCustomServiceUrlResponseBodyUrlData : public Darabonba::Model {
public:
  shared_ptr<string> returnUrl{};

  GetCustomServiceUrlResponseBodyUrlData() {}

  explicit GetCustomServiceUrlResponseBodyUrlData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (returnUrl) {
      res["ReturnUrl"] = boost::any(*returnUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReturnUrl") != m.end() && !m["ReturnUrl"].empty()) {
      returnUrl = make_shared<string>(boost::any_cast<string>(m["ReturnUrl"]));
    }
  }


  virtual ~GetCustomServiceUrlResponseBodyUrlData() = default;
};
class GetCustomServiceUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCustomServiceUrlResponseBodyUrlData> urlData{};

  GetCustomServiceUrlResponseBody() {}

  explicit GetCustomServiceUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlData) {
      res["UrlData"] = urlData ? boost::any(urlData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlData") != m.end() && !m["UrlData"].empty()) {
      if (typeid(map<string, boost::any>) == m["UrlData"].type()) {
        GetCustomServiceUrlResponseBodyUrlData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UrlData"]));
        urlData = make_shared<GetCustomServiceUrlResponseBodyUrlData>(model1);
      }
    }
  }


  virtual ~GetCustomServiceUrlResponseBody() = default;
};
class GetCustomServiceUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomServiceUrlResponseBody> body{};

  GetCustomServiceUrlResponse() {}

  explicit GetCustomServiceUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomServiceUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomServiceUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomServiceUrlResponse() = default;
};
class GetGuidePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  GetGuidePageRequest() {}

  explicit GetGuidePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~GetGuidePageRequest() = default;
};
class GetGuidePageResponseBodyMiniShopInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> liteShopId{};
  shared_ptr<string> name{};
  shared_ptr<string> src{};

  GetGuidePageResponseBodyMiniShopInfo() {}

  explicit GetGuidePageResponseBodyMiniShopInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (liteShopId) {
      res["LiteShopId"] = boost::any(*liteShopId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (src) {
      res["Src"] = boost::any(*src);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LiteShopId") != m.end() && !m["LiteShopId"].empty()) {
      liteShopId = make_shared<string>(boost::any_cast<string>(m["LiteShopId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Src") != m.end() && !m["Src"].empty()) {
      src = make_shared<string>(boost::any_cast<string>(m["Src"]));
    }
  }


  virtual ~GetGuidePageResponseBodyMiniShopInfo() = default;
};
class GetGuidePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<GetGuidePageResponseBodyMiniShopInfo>> miniShopInfo{};
  shared_ptr<string> requestId{};

  GetGuidePageResponseBody() {}

  explicit GetGuidePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (miniShopInfo) {
      vector<boost::any> temp1;
      for(auto item1:*miniShopInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MiniShopInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MiniShopInfo") != m.end() && !m["MiniShopInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["MiniShopInfo"].type()) {
        vector<GetGuidePageResponseBodyMiniShopInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MiniShopInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGuidePageResponseBodyMiniShopInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        miniShopInfo = make_shared<vector<GetGuidePageResponseBodyMiniShopInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetGuidePageResponseBody() = default;
};
class GetGuidePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGuidePageResponseBody> body{};

  GetGuidePageResponse() {}

  explicit GetGuidePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGuidePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGuidePageResponseBody>(model1);
      }
    }
  }


  virtual ~GetGuidePageResponse() = default;
};
class GetItemPromotionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};

  GetItemPromotionRequest() {}

  explicit GetItemPromotionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~GetItemPromotionRequest() = default;
};
class GetItemPromotionResponseBodyItemPromotionModel : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> promotionDesc{};
  shared_ptr<bool> promotionFlag{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};
  shared_ptr<map<string, boost::any>> skuPromotion{};
  shared_ptr<string> startTime{};

  GetItemPromotionResponseBodyItemPromotionModel() {}

  explicit GetItemPromotionResponseBodyItemPromotionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (promotionDesc) {
      res["PromotionDesc"] = boost::any(*promotionDesc);
    }
    if (promotionFlag) {
      res["PromotionFlag"] = boost::any(*promotionFlag);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (skuPromotion) {
      res["SkuPromotion"] = boost::any(*skuPromotion);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PromotionDesc") != m.end() && !m["PromotionDesc"].empty()) {
      promotionDesc = make_shared<string>(boost::any_cast<string>(m["PromotionDesc"]));
    }
    if (m.find("PromotionFlag") != m.end() && !m["PromotionFlag"].empty()) {
      promotionFlag = make_shared<bool>(boost::any_cast<bool>(m["PromotionFlag"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("SkuPromotion") != m.end() && !m["SkuPromotion"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SkuPromotion"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      skuPromotion = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetItemPromotionResponseBodyItemPromotionModel() = default;
};
class GetItemPromotionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetItemPromotionResponseBodyItemPromotionModel> itemPromotionModel{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  GetItemPromotionResponseBody() {}

  explicit GetItemPromotionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemPromotionModel) {
      res["ItemPromotionModel"] = itemPromotionModel ? boost::any(itemPromotionModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemPromotionModel") != m.end() && !m["ItemPromotionModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemPromotionModel"].type()) {
        GetItemPromotionResponseBodyItemPromotionModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemPromotionModel"]));
        itemPromotionModel = make_shared<GetItemPromotionResponseBodyItemPromotionModel>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetItemPromotionResponseBody() = default;
};
class GetItemPromotionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetItemPromotionResponseBody> body{};

  GetItemPromotionResponse() {}

  explicit GetItemPromotionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetItemPromotionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetItemPromotionResponseBody>(model1);
      }
    }
  }


  virtual ~GetItemPromotionResponse() = default;
};
class GetLoginPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> failUrl{};
  shared_ptr<string> targetUrl{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  GetLoginPageRequest() {}

  explicit GetLoginPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (failUrl) {
      res["FailUrl"] = boost::any(*failUrl);
    }
    if (targetUrl) {
      res["TargetUrl"] = boost::any(*targetUrl);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FailUrl") != m.end() && !m["FailUrl"].empty()) {
      failUrl = make_shared<string>(boost::any_cast<string>(m["FailUrl"]));
    }
    if (m.find("TargetUrl") != m.end() && !m["TargetUrl"].empty()) {
      targetUrl = make_shared<string>(boost::any_cast<string>(m["TargetUrl"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~GetLoginPageRequest() = default;
};
class GetLoginPageResponseBodyUrlData : public Darabonba::Model {
public:
  shared_ptr<string> returnUrl{};

  GetLoginPageResponseBodyUrlData() {}

  explicit GetLoginPageResponseBodyUrlData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (returnUrl) {
      res["ReturnUrl"] = boost::any(*returnUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReturnUrl") != m.end() && !m["ReturnUrl"].empty()) {
      returnUrl = make_shared<string>(boost::any_cast<string>(m["ReturnUrl"]));
    }
  }


  virtual ~GetLoginPageResponseBodyUrlData() = default;
};
class GetLoginPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetLoginPageResponseBodyUrlData> urlData{};

  GetLoginPageResponseBody() {}

  explicit GetLoginPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlData) {
      res["UrlData"] = urlData ? boost::any(urlData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlData") != m.end() && !m["UrlData"].empty()) {
      if (typeid(map<string, boost::any>) == m["UrlData"].type()) {
        GetLoginPageResponseBodyUrlData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UrlData"]));
        urlData = make_shared<GetLoginPageResponseBodyUrlData>(model1);
      }
    }
  }


  virtual ~GetLoginPageResponseBody() = default;
};
class GetLoginPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLoginPageResponseBody> body{};

  GetLoginPageResponse() {}

  explicit GetLoginPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLoginPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLoginPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetLoginPageResponse() = default;
};
class GetSwitchUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> url{};
  shared_ptr<bool> useAnonymousTbAccount{};

  GetSwitchUrlRequest() {}

  explicit GetSwitchUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~GetSwitchUrlRequest() = default;
};
class GetSwitchUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> url{};

  GetSwitchUrlResponseBody() {}

  explicit GetSwitchUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetSwitchUrlResponseBody() = default;
};
class GetSwitchUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSwitchUrlResponseBody> body{};

  GetSwitchUrlResponse() {}

  explicit GetSwitchUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSwitchUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSwitchUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetSwitchUrlResponse() = default;
};
class GetUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bizId{};
  shared_ptr<string> queryJson{};
  shared_ptr<string> userFlag{};

  GetUserInfoRequest() {}

  explicit GetUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (queryJson) {
      res["QueryJson"] = boost::any(*queryJson);
    }
    if (userFlag) {
      res["UserFlag"] = boost::any(*userFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("QueryJson") != m.end() && !m["QueryJson"].empty()) {
      queryJson = make_shared<string>(boost::any_cast<string>(m["QueryJson"]));
    }
    if (m.find("UserFlag") != m.end() && !m["UserFlag"].empty()) {
      userFlag = make_shared<string>(boost::any_cast<string>(m["UserFlag"]));
    }
  }


  virtual ~GetUserInfoRequest() = default;
};
class GetUserInfoResponseBodyLoginResult : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> bizUserName{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> lmUserId{};
  shared_ptr<string> returnUrl{};
  shared_ptr<vector<string>> subBizId{};

  GetUserInfoResponseBodyLoginResult() {}

  explicit GetUserInfoResponseBodyLoginResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (bizUserName) {
      res["BizUserName"] = boost::any(*bizUserName);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmUserId) {
      res["LmUserId"] = boost::any(*lmUserId);
    }
    if (returnUrl) {
      res["ReturnUrl"] = boost::any(*returnUrl);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BizUserName") != m.end() && !m["BizUserName"].empty()) {
      bizUserName = make_shared<string>(boost::any_cast<string>(m["BizUserName"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmUserId") != m.end() && !m["LmUserId"].empty()) {
      lmUserId = make_shared<long>(boost::any_cast<long>(m["LmUserId"]));
    }
    if (m.find("ReturnUrl") != m.end() && !m["ReturnUrl"].empty()) {
      returnUrl = make_shared<string>(boost::any_cast<string>(m["ReturnUrl"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubBizId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubBizId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subBizId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetUserInfoResponseBodyLoginResult() = default;
};
class GetUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserInfoResponseBodyLoginResult> loginResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetUserInfoResponseBody() {}

  explicit GetUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (loginResult) {
      res["LoginResult"] = loginResult ? boost::any(loginResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LoginResult") != m.end() && !m["LoginResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoginResult"].type()) {
        GetUserInfoResponseBodyLoginResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoginResult"]));
        loginResult = make_shared<GetUserInfoResponseBodyLoginResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUserInfoResponseBody() = default;
};
class GetUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserInfoResponseBody> body{};

  GetUserInfoResponse() {}

  explicit GetUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserInfoResponse() = default;
};
class GetUserTokenPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> expireSeconds{};
  shared_ptr<string> extJson{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> userNick{};

  GetUserTokenPageRequest() {}

  explicit GetUserTokenPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (expireSeconds) {
      res["ExpireSeconds"] = boost::any(*expireSeconds);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (userNick) {
      res["UserNick"] = boost::any(*userNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExpireSeconds") != m.end() && !m["ExpireSeconds"].empty()) {
      expireSeconds = make_shared<long>(boost::any_cast<long>(m["ExpireSeconds"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UserNick") != m.end() && !m["UserNick"].empty()) {
      userNick = make_shared<string>(boost::any_cast<string>(m["UserNick"]));
    }
  }


  virtual ~GetUserTokenPageRequest() = default;
};
class GetUserTokenPageResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  GetUserTokenPageResponseBodyModel() {}

  explicit GetUserTokenPageResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetUserTokenPageResponseBodyModel() = default;
};
class GetUserTokenPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GetUserTokenPageResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  GetUserTokenPageResponseBody() {}

  explicit GetUserTokenPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        GetUserTokenPageResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<GetUserTokenPageResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUserTokenPageResponseBody() = default;
};
class GetUserTokenPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserTokenPageResponseBody> body{};

  GetUserTokenPageResponse() {}

  explicit GetUserTokenPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserTokenPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserTokenPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserTokenPageResponse() = default;
};
class GetWithholdSignPageUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> externalAgreementNo{};
  shared_ptr<string> identityParameters{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> merchantServiceDescription{};
  shared_ptr<string> merchantServiceName{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> returnUrl{};

  GetWithholdSignPageUrlRequest() {}

  explicit GetWithholdSignPageUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (externalAgreementNo) {
      res["ExternalAgreementNo"] = boost::any(*externalAgreementNo);
    }
    if (identityParameters) {
      res["IdentityParameters"] = boost::any(*identityParameters);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (merchantServiceDescription) {
      res["MerchantServiceDescription"] = boost::any(*merchantServiceDescription);
    }
    if (merchantServiceName) {
      res["MerchantServiceName"] = boost::any(*merchantServiceName);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (returnUrl) {
      res["ReturnUrl"] = boost::any(*returnUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("ExternalAgreementNo") != m.end() && !m["ExternalAgreementNo"].empty()) {
      externalAgreementNo = make_shared<string>(boost::any_cast<string>(m["ExternalAgreementNo"]));
    }
    if (m.find("IdentityParameters") != m.end() && !m["IdentityParameters"].empty()) {
      identityParameters = make_shared<string>(boost::any_cast<string>(m["IdentityParameters"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("MerchantServiceDescription") != m.end() && !m["MerchantServiceDescription"].empty()) {
      merchantServiceDescription = make_shared<string>(boost::any_cast<string>(m["MerchantServiceDescription"]));
    }
    if (m.find("MerchantServiceName") != m.end() && !m["MerchantServiceName"].empty()) {
      merchantServiceName = make_shared<string>(boost::any_cast<string>(m["MerchantServiceName"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("ReturnUrl") != m.end() && !m["ReturnUrl"].empty()) {
      returnUrl = make_shared<string>(boost::any_cast<string>(m["ReturnUrl"]));
    }
  }


  virtual ~GetWithholdSignPageUrlRequest() = default;
};
class GetWithholdSignPageUrlResponseBodyWithholdSignResponse : public Darabonba::Model {
public:
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> pageUrl{};

  GetWithholdSignPageUrlResponseBodyWithholdSignResponse() {}

  explicit GetWithholdSignPageUrlResponseBodyWithholdSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (pageUrl) {
      res["PageUrl"] = boost::any(*pageUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("PageUrl") != m.end() && !m["PageUrl"].empty()) {
      pageUrl = make_shared<string>(boost::any_cast<string>(m["PageUrl"]));
    }
  }


  virtual ~GetWithholdSignPageUrlResponseBodyWithholdSignResponse() = default;
};
class GetWithholdSignPageUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetWithholdSignPageUrlResponseBodyWithholdSignResponse> withholdSignResponse{};

  GetWithholdSignPageUrlResponseBody() {}

  explicit GetWithholdSignPageUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (withholdSignResponse) {
      res["WithholdSignResponse"] = withholdSignResponse ? boost::any(withholdSignResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WithholdSignResponse") != m.end() && !m["WithholdSignResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["WithholdSignResponse"].type()) {
        GetWithholdSignPageUrlResponseBodyWithholdSignResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WithholdSignResponse"]));
        withholdSignResponse = make_shared<GetWithholdSignPageUrlResponseBodyWithholdSignResponse>(model1);
      }
    }
  }


  virtual ~GetWithholdSignPageUrlResponseBody() = default;
};
class GetWithholdSignPageUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWithholdSignPageUrlResponseBody> body{};

  GetWithholdSignPageUrlResponse() {}

  explicit GetWithholdSignPageUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWithholdSignPageUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWithholdSignPageUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetWithholdSignPageUrlResponse() = default;
};
class GiveUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> targetBizUid{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  GiveUserPointRequest() {}

  explicit GiveUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (targetBizUid) {
      res["TargetBizUid"] = boost::any(*targetBizUid);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TargetBizUid") != m.end() && !m["TargetBizUid"].empty()) {
      targetBizUid = make_shared<string>(boost::any_cast<string>(m["TargetBizUid"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GiveUserPointRequest() = default;
};
class GiveUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> targetBizUid{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  GiveUserPointShrinkRequest() {}

  explicit GiveUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (targetBizUid) {
      res["TargetBizUid"] = boost::any(*targetBizUid);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TargetBizUid") != m.end() && !m["TargetBizUid"].empty()) {
      targetBizUid = make_shared<string>(boost::any_cast<string>(m["TargetBizUid"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GiveUserPointShrinkRequest() = default;
};
class GiveUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  GiveUserPointResponseBodyModel() {}

  explicit GiveUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GiveUserPointResponseBodyModel() = default;
};
class GiveUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GiveUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  GiveUserPointResponseBody() {}

  explicit GiveUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        GiveUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<GiveUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GiveUserPointResponseBody() = default;
};
class GiveUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GiveUserPointResponseBody> body{};

  GiveUserPointResponse() {}

  explicit GiveUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GiveUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GiveUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~GiveUserPointResponse() = default;
};
class GrantPromotionToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> expireSeconds{};
  shared_ptr<string> grantMode{};
  shared_ptr<string> grantWay{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> securityCode{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<map<string, boost::any>> body{};

  GrantPromotionToUserRequest() {}

  explicit GrantPromotionToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (expireSeconds) {
      res["ExpireSeconds"] = boost::any(*expireSeconds);
    }
    if (grantMode) {
      res["GrantMode"] = boost::any(*grantMode);
    }
    if (grantWay) {
      res["GrantWay"] = boost::any(*grantWay);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (securityCode) {
      res["SecurityCode"] = boost::any(*securityCode);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExpireSeconds") != m.end() && !m["ExpireSeconds"].empty()) {
      expireSeconds = make_shared<long>(boost::any_cast<long>(m["ExpireSeconds"]));
    }
    if (m.find("GrantMode") != m.end() && !m["GrantMode"].empty()) {
      grantMode = make_shared<string>(boost::any_cast<string>(m["GrantMode"]));
    }
    if (m.find("GrantWay") != m.end() && !m["GrantWay"].empty()) {
      grantWay = make_shared<string>(boost::any_cast<string>(m["GrantWay"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("SecurityCode") != m.end() && !m["SecurityCode"].empty()) {
      securityCode = make_shared<string>(boost::any_cast<string>(m["SecurityCode"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GrantPromotionToUserRequest() = default;
};
class GrantPromotionToUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> expireSeconds{};
  shared_ptr<string> grantMode{};
  shared_ptr<string> grantWay{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> securityCode{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> bodyShrink{};

  GrantPromotionToUserShrinkRequest() {}

  explicit GrantPromotionToUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (expireSeconds) {
      res["ExpireSeconds"] = boost::any(*expireSeconds);
    }
    if (grantMode) {
      res["GrantMode"] = boost::any(*grantMode);
    }
    if (grantWay) {
      res["GrantWay"] = boost::any(*grantWay);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (securityCode) {
      res["SecurityCode"] = boost::any(*securityCode);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (bodyShrink) {
      res["body"] = boost::any(*bodyShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExpireSeconds") != m.end() && !m["ExpireSeconds"].empty()) {
      expireSeconds = make_shared<long>(boost::any_cast<long>(m["ExpireSeconds"]));
    }
    if (m.find("GrantMode") != m.end() && !m["GrantMode"].empty()) {
      grantMode = make_shared<string>(boost::any_cast<string>(m["GrantMode"]));
    }
    if (m.find("GrantWay") != m.end() && !m["GrantWay"].empty()) {
      grantWay = make_shared<string>(boost::any_cast<string>(m["GrantWay"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("SecurityCode") != m.end() && !m["SecurityCode"].empty()) {
      securityCode = make_shared<string>(boost::any_cast<string>(m["SecurityCode"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      bodyShrink = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~GrantPromotionToUserShrinkRequest() = default;
};
class GrantPromotionToUserResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> effectiveEndTime{};
  shared_ptr<long> effectiveStartTime{};
  shared_ptr<string> promotionInstanceId{};
  shared_ptr<string> subBizCode{};
  shared_ptr<bool> success{};

  GrantPromotionToUserResponseBodyModel() {}

  explicit GrantPromotionToUserResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveEndTime) {
      res["EffectiveEndTime"] = boost::any(*effectiveEndTime);
    }
    if (effectiveStartTime) {
      res["EffectiveStartTime"] = boost::any(*effectiveStartTime);
    }
    if (promotionInstanceId) {
      res["PromotionInstanceId"] = boost::any(*promotionInstanceId);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveEndTime") != m.end() && !m["EffectiveEndTime"].empty()) {
      effectiveEndTime = make_shared<long>(boost::any_cast<long>(m["EffectiveEndTime"]));
    }
    if (m.find("EffectiveStartTime") != m.end() && !m["EffectiveStartTime"].empty()) {
      effectiveStartTime = make_shared<long>(boost::any_cast<long>(m["EffectiveStartTime"]));
    }
    if (m.find("PromotionInstanceId") != m.end() && !m["PromotionInstanceId"].empty()) {
      promotionInstanceId = make_shared<string>(boost::any_cast<string>(m["PromotionInstanceId"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GrantPromotionToUserResponseBodyModel() = default;
};
class GrantPromotionToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GrantPromotionToUserResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  GrantPromotionToUserResponseBody() {}

  explicit GrantPromotionToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        GrantPromotionToUserResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<GrantPromotionToUserResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantPromotionToUserResponseBody() = default;
};
class GrantPromotionToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantPromotionToUserResponseBody> body{};

  GrantPromotionToUserResponse() {}

  explicit GrantPromotionToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantPromotionToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantPromotionToUserResponseBody>(model1);
      }
    }
  }


  virtual ~GrantPromotionToUserResponse() = default;
};
class GrantUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  GrantUserPointRequest() {}

  explicit GrantUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GrantUserPointRequest() = default;
};
class GrantUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  GrantUserPointShrinkRequest() {}

  explicit GrantUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GrantUserPointShrinkRequest() = default;
};
class GrantUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  GrantUserPointResponseBodyModel() {}

  explicit GrantUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GrantUserPointResponseBodyModel() = default;
};
class GrantUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<GrantUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  GrantUserPointResponseBody() {}

  explicit GrantUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        GrantUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<GrantUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantUserPointResponseBody() = default;
};
class GrantUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantUserPointResponseBody> body{};

  GrantUserPointResponse() {}

  explicit GrantUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~GrantUserPointResponse() = default;
};
class InitApplyRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  InitApplyRefundRequest() {}

  explicit InitApplyRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~InitApplyRefundRequest() = default;
};
class InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData() {}

  explicit InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData() = default;
};
class InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<bool> proofRequired{};
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};
  shared_ptr<bool> refundDescRequired{};

  InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList() {}

  explicit InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proofRequired) {
      res["ProofRequired"] = boost::any(*proofRequired);
    }
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    if (refundDescRequired) {
      res["RefundDescRequired"] = boost::any(*refundDescRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProofRequired") != m.end() && !m["ProofRequired"].empty()) {
      proofRequired = make_shared<bool>(boost::any_cast<bool>(m["ProofRequired"]));
    }
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
    if (m.find("RefundDescRequired") != m.end() && !m["RefundDescRequired"].empty()) {
      refundDescRequired = make_shared<bool>(boost::any_cast<bool>(m["RefundDescRequired"]));
    }
  }


  virtual ~InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList() = default;
};
class InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<vector<InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList>> refundReasonList{};

  InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList() {}

  explicit InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refundReasonList) {
      vector<boost::any> temp1;
      for(auto item1:*refundReasonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RefundReasonList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RefundReasonList"].type()) {
        vector<InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RefundReasonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundReasonList = make_shared<vector<InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList>>(expect1);
      }
    }
  }


  virtual ~InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList() = default;
};
class InitApplyRefundResponseBodyInitApplyRefundData : public Darabonba::Model {
public:
  shared_ptr<long> bizClaimType{};
  shared_ptr<bool> mainOrderRefund{};
  shared_ptr<InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList> refundReasonList{};

  InitApplyRefundResponseBodyInitApplyRefundData() {}

  explicit InitApplyRefundResponseBodyInitApplyRefundData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (mainOrderRefund) {
      res["MainOrderRefund"] = boost::any(*mainOrderRefund);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundReasonList) {
      res["RefundReasonList"] = refundReasonList ? boost::any(refundReasonList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("MainOrderRefund") != m.end() && !m["MainOrderRefund"].empty()) {
      mainOrderRefund = make_shared<bool>(boost::any_cast<bool>(m["MainOrderRefund"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<InitApplyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData>(model1);
      }
    }
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundReasonList"].type()) {
        InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundReasonList"]));
        refundReasonList = make_shared<InitApplyRefundResponseBodyInitApplyRefundDataRefundReasonList>(model1);
      }
    }
  }


  virtual ~InitApplyRefundResponseBodyInitApplyRefundData() = default;
};
class InitApplyRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InitApplyRefundResponseBodyInitApplyRefundData> initApplyRefundData{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subLmOrderId{};

  InitApplyRefundResponseBody() {}

  explicit InitApplyRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (initApplyRefundData) {
      res["InitApplyRefundData"] = initApplyRefundData ? boost::any(initApplyRefundData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InitApplyRefundData") != m.end() && !m["InitApplyRefundData"].empty()) {
      if (typeid(map<string, boost::any>) == m["InitApplyRefundData"].type()) {
        InitApplyRefundResponseBodyInitApplyRefundData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InitApplyRefundData"]));
        initApplyRefundData = make_shared<InitApplyRefundResponseBodyInitApplyRefundData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~InitApplyRefundResponseBody() = default;
};
class InitApplyRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitApplyRefundResponseBody> body{};

  InitApplyRefundResponse() {}

  explicit InitApplyRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitApplyRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitApplyRefundResponseBody>(model1);
      }
    }
  }


  virtual ~InitApplyRefundResponse() = default;
};
class InitApplyRefundWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> refundCode{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  InitApplyRefundWithDesignatedTbUidRequest() {}

  explicit InitApplyRefundWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidRequest() = default;
};
class InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() {}

  explicit InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() = default;
};
class InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<bool> proofRequired{};
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};
  shared_ptr<bool> refundDescRequired{};

  InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList() {}

  explicit InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proofRequired) {
      res["ProofRequired"] = boost::any(*proofRequired);
    }
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    if (refundDescRequired) {
      res["RefundDescRequired"] = boost::any(*refundDescRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProofRequired") != m.end() && !m["ProofRequired"].empty()) {
      proofRequired = make_shared<bool>(boost::any_cast<bool>(m["ProofRequired"]));
    }
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
    if (m.find("RefundDescRequired") != m.end() && !m["RefundDescRequired"].empty()) {
      refundDescRequired = make_shared<bool>(boost::any_cast<bool>(m["RefundDescRequired"]));
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList() = default;
};
class InitApplyRefundWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<bool> mainOrderRefund{};
  shared_ptr<InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<vector<InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList>> refundReasonList{};

  InitApplyRefundWithDesignatedTbUidResponseBodyModel() {}

  explicit InitApplyRefundWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (mainOrderRefund) {
      res["MainOrderRefund"] = boost::any(*mainOrderRefund);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundReasonList) {
      vector<boost::any> temp1;
      for(auto item1:*refundReasonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RefundReasonList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("MainOrderRefund") != m.end() && !m["MainOrderRefund"].empty()) {
      mainOrderRefund = make_shared<bool>(boost::any_cast<bool>(m["MainOrderRefund"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<InitApplyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData>(model1);
      }
    }
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RefundReasonList"].type()) {
        vector<InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RefundReasonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundReasonList = make_shared<vector<InitApplyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList>>(expect1);
      }
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidResponseBodyModel() = default;
};
class InitApplyRefundWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<InitApplyRefundWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  InitApplyRefundWithDesignatedTbUidResponseBody() {}

  explicit InitApplyRefundWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        InitApplyRefundWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<InitApplyRefundWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidResponseBody() = default;
};
class InitApplyRefundWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitApplyRefundWithDesignatedTbUidResponseBody> body{};

  InitApplyRefundWithDesignatedTbUidResponse() {}

  explicit InitApplyRefundWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitApplyRefundWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitApplyRefundWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~InitApplyRefundWithDesignatedTbUidResponse() = default;
};
class InitModifyRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  InitModifyRefundRequest() {}

  explicit InitModifyRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~InitModifyRefundRequest() = default;
};
class InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData() {}

  explicit InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData() = default;
};
class InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<bool> proofRequired{};
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};
  shared_ptr<bool> refundDescRequired{};

  InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList() {}

  explicit InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proofRequired) {
      res["ProofRequired"] = boost::any(*proofRequired);
    }
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    if (refundDescRequired) {
      res["RefundDescRequired"] = boost::any(*refundDescRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProofRequired") != m.end() && !m["ProofRequired"].empty()) {
      proofRequired = make_shared<bool>(boost::any_cast<bool>(m["ProofRequired"]));
    }
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
    if (m.find("RefundDescRequired") != m.end() && !m["RefundDescRequired"].empty()) {
      refundDescRequired = make_shared<bool>(boost::any_cast<bool>(m["RefundDescRequired"]));
    }
  }


  virtual ~InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList() = default;
};
class InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<vector<InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList>> refundReasonList{};

  InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList() {}

  explicit InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refundReasonList) {
      vector<boost::any> temp1;
      for(auto item1:*refundReasonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RefundReasonList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RefundReasonList"].type()) {
        vector<InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RefundReasonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundReasonList = make_shared<vector<InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonListRefundReasonList>>(expect1);
      }
    }
  }


  virtual ~InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList() = default;
};
class InitModifyRefundResponseBodyInitApplyRefundData : public Darabonba::Model {
public:
  shared_ptr<long> bizClaimType{};
  shared_ptr<bool> mainOrderRefund{};
  shared_ptr<InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList> refundReasonList{};

  InitModifyRefundResponseBodyInitApplyRefundData() {}

  explicit InitModifyRefundResponseBodyInitApplyRefundData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (mainOrderRefund) {
      res["MainOrderRefund"] = boost::any(*mainOrderRefund);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundReasonList) {
      res["RefundReasonList"] = refundReasonList ? boost::any(refundReasonList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("MainOrderRefund") != m.end() && !m["MainOrderRefund"].empty()) {
      mainOrderRefund = make_shared<bool>(boost::any_cast<bool>(m["MainOrderRefund"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<InitModifyRefundResponseBodyInitApplyRefundDataMaxRefundFeeData>(model1);
      }
    }
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundReasonList"].type()) {
        InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundReasonList"]));
        refundReasonList = make_shared<InitModifyRefundResponseBodyInitApplyRefundDataRefundReasonList>(model1);
      }
    }
  }


  virtual ~InitModifyRefundResponseBodyInitApplyRefundData() = default;
};
class InitModifyRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InitModifyRefundResponseBodyInitApplyRefundData> initApplyRefundData{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subLmOrderId{};

  InitModifyRefundResponseBody() {}

  explicit InitModifyRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (initApplyRefundData) {
      res["InitApplyRefundData"] = initApplyRefundData ? boost::any(initApplyRefundData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("InitApplyRefundData") != m.end() && !m["InitApplyRefundData"].empty()) {
      if (typeid(map<string, boost::any>) == m["InitApplyRefundData"].type()) {
        InitModifyRefundResponseBodyInitApplyRefundData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InitApplyRefundData"]));
        initApplyRefundData = make_shared<InitModifyRefundResponseBodyInitApplyRefundData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~InitModifyRefundResponseBody() = default;
};
class InitModifyRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitModifyRefundResponseBody> body{};

  InitModifyRefundResponse() {}

  explicit InitModifyRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitModifyRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitModifyRefundResponseBody>(model1);
      }
    }
  }


  virtual ~InitModifyRefundResponse() = default;
};
class InitModifyRefundWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> refundCode{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  InitModifyRefundWithDesignatedTbUidRequest() {}

  explicit InitModifyRefundWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidRequest() = default;
};
class InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() {}

  explicit InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() = default;
};
class InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList : public Darabonba::Model {
public:
  shared_ptr<bool> proofRequired{};
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};
  shared_ptr<bool> refundDescRequired{};

  InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList() {}

  explicit InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proofRequired) {
      res["ProofRequired"] = boost::any(*proofRequired);
    }
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    if (refundDescRequired) {
      res["RefundDescRequired"] = boost::any(*refundDescRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProofRequired") != m.end() && !m["ProofRequired"].empty()) {
      proofRequired = make_shared<bool>(boost::any_cast<bool>(m["ProofRequired"]));
    }
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
    if (m.find("RefundDescRequired") != m.end() && !m["RefundDescRequired"].empty()) {
      refundDescRequired = make_shared<bool>(boost::any_cast<bool>(m["RefundDescRequired"]));
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList() = default;
};
class InitModifyRefundWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<bool> mainOrderRefund{};
  shared_ptr<InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<vector<InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList>> refundReasonList{};

  InitModifyRefundWithDesignatedTbUidResponseBodyModel() {}

  explicit InitModifyRefundWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (mainOrderRefund) {
      res["MainOrderRefund"] = boost::any(*mainOrderRefund);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundReasonList) {
      vector<boost::any> temp1;
      for(auto item1:*refundReasonList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RefundReasonList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("MainOrderRefund") != m.end() && !m["MainOrderRefund"].empty()) {
      mainOrderRefund = make_shared<bool>(boost::any_cast<bool>(m["MainOrderRefund"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<InitModifyRefundWithDesignatedTbUidResponseBodyModelMaxRefundFeeData>(model1);
      }
    }
    if (m.find("RefundReasonList") != m.end() && !m["RefundReasonList"].empty()) {
      if (typeid(vector<boost::any>) == m["RefundReasonList"].type()) {
        vector<InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RefundReasonList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        refundReasonList = make_shared<vector<InitModifyRefundWithDesignatedTbUidResponseBodyModelRefundReasonList>>(expect1);
      }
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidResponseBodyModel() = default;
};
class InitModifyRefundWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<InitModifyRefundWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  InitModifyRefundWithDesignatedTbUidResponseBody() {}

  explicit InitModifyRefundWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        InitModifyRefundWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<InitModifyRefundWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidResponseBody() = default;
};
class InitModifyRefundWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitModifyRefundWithDesignatedTbUidResponseBody> body{};

  InitModifyRefundWithDesignatedTbUidResponse() {}

  explicit InitModifyRefundWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitModifyRefundWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitModifyRefundWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~InitModifyRefundWithDesignatedTbUidResponse() = default;
};
class ListActivityAtmosphereRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> gameId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> thirdPartyUserId{};

  ListActivityAtmosphereRequest() {}

  explicit ListActivityAtmosphereRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ListActivityAtmosphereRequest() = default;
};
class ListActivityAtmosphereResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> bizUid{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};

  ListActivityAtmosphereResponseBodyModel() {}

  explicit ListActivityAtmosphereResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListActivityAtmosphereResponseBodyModel() = default;
};
class ListActivityAtmosphereResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListActivityAtmosphereResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListActivityAtmosphereResponseBody() {}

  explicit ListActivityAtmosphereResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<ListActivityAtmosphereResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivityAtmosphereResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<ListActivityAtmosphereResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListActivityAtmosphereResponseBody() = default;
};
class ListActivityAtmosphereResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListActivityAtmosphereResponseBody> body{};

  ListActivityAtmosphereResponse() {}

  explicit ListActivityAtmosphereResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListActivityAtmosphereResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListActivityAtmosphereResponseBody>(model1);
      }
    }
  }


  virtual ~ListActivityAtmosphereResponse() = default;
};
class ListActivityGameInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> gameId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> statuses{};
  shared_ptr<string> subType{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> type{};

  ListActivityGameInfoRequest() {}

  explicit ListActivityGameInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statuses = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListActivityGameInfoRequest() = default;
};
class ListActivityGameInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameShowInfo{};

  ListActivityGameInfoResponseBodyModel() {}

  explicit ListActivityGameInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameShowInfo) {
      res["GameShowInfo"] = boost::any(*gameShowInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameShowInfo") != m.end() && !m["GameShowInfo"].empty()) {
      gameShowInfo = make_shared<string>(boost::any_cast<string>(m["GameShowInfo"]));
    }
  }


  virtual ~ListActivityGameInfoResponseBodyModel() = default;
};
class ListActivityGameInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListActivityGameInfoResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListActivityGameInfoResponseBody() {}

  explicit ListActivityGameInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<ListActivityGameInfoResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActivityGameInfoResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<ListActivityGameInfoResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListActivityGameInfoResponseBody() = default;
};
class ListActivityGameInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListActivityGameInfoResponseBody> body{};

  ListActivityGameInfoResponse() {}

  explicit ListActivityGameInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListActivityGameInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListActivityGameInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ListActivityGameInfoResponse() = default;
};
class ListItemActivitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> itemIds{};
  shared_ptr<map<string, boost::any>> lmItemIds{};

  ListItemActivitiesRequest() {}

  explicit ListItemActivitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      itemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LmItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lmItemIds = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListItemActivitiesRequest() = default;
};
class ListItemActivitiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};

  ListItemActivitiesShrinkRequest() {}

  explicit ListItemActivitiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
  }


  virtual ~ListItemActivitiesShrinkRequest() = default;
};
class ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> displayDate{};
  shared_ptr<string> endDate{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> id{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subBizCode{};
  shared_ptr<string> title{};

  ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel() {}

  explicit ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<string>(boost::any_cast<string>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel() = default;
};
class ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel> lmActivityPopModel{};
  shared_ptr<string> lmItemId{};

  ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel() {}

  explicit ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivityPopModel) {
      res["LmActivityPopModel"] = lmActivityPopModel ? boost::any(lmActivityPopModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivityPopModel") != m.end() && !m["LmActivityPopModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivityPopModel"].type()) {
        ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivityPopModel"]));
        lmActivityPopModel = make_shared<ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModelLmActivityPopModel>(model1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel() = default;
};
class ListItemActivitiesResponseBodyLmItemActivityModelList : public Darabonba::Model {
public:
  shared_ptr<vector<ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel>> lmItemActivityModel{};

  ListItemActivitiesResponseBodyLmItemActivityModelList() {}

  explicit ListItemActivitiesResponseBodyLmItemActivityModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmItemActivityModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemActivityModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemActivityModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmItemActivityModel") != m.end() && !m["LmItemActivityModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemActivityModel"].type()) {
        vector<ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemActivityModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemActivityModel = make_shared<vector<ListItemActivitiesResponseBodyLmItemActivityModelListLmItemActivityModel>>(expect1);
      }
    }
  }


  virtual ~ListItemActivitiesResponseBodyLmItemActivityModelList() = default;
};
class ListItemActivitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListItemActivitiesResponseBodyLmItemActivityModelList> lmItemActivityModelList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListItemActivitiesResponseBody() {}

  explicit ListItemActivitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmItemActivityModelList) {
      res["LmItemActivityModelList"] = lmItemActivityModelList ? boost::any(lmItemActivityModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmItemActivityModelList") != m.end() && !m["LmItemActivityModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmItemActivityModelList"].type()) {
        ListItemActivitiesResponseBodyLmItemActivityModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmItemActivityModelList"]));
        lmItemActivityModelList = make_shared<ListItemActivitiesResponseBodyLmItemActivityModelList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListItemActivitiesResponseBody() = default;
};
class ListItemActivitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListItemActivitiesResponseBody> body{};

  ListItemActivitiesResponse() {}

  explicit ListItemActivitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListItemActivitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListItemActivitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListItemActivitiesResponse() = default;
};
class ListUserGameProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> gameId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> statuses{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> type{};

  ListUserGameProcessRequest() {}

  explicit ListUserGameProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statuses = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUserGameProcessRequest() = default;
};
class ListUserGameProcessResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> currentShowContent{};
  shared_ptr<string> currentStepId{};
  shared_ptr<string> currentStepStatus{};
  shared_ptr<string> desc{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> processId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListUserGameProcessResponseBodyModel() {}

  explicit ListUserGameProcessResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentShowContent) {
      res["CurrentShowContent"] = boost::any(*currentShowContent);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (currentStepStatus) {
      res["CurrentStepStatus"] = boost::any(*currentStepStatus);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CurrentShowContent") != m.end() && !m["CurrentShowContent"].empty()) {
      currentShowContent = make_shared<string>(boost::any_cast<string>(m["CurrentShowContent"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("CurrentStepStatus") != m.end() && !m["CurrentStepStatus"].empty()) {
      currentStepStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStepStatus"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListUserGameProcessResponseBodyModel() = default;
};
class ListUserGameProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListUserGameProcessResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListUserGameProcessResponseBody() {}

  explicit ListUserGameProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<ListUserGameProcessResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserGameProcessResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<ListUserGameProcessResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserGameProcessResponseBody() = default;
};
class ListUserGameProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserGameProcessResponseBody> body{};

  ListUserGameProcessResponse() {}

  explicit ListUserGameProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserGameProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserGameProcessResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserGameProcessResponse() = default;
};
class ListUserPointRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pointAction{};
  shared_ptr<string> pointActions{};
  shared_ptr<string> recordId{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> thirdPartyUserId{};

  ListUserPointRecordsRequest() {}

  explicit ListUserPointRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pointAction) {
      res["PointAction"] = boost::any(*pointAction);
    }
    if (pointActions) {
      res["PointActions"] = boost::any(*pointActions);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PointAction") != m.end() && !m["PointAction"].empty()) {
      pointAction = make_shared<string>(boost::any_cast<string>(m["PointAction"]));
    }
    if (m.find("PointActions") != m.end() && !m["PointActions"].empty()) {
      pointActions = make_shared<string>(boost::any_cast<string>(m["PointActions"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ListUserPointRecordsRequest() = default;
};
class ListUserPointRecordsResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  ListUserPointRecordsResponseBodyModel() {}

  explicit ListUserPointRecordsResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListUserPointRecordsResponseBodyModel() = default;
};
class ListUserPointRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListUserPointRecordsResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListUserPointRecordsResponseBody() {}

  explicit ListUserPointRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<ListUserPointRecordsResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserPointRecordsResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<ListUserPointRecordsResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserPointRecordsResponseBody() = default;
};
class ListUserPointRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserPointRecordsResponseBody> body{};

  ListUserPointRecordsResponse() {}

  explicit ListUserPointRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserPointRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserPointRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserPointRecordsResponse() = default;
};
class ModifyBasicAndBizItemsRequestItemListSkuList : public Darabonba::Model {
public:
  shared_ptr<string> benefitId{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};
  shared_ptr<long> statusAction{};
  shared_ptr<long> supplierPrice{};

  ModifyBasicAndBizItemsRequestItemListSkuList() {}

  explicit ModifyBasicAndBizItemsRequestItemListSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (benefitId) {
      res["BenefitId"] = boost::any(*benefitId);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (statusAction) {
      res["StatusAction"] = boost::any(*statusAction);
    }
    if (supplierPrice) {
      res["SupplierPrice"] = boost::any(*supplierPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BenefitId") != m.end() && !m["BenefitId"].empty()) {
      benefitId = make_shared<string>(boost::any_cast<string>(m["BenefitId"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("StatusAction") != m.end() && !m["StatusAction"].empty()) {
      statusAction = make_shared<long>(boost::any_cast<long>(m["StatusAction"]));
    }
    if (m.find("SupplierPrice") != m.end() && !m["SupplierPrice"].empty()) {
      supplierPrice = make_shared<long>(boost::any_cast<long>(m["SupplierPrice"]));
    }
  }


  virtual ~ModifyBasicAndBizItemsRequestItemListSkuList() = default;
};
class ModifyBasicAndBizItemsRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<vector<ModifyBasicAndBizItemsRequestItemListSkuList>> skuList{};

  ModifyBasicAndBizItemsRequestItemList() {}

  explicit ModifyBasicAndBizItemsRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuList) {
      vector<boost::any> temp1;
      for(auto item1:*skuList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkuList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkuList"].type()) {
        vector<ModifyBasicAndBizItemsRequestItemListSkuList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkuList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBasicAndBizItemsRequestItemListSkuList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skuList = make_shared<vector<ModifyBasicAndBizItemsRequestItemListSkuList>>(expect1);
      }
    }
  }


  virtual ~ModifyBasicAndBizItemsRequestItemList() = default;
};
class ModifyBasicAndBizItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<ModifyBasicAndBizItemsRequestItemList>> itemList{};
  shared_ptr<string> subBizId{};

  ModifyBasicAndBizItemsRequest() {}

  explicit ModifyBasicAndBizItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<ModifyBasicAndBizItemsRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBasicAndBizItemsRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<ModifyBasicAndBizItemsRequestItemList>>(expect1);
      }
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~ModifyBasicAndBizItemsRequest() = default;
};
class ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sku{};

  ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList() {}

  explicit ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      res["Sku"] = boost::any(*sku);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sku"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sku = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList() = default;
};
class ModifyBasicAndBizItemsResponseBodyFailedItemListItem : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList> skuIdList{};

  ModifyBasicAndBizItemsResponseBodyFailedItemListItem() {}

  explicit ModifyBasicAndBizItemsResponseBodyFailedItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuIdList) {
      res["SkuIdList"] = skuIdList ? boost::any(skuIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuIdList") != m.end() && !m["SkuIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuIdList"].type()) {
        ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuIdList"]));
        skuIdList = make_shared<ModifyBasicAndBizItemsResponseBodyFailedItemListItemSkuIdList>(model1);
      }
    }
  }


  virtual ~ModifyBasicAndBizItemsResponseBodyFailedItemListItem() = default;
};
class ModifyBasicAndBizItemsResponseBodyFailedItemList : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyBasicAndBizItemsResponseBodyFailedItemListItem>> item{};

  ModifyBasicAndBizItemsResponseBodyFailedItemList() {}

  explicit ModifyBasicAndBizItemsResponseBodyFailedItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ModifyBasicAndBizItemsResponseBodyFailedItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBasicAndBizItemsResponseBodyFailedItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ModifyBasicAndBizItemsResponseBodyFailedItemListItem>>(expect1);
      }
    }
  }


  virtual ~ModifyBasicAndBizItemsResponseBodyFailedItemList() = default;
};
class ModifyBasicAndBizItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifyBasicAndBizItemsResponseBodyFailedItemList> failedItemList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyBasicAndBizItemsResponseBody() {}

  explicit ModifyBasicAndBizItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failedItemList) {
      res["FailedItemList"] = failedItemList ? boost::any(failedItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailedItemList") != m.end() && !m["FailedItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedItemList"].type()) {
        ModifyBasicAndBizItemsResponseBodyFailedItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedItemList"]));
        failedItemList = make_shared<ModifyBasicAndBizItemsResponseBodyFailedItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBasicAndBizItemsResponseBody() = default;
};
class ModifyBasicAndBizItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBasicAndBizItemsResponseBody> body{};

  ModifyBasicAndBizItemsResponse() {}

  explicit ModifyBasicAndBizItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBasicAndBizItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBasicAndBizItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBasicAndBizItemsResponse() = default;
};
class ModifyBasicItemSupplierPriceRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmShopId{};
  shared_ptr<long> skuId{};
  shared_ptr<long> supplierPrice{};

  ModifyBasicItemSupplierPriceRequest() {}

  explicit ModifyBasicItemSupplierPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (supplierPrice) {
      res["SupplierPrice"] = boost::any(*supplierPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SupplierPrice") != m.end() && !m["SupplierPrice"].empty()) {
      supplierPrice = make_shared<long>(boost::any_cast<long>(m["SupplierPrice"]));
    }
  }


  virtual ~ModifyBasicItemSupplierPriceRequest() = default;
};
class ModifyBasicItemSupplierPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> model{};
  shared_ptr<string> requestId{};

  ModifyBasicItemSupplierPriceResponseBody() {}

  explicit ModifyBasicItemSupplierPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<bool>(boost::any_cast<bool>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBasicItemSupplierPriceResponseBody() = default;
};
class ModifyBasicItemSupplierPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBasicItemSupplierPriceResponseBody> body{};

  ModifyBasicItemSupplierPriceResponse() {}

  explicit ModifyBasicItemSupplierPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBasicItemSupplierPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBasicItemSupplierPriceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBasicItemSupplierPriceResponse() = default;
};
class ModifyBizItemsRequestItemListSkuList : public Darabonba::Model {
public:
  shared_ptr<string> benefitId{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};
  shared_ptr<long> statusAction{};

  ModifyBizItemsRequestItemListSkuList() {}

  explicit ModifyBizItemsRequestItemListSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (benefitId) {
      res["BenefitId"] = boost::any(*benefitId);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (statusAction) {
      res["StatusAction"] = boost::any(*statusAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BenefitId") != m.end() && !m["BenefitId"].empty()) {
      benefitId = make_shared<string>(boost::any_cast<string>(m["BenefitId"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("StatusAction") != m.end() && !m["StatusAction"].empty()) {
      statusAction = make_shared<long>(boost::any_cast<long>(m["StatusAction"]));
    }
  }


  virtual ~ModifyBizItemsRequestItemListSkuList() = default;
};
class ModifyBizItemsRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<vector<ModifyBizItemsRequestItemListSkuList>> skuList{};

  ModifyBizItemsRequestItemList() {}

  explicit ModifyBizItemsRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuList) {
      vector<boost::any> temp1;
      for(auto item1:*skuList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkuList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkuList"].type()) {
        vector<ModifyBizItemsRequestItemListSkuList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkuList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBizItemsRequestItemListSkuList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skuList = make_shared<vector<ModifyBizItemsRequestItemListSkuList>>(expect1);
      }
    }
  }


  virtual ~ModifyBizItemsRequestItemList() = default;
};
class ModifyBizItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<ModifyBizItemsRequestItemList>> itemList{};
  shared_ptr<string> subBizId{};

  ModifyBizItemsRequest() {}

  explicit ModifyBizItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<ModifyBizItemsRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBizItemsRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<ModifyBizItemsRequestItemList>>(expect1);
      }
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~ModifyBizItemsRequest() = default;
};
class ModifyBizItemsResponseBodyFailedItemListItemSkuIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sku{};

  ModifyBizItemsResponseBodyFailedItemListItemSkuIdList() {}

  explicit ModifyBizItemsResponseBodyFailedItemListItemSkuIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      res["Sku"] = boost::any(*sku);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sku"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sku = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBizItemsResponseBodyFailedItemListItemSkuIdList() = default;
};
class ModifyBizItemsResponseBodyFailedItemListItem : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<ModifyBizItemsResponseBodyFailedItemListItemSkuIdList> skuIdList{};

  ModifyBizItemsResponseBodyFailedItemListItem() {}

  explicit ModifyBizItemsResponseBodyFailedItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuIdList) {
      res["SkuIdList"] = skuIdList ? boost::any(skuIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuIdList") != m.end() && !m["SkuIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuIdList"].type()) {
        ModifyBizItemsResponseBodyFailedItemListItemSkuIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuIdList"]));
        skuIdList = make_shared<ModifyBizItemsResponseBodyFailedItemListItemSkuIdList>(model1);
      }
    }
  }


  virtual ~ModifyBizItemsResponseBodyFailedItemListItem() = default;
};
class ModifyBizItemsResponseBodyFailedItemList : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyBizItemsResponseBodyFailedItemListItem>> item{};

  ModifyBizItemsResponseBodyFailedItemList() {}

  explicit ModifyBizItemsResponseBodyFailedItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<ModifyBizItemsResponseBodyFailedItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyBizItemsResponseBodyFailedItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<ModifyBizItemsResponseBodyFailedItemListItem>>(expect1);
      }
    }
  }


  virtual ~ModifyBizItemsResponseBodyFailedItemList() = default;
};
class ModifyBizItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifyBizItemsResponseBodyFailedItemList> failedItemList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ModifyBizItemsResponseBody() {}

  explicit ModifyBizItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failedItemList) {
      res["FailedItemList"] = failedItemList ? boost::any(failedItemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailedItemList") != m.end() && !m["FailedItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedItemList"].type()) {
        ModifyBizItemsResponseBodyFailedItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedItemList"]));
        failedItemList = make_shared<ModifyBizItemsResponseBodyFailedItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ModifyBizItemsResponseBody() = default;
};
class ModifyBizItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBizItemsResponseBody> body{};

  ModifyBizItemsResponse() {}

  explicit ModifyBizItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBizItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBizItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBizItemsResponse() = default;
};
class ModifyItemLimitRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<string> bizId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> itemId{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> upperNum{};

  ModifyItemLimitRuleRequest() {}

  explicit ModifyItemLimitRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (upperNum) {
      res["UpperNum"] = boost::any(*upperNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("UpperNum") != m.end() && !m["UpperNum"].empty()) {
      upperNum = make_shared<long>(boost::any_cast<long>(m["UpperNum"]));
    }
  }


  virtual ~ModifyItemLimitRuleRequest() = default;
};
class ModifyItemLimitRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> model{};
  shared_ptr<string> requestId{};

  ModifyItemLimitRuleResponseBody() {}

  explicit ModifyItemLimitRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<bool>(boost::any_cast<bool>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyItemLimitRuleResponseBody() = default;
};
class ModifyItemLimitRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyItemLimitRuleResponseBody> body{};

  ModifyItemLimitRuleResponse() {}

  explicit ModifyItemLimitRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyItemLimitRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyItemLimitRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyItemLimitRuleResponse() = default;
};
class ModifyOrderDeliveryAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> extJson{};
  shared_ptr<long> lmOrderId{};

  ModifyOrderDeliveryAddressRequest() {}

  explicit ModifyOrderDeliveryAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
  }


  virtual ~ModifyOrderDeliveryAddressRequest() = default;
};
class ModifyOrderDeliveryAddressResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> resultInfo{};

  ModifyOrderDeliveryAddressResponseBodyModel() {}

  explicit ModifyOrderDeliveryAddressResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultInfo) {
      res["ResultInfo"] = boost::any(*resultInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultInfo") != m.end() && !m["ResultInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ResultInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resultInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ModifyOrderDeliveryAddressResponseBodyModel() = default;
};
class ModifyOrderDeliveryAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ModifyOrderDeliveryAddressResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ModifyOrderDeliveryAddressResponseBody() {}

  explicit ModifyOrderDeliveryAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ModifyOrderDeliveryAddressResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ModifyOrderDeliveryAddressResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ModifyOrderDeliveryAddressResponseBody() = default;
};
class ModifyOrderDeliveryAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOrderDeliveryAddressResponseBody> body{};

  ModifyOrderDeliveryAddressResponse() {}

  explicit ModifyOrderDeliveryAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOrderDeliveryAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOrderDeliveryAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOrderDeliveryAddressResponse() = default;
};
class ModifyRefundRequestLeavePictureList : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> picture{};

  ModifyRefundRequestLeavePictureList() {}

  explicit ModifyRefundRequestLeavePictureList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (picture) {
      res["Picture"] = boost::any(*picture);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Picture") != m.end() && !m["Picture"].empty()) {
      picture = make_shared<string>(boost::any_cast<string>(m["Picture"]));
    }
  }


  virtual ~ModifyRefundRequestLeavePictureList() = default;
};
class ModifyRefundRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> applyReasonTextId{};
  shared_ptr<long> applyRefundCount{};
  shared_ptr<long> applyRefundFee{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> leaveMessage{};
  shared_ptr<vector<ModifyRefundRequestLeavePictureList>> leavePictureList{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  ModifyRefundRequest() {}

  explicit ModifyRefundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (applyReasonTextId) {
      res["ApplyReasonTextId"] = boost::any(*applyReasonTextId);
    }
    if (applyRefundCount) {
      res["ApplyRefundCount"] = boost::any(*applyRefundCount);
    }
    if (applyRefundFee) {
      res["ApplyRefundFee"] = boost::any(*applyRefundFee);
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (leaveMessage) {
      res["LeaveMessage"] = boost::any(*leaveMessage);
    }
    if (leavePictureList) {
      vector<boost::any> temp1;
      for(auto item1:*leavePictureList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LeavePictureList"] = boost::any(temp1);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ApplyReasonTextId") != m.end() && !m["ApplyReasonTextId"].empty()) {
      applyReasonTextId = make_shared<long>(boost::any_cast<long>(m["ApplyReasonTextId"]));
    }
    if (m.find("ApplyRefundCount") != m.end() && !m["ApplyRefundCount"].empty()) {
      applyRefundCount = make_shared<long>(boost::any_cast<long>(m["ApplyRefundCount"]));
    }
    if (m.find("ApplyRefundFee") != m.end() && !m["ApplyRefundFee"].empty()) {
      applyRefundFee = make_shared<long>(boost::any_cast<long>(m["ApplyRefundFee"]));
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("LeaveMessage") != m.end() && !m["LeaveMessage"].empty()) {
      leaveMessage = make_shared<string>(boost::any_cast<string>(m["LeaveMessage"]));
    }
    if (m.find("LeavePictureList") != m.end() && !m["LeavePictureList"].empty()) {
      if (typeid(vector<boost::any>) == m["LeavePictureList"].type()) {
        vector<ModifyRefundRequestLeavePictureList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LeavePictureList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyRefundRequestLeavePictureList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        leavePictureList = make_shared<vector<ModifyRefundRequestLeavePictureList>>(expect1);
      }
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~ModifyRefundRequest() = default;
};
class ModifyRefundResponseBodyRefundApplicationData : public Darabonba::Model {
public:
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> subLmOrderId{};

  ModifyRefundResponseBodyRefundApplicationData() {}

  explicit ModifyRefundResponseBodyRefundApplicationData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~ModifyRefundResponseBodyRefundApplicationData() = default;
};
class ModifyRefundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<ModifyRefundResponseBodyRefundApplicationData> refundApplicationData{};
  shared_ptr<string> requestId{};

  ModifyRefundResponseBody() {}

  explicit ModifyRefundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (refundApplicationData) {
      res["RefundApplicationData"] = refundApplicationData ? boost::any(refundApplicationData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RefundApplicationData") != m.end() && !m["RefundApplicationData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundApplicationData"].type()) {
        ModifyRefundResponseBodyRefundApplicationData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundApplicationData"]));
        refundApplicationData = make_shared<ModifyRefundResponseBodyRefundApplicationData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRefundResponseBody() = default;
};
class ModifyRefundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRefundResponseBody> body{};

  ModifyRefundResponse() {}

  explicit ModifyRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRefundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRefundResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRefundResponse() = default;
};
class ModifyRefundWithDesignatedTbUidRequestProofs : public Darabonba::Model {
public:
  shared_ptr<string> messagePic{};
  shared_ptr<string> messagePicDesc{};

  ModifyRefundWithDesignatedTbUidRequestProofs() {}

  explicit ModifyRefundWithDesignatedTbUidRequestProofs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messagePic) {
      res["MessagePic"] = boost::any(*messagePic);
    }
    if (messagePicDesc) {
      res["MessagePicDesc"] = boost::any(*messagePicDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessagePic") != m.end() && !m["MessagePic"].empty()) {
      messagePic = make_shared<string>(boost::any_cast<string>(m["MessagePic"]));
    }
    if (m.find("MessagePicDesc") != m.end() && !m["MessagePicDesc"].empty()) {
      messagePicDesc = make_shared<string>(boost::any_cast<string>(m["MessagePicDesc"]));
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidRequestProofs() = default;
};
class ModifyRefundWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> message{};
  shared_ptr<vector<ModifyRefundWithDesignatedTbUidRequestProofs>> proofs{};
  shared_ptr<long> reasonId{};
  shared_ptr<long> refundCode{};
  shared_ptr<long> refundCount{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  ModifyRefundWithDesignatedTbUidRequest() {}

  explicit ModifyRefundWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (proofs) {
      vector<boost::any> temp1;
      for(auto item1:*proofs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Proofs"] = boost::any(temp1);
    }
    if (reasonId) {
      res["ReasonId"] = boost::any(*reasonId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (refundCount) {
      res["RefundCount"] = boost::any(*refundCount);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Proofs") != m.end() && !m["Proofs"].empty()) {
      if (typeid(vector<boost::any>) == m["Proofs"].type()) {
        vector<ModifyRefundWithDesignatedTbUidRequestProofs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Proofs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyRefundWithDesignatedTbUidRequestProofs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        proofs = make_shared<vector<ModifyRefundWithDesignatedTbUidRequestProofs>>(expect1);
      }
    }
    if (m.find("ReasonId") != m.end() && !m["ReasonId"].empty()) {
      reasonId = make_shared<long>(boost::any_cast<long>(m["ReasonId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("RefundCount") != m.end() && !m["RefundCount"].empty()) {
      refundCount = make_shared<long>(boost::any_cast<long>(m["RefundCount"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidRequest() = default;
};
class ModifyRefundWithDesignatedTbUidShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> goodsStatus{};
  shared_ptr<string> message{};
  shared_ptr<string> proofsShrink{};
  shared_ptr<long> reasonId{};
  shared_ptr<long> refundCode{};
  shared_ptr<long> refundCount{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  ModifyRefundWithDesignatedTbUidShrinkRequest() {}

  explicit ModifyRefundWithDesignatedTbUidShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (goodsStatus) {
      res["GoodsStatus"] = boost::any(*goodsStatus);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (proofsShrink) {
      res["Proofs"] = boost::any(*proofsShrink);
    }
    if (reasonId) {
      res["ReasonId"] = boost::any(*reasonId);
    }
    if (refundCode) {
      res["RefundCode"] = boost::any(*refundCode);
    }
    if (refundCount) {
      res["RefundCount"] = boost::any(*refundCount);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("GoodsStatus") != m.end() && !m["GoodsStatus"].empty()) {
      goodsStatus = make_shared<long>(boost::any_cast<long>(m["GoodsStatus"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Proofs") != m.end() && !m["Proofs"].empty()) {
      proofsShrink = make_shared<string>(boost::any_cast<string>(m["Proofs"]));
    }
    if (m.find("ReasonId") != m.end() && !m["ReasonId"].empty()) {
      reasonId = make_shared<long>(boost::any_cast<long>(m["ReasonId"]));
    }
    if (m.find("RefundCode") != m.end() && !m["RefundCode"].empty()) {
      refundCode = make_shared<long>(boost::any_cast<long>(m["RefundCode"]));
    }
    if (m.find("RefundCount") != m.end() && !m["RefundCount"].empty()) {
      refundCount = make_shared<long>(boost::any_cast<long>(m["RefundCount"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidShrinkRequest() = default;
};
class ModifyRefundWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> disputeId{};
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> subLmOrderId{};

  ModifyRefundWithDesignatedTbUidResponseBodyModel() {}

  explicit ModifyRefundWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidResponseBodyModel() = default;
};
class ModifyRefundWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ModifyRefundWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ModifyRefundWithDesignatedTbUidResponseBody() {}

  explicit ModifyRefundWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ModifyRefundWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ModifyRefundWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidResponseBody() = default;
};
class ModifyRefundWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRefundWithDesignatedTbUidResponseBody> body{};

  ModifyRefundWithDesignatedTbUidResponse() {}

  explicit ModifyRefundWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRefundWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRefundWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRefundWithDesignatedTbUidResponse() = default;
};
class ModifySettleAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountChannel{};
  shared_ptr<string> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountNo{};
  shared_ptr<string> accountPayType{};
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> countryOrAreaCode{};
  shared_ptr<string> currency{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> idempotentId{};

  ModifySettleAccountRequest() {}

  explicit ModifySettleAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountChannel) {
      res["AccountChannel"] = boost::any(*accountChannel);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountNo) {
      res["AccountNo"] = boost::any(*accountNo);
    }
    if (accountPayType) {
      res["AccountPayType"] = boost::any(*accountPayType);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (countryOrAreaCode) {
      res["CountryOrAreaCode"] = boost::any(*countryOrAreaCode);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountChannel") != m.end() && !m["AccountChannel"].empty()) {
      accountChannel = make_shared<string>(boost::any_cast<string>(m["AccountChannel"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountNo") != m.end() && !m["AccountNo"].empty()) {
      accountNo = make_shared<string>(boost::any_cast<string>(m["AccountNo"]));
    }
    if (m.find("AccountPayType") != m.end() && !m["AccountPayType"].empty()) {
      accountPayType = make_shared<string>(boost::any_cast<string>(m["AccountPayType"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CountryOrAreaCode") != m.end() && !m["CountryOrAreaCode"].empty()) {
      countryOrAreaCode = make_shared<string>(boost::any_cast<string>(m["CountryOrAreaCode"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
  }


  virtual ~ModifySettleAccountRequest() = default;
};
class ModifySettleAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> accountNo{};
  shared_ptr<string> id{};

  ModifySettleAccountResponseBodyModel() {}

  explicit ModifySettleAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountNo) {
      res["AccountNo"] = boost::any(*accountNo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountNo") != m.end() && !m["AccountNo"].empty()) {
      accountNo = make_shared<string>(boost::any_cast<string>(m["AccountNo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ModifySettleAccountResponseBodyModel() = default;
};
class ModifySettleAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ModifySettleAccountResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  ModifySettleAccountResponseBody() {}

  explicit ModifySettleAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ModifySettleAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ModifySettleAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySettleAccountResponseBody() = default;
};
class ModifySettleAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySettleAccountResponseBody> body{};

  ModifySettleAccountResponse() {}

  explicit ModifySettleAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySettleAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySettleAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySettleAccountResponse() = default;
};
class ModifySupplierPriceAndPriceCentRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> lmShopId{};
  shared_ptr<string> priceCent{};
  shared_ptr<string> skuId{};
  shared_ptr<string> supplierPrice{};

  ModifySupplierPriceAndPriceCentRequest() {}

  explicit ModifySupplierPriceAndPriceCentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (supplierPrice) {
      res["SupplierPrice"] = boost::any(*supplierPrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<string>(boost::any_cast<string>(m["LmShopId"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<string>(boost::any_cast<string>(m["PriceCent"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<string>(boost::any_cast<string>(m["SkuId"]));
    }
    if (m.find("SupplierPrice") != m.end() && !m["SupplierPrice"].empty()) {
      supplierPrice = make_shared<string>(boost::any_cast<string>(m["SupplierPrice"]));
    }
  }


  virtual ~ModifySupplierPriceAndPriceCentRequest() = default;
};
class ModifySupplierPriceAndPriceCentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> model{};
  shared_ptr<string> requestId{};

  ModifySupplierPriceAndPriceCentResponseBody() {}

  explicit ModifySupplierPriceAndPriceCentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<bool>(boost::any_cast<bool>(m["Model"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySupplierPriceAndPriceCentResponseBody() = default;
};
class ModifySupplierPriceAndPriceCentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySupplierPriceAndPriceCentResponseBody> body{};

  ModifySupplierPriceAndPriceCentResponse() {}

  explicit ModifySupplierPriceAndPriceCentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySupplierPriceAndPriceCentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySupplierPriceAndPriceCentResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySupplierPriceAndPriceCentResponse() = default;
};
class NotifyPayOrderStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> operationDate{};
  shared_ptr<string> payTypes{};
  shared_ptr<string> requestId{};

  NotifyPayOrderStatusRequest() {}

  explicit NotifyPayOrderStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (operationDate) {
      res["OperationDate"] = boost::any(*operationDate);
    }
    if (payTypes) {
      res["PayTypes"] = boost::any(*payTypes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OperationDate") != m.end() && !m["OperationDate"].empty()) {
      operationDate = make_shared<string>(boost::any_cast<string>(m["OperationDate"]));
    }
    if (m.find("PayTypes") != m.end() && !m["PayTypes"].empty()) {
      payTypes = make_shared<string>(boost::any_cast<string>(m["PayTypes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~NotifyPayOrderStatusRequest() = default;
};
class NotifyPayOrderStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  NotifyPayOrderStatusResponseBody() {}

  explicit NotifyPayOrderStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~NotifyPayOrderStatusResponseBody() = default;
};
class NotifyPayOrderStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<NotifyPayOrderStatusResponseBody> body{};

  NotifyPayOrderStatusResponse() {}

  explicit NotifyPayOrderStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        NotifyPayOrderStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<NotifyPayOrderStatusResponseBody>(model1);
      }
    }
  }


  virtual ~NotifyPayOrderStatusResponse() = default;
};
class NotifyWithholdFundRequest : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> operationDate{};
  shared_ptr<string> payTypes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> tenantOrderId{};

  NotifyWithholdFundRequest() {}

  explicit NotifyWithholdFundRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (operationDate) {
      res["OperationDate"] = boost::any(*operationDate);
    }
    if (payTypes) {
      res["PayTypes"] = boost::any(*payTypes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantOrderId) {
      res["TenantOrderId"] = boost::any(*tenantOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OperationDate") != m.end() && !m["OperationDate"].empty()) {
      operationDate = make_shared<string>(boost::any_cast<string>(m["OperationDate"]));
    }
    if (m.find("PayTypes") != m.end() && !m["PayTypes"].empty()) {
      payTypes = make_shared<string>(boost::any_cast<string>(m["PayTypes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantOrderId") != m.end() && !m["TenantOrderId"].empty()) {
      tenantOrderId = make_shared<string>(boost::any_cast<string>(m["TenantOrderId"]));
    }
  }


  virtual ~NotifyWithholdFundRequest() = default;
};
class NotifyWithholdFundResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  NotifyWithholdFundResponseBody() {}

  explicit NotifyWithholdFundResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~NotifyWithholdFundResponseBody() = default;
};
class NotifyWithholdFundResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<NotifyWithholdFundResponseBody> body{};

  NotifyWithholdFundResponse() {}

  explicit NotifyWithholdFundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        NotifyWithholdFundResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<NotifyWithholdFundResponseBody>(model1);
      }
    }
  }


  virtual ~NotifyWithholdFundResponse() = default;
};
class OpenRealTbAccountSupportRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  OpenRealTbAccountSupportRequest() {}

  explicit OpenRealTbAccountSupportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~OpenRealTbAccountSupportRequest() = default;
};
class OpenRealTbAccountSupportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<boost::any> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  OpenRealTbAccountSupportResponseBody() {}

  explicit OpenRealTbAccountSupportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<boost::any>(boost::any_cast<boost::any>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~OpenRealTbAccountSupportResponseBody() = default;
};
class OpenRealTbAccountSupportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenRealTbAccountSupportResponseBody> body{};

  OpenRealTbAccountSupportResponse() {}

  explicit OpenRealTbAccountSupportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenRealTbAccountSupportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenRealTbAccountSupportResponseBody>(model1);
      }
    }
  }


  virtual ~OpenRealTbAccountSupportResponse() = default;
};
class PushUserGameProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> currentStepId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> processId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<map<string, boost::any>> body{};

  PushUserGameProcessRequest() {}

  explicit PushUserGameProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["body"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      body = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~PushUserGameProcessRequest() = default;
};
class PushUserGameProcessShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> currentStepId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> processId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> bodyShrink{};

  PushUserGameProcessShrinkRequest() {}

  explicit PushUserGameProcessShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (bodyShrink) {
      res["body"] = boost::any(*bodyShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      bodyShrink = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~PushUserGameProcessShrinkRequest() = default;
};
class PushUserGameProcessResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> currentShowContent{};
  shared_ptr<string> currentStepId{};
  shared_ptr<string> currentStepStatus{};
  shared_ptr<string> desc{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<string> name{};
  shared_ptr<string> processId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  PushUserGameProcessResponseBodyModel() {}

  explicit PushUserGameProcessResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (currentShowContent) {
      res["CurrentShowContent"] = boost::any(*currentShowContent);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (currentStepStatus) {
      res["CurrentStepStatus"] = boost::any(*currentStepStatus);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("CurrentShowContent") != m.end() && !m["CurrentShowContent"].empty()) {
      currentShowContent = make_shared<string>(boost::any_cast<string>(m["CurrentShowContent"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("CurrentStepStatus") != m.end() && !m["CurrentStepStatus"].empty()) {
      currentStepStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStepStatus"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PushUserGameProcessResponseBodyModel() = default;
};
class PushUserGameProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<PushUserGameProcessResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  PushUserGameProcessResponseBody() {}

  explicit PushUserGameProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        PushUserGameProcessResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<PushUserGameProcessResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushUserGameProcessResponseBody() = default;
};
class PushUserGameProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushUserGameProcessResponseBody> body{};

  PushUserGameProcessResponse() {}

  explicit PushUserGameProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushUserGameProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushUserGameProcessResponseBody>(model1);
      }
    }
  }


  virtual ~PushUserGameProcessResponse() = default;
};
class QueryActivityItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryActivityItemsRequest() {}

  explicit QueryActivityItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryActivityItemsRequest() = default;
};
class QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel : public Darabonba::Model {
public:
  shared_ptr<long> activityPrice{};
  shared_ptr<string> activityStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> reservedPrice{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuTitle{};
  shared_ptr<string> tips{};

  QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel() {}

  explicit QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityPrice) {
      res["ActivityPrice"] = boost::any(*activityPrice);
    }
    if (activityStatus) {
      res["ActivityStatus"] = boost::any(*activityStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (reservedPrice) {
      res["ReservedPrice"] = boost::any(*reservedPrice);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityPrice") != m.end() && !m["ActivityPrice"].empty()) {
      activityPrice = make_shared<long>(boost::any_cast<long>(m["ActivityPrice"]));
    }
    if (m.find("ActivityStatus") != m.end() && !m["ActivityStatus"].empty()) {
      activityStatus = make_shared<string>(boost::any_cast<string>(m["ActivityStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("ReservedPrice") != m.end() && !m["ReservedPrice"].empty()) {
      reservedPrice = make_shared<long>(boost::any_cast<long>(m["ReservedPrice"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
  }


  virtual ~QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel() = default;
};
class QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel>> lmActivityItemSkuModel{};

  QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList() {}

  explicit QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivityItemSkuModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivityItemSkuModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivityItemSkuModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivityItemSkuModel") != m.end() && !m["LmActivityItemSkuModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivityItemSkuModel"].type()) {
        vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivityItemSkuModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivityItemSkuModel = make_shared<vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelListLmActivityItemSkuModel>>(expect1);
      }
    }
  }


  virtual ~QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList() = default;
};
class QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> itemActivityQuantity{};
  shared_ptr<string> itemActivityStatus{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> lmShopId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> sellableQuantity{};
  shared_ptr<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList> skuModelList{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> tbShopId{};
  shared_ptr<string> tbShopName{};
  shared_ptr<string> tips{};

  QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel() {}

  explicit QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (itemActivityQuantity) {
      res["ItemActivityQuantity"] = boost::any(*itemActivityQuantity);
    }
    if (itemActivityStatus) {
      res["ItemActivityStatus"] = boost::any(*itemActivityStatus);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (sellableQuantity) {
      res["SellableQuantity"] = boost::any(*sellableQuantity);
    }
    if (skuModelList) {
      res["SkuModelList"] = skuModelList ? boost::any(skuModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (tbShopId) {
      res["TbShopId"] = boost::any(*tbShopId);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("ItemActivityQuantity") != m.end() && !m["ItemActivityQuantity"].empty()) {
      itemActivityQuantity = make_shared<long>(boost::any_cast<long>(m["ItemActivityQuantity"]));
    }
    if (m.find("ItemActivityStatus") != m.end() && !m["ItemActivityStatus"].empty()) {
      itemActivityStatus = make_shared<string>(boost::any_cast<string>(m["ItemActivityStatus"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<string>(boost::any_cast<string>(m["LmShopId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("SellableQuantity") != m.end() && !m["SellableQuantity"].empty()) {
      sellableQuantity = make_shared<long>(boost::any_cast<long>(m["SellableQuantity"]));
    }
    if (m.find("SkuModelList") != m.end() && !m["SkuModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuModelList"].type()) {
        QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuModelList"]));
        skuModelList = make_shared<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModelSkuModelList>(model1);
      }
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("TbShopId") != m.end() && !m["TbShopId"].empty()) {
      tbShopId = make_shared<long>(boost::any_cast<long>(m["TbShopId"]));
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
  }


  virtual ~QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel() = default;
};
class QueryActivityItemsResponseBodyLmActivityItemModelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel>> lmActivityItemModel{};

  QueryActivityItemsResponseBodyLmActivityItemModelList() {}

  explicit QueryActivityItemsResponseBodyLmActivityItemModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivityItemModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivityItemModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivityItemModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivityItemModel") != m.end() && !m["LmActivityItemModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivityItemModel"].type()) {
        vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivityItemModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivityItemModel = make_shared<vector<QueryActivityItemsResponseBodyLmActivityItemModelListLmActivityItemModel>>(expect1);
      }
    }
  }


  virtual ~QueryActivityItemsResponseBodyLmActivityItemModelList() = default;
};
class QueryActivityItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryActivityItemsResponseBodyLmActivityItemModelList> lmActivityItemModelList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryActivityItemsResponseBody() {}

  explicit QueryActivityItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmActivityItemModelList) {
      res["LmActivityItemModelList"] = lmActivityItemModelList ? boost::any(lmActivityItemModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmActivityItemModelList") != m.end() && !m["LmActivityItemModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivityItemModelList"].type()) {
        QueryActivityItemsResponseBodyLmActivityItemModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivityItemModelList"]));
        lmActivityItemModelList = make_shared<QueryActivityItemsResponseBodyLmActivityItemModelList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryActivityItemsResponseBody() = default;
};
class QueryActivityItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryActivityItemsResponseBody> body{};

  QueryActivityItemsResponse() {}

  explicit QueryActivityItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryActivityItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryActivityItemsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryActivityItemsResponse() = default;
};
class QueryAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> ip{};

  QueryAddressRequest() {}

  explicit QueryAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
  }


  virtual ~QueryAddressRequest() = default;
};
class QueryAddressResponseBodyDivisionAddressDivisionAddress : public Darabonba::Model {
public:
  shared_ptr<long> divisionCode{};
  shared_ptr<long> divisionLevel{};
  shared_ptr<string> divisionName{};
  shared_ptr<long> parentId{};

  QueryAddressResponseBodyDivisionAddressDivisionAddress() {}

  explicit QueryAddressResponseBodyDivisionAddressDivisionAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (divisionLevel) {
      res["DivisionLevel"] = boost::any(*divisionLevel);
    }
    if (divisionName) {
      res["DivisionName"] = boost::any(*divisionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<long>(boost::any_cast<long>(m["DivisionCode"]));
    }
    if (m.find("DivisionLevel") != m.end() && !m["DivisionLevel"].empty()) {
      divisionLevel = make_shared<long>(boost::any_cast<long>(m["DivisionLevel"]));
    }
    if (m.find("DivisionName") != m.end() && !m["DivisionName"].empty()) {
      divisionName = make_shared<string>(boost::any_cast<string>(m["DivisionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~QueryAddressResponseBodyDivisionAddressDivisionAddress() = default;
};
class QueryAddressResponseBodyDivisionAddress : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAddressResponseBodyDivisionAddressDivisionAddress>> divisionAddress{};

  QueryAddressResponseBodyDivisionAddress() {}

  explicit QueryAddressResponseBodyDivisionAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (divisionAddress) {
      vector<boost::any> temp1;
      for(auto item1:*divisionAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DivisionAddress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DivisionAddress") != m.end() && !m["DivisionAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["DivisionAddress"].type()) {
        vector<QueryAddressResponseBodyDivisionAddressDivisionAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DivisionAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAddressResponseBodyDivisionAddressDivisionAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        divisionAddress = make_shared<vector<QueryAddressResponseBodyDivisionAddressDivisionAddress>>(expect1);
      }
    }
  }


  virtual ~QueryAddressResponseBodyDivisionAddress() = default;
};
class QueryAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryAddressResponseBodyDivisionAddress> divisionAddress{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryAddressResponseBody() {}

  explicit QueryAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (divisionAddress) {
      res["DivisionAddress"] = divisionAddress ? boost::any(divisionAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DivisionAddress") != m.end() && !m["DivisionAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["DivisionAddress"].type()) {
        QueryAddressResponseBodyDivisionAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DivisionAddress"]));
        divisionAddress = make_shared<QueryAddressResponseBodyDivisionAddress>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAddressResponseBody() = default;
};
class QueryAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAddressResponseBody> body{};

  QueryAddressResponse() {}

  explicit QueryAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAddressResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAddressResponse() = default;
};
class QueryAddressDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressInfo{};
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryAddressDetailRequest() {}

  explicit QueryAddressDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfo) {
      res["AddressInfo"] = boost::any(*addressInfo);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfo") != m.end() && !m["AddressInfo"].empty()) {
      addressInfo = make_shared<string>(boost::any_cast<string>(m["AddressInfo"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryAddressDetailRequest() = default;
};
class QueryAddressDetailResponseBodyDeliveryAddress : public Darabonba::Model {
public:
  shared_ptr<string> addressDetail{};
  shared_ptr<long> addressId{};
  shared_ptr<string> area{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> fullName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<long> status{};
  shared_ptr<string> town{};
  shared_ptr<string> townDivisionCode{};

  QueryAddressDetailResponseBodyDeliveryAddress() {}

  explicit QueryAddressDetailResponseBodyDeliveryAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressDetail) {
      res["AddressDetail"] = boost::any(*addressDetail);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (fullName) {
      res["FullName"] = boost::any(*fullName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (townDivisionCode) {
      res["TownDivisionCode"] = boost::any(*townDivisionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressDetail") != m.end() && !m["AddressDetail"].empty()) {
      addressDetail = make_shared<string>(boost::any_cast<string>(m["AddressDetail"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<long>(boost::any_cast<long>(m["AddressId"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("FullName") != m.end() && !m["FullName"].empty()) {
      fullName = make_shared<string>(boost::any_cast<string>(m["FullName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("TownDivisionCode") != m.end() && !m["TownDivisionCode"].empty()) {
      townDivisionCode = make_shared<string>(boost::any_cast<string>(m["TownDivisionCode"]));
    }
  }


  virtual ~QueryAddressDetailResponseBodyDeliveryAddress() = default;
};
class QueryAddressDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryAddressDetailResponseBodyDeliveryAddress> deliveryAddress{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryAddressDetailResponseBody() {}

  explicit QueryAddressDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = deliveryAddress ? boost::any(deliveryAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeliveryAddress"].type()) {
        QueryAddressDetailResponseBodyDeliveryAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeliveryAddress"]));
        deliveryAddress = make_shared<QueryAddressDetailResponseBodyDeliveryAddress>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAddressDetailResponseBody() = default;
};
class QueryAddressDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAddressDetailResponseBody> body{};

  QueryAddressDetailResponse() {}

  explicit QueryAddressDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAddressDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAddressDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAddressDetailResponse() = default;
};
class QueryAddressListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryAddressListRequest() {}

  explicit QueryAddressListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryAddressListRequest() = default;
};
class QueryAddressListResponseBodyAddressList : public Darabonba::Model {
public:
  shared_ptr<string> addressDetail{};
  shared_ptr<long> addressId{};
  shared_ptr<string> area{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> fullName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> postCode{};
  shared_ptr<string> province{};
  shared_ptr<long> status{};
  shared_ptr<string> town{};
  shared_ptr<string> townDivisionCode{};

  QueryAddressListResponseBodyAddressList() {}

  explicit QueryAddressListResponseBodyAddressList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressDetail) {
      res["AddressDetail"] = boost::any(*addressDetail);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (fullName) {
      res["FullName"] = boost::any(*fullName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (postCode) {
      res["PostCode"] = boost::any(*postCode);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (town) {
      res["Town"] = boost::any(*town);
    }
    if (townDivisionCode) {
      res["TownDivisionCode"] = boost::any(*townDivisionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressDetail") != m.end() && !m["AddressDetail"].empty()) {
      addressDetail = make_shared<string>(boost::any_cast<string>(m["AddressDetail"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<long>(boost::any_cast<long>(m["AddressId"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("FullName") != m.end() && !m["FullName"].empty()) {
      fullName = make_shared<string>(boost::any_cast<string>(m["FullName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PostCode") != m.end() && !m["PostCode"].empty()) {
      postCode = make_shared<string>(boost::any_cast<string>(m["PostCode"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Town") != m.end() && !m["Town"].empty()) {
      town = make_shared<string>(boost::any_cast<string>(m["Town"]));
    }
    if (m.find("TownDivisionCode") != m.end() && !m["TownDivisionCode"].empty()) {
      townDivisionCode = make_shared<string>(boost::any_cast<string>(m["TownDivisionCode"]));
    }
  }


  virtual ~QueryAddressListResponseBodyAddressList() = default;
};
class QueryAddressListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAddressListResponseBodyAddressList>> addressList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryAddressListResponseBody() {}

  explicit QueryAddressListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressList) {
      vector<boost::any> temp1;
      for(auto item1:*addressList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressList") != m.end() && !m["AddressList"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressList"].type()) {
        vector<QueryAddressListResponseBodyAddressList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAddressListResponseBodyAddressList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressList = make_shared<vector<QueryAddressListResponseBodyAddressList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAddressListResponseBody() = default;
};
class QueryAddressListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAddressListResponseBody> body{};

  QueryAddressListResponse() {}

  explicit QueryAddressListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAddressListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAddressListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAddressListResponse() = default;
};
class QueryAdvertisementSettleInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> mediaSettleDetailId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> settleNo{};
  shared_ptr<string> startTime{};

  QueryAdvertisementSettleInfoRequest() {}

  explicit QueryAdvertisementSettleInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (mediaSettleDetailId) {
      res["MediaSettleDetailId"] = boost::any(*mediaSettleDetailId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MediaSettleDetailId") != m.end() && !m["MediaSettleDetailId"].empty()) {
      mediaSettleDetailId = make_shared<string>(boost::any_cast<string>(m["MediaSettleDetailId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryAdvertisementSettleInfoRequest() = default;
};
class QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList : public Darabonba::Model {
public:
  shared_ptr<string> advertiseName{};
  shared_ptr<string> advertiseSettleAmount{};
  shared_ptr<string> advertiseSettleDetailId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> createDate{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> mediaSettleDetailId{};
  shared_ptr<string> modifiedDate{};
  shared_ptr<string> settleNo{};
  shared_ptr<string> settleStatus{};
  shared_ptr<string> startTime{};

  QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList() {}

  explicit QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advertiseName) {
      res["AdvertiseName"] = boost::any(*advertiseName);
    }
    if (advertiseSettleAmount) {
      res["AdvertiseSettleAmount"] = boost::any(*advertiseSettleAmount);
    }
    if (advertiseSettleDetailId) {
      res["AdvertiseSettleDetailId"] = boost::any(*advertiseSettleDetailId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (mediaSettleDetailId) {
      res["MediaSettleDetailId"] = boost::any(*mediaSettleDetailId);
    }
    if (modifiedDate) {
      res["ModifiedDate"] = boost::any(*modifiedDate);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    if (settleStatus) {
      res["SettleStatus"] = boost::any(*settleStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvertiseName") != m.end() && !m["AdvertiseName"].empty()) {
      advertiseName = make_shared<string>(boost::any_cast<string>(m["AdvertiseName"]));
    }
    if (m.find("AdvertiseSettleAmount") != m.end() && !m["AdvertiseSettleAmount"].empty()) {
      advertiseSettleAmount = make_shared<string>(boost::any_cast<string>(m["AdvertiseSettleAmount"]));
    }
    if (m.find("AdvertiseSettleDetailId") != m.end() && !m["AdvertiseSettleDetailId"].empty()) {
      advertiseSettleDetailId = make_shared<string>(boost::any_cast<string>(m["AdvertiseSettleDetailId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MediaSettleDetailId") != m.end() && !m["MediaSettleDetailId"].empty()) {
      mediaSettleDetailId = make_shared<string>(boost::any_cast<string>(m["MediaSettleDetailId"]));
    }
    if (m.find("ModifiedDate") != m.end() && !m["ModifiedDate"].empty()) {
      modifiedDate = make_shared<string>(boost::any_cast<string>(m["ModifiedDate"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
    if (m.find("SettleStatus") != m.end() && !m["SettleStatus"].empty()) {
      settleStatus = make_shared<string>(boost::any_cast<string>(m["SettleStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList() = default;
};
class QueryAdvertisementSettleInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList>> advertiseSettleInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  QueryAdvertisementSettleInfoResponseBodyModel() {}

  explicit QueryAdvertisementSettleInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advertiseSettleInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*advertiseSettleInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdvertiseSettleInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvertiseSettleInfoList") != m.end() && !m["AdvertiseSettleInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdvertiseSettleInfoList"].type()) {
        vector<QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdvertiseSettleInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        advertiseSettleInfoList = make_shared<vector<QueryAdvertisementSettleInfoResponseBodyModelAdvertiseSettleInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryAdvertisementSettleInfoResponseBodyModel() = default;
};
class QueryAdvertisementSettleInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryAdvertisementSettleInfoResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryAdvertisementSettleInfoResponseBody() {}

  explicit QueryAdvertisementSettleInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryAdvertisementSettleInfoResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryAdvertisementSettleInfoResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryAdvertisementSettleInfoResponseBody() = default;
};
class QueryAdvertisementSettleInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAdvertisementSettleInfoResponseBody> body{};

  QueryAdvertisementSettleInfoResponse() {}

  explicit QueryAdvertisementSettleInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAdvertisementSettleInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAdvertisementSettleInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAdvertisementSettleInfoResponse() = default;
};
class QueryAgreementRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementNo{};
  shared_ptr<string> externalAgreementNo{};
  shared_ptr<string> merchantId{};

  QueryAgreementRequest() {}

  explicit QueryAgreementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementNo) {
      res["AgreementNo"] = boost::any(*agreementNo);
    }
    if (externalAgreementNo) {
      res["ExternalAgreementNo"] = boost::any(*externalAgreementNo);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementNo") != m.end() && !m["AgreementNo"].empty()) {
      agreementNo = make_shared<string>(boost::any_cast<string>(m["AgreementNo"]));
    }
    if (m.find("ExternalAgreementNo") != m.end() && !m["ExternalAgreementNo"].empty()) {
      externalAgreementNo = make_shared<string>(boost::any_cast<string>(m["ExternalAgreementNo"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
  }


  virtual ~QueryAgreementRequest() = default;
};
class QueryAgreementResponseBodyQueryAgreementResponse : public Darabonba::Model {
public:
  shared_ptr<string> agreementNo{};
  shared_ptr<string> externalAgreementNo{};
  shared_ptr<string> invalidTime{};
  shared_ptr<string> signTime{};
  shared_ptr<string> status{};
  shared_ptr<string> validTime{};

  QueryAgreementResponseBodyQueryAgreementResponse() {}

  explicit QueryAgreementResponseBodyQueryAgreementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementNo) {
      res["AgreementNo"] = boost::any(*agreementNo);
    }
    if (externalAgreementNo) {
      res["ExternalAgreementNo"] = boost::any(*externalAgreementNo);
    }
    if (invalidTime) {
      res["InvalidTime"] = boost::any(*invalidTime);
    }
    if (signTime) {
      res["SignTime"] = boost::any(*signTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validTime) {
      res["ValidTime"] = boost::any(*validTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementNo") != m.end() && !m["AgreementNo"].empty()) {
      agreementNo = make_shared<string>(boost::any_cast<string>(m["AgreementNo"]));
    }
    if (m.find("ExternalAgreementNo") != m.end() && !m["ExternalAgreementNo"].empty()) {
      externalAgreementNo = make_shared<string>(boost::any_cast<string>(m["ExternalAgreementNo"]));
    }
    if (m.find("InvalidTime") != m.end() && !m["InvalidTime"].empty()) {
      invalidTime = make_shared<string>(boost::any_cast<string>(m["InvalidTime"]));
    }
    if (m.find("SignTime") != m.end() && !m["SignTime"].empty()) {
      signTime = make_shared<string>(boost::any_cast<string>(m["SignTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidTime") != m.end() && !m["ValidTime"].empty()) {
      validTime = make_shared<string>(boost::any_cast<string>(m["ValidTime"]));
    }
  }


  virtual ~QueryAgreementResponseBodyQueryAgreementResponse() = default;
};
class QueryAgreementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryAgreementResponseBodyQueryAgreementResponse> queryAgreementResponse{};
  shared_ptr<string> requestId{};

  QueryAgreementResponseBody() {}

  explicit QueryAgreementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (queryAgreementResponse) {
      res["QueryAgreementResponse"] = queryAgreementResponse ? boost::any(queryAgreementResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("QueryAgreementResponse") != m.end() && !m["QueryAgreementResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryAgreementResponse"].type()) {
        QueryAgreementResponseBodyQueryAgreementResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryAgreementResponse"]));
        queryAgreementResponse = make_shared<QueryAgreementResponseBodyQueryAgreementResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryAgreementResponseBody() = default;
};
class QueryAgreementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAgreementResponseBody> body{};

  QueryAgreementResponse() {}

  explicit QueryAgreementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAgreementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAgreementResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAgreementResponse() = default;
};
class QueryAllCinemasRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> cityCode{};
  shared_ptr<string> extJson{};
  shared_ptr<long> pageNumber{};

  QueryAllCinemasRequest() {}

  explicit QueryAllCinemasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~QueryAllCinemasRequest() = default;
};
class QueryAllCinemasResponseBodyCinemasCinema : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> cinemaName{};
  shared_ptr<long> cityId{};
  shared_ptr<string> cityName{};
  shared_ptr<long> id{};
  shared_ptr<string> latitude{};
  shared_ptr<string> longitude{};
  shared_ptr<string> phone{};
  shared_ptr<long> scheduleCloseTime{};
  shared_ptr<string> standardId{};

  QueryAllCinemasResponseBodyCinemasCinema() {}

  explicit QueryAllCinemasResponseBodyCinemasCinema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (cinemaName) {
      res["CinemaName"] = boost::any(*cinemaName);
    }
    if (cityId) {
      res["CityId"] = boost::any(*cityId);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (scheduleCloseTime) {
      res["ScheduleCloseTime"] = boost::any(*scheduleCloseTime);
    }
    if (standardId) {
      res["StandardId"] = boost::any(*standardId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("CinemaName") != m.end() && !m["CinemaName"].empty()) {
      cinemaName = make_shared<string>(boost::any_cast<string>(m["CinemaName"]));
    }
    if (m.find("CityId") != m.end() && !m["CityId"].empty()) {
      cityId = make_shared<long>(boost::any_cast<long>(m["CityId"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("ScheduleCloseTime") != m.end() && !m["ScheduleCloseTime"].empty()) {
      scheduleCloseTime = make_shared<long>(boost::any_cast<long>(m["ScheduleCloseTime"]));
    }
    if (m.find("StandardId") != m.end() && !m["StandardId"].empty()) {
      standardId = make_shared<string>(boost::any_cast<string>(m["StandardId"]));
    }
  }


  virtual ~QueryAllCinemasResponseBodyCinemasCinema() = default;
};
class QueryAllCinemasResponseBodyCinemas : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAllCinemasResponseBodyCinemasCinema>> cinema{};

  QueryAllCinemasResponseBodyCinemas() {}

  explicit QueryAllCinemasResponseBodyCinemas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cinema) {
      vector<boost::any> temp1;
      for(auto item1:*cinema){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cinema"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cinema") != m.end() && !m["Cinema"].empty()) {
      if (typeid(vector<boost::any>) == m["Cinema"].type()) {
        vector<QueryAllCinemasResponseBodyCinemasCinema> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cinema"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllCinemasResponseBodyCinemasCinema model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cinema = make_shared<vector<QueryAllCinemasResponseBodyCinemasCinema>>(expect1);
      }
    }
  }


  virtual ~QueryAllCinemasResponseBodyCinemas() = default;
};
class QueryAllCinemasResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryAllCinemasResponseBodyCinemas> cinemas{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryAllCinemasResponseBody() {}

  explicit QueryAllCinemasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cinemas) {
      res["Cinemas"] = cinemas ? boost::any(cinemas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cinemas") != m.end() && !m["Cinemas"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cinemas"].type()) {
        QueryAllCinemasResponseBodyCinemas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cinemas"]));
        cinemas = make_shared<QueryAllCinemasResponseBodyCinemas>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryAllCinemasResponseBody() = default;
};
class QueryAllCinemasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAllCinemasResponseBody> body{};

  QueryAllCinemasResponse() {}

  explicit QueryAllCinemasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAllCinemasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAllCinemasResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAllCinemasResponse() = default;
};
class QueryAllCitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extJson{};

  QueryAllCitiesRequest() {}

  explicit QueryAllCitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extJson = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryAllCitiesRequest() = default;
};
class QueryAllCitiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJsonShrink{};

  QueryAllCitiesShrinkRequest() {}

  explicit QueryAllCitiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJsonShrink) {
      res["ExtJson"] = boost::any(*extJsonShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJsonShrink = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
  }


  virtual ~QueryAllCitiesShrinkRequest() = default;
};
class QueryAllCitiesResponseBodyCitiesCity : public Darabonba::Model {
public:
  shared_ptr<long> cityCode{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};
  shared_ptr<string> pinYin{};

  QueryAllCitiesResponseBodyCitiesCity() {}

  explicit QueryAllCitiesResponseBodyCitiesCity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pinYin) {
      res["PinYin"] = boost::any(*pinYin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PinYin") != m.end() && !m["PinYin"].empty()) {
      pinYin = make_shared<string>(boost::any_cast<string>(m["PinYin"]));
    }
  }


  virtual ~QueryAllCitiesResponseBodyCitiesCity() = default;
};
class QueryAllCitiesResponseBodyCities : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAllCitiesResponseBodyCitiesCity>> city{};

  QueryAllCitiesResponseBodyCities() {}

  explicit QueryAllCitiesResponseBodyCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      vector<boost::any> temp1;
      for(auto item1:*city){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["City"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      if (typeid(vector<boost::any>) == m["City"].type()) {
        vector<QueryAllCitiesResponseBodyCitiesCity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["City"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllCitiesResponseBodyCitiesCity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        city = make_shared<vector<QueryAllCitiesResponseBodyCitiesCity>>(expect1);
      }
    }
  }


  virtual ~QueryAllCitiesResponseBodyCities() = default;
};
class QueryAllCitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryAllCitiesResponseBodyCities> cities{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryAllCitiesResponseBody() {}

  explicit QueryAllCitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cities) {
      res["Cities"] = cities ? boost::any(cities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cities") != m.end() && !m["Cities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cities"].type()) {
        QueryAllCitiesResponseBodyCities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cities"]));
        cities = make_shared<QueryAllCitiesResponseBodyCities>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAllCitiesResponseBody() = default;
};
class QueryAllCitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAllCitiesResponseBody> body{};

  QueryAllCitiesResponse() {}

  explicit QueryAllCitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAllCitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAllCitiesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAllCitiesResponse() = default;
};
class QueryBatchRegistAnonymousTbAccountResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> batchId{};
  shared_ptr<string> bizId{};

  QueryBatchRegistAnonymousTbAccountResultRequest() {}

  explicit QueryBatchRegistAnonymousTbAccountResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<string>(boost::any_cast<string>(m["BatchId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryBatchRegistAnonymousTbAccountResultRequest() = default;
};
class QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failId{};

  QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds() {}

  explicit QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failId) {
      res["FailId"] = boost::any(*failId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailId") != m.end() && !m["FailId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds() = default;
};
class QueryBatchRegistAnonymousTbAccountResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> batchId{};
  shared_ptr<string> code{};
  shared_ptr<QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds> failIds{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  QueryBatchRegistAnonymousTbAccountResultResponseBody() {}

  explicit QueryBatchRegistAnonymousTbAccountResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failIds) {
      res["FailIds"] = failIds ? boost::any(failIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<string>(boost::any_cast<string>(m["BatchId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailIds") != m.end() && !m["FailIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailIds"].type()) {
        QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailIds"]));
        failIds = make_shared<QueryBatchRegistAnonymousTbAccountResultResponseBodyFailIds>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QueryBatchRegistAnonymousTbAccountResultResponseBody() = default;
};
class QueryBatchRegistAnonymousTbAccountResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBatchRegistAnonymousTbAccountResultResponseBody> body{};

  QueryBatchRegistAnonymousTbAccountResultResponse() {}

  explicit QueryBatchRegistAnonymousTbAccountResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBatchRegistAnonymousTbAccountResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBatchRegistAnonymousTbAccountResultResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBatchRegistAnonymousTbAccountResultResponse() = default;
};
class QueryBestSession4ItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> itemIds{};
  shared_ptr<map<string, boost::any>> lmItemIds{};

  QueryBestSession4ItemsRequest() {}

  explicit QueryBestSession4ItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      itemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LmItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lmItemIds = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryBestSession4ItemsRequest() = default;
};
class QueryBestSession4ItemsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};

  QueryBestSession4ItemsShrinkRequest() {}

  explicit QueryBestSession4ItemsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
  }


  virtual ~QueryBestSession4ItemsShrinkRequest() = default;
};
class QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayDate{};
  shared_ptr<string> endDate{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> lmSessionId{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subBizCode{};

  QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel() {}

  explicit QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmSessionId) {
      res["LmSessionId"] = boost::any(*lmSessionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<string>(boost::any_cast<string>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmSessionId") != m.end() && !m["LmSessionId"].empty()) {
      lmSessionId = make_shared<long>(boost::any_cast<long>(m["LmSessionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel() = default;
};
class QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel> lmActivitySessionModel{};
  shared_ptr<string> lmItemId{};

  QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel() {}

  explicit QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivitySessionModel) {
      res["LmActivitySessionModel"] = lmActivitySessionModel ? boost::any(lmActivitySessionModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivitySessionModel") != m.end() && !m["LmActivitySessionModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivitySessionModel"].type()) {
        QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivitySessionModel"]));
        lmActivitySessionModel = make_shared<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModelLmActivitySessionModel>(model1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel() = default;
};
class QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel>> lmItemActivitySessionModel{};

  QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList() {}

  explicit QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmItemActivitySessionModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemActivitySessionModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemActivitySessionModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmItemActivitySessionModel") != m.end() && !m["LmItemActivitySessionModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemActivitySessionModel"].type()) {
        vector<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemActivitySessionModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemActivitySessionModel = make_shared<vector<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelListLmItemActivitySessionModel>>(expect1);
      }
    }
  }


  virtual ~QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList() = default;
};
class QueryBestSession4ItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList> lmItemActivitySessionModelList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryBestSession4ItemsResponseBody() {}

  explicit QueryBestSession4ItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmItemActivitySessionModelList) {
      res["LmItemActivitySessionModelList"] = lmItemActivitySessionModelList ? boost::any(lmItemActivitySessionModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmItemActivitySessionModelList") != m.end() && !m["LmItemActivitySessionModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmItemActivitySessionModelList"].type()) {
        QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmItemActivitySessionModelList"]));
        lmItemActivitySessionModelList = make_shared<QueryBestSession4ItemsResponseBodyLmItemActivitySessionModelList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryBestSession4ItemsResponseBody() = default;
};
class QueryBestSession4ItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBestSession4ItemsResponseBody> body{};

  QueryBestSession4ItemsResponse() {}

  explicit QueryBestSession4ItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBestSession4ItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBestSession4ItemsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBestSession4ItemsResponse() = default;
};
class QueryBizItemListRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};
  shared_ptr<map<string, boost::any>> itemIds{};
  shared_ptr<map<string, boost::any>> lmItemIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> userId{};

  QueryBizItemListRequest() {}

  explicit QueryBizItemListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      itemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LmItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lmItemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryBizItemListRequest() = default;
};
class QueryBizItemListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> userId{};

  QueryBizItemListShrinkRequest() {}

  explicit QueryBizItemListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryBizItemListShrinkRequest() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userLabelList{};

  QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userLabelList) {
      res["UserLabelList"] = boost::any(*userLabelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserLabelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserLabelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userLabelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel : public Darabonba::Model {
public:
  shared_ptr<string> accessUrl{};
  shared_ptr<bool> canBuy{};
  shared_ptr<string> characteristicCode{};
  shared_ptr<string> characteristicName{};
  shared_ptr<bool> exclusive{};
  shared_ptr<string> icon{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> recommend{};
  shared_ptr<string> showName{};
  shared_ptr<string> subBizCode{};
  shared_ptr<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList> userLabelList{};

  QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessUrl) {
      res["AccessUrl"] = boost::any(*accessUrl);
    }
    if (canBuy) {
      res["CanBuy"] = boost::any(*canBuy);
    }
    if (characteristicCode) {
      res["CharacteristicCode"] = boost::any(*characteristicCode);
    }
    if (characteristicName) {
      res["CharacteristicName"] = boost::any(*characteristicName);
    }
    if (exclusive) {
      res["Exclusive"] = boost::any(*exclusive);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (recommend) {
      res["Recommend"] = boost::any(*recommend);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (userLabelList) {
      res["UserLabelList"] = userLabelList ? boost::any(userLabelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessUrl") != m.end() && !m["AccessUrl"].empty()) {
      accessUrl = make_shared<string>(boost::any_cast<string>(m["AccessUrl"]));
    }
    if (m.find("CanBuy") != m.end() && !m["CanBuy"].empty()) {
      canBuy = make_shared<bool>(boost::any_cast<bool>(m["CanBuy"]));
    }
    if (m.find("CharacteristicCode") != m.end() && !m["CharacteristicCode"].empty()) {
      characteristicCode = make_shared<string>(boost::any_cast<string>(m["CharacteristicCode"]));
    }
    if (m.find("CharacteristicName") != m.end() && !m["CharacteristicName"].empty()) {
      characteristicName = make_shared<string>(boost::any_cast<string>(m["CharacteristicName"]));
    }
    if (m.find("Exclusive") != m.end() && !m["Exclusive"].empty()) {
      exclusive = make_shared<bool>(boost::any_cast<bool>(m["Exclusive"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Recommend") != m.end() && !m["Recommend"].empty()) {
      recommend = make_shared<bool>(boost::any_cast<bool>(m["Recommend"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserLabelList"].type()) {
        QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserLabelList"]));
        userLabelList = make_shared<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList>(model1);
      }
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel>> gradePriceModel{};

  QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gradePriceModel) {
      vector<boost::any> temp1;
      for(auto item1:*gradePriceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GradePriceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GradePriceModel") != m.end() && !m["GradePriceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["GradePriceModel"].type()) {
        vector<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GradePriceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gradePriceModel = make_shared<vector<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userLabelList{};

  QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userLabelList) {
      res["UserLabelList"] = boost::any(*userLabelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserLabelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserLabelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userLabelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuListSku : public Darabonba::Model {
public:
  shared_ptr<string> benefitId{};
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels> gradePriceModels{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuTitle{};
  shared_ptr<long> taoBaoCurrentPrice{};
  shared_ptr<QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList> userLabelList{};

  QueryBizItemListResponseBodyItemListItemSkuListSku() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuListSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (benefitId) {
      res["BenefitId"] = boost::any(*benefitId);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (gradePriceModels) {
      res["GradePriceModels"] = gradePriceModels ? boost::any(gradePriceModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    if (taoBaoCurrentPrice) {
      res["TaoBaoCurrentPrice"] = boost::any(*taoBaoCurrentPrice);
    }
    if (userLabelList) {
      res["UserLabelList"] = userLabelList ? boost::any(userLabelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BenefitId") != m.end() && !m["BenefitId"].empty()) {
      benefitId = make_shared<string>(boost::any_cast<string>(m["BenefitId"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GradePriceModels") != m.end() && !m["GradePriceModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["GradePriceModels"].type()) {
        QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GradePriceModels"]));
        gradePriceModels = make_shared<QueryBizItemListResponseBodyItemListItemSkuListSkuGradePriceModels>(model1);
      }
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
    if (m.find("TaoBaoCurrentPrice") != m.end() && !m["TaoBaoCurrentPrice"].empty()) {
      taoBaoCurrentPrice = make_shared<long>(boost::any_cast<long>(m["TaoBaoCurrentPrice"]));
    }
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserLabelList"].type()) {
        QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserLabelList"]));
        userLabelList = make_shared<QueryBizItemListResponseBodyItemListItemSkuListSkuUserLabelList>(model1);
      }
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuListSku() = default;
};
class QueryBizItemListResponseBodyItemListItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListResponseBodyItemListItemSkuListSku>> sku{};

  QueryBizItemListResponseBodyItemListItemSkuList() {}

  explicit QueryBizItemListResponseBodyItemListItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryBizItemListResponseBodyItemListItemSkuListSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListResponseBodyItemListItemSkuListSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryBizItemListResponseBodyItemListItemSkuListSku>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItemSkuList() = default;
};
class QueryBizItemListResponseBodyItemListItem : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> customizedItemName{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<QueryBizItemListResponseBodyItemListItemSkuList> skuList{};
  shared_ptr<string> taobaoShopName{};

  QueryBizItemListResponseBodyItemListItem() {}

  explicit QueryBizItemListResponseBodyItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (customizedItemName) {
      res["CustomizedItemName"] = boost::any(*customizedItemName);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (skuList) {
      res["SkuList"] = skuList ? boost::any(skuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taobaoShopName) {
      res["TaobaoShopName"] = boost::any(*taobaoShopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("CustomizedItemName") != m.end() && !m["CustomizedItemName"].empty()) {
      customizedItemName = make_shared<string>(boost::any_cast<string>(m["CustomizedItemName"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuList"].type()) {
        QueryBizItemListResponseBodyItemListItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuList"]));
        skuList = make_shared<QueryBizItemListResponseBodyItemListItemSkuList>(model1);
      }
    }
    if (m.find("TaobaoShopName") != m.end() && !m["TaobaoShopName"].empty()) {
      taobaoShopName = make_shared<string>(boost::any_cast<string>(m["TaobaoShopName"]));
    }
  }


  virtual ~QueryBizItemListResponseBodyItemListItem() = default;
};
class QueryBizItemListResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListResponseBodyItemListItem>> item{};

  QueryBizItemListResponseBodyItemList() {}

  explicit QueryBizItemListResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<QueryBizItemListResponseBodyItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListResponseBodyItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryBizItemListResponseBodyItemListItem>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListResponseBodyItemList() = default;
};
class QueryBizItemListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryBizItemListResponseBodyItemList> itemList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryBizItemListResponseBody() {}

  explicit QueryBizItemListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      res["ItemList"] = itemList ? boost::any(itemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemList"].type()) {
        QueryBizItemListResponseBodyItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemList"]));
        itemList = make_shared<QueryBizItemListResponseBodyItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryBizItemListResponseBody() = default;
};
class QueryBizItemListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBizItemListResponseBody> body{};

  QueryBizItemListResponse() {}

  explicit QueryBizItemListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBizItemListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBizItemListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBizItemListResponse() = default;
};
class QueryBizItemListV2Request : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};
  shared_ptr<vector<long>> itemIds{};
  shared_ptr<vector<string>> lmItemIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> userId{};

  QueryBizItemListV2Request() {}

  explicit QueryBizItemListV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      itemIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmItemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryBizItemListV2Request() = default;
};
class QueryBizItemListV2ShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> userId{};

  QueryBizItemListV2ShrinkRequest() {}

  explicit QueryBizItemListV2ShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryBizItemListV2ShrinkRequest() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userLabelList{};

  QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userLabelList) {
      res["UserLabelList"] = boost::any(*userLabelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserLabelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserLabelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userLabelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel : public Darabonba::Model {
public:
  shared_ptr<string> accessUrl{};
  shared_ptr<bool> canBuy{};
  shared_ptr<string> characteristicCode{};
  shared_ptr<string> characteristicName{};
  shared_ptr<bool> exclusive{};
  shared_ptr<string> icon{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> recommend{};
  shared_ptr<string> showName{};
  shared_ptr<string> subBizCode{};
  shared_ptr<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList> userLabelList{};

  QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessUrl) {
      res["AccessUrl"] = boost::any(*accessUrl);
    }
    if (canBuy) {
      res["CanBuy"] = boost::any(*canBuy);
    }
    if (characteristicCode) {
      res["CharacteristicCode"] = boost::any(*characteristicCode);
    }
    if (characteristicName) {
      res["CharacteristicName"] = boost::any(*characteristicName);
    }
    if (exclusive) {
      res["Exclusive"] = boost::any(*exclusive);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (recommend) {
      res["Recommend"] = boost::any(*recommend);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (userLabelList) {
      res["UserLabelList"] = userLabelList ? boost::any(userLabelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessUrl") != m.end() && !m["AccessUrl"].empty()) {
      accessUrl = make_shared<string>(boost::any_cast<string>(m["AccessUrl"]));
    }
    if (m.find("CanBuy") != m.end() && !m["CanBuy"].empty()) {
      canBuy = make_shared<bool>(boost::any_cast<bool>(m["CanBuy"]));
    }
    if (m.find("CharacteristicCode") != m.end() && !m["CharacteristicCode"].empty()) {
      characteristicCode = make_shared<string>(boost::any_cast<string>(m["CharacteristicCode"]));
    }
    if (m.find("CharacteristicName") != m.end() && !m["CharacteristicName"].empty()) {
      characteristicName = make_shared<string>(boost::any_cast<string>(m["CharacteristicName"]));
    }
    if (m.find("Exclusive") != m.end() && !m["Exclusive"].empty()) {
      exclusive = make_shared<bool>(boost::any_cast<bool>(m["Exclusive"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Recommend") != m.end() && !m["Recommend"].empty()) {
      recommend = make_shared<bool>(boost::any_cast<bool>(m["Recommend"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserLabelList"].type()) {
        QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserLabelList"]));
        userLabelList = make_shared<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModelUserLabelList>(model1);
      }
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel>> gradePriceModel{};

  QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gradePriceModel) {
      vector<boost::any> temp1;
      for(auto item1:*gradePriceModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GradePriceModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GradePriceModel") != m.end() && !m["GradePriceModel"].empty()) {
      if (typeid(vector<boost::any>) == m["GradePriceModel"].type()) {
        vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GradePriceModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gradePriceModel = make_shared<vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModelsGradePriceModel>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userLabelList{};

  QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userLabelList) {
      res["UserLabelList"] = boost::any(*userLabelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserLabelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserLabelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userLabelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuListSku : public Darabonba::Model {
public:
  shared_ptr<string> benefitId{};
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels> gradePriceModels{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuTitle{};
  shared_ptr<long> taoBaoCurrentPrice{};
  shared_ptr<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList> userLabelList{};

  QueryBizItemListV2ResponseBodyItemListItemSkuListSku() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuListSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (benefitId) {
      res["BenefitId"] = boost::any(*benefitId);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (gradePriceModels) {
      res["GradePriceModels"] = gradePriceModels ? boost::any(gradePriceModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    if (taoBaoCurrentPrice) {
      res["TaoBaoCurrentPrice"] = boost::any(*taoBaoCurrentPrice);
    }
    if (userLabelList) {
      res["UserLabelList"] = userLabelList ? boost::any(userLabelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BenefitId") != m.end() && !m["BenefitId"].empty()) {
      benefitId = make_shared<string>(boost::any_cast<string>(m["BenefitId"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GradePriceModels") != m.end() && !m["GradePriceModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["GradePriceModels"].type()) {
        QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GradePriceModels"]));
        gradePriceModels = make_shared<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuGradePriceModels>(model1);
      }
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
    if (m.find("TaoBaoCurrentPrice") != m.end() && !m["TaoBaoCurrentPrice"].empty()) {
      taoBaoCurrentPrice = make_shared<long>(boost::any_cast<long>(m["TaoBaoCurrentPrice"]));
    }
    if (m.find("UserLabelList") != m.end() && !m["UserLabelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserLabelList"].type()) {
        QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserLabelList"]));
        userLabelList = make_shared<QueryBizItemListV2ResponseBodyItemListItemSkuListSkuUserLabelList>(model1);
      }
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuListSku() = default;
};
class QueryBizItemListV2ResponseBodyItemListItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSku>> sku{};

  QueryBizItemListV2ResponseBodyItemListItemSkuList() {}

  explicit QueryBizItemListV2ResponseBodyItemListItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListV2ResponseBodyItemListItemSkuListSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryBizItemListV2ResponseBodyItemListItemSkuListSku>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItemSkuList() = default;
};
class QueryBizItemListV2ResponseBodyItemListItem : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> customizedItemName{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<QueryBizItemListV2ResponseBodyItemListItemSkuList> skuList{};
  shared_ptr<string> taobaoShopName{};

  QueryBizItemListV2ResponseBodyItemListItem() {}

  explicit QueryBizItemListV2ResponseBodyItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (customizedItemName) {
      res["CustomizedItemName"] = boost::any(*customizedItemName);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (skuList) {
      res["SkuList"] = skuList ? boost::any(skuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taobaoShopName) {
      res["TaobaoShopName"] = boost::any(*taobaoShopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("CustomizedItemName") != m.end() && !m["CustomizedItemName"].empty()) {
      customizedItemName = make_shared<string>(boost::any_cast<string>(m["CustomizedItemName"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuList"].type()) {
        QueryBizItemListV2ResponseBodyItemListItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuList"]));
        skuList = make_shared<QueryBizItemListV2ResponseBodyItemListItemSkuList>(model1);
      }
    }
    if (m.find("TaobaoShopName") != m.end() && !m["TaobaoShopName"].empty()) {
      taobaoShopName = make_shared<string>(boost::any_cast<string>(m["TaobaoShopName"]));
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemListItem() = default;
};
class QueryBizItemListV2ResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemListV2ResponseBodyItemListItem>> item{};

  QueryBizItemListV2ResponseBodyItemList() {}

  explicit QueryBizItemListV2ResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<QueryBizItemListV2ResponseBodyItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListV2ResponseBodyItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryBizItemListV2ResponseBodyItemListItem>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemListV2ResponseBodyItemList() = default;
};
class QueryBizItemListV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryBizItemListV2ResponseBodyItemList> itemList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryBizItemListV2ResponseBody() {}

  explicit QueryBizItemListV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      res["ItemList"] = itemList ? boost::any(itemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemList"].type()) {
        QueryBizItemListV2ResponseBodyItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemList"]));
        itemList = make_shared<QueryBizItemListV2ResponseBodyItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryBizItemListV2ResponseBody() = default;
};
class QueryBizItemListV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBizItemListV2ResponseBody> body{};

  QueryBizItemListV2Response() {}

  explicit QueryBizItemListV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBizItemListV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBizItemListV2ResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBizItemListV2Response() = default;
};
class QueryBizItemListWithCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<long>> itemIds{};
  shared_ptr<vector<string>> lmItemIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizCode{};

  QueryBizItemListWithCacheRequest() {}

  explicit QueryBizItemListWithCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      itemIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmItemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryBizItemListWithCacheRequest() = default;
};
class QueryBizItemListWithCacheShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizCode{};

  QueryBizItemListWithCacheShrinkRequest() {}

  explicit QueryBizItemListWithCacheShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryBizItemListWithCacheShrinkRequest() = default;
};
class QueryBizItemListWithCacheResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> status{};

  QueryBizItemListWithCacheResponseBodyItemList() {}

  explicit QueryBizItemListWithCacheResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryBizItemListWithCacheResponseBodyItemList() = default;
};
class QueryBizItemListWithCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryBizItemListWithCacheResponseBodyItemList>> itemList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryBizItemListWithCacheResponseBody() {}

  explicit QueryBizItemListWithCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<QueryBizItemListWithCacheResponseBodyItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemListWithCacheResponseBodyItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<QueryBizItemListWithCacheResponseBodyItemList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryBizItemListWithCacheResponseBody() = default;
};
class QueryBizItemListWithCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBizItemListWithCacheResponseBody> body{};

  QueryBizItemListWithCacheResponse() {}

  explicit QueryBizItemListWithCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBizItemListWithCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBizItemListWithCacheResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBizItemListWithCacheResponse() = default;
};
class QueryBizItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> userId{};

  QueryBizItemsRequest() {}

  explicit QueryBizItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryBizItemsRequest() = default;
};
class QueryBizItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryBizItemsResponseBody() {}

  explicit QueryBizItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryBizItemsResponseBody() = default;
};
class QueryBizItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBizItemsResponseBody> body{};

  QueryBizItemsResponse() {}

  explicit QueryBizItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBizItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBizItemsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBizItemsResponse() = default;
};
class QueryBizItemsWithActivityRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> itemIds{};
  shared_ptr<map<string, boost::any>> lmItemIds{};

  QueryBizItemsWithActivityRequest() {}

  explicit QueryBizItemsWithActivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      itemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LmItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lmItemIds = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryBizItemsWithActivityRequest() = default;
};
class QueryBizItemsWithActivityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};

  QueryBizItemsWithActivityShrinkRequest() {}

  explicit QueryBizItemsWithActivityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
  }


  virtual ~QueryBizItemsWithActivityShrinkRequest() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku : public Darabonba::Model {
public:
  shared_ptr<long> activityPrice{};
  shared_ptr<long> skuId{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityPrice) {
      res["ActivityPrice"] = boost::any(*activityPrice);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityPrice") != m.end() && !m["ActivityPrice"].empty()) {
      activityPrice = make_shared<long>(boost::any_cast<long>(m["ActivityPrice"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku>> activityItemSku{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityItemSku) {
      vector<boost::any> temp1;
      for(auto item1:*activityItemSku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivityItemSku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityItemSku") != m.end() && !m["ActivityItemSku"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivityItemSku"].type()) {
        vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivityItemSku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activityItemSku = make_shared<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuListActivityItemSku>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem : public Darabonba::Model {
public:
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList> activityItemSkuList{};
  shared_ptr<long> activityQuantity{};
  shared_ptr<long> limitQuantityForPerson{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityItemSkuList) {
      res["ActivityItemSkuList"] = activityItemSkuList ? boost::any(activityItemSkuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (activityQuantity) {
      res["ActivityQuantity"] = boost::any(*activityQuantity);
    }
    if (limitQuantityForPerson) {
      res["LimitQuantityForPerson"] = boost::any(*limitQuantityForPerson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityItemSkuList") != m.end() && !m["ActivityItemSkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityItemSkuList"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityItemSkuList"]));
        activityItemSkuList = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItemActivityItemSkuList>(model1);
      }
    }
    if (m.find("ActivityQuantity") != m.end() && !m["ActivityQuantity"].empty()) {
      activityQuantity = make_shared<long>(boost::any_cast<long>(m["ActivityQuantity"]));
    }
    if (m.find("LimitQuantityForPerson") != m.end() && !m["LimitQuantityForPerson"].empty()) {
      limitQuantityForPerson = make_shared<long>(boost::any_cast<long>(m["LimitQuantityForPerson"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList : public Darabonba::Model {
public:
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> skuId{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem : public Darabonba::Model {
public:
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList> activitySessionItemSkuList{};
  shared_ptr<long> limitQuantityForPerson{};
  shared_ptr<long> saleableQuantity{};
  shared_ptr<long> sessionQuantity{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activitySessionItemSkuList) {
      res["ActivitySessionItemSkuList"] = activitySessionItemSkuList ? boost::any(activitySessionItemSkuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (limitQuantityForPerson) {
      res["LimitQuantityForPerson"] = boost::any(*limitQuantityForPerson);
    }
    if (saleableQuantity) {
      res["SaleableQuantity"] = boost::any(*saleableQuantity);
    }
    if (sessionQuantity) {
      res["SessionQuantity"] = boost::any(*sessionQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivitySessionItemSkuList") != m.end() && !m["ActivitySessionItemSkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivitySessionItemSkuList"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivitySessionItemSkuList"]));
        activitySessionItemSkuList = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItemActivitySessionItemSkuList>(model1);
      }
    }
    if (m.find("LimitQuantityForPerson") != m.end() && !m["LimitQuantityForPerson"].empty()) {
      limitQuantityForPerson = make_shared<long>(boost::any_cast<long>(m["LimitQuantityForPerson"]));
    }
    if (m.find("SaleableQuantity") != m.end() && !m["SaleableQuantity"].empty()) {
      saleableQuantity = make_shared<long>(boost::any_cast<long>(m["SaleableQuantity"]));
    }
    if (m.find("SessionQuantity") != m.end() && !m["SessionQuantity"].empty()) {
      sessionQuantity = make_shared<long>(boost::any_cast<long>(m["SessionQuantity"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession : public Darabonba::Model {
public:
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem> activitySessionItem{};
  shared_ptr<string> description{};
  shared_ptr<long> displayDate{};
  shared_ptr<long> endDate{};
  shared_ptr<long> lmSessionId{};
  shared_ptr<long> startDate{};
  shared_ptr<string> subBizCode{};
  shared_ptr<string> title{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activitySessionItem) {
      res["ActivitySessionItem"] = activitySessionItem ? boost::any(activitySessionItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lmSessionId) {
      res["LmSessionId"] = boost::any(*lmSessionId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivitySessionItem") != m.end() && !m["ActivitySessionItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivitySessionItem"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivitySessionItem"]));
        activitySessionItem = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySessionActivitySessionItem>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<long>(boost::any_cast<long>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("LmSessionId") != m.end() && !m["LmSessionId"].empty()) {
      lmSessionId = make_shared<long>(boost::any_cast<long>(m["LmSessionId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession>> activitySession{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activitySession) {
      vector<boost::any> temp1;
      for(auto item1:*activitySession){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivitySession"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivitySession") != m.end() && !m["ActivitySession"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivitySession"].type()) {
        vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivitySession"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activitySession = make_shared<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessionsActivitySession>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity : public Darabonba::Model {
public:
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem> activityItem{};
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions> activitySessions{};
  shared_ptr<string> description{};
  shared_ptr<long> endDate{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> startDate{};
  shared_ptr<string> title{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityItem) {
      res["ActivityItem"] = activityItem ? boost::any(activityItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (activitySessions) {
      res["ActivitySessions"] = activitySessions ? boost::any(activitySessions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityItem") != m.end() && !m["ActivityItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivityItem"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivityItem"]));
        activityItem = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivityItem>(model1);
      }
    }
    if (m.find("ActivitySessions") != m.end() && !m["ActivitySessions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActivitySessions"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActivitySessions"]));
        activitySessions = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivityActivitySessions>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemActivities : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity>> activity{};

  QueryBizItemsWithActivityResponseBodyItemListItemActivities() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemActivities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activity) {
      vector<boost::any> temp1;
      for(auto item1:*activity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Activity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activity") != m.end() && !m["Activity"].empty()) {
      if (typeid(vector<boost::any>) == m["Activity"].type()) {
        vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Activity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activity = make_shared<vector<QueryBizItemsWithActivityResponseBodyItemListItemActivitiesActivity>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemActivities() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku : public Darabonba::Model {
public:
  shared_ptr<long> maxAllowedCount{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<string> pointsInfo{};
  shared_ptr<string> pointsKey{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};
  shared_ptr<long> status{};

  QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAllowedCount) {
      res["MaxAllowedCount"] = boost::any(*maxAllowedCount);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (pointsInfo) {
      res["PointsInfo"] = boost::any(*pointsInfo);
    }
    if (pointsKey) {
      res["PointsKey"] = boost::any(*pointsKey);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxAllowedCount") != m.end() && !m["MaxAllowedCount"].empty()) {
      maxAllowedCount = make_shared<long>(boost::any_cast<long>(m["MaxAllowedCount"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PointsInfo") != m.end() && !m["PointsInfo"].empty()) {
      pointsInfo = make_shared<string>(boost::any_cast<string>(m["PointsInfo"]));
    }
    if (m.find("PointsKey") != m.end() && !m["PointsKey"].empty()) {
      pointsKey = make_shared<string>(boost::any_cast<string>(m["PointsKey"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku>> sku{};

  QueryBizItemsWithActivityResponseBodyItemListItemSkuList() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryBizItemsWithActivityResponseBodyItemListItemSkuListSku>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItemSkuList() = default;
};
class QueryBizItemsWithActivityResponseBodyItemListItem : public Darabonba::Model {
public:
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemActivities> activities{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> maxAllowedCount{};
  shared_ptr<string> picUrl{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemListItemSkuList> skuList{};
  shared_ptr<string> taobaoShopName{};
  shared_ptr<long> totalSoldQuantity{};

  QueryBizItemsWithActivityResponseBodyItemListItem() {}

  explicit QueryBizItemsWithActivityResponseBodyItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activities) {
      res["Activities"] = activities ? boost::any(activities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (maxAllowedCount) {
      res["MaxAllowedCount"] = boost::any(*maxAllowedCount);
    }
    if (picUrl) {
      res["PicUrl"] = boost::any(*picUrl);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (skuList) {
      res["SkuList"] = skuList ? boost::any(skuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taobaoShopName) {
      res["TaobaoShopName"] = boost::any(*taobaoShopName);
    }
    if (totalSoldQuantity) {
      res["TotalSoldQuantity"] = boost::any(*totalSoldQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Activities") != m.end() && !m["Activities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Activities"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemActivities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Activities"]));
        activities = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemActivities>(model1);
      }
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MaxAllowedCount") != m.end() && !m["MaxAllowedCount"].empty()) {
      maxAllowedCount = make_shared<long>(boost::any_cast<long>(m["MaxAllowedCount"]));
    }
    if (m.find("PicUrl") != m.end() && !m["PicUrl"].empty()) {
      picUrl = make_shared<string>(boost::any_cast<string>(m["PicUrl"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuList"].type()) {
        QueryBizItemsWithActivityResponseBodyItemListItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuList"]));
        skuList = make_shared<QueryBizItemsWithActivityResponseBodyItemListItemSkuList>(model1);
      }
    }
    if (m.find("TaobaoShopName") != m.end() && !m["TaobaoShopName"].empty()) {
      taobaoShopName = make_shared<string>(boost::any_cast<string>(m["TaobaoShopName"]));
    }
    if (m.find("TotalSoldQuantity") != m.end() && !m["TotalSoldQuantity"].empty()) {
      totalSoldQuantity = make_shared<long>(boost::any_cast<long>(m["TotalSoldQuantity"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemListItem() = default;
};
class QueryBizItemsWithActivityResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBizItemsWithActivityResponseBodyItemListItem>> item{};

  QueryBizItemsWithActivityResponseBodyItemList() {}

  explicit QueryBizItemsWithActivityResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<QueryBizItemsWithActivityResponseBodyItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBizItemsWithActivityResponseBodyItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryBizItemsWithActivityResponseBodyItemListItem>>(expect1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBodyItemList() = default;
};
class QueryBizItemsWithActivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryBizItemsWithActivityResponseBodyItemList> itemList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryBizItemsWithActivityResponseBody() {}

  explicit QueryBizItemsWithActivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      res["ItemList"] = itemList ? boost::any(itemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemList"].type()) {
        QueryBizItemsWithActivityResponseBodyItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemList"]));
        itemList = make_shared<QueryBizItemsWithActivityResponseBodyItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryBizItemsWithActivityResponseBody() = default;
};
class QueryBizItemsWithActivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBizItemsWithActivityResponseBody> body{};

  QueryBizItemsWithActivityResponse() {}

  explicit QueryBizItemsWithActivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBizItemsWithActivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBizItemsWithActivityResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBizItemsWithActivityResponse() = default;
};
class QueryBudgetTicketItemListByBizIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> budgetTicketNo{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryBudgetTicketItemListByBizIdRequest() {}

  explicit QueryBudgetTicketItemListByBizIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (budgetTicketNo) {
      res["BudgetTicketNo"] = boost::any(*budgetTicketNo);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BudgetTicketNo") != m.end() && !m["BudgetTicketNo"].empty()) {
      budgetTicketNo = make_shared<string>(boost::any_cast<string>(m["BudgetTicketNo"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryBudgetTicketItemListByBizIdRequest() = default;
};
class QueryBudgetTicketItemListByBizIdResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<bool> invalid{};
  shared_ptr<long> itemId{};
  shared_ptr<string> poCode{};
  shared_ptr<string> promotionId{};
  shared_ptr<long> remnantAmount{};
  shared_ptr<string> securityCode{};
  shared_ptr<long> settlementPrice{};
  shared_ptr<long> skuId{};
  shared_ptr<long> subsidyAmount{};

  QueryBudgetTicketItemListByBizIdResponseBodyModel() {}

  explicit QueryBudgetTicketItemListByBizIdResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalid) {
      res["Invalid"] = boost::any(*invalid);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (poCode) {
      res["PoCode"] = boost::any(*poCode);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (remnantAmount) {
      res["RemnantAmount"] = boost::any(*remnantAmount);
    }
    if (securityCode) {
      res["SecurityCode"] = boost::any(*securityCode);
    }
    if (settlementPrice) {
      res["SettlementPrice"] = boost::any(*settlementPrice);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (subsidyAmount) {
      res["SubsidyAmount"] = boost::any(*subsidyAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Invalid") != m.end() && !m["Invalid"].empty()) {
      invalid = make_shared<bool>(boost::any_cast<bool>(m["Invalid"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("PoCode") != m.end() && !m["PoCode"].empty()) {
      poCode = make_shared<string>(boost::any_cast<string>(m["PoCode"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("RemnantAmount") != m.end() && !m["RemnantAmount"].empty()) {
      remnantAmount = make_shared<long>(boost::any_cast<long>(m["RemnantAmount"]));
    }
    if (m.find("SecurityCode") != m.end() && !m["SecurityCode"].empty()) {
      securityCode = make_shared<string>(boost::any_cast<string>(m["SecurityCode"]));
    }
    if (m.find("SettlementPrice") != m.end() && !m["SettlementPrice"].empty()) {
      settlementPrice = make_shared<long>(boost::any_cast<long>(m["SettlementPrice"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SubsidyAmount") != m.end() && !m["SubsidyAmount"].empty()) {
      subsidyAmount = make_shared<long>(boost::any_cast<long>(m["SubsidyAmount"]));
    }
  }


  virtual ~QueryBudgetTicketItemListByBizIdResponseBodyModel() = default;
};
class QueryBudgetTicketItemListByBizIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryBudgetTicketItemListByBizIdResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryBudgetTicketItemListByBizIdResponseBody() {}

  explicit QueryBudgetTicketItemListByBizIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryBudgetTicketItemListByBizIdResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBudgetTicketItemListByBizIdResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryBudgetTicketItemListByBizIdResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryBudgetTicketItemListByBizIdResponseBody() = default;
};
class QueryBudgetTicketItemListByBizIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBudgetTicketItemListByBizIdResponseBody> body{};

  QueryBudgetTicketItemListByBizIdResponse() {}

  explicit QueryBudgetTicketItemListByBizIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBudgetTicketItemListByBizIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBudgetTicketItemListByBizIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBudgetTicketItemListByBizIdResponse() = default;
};
class QueryChannelItemBillDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> billPeriod{};
  shared_ptr<string> billStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizName{};
  shared_ptr<long> lmShopId{};
  shared_ptr<string> lmShopName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};

  QueryChannelItemBillDownloadUrlRequest() {}

  explicit QueryChannelItemBillDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (billPeriod) {
      res["BillPeriod"] = boost::any(*billPeriod);
    }
    if (billStatus) {
      res["BillStatus"] = boost::any(*billStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (lmShopName) {
      res["LmShopName"] = boost::any(*lmShopName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("BillPeriod") != m.end() && !m["BillPeriod"].empty()) {
      billPeriod = make_shared<string>(boost::any_cast<string>(m["BillPeriod"]));
    }
    if (m.find("BillStatus") != m.end() && !m["BillStatus"].empty()) {
      billStatus = make_shared<string>(boost::any_cast<string>(m["BillStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("LmShopName") != m.end() && !m["LmShopName"].empty()) {
      lmShopName = make_shared<string>(boost::any_cast<string>(m["LmShopName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~QueryChannelItemBillDownloadUrlRequest() = default;
};
class QueryChannelItemBillDownloadUrlResponseBodyModelData : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> fileDownloadUrl{};
  shared_ptr<string> message{};

  QueryChannelItemBillDownloadUrlResponseBodyModelData() {}

  explicit QueryChannelItemBillDownloadUrlResponseBodyModelData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (fileDownloadUrl) {
      res["FileDownloadUrl"] = boost::any(*fileDownloadUrl);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("FileDownloadUrl") != m.end() && !m["FileDownloadUrl"].empty()) {
      fileDownloadUrl = make_shared<string>(boost::any_cast<string>(m["FileDownloadUrl"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryChannelItemBillDownloadUrlResponseBodyModelData() = default;
};
class QueryChannelItemBillDownloadUrlResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<QueryChannelItemBillDownloadUrlResponseBodyModelData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QueryChannelItemBillDownloadUrlResponseBodyModel() {}

  explicit QueryChannelItemBillDownloadUrlResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryChannelItemBillDownloadUrlResponseBodyModelData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryChannelItemBillDownloadUrlResponseBodyModelData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryChannelItemBillDownloadUrlResponseBodyModelData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QueryChannelItemBillDownloadUrlResponseBodyModel() = default;
};
class QueryChannelItemBillDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryChannelItemBillDownloadUrlResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QueryChannelItemBillDownloadUrlResponseBody() {}

  explicit QueryChannelItemBillDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryChannelItemBillDownloadUrlResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryChannelItemBillDownloadUrlResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryChannelItemBillDownloadUrlResponseBody() = default;
};
class QueryChannelItemBillDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryChannelItemBillDownloadUrlResponseBody> body{};

  QueryChannelItemBillDownloadUrlResponse() {}

  explicit QueryChannelItemBillDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryChannelItemBillDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryChannelItemBillDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~QueryChannelItemBillDownloadUrlResponse() = default;
};
class QueryGuideItemGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> itemState{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryGuideItemGroupRequest() {}

  explicit QueryGuideItemGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (itemState) {
      res["ItemState"] = boost::any(*itemState);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ItemState") != m.end() && !m["ItemState"].empty()) {
      itemState = make_shared<string>(boost::any_cast<string>(m["ItemState"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryGuideItemGroupRequest() = default;
};
class QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<string> reservePrice{};

  QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo() {}

  explicit QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<string>(boost::any_cast<string>(m["ReservePrice"]));
    }
  }


  virtual ~QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo() = default;
};
class QueryGuideItemGroupResponseBodyGuideItemGroup : public Darabonba::Model {
public:
  shared_ptr<vector<QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo>> itemInfo{};

  QueryGuideItemGroupResponseBodyGuideItemGroup() {}

  explicit QueryGuideItemGroupResponseBodyGuideItemGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemInfo) {
      vector<boost::any> temp1;
      for(auto item1:*itemInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemInfo") != m.end() && !m["ItemInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemInfo"].type()) {
        vector<QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemInfo = make_shared<vector<QueryGuideItemGroupResponseBodyGuideItemGroupItemInfo>>(expect1);
      }
    }
  }


  virtual ~QueryGuideItemGroupResponseBodyGuideItemGroup() = default;
};
class QueryGuideItemGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryGuideItemGroupResponseBodyGuideItemGroup> guideItemGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryGuideItemGroupResponseBody() {}

  explicit QueryGuideItemGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (guideItemGroup) {
      res["GuideItemGroup"] = guideItemGroup ? boost::any(guideItemGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GuideItemGroup") != m.end() && !m["GuideItemGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["GuideItemGroup"].type()) {
        QueryGuideItemGroupResponseBodyGuideItemGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GuideItemGroup"]));
        guideItemGroup = make_shared<QueryGuideItemGroupResponseBodyGuideItemGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryGuideItemGroupResponseBody() = default;
};
class QueryGuideItemGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGuideItemGroupResponseBody> body{};

  QueryGuideItemGroupResponse() {}

  explicit QueryGuideItemGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGuideItemGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGuideItemGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGuideItemGroupResponse() = default;
};
class QueryGuideItemGroupForCrowdOperationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> itemState{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userFlag{};

  QueryGuideItemGroupForCrowdOperationRequest() {}

  explicit QueryGuideItemGroupForCrowdOperationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (itemState) {
      res["ItemState"] = boost::any(*itemState);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userFlag) {
      res["UserFlag"] = boost::any(*userFlag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ItemState") != m.end() && !m["ItemState"].empty()) {
      itemState = make_shared<string>(boost::any_cast<string>(m["ItemState"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserFlag") != m.end() && !m["UserFlag"].empty()) {
      userFlag = make_shared<string>(boost::any_cast<string>(m["UserFlag"]));
    }
  }


  virtual ~QueryGuideItemGroupForCrowdOperationRequest() = default;
};
class QueryGuideItemGroupForCrowdOperationResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> atmospherePicUrl{};
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, string>> customizedAttributeMap{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<string> reservePrice{};
  shared_ptr<vector<long>> tags{};
  shared_ptr<string> whitePicUrl{};

  QueryGuideItemGroupForCrowdOperationResponseBodyModel() {}

  explicit QueryGuideItemGroupForCrowdOperationResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (atmospherePicUrl) {
      res["AtmospherePicUrl"] = boost::any(*atmospherePicUrl);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (whitePicUrl) {
      res["WhitePicUrl"] = boost::any(*whitePicUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AtmospherePicUrl") != m.end() && !m["AtmospherePicUrl"].empty()) {
      atmospherePicUrl = make_shared<string>(boost::any_cast<string>(m["AtmospherePicUrl"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["CustomizedAttributeMap"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<string>(boost::any_cast<string>(m["ReservePrice"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      tags = make_shared<vector<long>>(toVec1);
    }
    if (m.find("WhitePicUrl") != m.end() && !m["WhitePicUrl"].empty()) {
      whitePicUrl = make_shared<string>(boost::any_cast<string>(m["WhitePicUrl"]));
    }
  }


  virtual ~QueryGuideItemGroupForCrowdOperationResponseBodyModel() = default;
};
class QueryGuideItemGroupForCrowdOperationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryGuideItemGroupForCrowdOperationResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryGuideItemGroupForCrowdOperationResponseBody() {}

  explicit QueryGuideItemGroupForCrowdOperationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryGuideItemGroupForCrowdOperationResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryGuideItemGroupForCrowdOperationResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryGuideItemGroupForCrowdOperationResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryGuideItemGroupForCrowdOperationResponseBody() = default;
};
class QueryGuideItemGroupForCrowdOperationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGuideItemGroupForCrowdOperationResponseBody> body{};

  QueryGuideItemGroupForCrowdOperationResponse() {}

  explicit QueryGuideItemGroupForCrowdOperationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGuideItemGroupForCrowdOperationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGuideItemGroupForCrowdOperationResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGuideItemGroupForCrowdOperationResponse() = default;
};
class QueryGuideItemGroupWithOutInventoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryGuideItemGroupWithOutInventoryRequest() {}

  explicit QueryGuideItemGroupWithOutInventoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryGuideItemGroupWithOutInventoryRequest() = default;
};
class QueryGuideItemGroupWithOutInventoryResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<string> itemId{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<string> reservePrice{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> whitePicUrl{};

  QueryGuideItemGroupWithOutInventoryResponseBodyItemList() {}

  explicit QueryGuideItemGroupWithOutInventoryResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (whitePicUrl) {
      res["WhitePicUrl"] = boost::any(*whitePicUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<string>(boost::any_cast<string>(m["ReservePrice"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhitePicUrl") != m.end() && !m["WhitePicUrl"].empty()) {
      whitePicUrl = make_shared<string>(boost::any_cast<string>(m["WhitePicUrl"]));
    }
  }


  virtual ~QueryGuideItemGroupWithOutInventoryResponseBodyItemList() = default;
};
class QueryGuideItemGroupWithOutInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryGuideItemGroupWithOutInventoryResponseBodyItemList>> itemList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryGuideItemGroupWithOutInventoryResponseBody() {}

  explicit QueryGuideItemGroupWithOutInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<QueryGuideItemGroupWithOutInventoryResponseBodyItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryGuideItemGroupWithOutInventoryResponseBodyItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<QueryGuideItemGroupWithOutInventoryResponseBodyItemList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryGuideItemGroupWithOutInventoryResponseBody() = default;
};
class QueryGuideItemGroupWithOutInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGuideItemGroupWithOutInventoryResponseBody> body{};

  QueryGuideItemGroupWithOutInventoryResponse() {}

  explicit QueryGuideItemGroupWithOutInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGuideItemGroupWithOutInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGuideItemGroupWithOutInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGuideItemGroupWithOutInventoryResponse() = default;
};
class QueryHotMoviesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> cityCode{};
  shared_ptr<string> extJson{};

  QueryHotMoviesRequest() {}

  explicit QueryHotMoviesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
  }


  virtual ~QueryHotMoviesRequest() = default;
};
class QueryHotMoviesResponseBodyMoviesMovieMovieTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> movieTypeList{};

  QueryHotMoviesResponseBodyMoviesMovieMovieTypeList() {}

  explicit QueryHotMoviesResponseBodyMoviesMovieMovieTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (movieTypeList) {
      res["MovieTypeList"] = boost::any(*movieTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MovieTypeList") != m.end() && !m["MovieTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MovieTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MovieTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      movieTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryHotMoviesResponseBodyMoviesMovieMovieTypeList() = default;
};
class QueryHotMoviesResponseBodyMoviesMovieTrailerList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> trailerList{};

  QueryHotMoviesResponseBodyMoviesMovieTrailerList() {}

  explicit QueryHotMoviesResponseBodyMoviesMovieTrailerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trailerList) {
      res["TrailerList"] = boost::any(*trailerList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrailerList") != m.end() && !m["TrailerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TrailerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TrailerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trailerList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryHotMoviesResponseBodyMoviesMovieTrailerList() = default;
};
class QueryHotMoviesResponseBodyMoviesMovie : public Darabonba::Model {
public:
  shared_ptr<string> backgroundPicture{};
  shared_ptr<string> country{};
  shared_ptr<string> description{};
  shared_ptr<string> director{};
  shared_ptr<long> duration{};
  shared_ptr<string> highlight{};
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<string> leadingRole{};
  shared_ptr<string> movieName{};
  shared_ptr<string> movieNameEn{};
  shared_ptr<QueryHotMoviesResponseBodyMoviesMovieMovieTypeList> movieTypeList{};
  shared_ptr<string> movieVersion{};
  shared_ptr<string> openDay{};
  shared_ptr<string> openTime{};
  shared_ptr<string> poster{};
  shared_ptr<string> remark{};
  shared_ptr<QueryHotMoviesResponseBodyMoviesMovieTrailerList> trailerList{};
  shared_ptr<string> type{};

  QueryHotMoviesResponseBodyMoviesMovie() {}

  explicit QueryHotMoviesResponseBodyMoviesMovie(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundPicture) {
      res["BackgroundPicture"] = boost::any(*backgroundPicture);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (director) {
      res["Director"] = boost::any(*director);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (highlight) {
      res["Highlight"] = boost::any(*highlight);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (leadingRole) {
      res["LeadingRole"] = boost::any(*leadingRole);
    }
    if (movieName) {
      res["MovieName"] = boost::any(*movieName);
    }
    if (movieNameEn) {
      res["MovieNameEn"] = boost::any(*movieNameEn);
    }
    if (movieTypeList) {
      res["MovieTypeList"] = movieTypeList ? boost::any(movieTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (movieVersion) {
      res["MovieVersion"] = boost::any(*movieVersion);
    }
    if (openDay) {
      res["OpenDay"] = boost::any(*openDay);
    }
    if (openTime) {
      res["OpenTime"] = boost::any(*openTime);
    }
    if (poster) {
      res["Poster"] = boost::any(*poster);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (trailerList) {
      res["TrailerList"] = trailerList ? boost::any(trailerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundPicture") != m.end() && !m["BackgroundPicture"].empty()) {
      backgroundPicture = make_shared<string>(boost::any_cast<string>(m["BackgroundPicture"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Director") != m.end() && !m["Director"].empty()) {
      director = make_shared<string>(boost::any_cast<string>(m["Director"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Highlight") != m.end() && !m["Highlight"].empty()) {
      highlight = make_shared<string>(boost::any_cast<string>(m["Highlight"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LeadingRole") != m.end() && !m["LeadingRole"].empty()) {
      leadingRole = make_shared<string>(boost::any_cast<string>(m["LeadingRole"]));
    }
    if (m.find("MovieName") != m.end() && !m["MovieName"].empty()) {
      movieName = make_shared<string>(boost::any_cast<string>(m["MovieName"]));
    }
    if (m.find("MovieNameEn") != m.end() && !m["MovieNameEn"].empty()) {
      movieNameEn = make_shared<string>(boost::any_cast<string>(m["MovieNameEn"]));
    }
    if (m.find("MovieTypeList") != m.end() && !m["MovieTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MovieTypeList"].type()) {
        QueryHotMoviesResponseBodyMoviesMovieMovieTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MovieTypeList"]));
        movieTypeList = make_shared<QueryHotMoviesResponseBodyMoviesMovieMovieTypeList>(model1);
      }
    }
    if (m.find("MovieVersion") != m.end() && !m["MovieVersion"].empty()) {
      movieVersion = make_shared<string>(boost::any_cast<string>(m["MovieVersion"]));
    }
    if (m.find("OpenDay") != m.end() && !m["OpenDay"].empty()) {
      openDay = make_shared<string>(boost::any_cast<string>(m["OpenDay"]));
    }
    if (m.find("OpenTime") != m.end() && !m["OpenTime"].empty()) {
      openTime = make_shared<string>(boost::any_cast<string>(m["OpenTime"]));
    }
    if (m.find("Poster") != m.end() && !m["Poster"].empty()) {
      poster = make_shared<string>(boost::any_cast<string>(m["Poster"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TrailerList") != m.end() && !m["TrailerList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrailerList"].type()) {
        QueryHotMoviesResponseBodyMoviesMovieTrailerList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrailerList"]));
        trailerList = make_shared<QueryHotMoviesResponseBodyMoviesMovieTrailerList>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryHotMoviesResponseBodyMoviesMovie() = default;
};
class QueryHotMoviesResponseBodyMovies : public Darabonba::Model {
public:
  shared_ptr<vector<QueryHotMoviesResponseBodyMoviesMovie>> movie{};

  QueryHotMoviesResponseBodyMovies() {}

  explicit QueryHotMoviesResponseBodyMovies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (movie) {
      vector<boost::any> temp1;
      for(auto item1:*movie){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Movie"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Movie") != m.end() && !m["Movie"].empty()) {
      if (typeid(vector<boost::any>) == m["Movie"].type()) {
        vector<QueryHotMoviesResponseBodyMoviesMovie> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Movie"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryHotMoviesResponseBodyMoviesMovie model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        movie = make_shared<vector<QueryHotMoviesResponseBodyMoviesMovie>>(expect1);
      }
    }
  }


  virtual ~QueryHotMoviesResponseBodyMovies() = default;
};
class QueryHotMoviesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryHotMoviesResponseBodyMovies> movies{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryHotMoviesResponseBody() {}

  explicit QueryHotMoviesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (movies) {
      res["Movies"] = movies ? boost::any(movies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Movies") != m.end() && !m["Movies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Movies"].type()) {
        QueryHotMoviesResponseBodyMovies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Movies"]));
        movies = make_shared<QueryHotMoviesResponseBodyMovies>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryHotMoviesResponseBody() = default;
};
class QueryHotMoviesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryHotMoviesResponseBody> body{};

  QueryHotMoviesResponse() {}

  explicit QueryHotMoviesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryHotMoviesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryHotMoviesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryHotMoviesResponse() = default;
};
class QueryInventoryOfItemsInBizItemGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<vector<long>> itemIds{};
  shared_ptr<vector<string>> lmItemIds{};
  shared_ptr<string> subBizId{};

  QueryInventoryOfItemsInBizItemGroupRequest() {}

  explicit QueryInventoryOfItemsInBizItemGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      itemIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmItemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupRequest() = default;
};
class QueryInventoryOfItemsInBizItemGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};
  shared_ptr<string> subBizId{};

  QueryInventoryOfItemsInBizItemGroupShrinkRequest() {}

  explicit QueryInventoryOfItemsInBizItemGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupShrinkRequest() = default;
};
class QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList : public Darabonba::Model {
public:
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList() {}

  explicit QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList() = default;
};
class QueryInventoryOfItemsInBizItemGroupResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList>> skuList{};
  shared_ptr<long> totalQuantity{};
  shared_ptr<long> totalSoldQuantity{};

  QueryInventoryOfItemsInBizItemGroupResponseBodyItemList() {}

  explicit QueryInventoryOfItemsInBizItemGroupResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuList) {
      vector<boost::any> temp1;
      for(auto item1:*skuList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkuList"] = boost::any(temp1);
    }
    if (totalQuantity) {
      res["TotalQuantity"] = boost::any(*totalQuantity);
    }
    if (totalSoldQuantity) {
      res["TotalSoldQuantity"] = boost::any(*totalSoldQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkuList"].type()) {
        vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkuList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skuList = make_shared<vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemListSkuList>>(expect1);
      }
    }
    if (m.find("TotalQuantity") != m.end() && !m["TotalQuantity"].empty()) {
      totalQuantity = make_shared<long>(boost::any_cast<long>(m["TotalQuantity"]));
    }
    if (m.find("TotalSoldQuantity") != m.end() && !m["TotalSoldQuantity"].empty()) {
      totalSoldQuantity = make_shared<long>(boost::any_cast<long>(m["TotalSoldQuantity"]));
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupResponseBodyItemList() = default;
};
class QueryInventoryOfItemsInBizItemGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemList>> itemList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryInventoryOfItemsInBizItemGroupResponseBody() {}

  explicit QueryInventoryOfItemsInBizItemGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryInventoryOfItemsInBizItemGroupResponseBodyItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<QueryInventoryOfItemsInBizItemGroupResponseBodyItemList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupResponseBody() = default;
};
class QueryInventoryOfItemsInBizItemGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryInventoryOfItemsInBizItemGroupResponseBody> body{};

  QueryInventoryOfItemsInBizItemGroupResponse() {}

  explicit QueryInventoryOfItemsInBizItemGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInventoryOfItemsInBizItemGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInventoryOfItemsInBizItemGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInventoryOfItemsInBizItemGroupResponse() = default;
};
class QueryItemDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};

  QueryItemDetailRequest() {}

  explicit QueryItemDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~QueryItemDetailRequest() = default;
};
class QueryItemDetailResponseBodyItemItemImages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemImage{};

  QueryItemDetailResponseBodyItemItemImages() {}

  explicit QueryItemDetailResponseBodyItemItemImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemImage) {
      res["ItemImage"] = boost::any(*itemImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemImage") != m.end() && !m["ItemImage"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemImage"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemImage"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemImage = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryItemDetailResponseBodyItemItemImages() = default;
};
class QueryItemDetailResponseBodyItemSkusSku : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuProperties{};
  shared_ptr<string> skuPropertiesJson{};
  shared_ptr<string> skuTitle{};

  QueryItemDetailResponseBodyItemSkusSku() {}

  explicit QueryItemDetailResponseBodyItemSkusSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuProperties) {
      res["SkuProperties"] = boost::any(*skuProperties);
    }
    if (skuPropertiesJson) {
      res["SkuPropertiesJson"] = boost::any(*skuPropertiesJson);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuProperties") != m.end() && !m["SkuProperties"].empty()) {
      skuProperties = make_shared<string>(boost::any_cast<string>(m["SkuProperties"]));
    }
    if (m.find("SkuPropertiesJson") != m.end() && !m["SkuPropertiesJson"].empty()) {
      skuPropertiesJson = make_shared<string>(boost::any_cast<string>(m["SkuPropertiesJson"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
  }


  virtual ~QueryItemDetailResponseBodyItemSkusSku() = default;
};
class QueryItemDetailResponseBodyItemSkus : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemDetailResponseBodyItemSkusSku>> sku{};

  QueryItemDetailResponseBodyItemSkus() {}

  explicit QueryItemDetailResponseBodyItemSkus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryItemDetailResponseBodyItemSkusSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemDetailResponseBodyItemSkusSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryItemDetailResponseBodyItemSkusSku>>(expect1);
      }
    }
  }


  virtual ~QueryItemDetailResponseBodyItemSkus() = default;
};
class QueryItemDetailResponseBodyItem : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<bool> centerInventory{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<string> descOption{};
  shared_ptr<string> descPath{};
  shared_ptr<string> extJson{};
  shared_ptr<string> iforestProps{};
  shared_ptr<string> iforestPropsJson{};
  shared_ptr<bool> isCanSell{};
  shared_ptr<bool> isSellerPayPostfee{};
  shared_ptr<long> itemId{};
  shared_ptr<QueryItemDetailResponseBodyItemItemImages> itemImages{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemCategory{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> minPoints{};
  shared_ptr<long> minPrice{};
  shared_ptr<string> properties{};
  shared_ptr<string> propertiesJson{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<bool> sellerPayPostfee{};
  shared_ptr<long> sellerType{};
  shared_ptr<QueryItemDetailResponseBodyItemSkus> skus{};
  shared_ptr<string> tbShopName{};
  shared_ptr<long> totalSoldQuantity{};
  shared_ptr<string> videoPicUrl{};
  shared_ptr<string> videoUrl{};

  QueryItemDetailResponseBodyItem() {}

  explicit QueryItemDetailResponseBodyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (centerInventory) {
      res["CenterInventory"] = boost::any(*centerInventory);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (descOption) {
      res["DescOption"] = boost::any(*descOption);
    }
    if (descPath) {
      res["DescPath"] = boost::any(*descPath);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (iforestProps) {
      res["IforestProps"] = boost::any(*iforestProps);
    }
    if (iforestPropsJson) {
      res["IforestPropsJson"] = boost::any(*iforestPropsJson);
    }
    if (isCanSell) {
      res["IsCanSell"] = boost::any(*isCanSell);
    }
    if (isSellerPayPostfee) {
      res["IsSellerPayPostfee"] = boost::any(*isSellerPayPostfee);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemImages) {
      res["ItemImages"] = itemImages ? boost::any(itemImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemCategory) {
      res["LmItemCategory"] = boost::any(*lmItemCategory);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (minPoints) {
      res["MinPoints"] = boost::any(*minPoints);
    }
    if (minPrice) {
      res["MinPrice"] = boost::any(*minPrice);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (propertiesJson) {
      res["PropertiesJson"] = boost::any(*propertiesJson);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerPayPostfee) {
      res["SellerPayPostfee"] = boost::any(*sellerPayPostfee);
    }
    if (sellerType) {
      res["SellerType"] = boost::any(*sellerType);
    }
    if (skus) {
      res["Skus"] = skus ? boost::any(skus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (totalSoldQuantity) {
      res["TotalSoldQuantity"] = boost::any(*totalSoldQuantity);
    }
    if (videoPicUrl) {
      res["VideoPicUrl"] = boost::any(*videoPicUrl);
    }
    if (videoUrl) {
      res["VideoUrl"] = boost::any(*videoUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("CenterInventory") != m.end() && !m["CenterInventory"].empty()) {
      centerInventory = make_shared<bool>(boost::any_cast<bool>(m["CenterInventory"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DescOption") != m.end() && !m["DescOption"].empty()) {
      descOption = make_shared<string>(boost::any_cast<string>(m["DescOption"]));
    }
    if (m.find("DescPath") != m.end() && !m["DescPath"].empty()) {
      descPath = make_shared<string>(boost::any_cast<string>(m["DescPath"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("IforestProps") != m.end() && !m["IforestProps"].empty()) {
      iforestProps = make_shared<string>(boost::any_cast<string>(m["IforestProps"]));
    }
    if (m.find("IforestPropsJson") != m.end() && !m["IforestPropsJson"].empty()) {
      iforestPropsJson = make_shared<string>(boost::any_cast<string>(m["IforestPropsJson"]));
    }
    if (m.find("IsCanSell") != m.end() && !m["IsCanSell"].empty()) {
      isCanSell = make_shared<bool>(boost::any_cast<bool>(m["IsCanSell"]));
    }
    if (m.find("IsSellerPayPostfee") != m.end() && !m["IsSellerPayPostfee"].empty()) {
      isSellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["IsSellerPayPostfee"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemImages") != m.end() && !m["ItemImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemImages"].type()) {
        QueryItemDetailResponseBodyItemItemImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemImages"]));
        itemImages = make_shared<QueryItemDetailResponseBodyItemItemImages>(model1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemCategory") != m.end() && !m["LmItemCategory"].empty()) {
      lmItemCategory = make_shared<string>(boost::any_cast<string>(m["LmItemCategory"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("MinPoints") != m.end() && !m["MinPoints"].empty()) {
      minPoints = make_shared<long>(boost::any_cast<long>(m["MinPoints"]));
    }
    if (m.find("MinPrice") != m.end() && !m["MinPrice"].empty()) {
      minPrice = make_shared<long>(boost::any_cast<long>(m["MinPrice"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("PropertiesJson") != m.end() && !m["PropertiesJson"].empty()) {
      propertiesJson = make_shared<string>(boost::any_cast<string>(m["PropertiesJson"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerPayPostfee") != m.end() && !m["SellerPayPostfee"].empty()) {
      sellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["SellerPayPostfee"]));
    }
    if (m.find("SellerType") != m.end() && !m["SellerType"].empty()) {
      sellerType = make_shared<long>(boost::any_cast<long>(m["SellerType"]));
    }
    if (m.find("Skus") != m.end() && !m["Skus"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skus"].type()) {
        QueryItemDetailResponseBodyItemSkus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skus"]));
        skus = make_shared<QueryItemDetailResponseBodyItemSkus>(model1);
      }
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("TotalSoldQuantity") != m.end() && !m["TotalSoldQuantity"].empty()) {
      totalSoldQuantity = make_shared<long>(boost::any_cast<long>(m["TotalSoldQuantity"]));
    }
    if (m.find("VideoPicUrl") != m.end() && !m["VideoPicUrl"].empty()) {
      videoPicUrl = make_shared<string>(boost::any_cast<string>(m["VideoPicUrl"]));
    }
    if (m.find("VideoUrl") != m.end() && !m["VideoUrl"].empty()) {
      videoUrl = make_shared<string>(boost::any_cast<string>(m["VideoUrl"]));
    }
  }


  virtual ~QueryItemDetailResponseBodyItem() = default;
};
class QueryItemDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryItemDetailResponseBodyItem> item{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryItemDetailResponseBody() {}

  explicit QueryItemDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (item) {
      res["Item"] = item ? boost::any(item->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(map<string, boost::any>) == m["Item"].type()) {
        QueryItemDetailResponseBodyItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Item"]));
        item = make_shared<QueryItemDetailResponseBodyItem>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryItemDetailResponseBody() = default;
};
class QueryItemDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemDetailResponseBody> body{};

  QueryItemDetailResponse() {}

  explicit QueryItemDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemDetailResponse() = default;
};
class QueryItemDetailInnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> ip{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryItemDetailInnerRequest() {}

  explicit QueryItemDetailInnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryItemDetailInnerRequest() = default;
};
class QueryItemDetailInnerResponseBodyItemSkuPropertysValues : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> text{};

  QueryItemDetailInnerResponseBodyItemSkuPropertysValues() {}

  explicit QueryItemDetailInnerResponseBodyItemSkuPropertysValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~QueryItemDetailInnerResponseBodyItemSkuPropertysValues() = default;
};
class QueryItemDetailInnerResponseBodyItemSkuPropertys : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> text{};
  shared_ptr<vector<QueryItemDetailInnerResponseBodyItemSkuPropertysValues>> values{};

  QueryItemDetailInnerResponseBodyItemSkuPropertys() {}

  explicit QueryItemDetailInnerResponseBodyItemSkuPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (values) {
      vector<boost::any> temp1;
      for(auto item1:*values){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Values"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<QueryItemDetailInnerResponseBodyItemSkuPropertysValues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Values"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemDetailInnerResponseBodyItemSkuPropertysValues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        values = make_shared<vector<QueryItemDetailInnerResponseBodyItemSkuPropertysValues>>(expect1);
      }
    }
  }


  virtual ~QueryItemDetailInnerResponseBodyItemSkuPropertys() = default;
};
class QueryItemDetailInnerResponseBodyItemSkus : public Darabonba::Model {
public:
  shared_ptr<string> extJson{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<string> skuDesc{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuPvs{};
  shared_ptr<string> skuTitle{};
  shared_ptr<long> status{};

  QueryItemDetailInnerResponseBodyItemSkus() {}

  explicit QueryItemDetailInnerResponseBodyItemSkus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (skuDesc) {
      res["SkuDesc"] = boost::any(*skuDesc);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuPvs) {
      res["SkuPvs"] = boost::any(*skuPvs);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SkuDesc") != m.end() && !m["SkuDesc"].empty()) {
      skuDesc = make_shared<string>(boost::any_cast<string>(m["SkuDesc"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuPvs") != m.end() && !m["SkuPvs"].empty()) {
      skuPvs = make_shared<string>(boost::any_cast<string>(m["SkuPvs"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~QueryItemDetailInnerResponseBodyItemSkus() = default;
};
class QueryItemDetailInnerResponseBodyItem : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<vector<long>> categoryIds{};
  shared_ptr<bool> centerInventory{};
  shared_ptr<string> city{};
  shared_ptr<string> descOption{};
  shared_ptr<string> descPath{};
  shared_ptr<string> firstPicUrl{};
  shared_ptr<vector<map<string, boost::any>>> iforestProps{};
  shared_ptr<bool> isCanSell{};
  shared_ptr<bool> isSellerPayPostfee{};
  shared_ptr<long> itemId{};
  shared_ptr<vector<string>> itemImages{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemCategory{};
  shared_ptr<long> lmShopId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> minPoints{};
  shared_ptr<long> minPrice{};
  shared_ptr<map<string, boost::any>> properties{};
  shared_ptr<string> province{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<bool> sellerPayPostfee{};
  shared_ptr<vector<QueryItemDetailInnerResponseBodyItemSkuPropertys>> skuPropertys{};
  shared_ptr<vector<QueryItemDetailInnerResponseBodyItemSkus>> skus{};
  shared_ptr<string> tbShopName{};
  shared_ptr<long> totalSoldQuantity{};

  QueryItemDetailInnerResponseBodyItem() {}

  explicit QueryItemDetailInnerResponseBodyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (categoryIds) {
      res["CategoryIds"] = boost::any(*categoryIds);
    }
    if (centerInventory) {
      res["CenterInventory"] = boost::any(*centerInventory);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (descOption) {
      res["DescOption"] = boost::any(*descOption);
    }
    if (descPath) {
      res["DescPath"] = boost::any(*descPath);
    }
    if (firstPicUrl) {
      res["FirstPicUrl"] = boost::any(*firstPicUrl);
    }
    if (iforestProps) {
      res["IforestProps"] = boost::any(*iforestProps);
    }
    if (isCanSell) {
      res["IsCanSell"] = boost::any(*isCanSell);
    }
    if (isSellerPayPostfee) {
      res["IsSellerPayPostfee"] = boost::any(*isSellerPayPostfee);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemImages) {
      res["ItemImages"] = boost::any(*itemImages);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemCategory) {
      res["LmItemCategory"] = boost::any(*lmItemCategory);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (minPoints) {
      res["MinPoints"] = boost::any(*minPoints);
    }
    if (minPrice) {
      res["MinPrice"] = boost::any(*minPrice);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (sellerPayPostfee) {
      res["SellerPayPostfee"] = boost::any(*sellerPayPostfee);
    }
    if (skuPropertys) {
      vector<boost::any> temp1;
      for(auto item1:*skuPropertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkuPropertys"] = boost::any(temp1);
    }
    if (skus) {
      vector<boost::any> temp1;
      for(auto item1:*skus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Skus"] = boost::any(temp1);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (totalSoldQuantity) {
      res["TotalSoldQuantity"] = boost::any(*totalSoldQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("CategoryIds") != m.end() && !m["CategoryIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CategoryIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CategoryIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      categoryIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CenterInventory") != m.end() && !m["CenterInventory"].empty()) {
      centerInventory = make_shared<bool>(boost::any_cast<bool>(m["CenterInventory"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("DescOption") != m.end() && !m["DescOption"].empty()) {
      descOption = make_shared<string>(boost::any_cast<string>(m["DescOption"]));
    }
    if (m.find("DescPath") != m.end() && !m["DescPath"].empty()) {
      descPath = make_shared<string>(boost::any_cast<string>(m["DescPath"]));
    }
    if (m.find("FirstPicUrl") != m.end() && !m["FirstPicUrl"].empty()) {
      firstPicUrl = make_shared<string>(boost::any_cast<string>(m["FirstPicUrl"]));
    }
    if (m.find("IforestProps") != m.end() && !m["IforestProps"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["IforestProps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IforestProps"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      iforestProps = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("IsCanSell") != m.end() && !m["IsCanSell"].empty()) {
      isCanSell = make_shared<bool>(boost::any_cast<bool>(m["IsCanSell"]));
    }
    if (m.find("IsSellerPayPostfee") != m.end() && !m["IsSellerPayPostfee"].empty()) {
      isSellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["IsSellerPayPostfee"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemImages") != m.end() && !m["ItemImages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemImages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemImages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemImages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemCategory") != m.end() && !m["LmItemCategory"].empty()) {
      lmItemCategory = make_shared<string>(boost::any_cast<string>(m["LmItemCategory"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("MinPoints") != m.end() && !m["MinPoints"].empty()) {
      minPoints = make_shared<long>(boost::any_cast<long>(m["MinPoints"]));
    }
    if (m.find("MinPrice") != m.end() && !m["MinPrice"].empty()) {
      minPrice = make_shared<long>(boost::any_cast<long>(m["MinPrice"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Properties"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      properties = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("SellerPayPostfee") != m.end() && !m["SellerPayPostfee"].empty()) {
      sellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["SellerPayPostfee"]));
    }
    if (m.find("SkuPropertys") != m.end() && !m["SkuPropertys"].empty()) {
      if (typeid(vector<boost::any>) == m["SkuPropertys"].type()) {
        vector<QueryItemDetailInnerResponseBodyItemSkuPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkuPropertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemDetailInnerResponseBodyItemSkuPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skuPropertys = make_shared<vector<QueryItemDetailInnerResponseBodyItemSkuPropertys>>(expect1);
      }
    }
    if (m.find("Skus") != m.end() && !m["Skus"].empty()) {
      if (typeid(vector<boost::any>) == m["Skus"].type()) {
        vector<QueryItemDetailInnerResponseBodyItemSkus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Skus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemDetailInnerResponseBodyItemSkus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skus = make_shared<vector<QueryItemDetailInnerResponseBodyItemSkus>>(expect1);
      }
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("TotalSoldQuantity") != m.end() && !m["TotalSoldQuantity"].empty()) {
      totalSoldQuantity = make_shared<long>(boost::any_cast<long>(m["TotalSoldQuantity"]));
    }
  }


  virtual ~QueryItemDetailInnerResponseBodyItem() = default;
};
class QueryItemDetailInnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryItemDetailInnerResponseBodyItem> item{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryItemDetailInnerResponseBody() {}

  explicit QueryItemDetailInnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (item) {
      res["Item"] = item ? boost::any(item->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(map<string, boost::any>) == m["Item"].type()) {
        QueryItemDetailInnerResponseBodyItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Item"]));
        item = make_shared<QueryItemDetailInnerResponseBodyItem>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryItemDetailInnerResponseBody() = default;
};
class QueryItemDetailInnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemDetailInnerResponseBody> body{};

  QueryItemDetailInnerResponse() {}

  explicit QueryItemDetailInnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemDetailInnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemDetailInnerResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemDetailInnerResponse() = default;
};
class QueryItemDetailTeaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};

  QueryItemDetailTeaRequest() {}

  explicit QueryItemDetailTeaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~QueryItemDetailTeaRequest() = default;
};
class QueryItemDetailTeaResponseBodyItemIforestProps : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> iforestProp{};

  QueryItemDetailTeaResponseBodyItemIforestProps() {}

  explicit QueryItemDetailTeaResponseBodyItemIforestProps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (iforestProp) {
      res["IforestProp"] = boost::any(*iforestProp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IforestProp") != m.end() && !m["IforestProp"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["IforestProp"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IforestProp"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      iforestProp = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryItemDetailTeaResponseBodyItemIforestProps() = default;
};
class QueryItemDetailTeaResponseBodyItemItemImages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> itemImage{};

  QueryItemDetailTeaResponseBodyItemItemImages() {}

  explicit QueryItemDetailTeaResponseBodyItemItemImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemImage) {
      res["ItemImage"] = boost::any(*itemImage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemImage") != m.end() && !m["ItemImage"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemImage"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemImage"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemImage = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryItemDetailTeaResponseBodyItemItemImages() = default;
};
class QueryItemDetailTeaResponseBodyItemSkusSku : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<string> extJson{};
  shared_ptr<bool> hasQuantity{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<string> simpleQuantity{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<map<string, boost::any>> skuProperties{};
  shared_ptr<string> skuTitle{};

  QueryItemDetailTeaResponseBodyItemSkusSku() {}

  explicit QueryItemDetailTeaResponseBodyItemSkusSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (hasQuantity) {
      res["HasQuantity"] = boost::any(*hasQuantity);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (simpleQuantity) {
      res["SimpleQuantity"] = boost::any(*simpleQuantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuProperties) {
      res["SkuProperties"] = boost::any(*skuProperties);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("HasQuantity") != m.end() && !m["HasQuantity"].empty()) {
      hasQuantity = make_shared<bool>(boost::any_cast<bool>(m["HasQuantity"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SimpleQuantity") != m.end() && !m["SimpleQuantity"].empty()) {
      simpleQuantity = make_shared<string>(boost::any_cast<string>(m["SimpleQuantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuProperties") != m.end() && !m["SkuProperties"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SkuProperties"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      skuProperties = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
  }


  virtual ~QueryItemDetailTeaResponseBodyItemSkusSku() = default;
};
class QueryItemDetailTeaResponseBodyItemSkus : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemDetailTeaResponseBodyItemSkusSku>> sku{};

  QueryItemDetailTeaResponseBodyItemSkus() {}

  explicit QueryItemDetailTeaResponseBodyItemSkus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryItemDetailTeaResponseBodyItemSkusSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemDetailTeaResponseBodyItemSkusSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryItemDetailTeaResponseBodyItemSkusSku>>(expect1);
      }
    }
  }


  virtual ~QueryItemDetailTeaResponseBodyItemSkus() = default;
};
class QueryItemDetailTeaResponseBodyItem : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<bool> centerInventory{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<string> descOption{};
  shared_ptr<string> descPath{};
  shared_ptr<string> extJson{};
  shared_ptr<string> firstPicUrl{};
  shared_ptr<bool> hasQuantity{};
  shared_ptr<QueryItemDetailTeaResponseBodyItemIforestProps> iforestProps{};
  shared_ptr<bool> isCanSell{};
  shared_ptr<bool> isSellerPayPostfee{};
  shared_ptr<long> itemId{};
  shared_ptr<QueryItemDetailTeaResponseBodyItemItemImages> itemImages{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> itemTotalSimpleValue{};
  shared_ptr<string> lmItemCategory{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<long> minPoints{};
  shared_ptr<long> minPrice{};
  shared_ptr<map<string, boost::any>> properties{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<bool> sellerPayPostfee{};
  shared_ptr<long> sellerType{};
  shared_ptr<string> simpleQuantity{};
  shared_ptr<QueryItemDetailTeaResponseBodyItemSkus> skus{};
  shared_ptr<string> tbShopName{};
  shared_ptr<long> totalSoldQuantity{};
  shared_ptr<string> totalSoldSimpleQuantity{};
  shared_ptr<string> videoPicUrl{};
  shared_ptr<string> videoUrl{};

  QueryItemDetailTeaResponseBodyItem() {}

  explicit QueryItemDetailTeaResponseBodyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (centerInventory) {
      res["CenterInventory"] = boost::any(*centerInventory);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (descOption) {
      res["DescOption"] = boost::any(*descOption);
    }
    if (descPath) {
      res["DescPath"] = boost::any(*descPath);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (firstPicUrl) {
      res["FirstPicUrl"] = boost::any(*firstPicUrl);
    }
    if (hasQuantity) {
      res["HasQuantity"] = boost::any(*hasQuantity);
    }
    if (iforestProps) {
      res["IforestProps"] = iforestProps ? boost::any(iforestProps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isCanSell) {
      res["IsCanSell"] = boost::any(*isCanSell);
    }
    if (isSellerPayPostfee) {
      res["IsSellerPayPostfee"] = boost::any(*isSellerPayPostfee);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemImages) {
      res["ItemImages"] = itemImages ? boost::any(itemImages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (itemTotalSimpleValue) {
      res["ItemTotalSimpleValue"] = boost::any(*itemTotalSimpleValue);
    }
    if (lmItemCategory) {
      res["LmItemCategory"] = boost::any(*lmItemCategory);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (minPoints) {
      res["MinPoints"] = boost::any(*minPoints);
    }
    if (minPrice) {
      res["MinPrice"] = boost::any(*minPrice);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerPayPostfee) {
      res["SellerPayPostfee"] = boost::any(*sellerPayPostfee);
    }
    if (sellerType) {
      res["SellerType"] = boost::any(*sellerType);
    }
    if (simpleQuantity) {
      res["SimpleQuantity"] = boost::any(*simpleQuantity);
    }
    if (skus) {
      res["Skus"] = skus ? boost::any(skus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (totalSoldQuantity) {
      res["TotalSoldQuantity"] = boost::any(*totalSoldQuantity);
    }
    if (totalSoldSimpleQuantity) {
      res["TotalSoldSimpleQuantity"] = boost::any(*totalSoldSimpleQuantity);
    }
    if (videoPicUrl) {
      res["VideoPicUrl"] = boost::any(*videoPicUrl);
    }
    if (videoUrl) {
      res["VideoUrl"] = boost::any(*videoUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("CenterInventory") != m.end() && !m["CenterInventory"].empty()) {
      centerInventory = make_shared<bool>(boost::any_cast<bool>(m["CenterInventory"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DescOption") != m.end() && !m["DescOption"].empty()) {
      descOption = make_shared<string>(boost::any_cast<string>(m["DescOption"]));
    }
    if (m.find("DescPath") != m.end() && !m["DescPath"].empty()) {
      descPath = make_shared<string>(boost::any_cast<string>(m["DescPath"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("FirstPicUrl") != m.end() && !m["FirstPicUrl"].empty()) {
      firstPicUrl = make_shared<string>(boost::any_cast<string>(m["FirstPicUrl"]));
    }
    if (m.find("HasQuantity") != m.end() && !m["HasQuantity"].empty()) {
      hasQuantity = make_shared<bool>(boost::any_cast<bool>(m["HasQuantity"]));
    }
    if (m.find("IforestProps") != m.end() && !m["IforestProps"].empty()) {
      if (typeid(map<string, boost::any>) == m["IforestProps"].type()) {
        QueryItemDetailTeaResponseBodyItemIforestProps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IforestProps"]));
        iforestProps = make_shared<QueryItemDetailTeaResponseBodyItemIforestProps>(model1);
      }
    }
    if (m.find("IsCanSell") != m.end() && !m["IsCanSell"].empty()) {
      isCanSell = make_shared<bool>(boost::any_cast<bool>(m["IsCanSell"]));
    }
    if (m.find("IsSellerPayPostfee") != m.end() && !m["IsSellerPayPostfee"].empty()) {
      isSellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["IsSellerPayPostfee"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemImages") != m.end() && !m["ItemImages"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemImages"].type()) {
        QueryItemDetailTeaResponseBodyItemItemImages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemImages"]));
        itemImages = make_shared<QueryItemDetailTeaResponseBodyItemItemImages>(model1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("ItemTotalSimpleValue") != m.end() && !m["ItemTotalSimpleValue"].empty()) {
      itemTotalSimpleValue = make_shared<string>(boost::any_cast<string>(m["ItemTotalSimpleValue"]));
    }
    if (m.find("LmItemCategory") != m.end() && !m["LmItemCategory"].empty()) {
      lmItemCategory = make_shared<string>(boost::any_cast<string>(m["LmItemCategory"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("MinPoints") != m.end() && !m["MinPoints"].empty()) {
      minPoints = make_shared<long>(boost::any_cast<long>(m["MinPoints"]));
    }
    if (m.find("MinPrice") != m.end() && !m["MinPrice"].empty()) {
      minPrice = make_shared<long>(boost::any_cast<long>(m["MinPrice"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Properties"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      properties = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerPayPostfee") != m.end() && !m["SellerPayPostfee"].empty()) {
      sellerPayPostfee = make_shared<bool>(boost::any_cast<bool>(m["SellerPayPostfee"]));
    }
    if (m.find("SellerType") != m.end() && !m["SellerType"].empty()) {
      sellerType = make_shared<long>(boost::any_cast<long>(m["SellerType"]));
    }
    if (m.find("SimpleQuantity") != m.end() && !m["SimpleQuantity"].empty()) {
      simpleQuantity = make_shared<string>(boost::any_cast<string>(m["SimpleQuantity"]));
    }
    if (m.find("Skus") != m.end() && !m["Skus"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skus"].type()) {
        QueryItemDetailTeaResponseBodyItemSkus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skus"]));
        skus = make_shared<QueryItemDetailTeaResponseBodyItemSkus>(model1);
      }
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("TotalSoldQuantity") != m.end() && !m["TotalSoldQuantity"].empty()) {
      totalSoldQuantity = make_shared<long>(boost::any_cast<long>(m["TotalSoldQuantity"]));
    }
    if (m.find("TotalSoldSimpleQuantity") != m.end() && !m["TotalSoldSimpleQuantity"].empty()) {
      totalSoldSimpleQuantity = make_shared<string>(boost::any_cast<string>(m["TotalSoldSimpleQuantity"]));
    }
    if (m.find("VideoPicUrl") != m.end() && !m["VideoPicUrl"].empty()) {
      videoPicUrl = make_shared<string>(boost::any_cast<string>(m["VideoPicUrl"]));
    }
    if (m.find("VideoUrl") != m.end() && !m["VideoUrl"].empty()) {
      videoUrl = make_shared<string>(boost::any_cast<string>(m["VideoUrl"]));
    }
  }


  virtual ~QueryItemDetailTeaResponseBodyItem() = default;
};
class QueryItemDetailTeaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryItemDetailTeaResponseBodyItem> item{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryItemDetailTeaResponseBody() {}

  explicit QueryItemDetailTeaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (item) {
      res["Item"] = item ? boost::any(item->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(map<string, boost::any>) == m["Item"].type()) {
        QueryItemDetailTeaResponseBodyItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Item"]));
        item = make_shared<QueryItemDetailTeaResponseBodyItem>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryItemDetailTeaResponseBody() = default;
};
class QueryItemDetailTeaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemDetailTeaResponseBody> body{};

  QueryItemDetailTeaResponse() {}

  explicit QueryItemDetailTeaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemDetailTeaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemDetailTeaResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemDetailTeaResponse() = default;
};
class QueryItemInSubBizsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<map<string, boost::any>> subBizIds{};

  QueryItemInSubBizsRequest() {}

  explicit QueryItemInSubBizsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (subBizIds) {
      res["SubBizIds"] = boost::any(*subBizIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SubBizIds") != m.end() && !m["SubBizIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubBizIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subBizIds = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryItemInSubBizsRequest() = default;
};
class QueryItemInSubBizsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> subBizIdsShrink{};

  QueryItemInSubBizsShrinkRequest() {}

  explicit QueryItemInSubBizsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (subBizIdsShrink) {
      res["SubBizIds"] = boost::any(*subBizIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SubBizIds") != m.end() && !m["SubBizIds"].empty()) {
      subBizIdsShrink = make_shared<string>(boost::any_cast<string>(m["SubBizIds"]));
    }
  }


  virtual ~QueryItemInSubBizsShrinkRequest() = default;
};
class QueryItemInSubBizsResponseBodyItemBizListSkuList : public Darabonba::Model {
public:
  shared_ptr<string> benefitId{};
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, boost::any>> customizedAttributeMap{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuPicUrl{};
  shared_ptr<string> skuProperties{};
  shared_ptr<string> skuPropertiesJson{};
  shared_ptr<string> skuTitle{};

  QueryItemInSubBizsResponseBodyItemBizListSkuList() {}

  explicit QueryItemInSubBizsResponseBodyItemBizListSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (benefitId) {
      res["BenefitId"] = boost::any(*benefitId);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (customizedAttributeMap) {
      res["CustomizedAttributeMap"] = boost::any(*customizedAttributeMap);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuPicUrl) {
      res["SkuPicUrl"] = boost::any(*skuPicUrl);
    }
    if (skuProperties) {
      res["SkuProperties"] = boost::any(*skuProperties);
    }
    if (skuPropertiesJson) {
      res["SkuPropertiesJson"] = boost::any(*skuPropertiesJson);
    }
    if (skuTitle) {
      res["SkuTitle"] = boost::any(*skuTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BenefitId") != m.end() && !m["BenefitId"].empty()) {
      benefitId = make_shared<string>(boost::any_cast<string>(m["BenefitId"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CustomizedAttributeMap") != m.end() && !m["CustomizedAttributeMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomizedAttributeMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customizedAttributeMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuPicUrl") != m.end() && !m["SkuPicUrl"].empty()) {
      skuPicUrl = make_shared<string>(boost::any_cast<string>(m["SkuPicUrl"]));
    }
    if (m.find("SkuProperties") != m.end() && !m["SkuProperties"].empty()) {
      skuProperties = make_shared<string>(boost::any_cast<string>(m["SkuProperties"]));
    }
    if (m.find("SkuPropertiesJson") != m.end() && !m["SkuPropertiesJson"].empty()) {
      skuPropertiesJson = make_shared<string>(boost::any_cast<string>(m["SkuPropertiesJson"]));
    }
    if (m.find("SkuTitle") != m.end() && !m["SkuTitle"].empty()) {
      skuTitle = make_shared<string>(boost::any_cast<string>(m["SkuTitle"]));
    }
  }


  virtual ~QueryItemInSubBizsResponseBodyItemBizListSkuList() = default;
};
class QueryItemInSubBizsResponseBodyItemBizList : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> descOption{};
  shared_ptr<long> itemId{};
  shared_ptr<vector<string>> itemImages{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> mainPicUrl{};
  shared_ptr<string> propertiesJson{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<vector<QueryItemInSubBizsResponseBodyItemBizListSkuList>> skuList{};
  shared_ptr<string> subBizId{};
  shared_ptr<string> tbShopName{};

  QueryItemInSubBizsResponseBodyItemBizList() {}

  explicit QueryItemInSubBizsResponseBodyItemBizList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (descOption) {
      res["DescOption"] = boost::any(*descOption);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemImages) {
      res["ItemImages"] = boost::any(*itemImages);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (mainPicUrl) {
      res["MainPicUrl"] = boost::any(*mainPicUrl);
    }
    if (propertiesJson) {
      res["PropertiesJson"] = boost::any(*propertiesJson);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (skuList) {
      vector<boost::any> temp1;
      for(auto item1:*skuList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkuList"] = boost::any(temp1);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("DescOption") != m.end() && !m["DescOption"].empty()) {
      descOption = make_shared<string>(boost::any_cast<string>(m["DescOption"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemImages") != m.end() && !m["ItemImages"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemImages"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemImages"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemImages = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("MainPicUrl") != m.end() && !m["MainPicUrl"].empty()) {
      mainPicUrl = make_shared<string>(boost::any_cast<string>(m["MainPicUrl"]));
    }
    if (m.find("PropertiesJson") != m.end() && !m["PropertiesJson"].empty()) {
      propertiesJson = make_shared<string>(boost::any_cast<string>(m["PropertiesJson"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkuList"].type()) {
        vector<QueryItemInSubBizsResponseBodyItemBizListSkuList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkuList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInSubBizsResponseBodyItemBizListSkuList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skuList = make_shared<vector<QueryItemInSubBizsResponseBodyItemBizListSkuList>>(expect1);
      }
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
  }


  virtual ~QueryItemInSubBizsResponseBodyItemBizList() = default;
};
class QueryItemInSubBizsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryItemInSubBizsResponseBodyItemBizList>> itemBizList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryItemInSubBizsResponseBody() {}

  explicit QueryItemInSubBizsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemBizList) {
      vector<boost::any> temp1;
      for(auto item1:*itemBizList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemBizList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemBizList") != m.end() && !m["ItemBizList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemBizList"].type()) {
        vector<QueryItemInSubBizsResponseBodyItemBizList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemBizList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInSubBizsResponseBodyItemBizList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemBizList = make_shared<vector<QueryItemInSubBizsResponseBodyItemBizList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryItemInSubBizsResponseBody() = default;
};
class QueryItemInSubBizsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemInSubBizsResponseBody> body{};

  QueryItemInSubBizsResponse() {}

  explicit QueryItemInSubBizsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemInSubBizsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemInSubBizsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemInSubBizsResponse() = default;
};
class QueryItemInventoryRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<vector<int>> skuIdList{};

  QueryItemInventoryRequestItemList() {}

  explicit QueryItemInventoryRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuIdList) {
      res["SkuIdList"] = boost::any(*skuIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuIdList") != m.end() && !m["SkuIdList"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skuIdList = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~QueryItemInventoryRequestItemList() = default;
};
class QueryItemInventoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> ip{};
  shared_ptr<vector<QueryItemInventoryRequestItemList>> itemList{};

  QueryItemInventoryRequest() {}

  explicit QueryItemInventoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<QueryItemInventoryRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<QueryItemInventoryRequestItemList>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryRequest() = default;
};
class QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory : public Darabonba::Model {
public:
  shared_ptr<long> quantity{};

  QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory() {}

  explicit QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory() = default;
};
class QueryItemInventoryResponseBodyItemListItemSkuListSku : public Darabonba::Model {
public:
  shared_ptr<QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory> inventory{};
  shared_ptr<long> skuId{};

  QueryItemInventoryResponseBodyItemListItemSkuListSku() {}

  explicit QueryItemInventoryResponseBodyItemListItemSkuListSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inventory) {
      res["Inventory"] = inventory ? boost::any(inventory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inventory") != m.end() && !m["Inventory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inventory"].type()) {
        QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inventory"]));
        inventory = make_shared<QueryItemInventoryResponseBodyItemListItemSkuListSkuInventory>(model1);
      }
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~QueryItemInventoryResponseBodyItemListItemSkuListSku() = default;
};
class QueryItemInventoryResponseBodyItemListItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemInventoryResponseBodyItemListItemSkuListSku>> sku{};

  QueryItemInventoryResponseBodyItemListItemSkuList() {}

  explicit QueryItemInventoryResponseBodyItemListItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryItemInventoryResponseBodyItemListItemSkuListSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryResponseBodyItemListItemSkuListSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryItemInventoryResponseBodyItemListItemSkuListSku>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryResponseBodyItemListItemSkuList() = default;
};
class QueryItemInventoryResponseBodyItemListItem : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<QueryItemInventoryResponseBodyItemListItemSkuList> skuList{};

  QueryItemInventoryResponseBodyItemListItem() {}

  explicit QueryItemInventoryResponseBodyItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuList) {
      res["SkuList"] = skuList ? boost::any(skuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuList"].type()) {
        QueryItemInventoryResponseBodyItemListItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuList"]));
        skuList = make_shared<QueryItemInventoryResponseBodyItemListItemSkuList>(model1);
      }
    }
  }


  virtual ~QueryItemInventoryResponseBodyItemListItem() = default;
};
class QueryItemInventoryResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemInventoryResponseBodyItemListItem>> item{};

  QueryItemInventoryResponseBodyItemList() {}

  explicit QueryItemInventoryResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<QueryItemInventoryResponseBodyItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryResponseBodyItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryItemInventoryResponseBodyItemListItem>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryResponseBodyItemList() = default;
};
class QueryItemInventoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryItemInventoryResponseBodyItemList> itemList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryItemInventoryResponseBody() {}

  explicit QueryItemInventoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      res["ItemList"] = itemList ? boost::any(itemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemList"].type()) {
        QueryItemInventoryResponseBodyItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemList"]));
        itemList = make_shared<QueryItemInventoryResponseBodyItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryItemInventoryResponseBody() = default;
};
class QueryItemInventoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemInventoryResponseBody> body{};

  QueryItemInventoryResponse() {}

  explicit QueryItemInventoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemInventoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemInventoryResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemInventoryResponse() = default;
};
class QueryItemInventoryV2RequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<vector<long>> skuIdList{};

  QueryItemInventoryV2RequestItemList() {}

  explicit QueryItemInventoryV2RequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuIdList) {
      res["SkuIdList"] = boost::any(*skuIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuIdList") != m.end() && !m["SkuIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      skuIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~QueryItemInventoryV2RequestItemList() = default;
};
class QueryItemInventoryV2Request : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> ip{};
  shared_ptr<vector<QueryItemInventoryV2RequestItemList>> itemList{};

  QueryItemInventoryV2Request() {}

  explicit QueryItemInventoryV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<QueryItemInventoryV2RequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryV2RequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<QueryItemInventoryV2RequestItemList>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryV2Request() = default;
};
class QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory : public Darabonba::Model {
public:
  shared_ptr<long> quantity{};

  QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory() {}

  explicit QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory() = default;
};
class QueryItemInventoryV2ResponseBodyItemListItemSkuListSku : public Darabonba::Model {
public:
  shared_ptr<QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory> inventory{};
  shared_ptr<long> skuId{};

  QueryItemInventoryV2ResponseBodyItemListItemSkuListSku() {}

  explicit QueryItemInventoryV2ResponseBodyItemListItemSkuListSku(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inventory) {
      res["Inventory"] = inventory ? boost::any(inventory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inventory") != m.end() && !m["Inventory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inventory"].type()) {
        QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inventory"]));
        inventory = make_shared<QueryItemInventoryV2ResponseBodyItemListItemSkuListSkuInventory>(model1);
      }
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~QueryItemInventoryV2ResponseBodyItemListItemSkuListSku() = default;
};
class QueryItemInventoryV2ResponseBodyItemListItemSkuList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemInventoryV2ResponseBodyItemListItemSkuListSku>> sku{};

  QueryItemInventoryV2ResponseBodyItemListItemSkuList() {}

  explicit QueryItemInventoryV2ResponseBodyItemListItemSkuList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sku) {
      vector<boost::any> temp1;
      for(auto item1:*sku){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sku"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sku") != m.end() && !m["Sku"].empty()) {
      if (typeid(vector<boost::any>) == m["Sku"].type()) {
        vector<QueryItemInventoryV2ResponseBodyItemListItemSkuListSku> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sku"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryV2ResponseBodyItemListItemSkuListSku model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sku = make_shared<vector<QueryItemInventoryV2ResponseBodyItemListItemSkuListSku>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryV2ResponseBodyItemListItemSkuList() = default;
};
class QueryItemInventoryV2ResponseBodyItemListItem : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<QueryItemInventoryV2ResponseBodyItemListItemSkuList> skuList{};

  QueryItemInventoryV2ResponseBodyItemListItem() {}

  explicit QueryItemInventoryV2ResponseBodyItemListItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (skuList) {
      res["SkuList"] = skuList ? boost::any(skuList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SkuList") != m.end() && !m["SkuList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkuList"].type()) {
        QueryItemInventoryV2ResponseBodyItemListItemSkuList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkuList"]));
        skuList = make_shared<QueryItemInventoryV2ResponseBodyItemListItemSkuList>(model1);
      }
    }
  }


  virtual ~QueryItemInventoryV2ResponseBodyItemListItem() = default;
};
class QueryItemInventoryV2ResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryItemInventoryV2ResponseBodyItemListItem>> item{};

  QueryItemInventoryV2ResponseBodyItemList() {}

  explicit QueryItemInventoryV2ResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      vector<boost::any> temp1;
      for(auto item1:*item){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Item"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      if (typeid(vector<boost::any>) == m["Item"].type()) {
        vector<QueryItemInventoryV2ResponseBodyItemListItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Item"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemInventoryV2ResponseBodyItemListItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        item = make_shared<vector<QueryItemInventoryV2ResponseBodyItemListItem>>(expect1);
      }
    }
  }


  virtual ~QueryItemInventoryV2ResponseBodyItemList() = default;
};
class QueryItemInventoryV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryItemInventoryV2ResponseBodyItemList> itemList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryItemInventoryV2ResponseBody() {}

  explicit QueryItemInventoryV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (itemList) {
      res["ItemList"] = itemList ? boost::any(itemList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemList"].type()) {
        QueryItemInventoryV2ResponseBodyItemList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemList"]));
        itemList = make_shared<QueryItemInventoryV2ResponseBodyItemList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryItemInventoryV2ResponseBody() = default;
};
class QueryItemInventoryV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemInventoryV2ResponseBody> body{};

  QueryItemInventoryV2Response() {}

  explicit QueryItemInventoryV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemInventoryV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemInventoryV2ResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemInventoryV2Response() = default;
};
class QueryItemNextCycleRestrictionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<vector<string>> lmItemId{};
  shared_ptr<string> subBizId{};

  QueryItemNextCycleRestrictionRequest() {}

  explicit QueryItemNextCycleRestrictionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LmItemId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LmItemId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lmItemId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~QueryItemNextCycleRestrictionRequest() = default;
};
class QueryItemNextCycleRestrictionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> lmItemIdShrink{};
  shared_ptr<string> subBizId{};

  QueryItemNextCycleRestrictionShrinkRequest() {}

  explicit QueryItemNextCycleRestrictionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmItemIdShrink) {
      res["LmItemId"] = boost::any(*lmItemIdShrink);
    }
    if (subBizId) {
      res["SubBizId"] = boost::any(*subBizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemIdShrink = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("SubBizId") != m.end() && !m["SubBizId"].empty()) {
      subBizId = make_shared<string>(boost::any_cast<string>(m["SubBizId"]));
    }
  }


  virtual ~QueryItemNextCycleRestrictionShrinkRequest() = default;
};
class QueryItemNextCycleRestrictionResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> restrictionQuantity{};

  QueryItemNextCycleRestrictionResponseBodyModel() {}

  explicit QueryItemNextCycleRestrictionResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (restrictionQuantity) {
      res["RestrictionQuantity"] = boost::any(*restrictionQuantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("RestrictionQuantity") != m.end() && !m["RestrictionQuantity"].empty()) {
      restrictionQuantity = make_shared<long>(boost::any_cast<long>(m["RestrictionQuantity"]));
    }
  }


  virtual ~QueryItemNextCycleRestrictionResponseBodyModel() = default;
};
class QueryItemNextCycleRestrictionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryItemNextCycleRestrictionResponseBodyModel>> model{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryItemNextCycleRestrictionResponseBody() {}

  explicit QueryItemNextCycleRestrictionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryItemNextCycleRestrictionResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryItemNextCycleRestrictionResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryItemNextCycleRestrictionResponseBodyModel>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryItemNextCycleRestrictionResponseBody() = default;
};
class QueryItemNextCycleRestrictionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryItemNextCycleRestrictionResponseBody> body{};

  QueryItemNextCycleRestrictionResponse() {}

  explicit QueryItemNextCycleRestrictionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryItemNextCycleRestrictionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryItemNextCycleRestrictionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryItemNextCycleRestrictionResponse() = default;
};
class QueryLogisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryLogisticsRequest() {}

  explicit QueryLogisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryLogisticsRequest() = default;
};
class QueryLogisticsResponseBodyDataDataGoodsGoods : public Darabonba::Model {
public:
  shared_ptr<string> goodName{};
  shared_ptr<long> itemId{};
  shared_ptr<long> quantity{};

  QueryLogisticsResponseBodyDataDataGoodsGoods() {}

  explicit QueryLogisticsResponseBodyDataDataGoodsGoods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (goodName) {
      res["GoodName"] = boost::any(*goodName);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GoodName") != m.end() && !m["GoodName"].empty()) {
      goodName = make_shared<string>(boost::any_cast<string>(m["GoodName"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~QueryLogisticsResponseBodyDataDataGoodsGoods() = default;
};
class QueryLogisticsResponseBodyDataDataGoods : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLogisticsResponseBodyDataDataGoodsGoods>> goods{};

  QueryLogisticsResponseBodyDataDataGoods() {}

  explicit QueryLogisticsResponseBodyDataDataGoods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (goods) {
      vector<boost::any> temp1;
      for(auto item1:*goods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Goods"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Goods") != m.end() && !m["Goods"].empty()) {
      if (typeid(vector<boost::any>) == m["Goods"].type()) {
        vector<QueryLogisticsResponseBodyDataDataGoodsGoods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Goods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLogisticsResponseBodyDataDataGoodsGoods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        goods = make_shared<vector<QueryLogisticsResponseBodyDataDataGoodsGoods>>(expect1);
      }
    }
  }


  virtual ~QueryLogisticsResponseBodyDataDataGoods() = default;
};
class QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList : public Darabonba::Model {
public:
  shared_ptr<string> ocurrTimeStr{};
  shared_ptr<string> standerdDesc{};

  QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList() {}

  explicit QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ocurrTimeStr) {
      res["OcurrTimeStr"] = boost::any(*ocurrTimeStr);
    }
    if (standerdDesc) {
      res["StanderdDesc"] = boost::any(*standerdDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OcurrTimeStr") != m.end() && !m["OcurrTimeStr"].empty()) {
      ocurrTimeStr = make_shared<string>(boost::any_cast<string>(m["OcurrTimeStr"]));
    }
    if (m.find("StanderdDesc") != m.end() && !m["StanderdDesc"].empty()) {
      standerdDesc = make_shared<string>(boost::any_cast<string>(m["StanderdDesc"]));
    }
  }


  virtual ~QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList() = default;
};
class QueryLogisticsResponseBodyDataDataLogisticsDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList>> logisticsDetailList{};

  QueryLogisticsResponseBodyDataDataLogisticsDetailList() {}

  explicit QueryLogisticsResponseBodyDataDataLogisticsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logisticsDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*logisticsDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogisticsDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogisticsDetailList") != m.end() && !m["LogisticsDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogisticsDetailList"].type()) {
        vector<QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogisticsDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logisticsDetailList = make_shared<vector<QueryLogisticsResponseBodyDataDataLogisticsDetailListLogisticsDetailList>>(expect1);
      }
    }
  }


  virtual ~QueryLogisticsResponseBodyDataDataLogisticsDetailList() = default;
};
class QueryLogisticsResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> dataProvider{};
  shared_ptr<string> dataProviderTitle{};
  shared_ptr<QueryLogisticsResponseBodyDataDataGoods> goods{};
  shared_ptr<string> logisticsCompanyCode{};
  shared_ptr<string> logisticsCompanyName{};
  shared_ptr<QueryLogisticsResponseBodyDataDataLogisticsDetailList> logisticsDetailList{};
  shared_ptr<string> mailNo{};

  QueryLogisticsResponseBodyDataData() {}

  explicit QueryLogisticsResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataProvider) {
      res["DataProvider"] = boost::any(*dataProvider);
    }
    if (dataProviderTitle) {
      res["DataProviderTitle"] = boost::any(*dataProviderTitle);
    }
    if (goods) {
      res["Goods"] = goods ? boost::any(goods->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logisticsCompanyCode) {
      res["LogisticsCompanyCode"] = boost::any(*logisticsCompanyCode);
    }
    if (logisticsCompanyName) {
      res["LogisticsCompanyName"] = boost::any(*logisticsCompanyName);
    }
    if (logisticsDetailList) {
      res["LogisticsDetailList"] = logisticsDetailList ? boost::any(logisticsDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mailNo) {
      res["MailNo"] = boost::any(*mailNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataProvider") != m.end() && !m["DataProvider"].empty()) {
      dataProvider = make_shared<string>(boost::any_cast<string>(m["DataProvider"]));
    }
    if (m.find("DataProviderTitle") != m.end() && !m["DataProviderTitle"].empty()) {
      dataProviderTitle = make_shared<string>(boost::any_cast<string>(m["DataProviderTitle"]));
    }
    if (m.find("Goods") != m.end() && !m["Goods"].empty()) {
      if (typeid(map<string, boost::any>) == m["Goods"].type()) {
        QueryLogisticsResponseBodyDataDataGoods model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Goods"]));
        goods = make_shared<QueryLogisticsResponseBodyDataDataGoods>(model1);
      }
    }
    if (m.find("LogisticsCompanyCode") != m.end() && !m["LogisticsCompanyCode"].empty()) {
      logisticsCompanyCode = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyCode"]));
    }
    if (m.find("LogisticsCompanyName") != m.end() && !m["LogisticsCompanyName"].empty()) {
      logisticsCompanyName = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyName"]));
    }
    if (m.find("LogisticsDetailList") != m.end() && !m["LogisticsDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogisticsDetailList"].type()) {
        QueryLogisticsResponseBodyDataDataLogisticsDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogisticsDetailList"]));
        logisticsDetailList = make_shared<QueryLogisticsResponseBodyDataDataLogisticsDetailList>(model1);
      }
    }
    if (m.find("MailNo") != m.end() && !m["MailNo"].empty()) {
      mailNo = make_shared<string>(boost::any_cast<string>(m["MailNo"]));
    }
  }


  virtual ~QueryLogisticsResponseBodyDataData() = default;
};
class QueryLogisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryLogisticsResponseBodyDataData>> data{};

  QueryLogisticsResponseBodyData() {}

  explicit QueryLogisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryLogisticsResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryLogisticsResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryLogisticsResponseBodyDataData>>(expect1);
      }
    }
  }


  virtual ~QueryLogisticsResponseBodyData() = default;
};
class QueryLogisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryLogisticsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryLogisticsResponseBody() {}

  explicit QueryLogisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryLogisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryLogisticsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryLogisticsResponseBody() = default;
};
class QueryLogisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLogisticsResponseBody> body{};

  QueryLogisticsResponse() {}

  explicit QueryLogisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLogisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLogisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLogisticsResponse() = default;
};
class QueryMediaSettleInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> mediaName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> settleNo{};
  shared_ptr<string> startTime{};

  QueryMediaSettleInfoRequest() {}

  explicit QueryMediaSettleInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (mediaName) {
      res["MediaName"] = boost::any(*mediaName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MediaName") != m.end() && !m["MediaName"].empty()) {
      mediaName = make_shared<string>(boost::any_cast<string>(m["MediaName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaSettleInfoRequest() = default;
};
class QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> createDate{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> mediaName{};
  shared_ptr<string> mediaSettleAmount{};
  shared_ptr<string> mediaSettleDetailId{};
  shared_ptr<string> modifiedDate{};
  shared_ptr<string> settleNo{};
  shared_ptr<string> settleStatus{};
  shared_ptr<string> startTime{};

  QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList() {}

  explicit QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (mediaName) {
      res["MediaName"] = boost::any(*mediaName);
    }
    if (mediaSettleAmount) {
      res["MediaSettleAmount"] = boost::any(*mediaSettleAmount);
    }
    if (mediaSettleDetailId) {
      res["MediaSettleDetailId"] = boost::any(*mediaSettleDetailId);
    }
    if (modifiedDate) {
      res["ModifiedDate"] = boost::any(*modifiedDate);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    if (settleStatus) {
      res["SettleStatus"] = boost::any(*settleStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MediaName") != m.end() && !m["MediaName"].empty()) {
      mediaName = make_shared<string>(boost::any_cast<string>(m["MediaName"]));
    }
    if (m.find("MediaSettleAmount") != m.end() && !m["MediaSettleAmount"].empty()) {
      mediaSettleAmount = make_shared<string>(boost::any_cast<string>(m["MediaSettleAmount"]));
    }
    if (m.find("MediaSettleDetailId") != m.end() && !m["MediaSettleDetailId"].empty()) {
      mediaSettleDetailId = make_shared<string>(boost::any_cast<string>(m["MediaSettleDetailId"]));
    }
    if (m.find("ModifiedDate") != m.end() && !m["ModifiedDate"].empty()) {
      modifiedDate = make_shared<string>(boost::any_cast<string>(m["ModifiedDate"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
    if (m.find("SettleStatus") != m.end() && !m["SettleStatus"].empty()) {
      settleStatus = make_shared<string>(boost::any_cast<string>(m["SettleStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList() = default;
};
class QueryMediaSettleInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList>> mediaSettleInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  QueryMediaSettleInfoResponseBodyModel() {}

  explicit QueryMediaSettleInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaSettleInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaSettleInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaSettleInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaSettleInfoList") != m.end() && !m["MediaSettleInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaSettleInfoList"].type()) {
        vector<QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaSettleInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaSettleInfoList = make_shared<vector<QueryMediaSettleInfoResponseBodyModelMediaSettleInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryMediaSettleInfoResponseBodyModel() = default;
};
class QueryMediaSettleInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryMediaSettleInfoResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryMediaSettleInfoResponseBody() {}

  explicit QueryMediaSettleInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryMediaSettleInfoResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryMediaSettleInfoResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryMediaSettleInfoResponseBody() = default;
};
class QueryMediaSettleInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaSettleInfoResponseBody> body{};

  QueryMediaSettleInfoResponse() {}

  explicit QueryMediaSettleInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaSettleInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaSettleInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaSettleInfoResponse() = default;
};
class QueryMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJson{};
  shared_ptr<string> topic{};

  QueryMessagesRequest() {}

  explicit QueryMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryMessagesRequest() = default;
};
class QueryMessagesResponseBodyBizMessagesBizMessage : public Darabonba::Model {
public:
  shared_ptr<string> contentMapJson{};
  shared_ptr<long> dataId{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> topic{};

  QueryMessagesResponseBodyBizMessagesBizMessage() {}

  explicit QueryMessagesResponseBodyBizMessagesBizMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentMapJson) {
      res["ContentMapJson"] = boost::any(*contentMapJson);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentMapJson") != m.end() && !m["ContentMapJson"].empty()) {
      contentMapJson = make_shared<string>(boost::any_cast<string>(m["ContentMapJson"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<long>(boost::any_cast<long>(m["DataId"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~QueryMessagesResponseBodyBizMessagesBizMessage() = default;
};
class QueryMessagesResponseBodyBizMessages : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMessagesResponseBodyBizMessagesBizMessage>> bizMessage{};

  QueryMessagesResponseBodyBizMessages() {}

  explicit QueryMessagesResponseBodyBizMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizMessage) {
      vector<boost::any> temp1;
      for(auto item1:*bizMessage){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizMessage"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizMessage") != m.end() && !m["BizMessage"].empty()) {
      if (typeid(vector<boost::any>) == m["BizMessage"].type()) {
        vector<QueryMessagesResponseBodyBizMessagesBizMessage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizMessage"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMessagesResponseBodyBizMessagesBizMessage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizMessage = make_shared<vector<QueryMessagesResponseBodyBizMessagesBizMessage>>(expect1);
      }
    }
  }


  virtual ~QueryMessagesResponseBodyBizMessages() = default;
};
class QueryMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMessagesResponseBodyBizMessages> bizMessages{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryMessagesResponseBody() {}

  explicit QueryMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizMessages) {
      res["BizMessages"] = bizMessages ? boost::any(bizMessages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizMessages") != m.end() && !m["BizMessages"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizMessages"].type()) {
        QueryMessagesResponseBodyBizMessages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizMessages"]));
        bizMessages = make_shared<QueryMessagesResponseBodyBizMessages>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMessagesResponseBody() = default;
};
class QueryMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMessagesResponseBody> body{};

  QueryMessagesResponse() {}

  explicit QueryMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMessagesResponse() = default;
};
class QueryMovieCommentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJson{};
  shared_ptr<long> movieId{};
  shared_ptr<long> pageNumber{};

  QueryMovieCommentsRequest() {}

  explicit QueryMovieCommentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (movieId) {
      res["MovieId"] = boost::any(*movieId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("MovieId") != m.end() && !m["MovieId"].empty()) {
      movieId = make_shared<long>(boost::any_cast<long>(m["MovieId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~QueryMovieCommentsRequest() = default;
};
class QueryMovieCommentsResponseBodyCommentListComment : public Darabonba::Model {
public:
  shared_ptr<string> commentTime{};
  shared_ptr<string> content{};
  shared_ptr<long> favorCount{};
  shared_ptr<long> id{};
  shared_ptr<long> movieId{};
  shared_ptr<string> nickName{};
  shared_ptr<long> remark{};
  shared_ptr<string> subject{};

  QueryMovieCommentsResponseBodyCommentListComment() {}

  explicit QueryMovieCommentsResponseBodyCommentListComment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentTime) {
      res["CommentTime"] = boost::any(*commentTime);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (favorCount) {
      res["FavorCount"] = boost::any(*favorCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (movieId) {
      res["MovieId"] = boost::any(*movieId);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommentTime") != m.end() && !m["CommentTime"].empty()) {
      commentTime = make_shared<string>(boost::any_cast<string>(m["CommentTime"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FavorCount") != m.end() && !m["FavorCount"].empty()) {
      favorCount = make_shared<long>(boost::any_cast<long>(m["FavorCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MovieId") != m.end() && !m["MovieId"].empty()) {
      movieId = make_shared<long>(boost::any_cast<long>(m["MovieId"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<long>(boost::any_cast<long>(m["Remark"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
  }


  virtual ~QueryMovieCommentsResponseBodyCommentListComment() = default;
};
class QueryMovieCommentsResponseBodyCommentList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMovieCommentsResponseBodyCommentListComment>> comment{};

  QueryMovieCommentsResponseBodyCommentList() {}

  explicit QueryMovieCommentsResponseBodyCommentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      vector<boost::any> temp1;
      for(auto item1:*comment){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Comment"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      if (typeid(vector<boost::any>) == m["Comment"].type()) {
        vector<QueryMovieCommentsResponseBodyCommentListComment> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Comment"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMovieCommentsResponseBodyCommentListComment model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comment = make_shared<vector<QueryMovieCommentsResponseBodyCommentListComment>>(expect1);
      }
    }
  }


  virtual ~QueryMovieCommentsResponseBodyCommentList() = default;
};
class QueryMovieCommentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryMovieCommentsResponseBodyCommentList> commentList{};
  shared_ptr<long> count{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryMovieCommentsResponseBody() {}

  explicit QueryMovieCommentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (commentList) {
      res["CommentList"] = commentList ? boost::any(commentList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CommentList") != m.end() && !m["CommentList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommentList"].type()) {
        QueryMovieCommentsResponseBodyCommentList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommentList"]));
        commentList = make_shared<QueryMovieCommentsResponseBodyCommentList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMovieCommentsResponseBody() = default;
};
class QueryMovieCommentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMovieCommentsResponseBody> body{};

  QueryMovieCommentsResponse() {}

  explicit QueryMovieCommentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMovieCommentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMovieCommentsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMovieCommentsResponse() = default;
};
class QueryMovieSchedulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> cinemaId{};
  shared_ptr<string> extJson{};

  QueryMovieSchedulesRequest() {}

  explicit QueryMovieSchedulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cinemaId) {
      res["CinemaId"] = boost::any(*cinemaId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CinemaId") != m.end() && !m["CinemaId"].empty()) {
      cinemaId = make_shared<long>(boost::any_cast<long>(m["CinemaId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
  }


  virtual ~QueryMovieSchedulesRequest() = default;
};
class QueryMovieSchedulesResponseBodySchedulesSchedule : public Darabonba::Model {
public:
  shared_ptr<long> cinemaId{};
  shared_ptr<string> hallName{};
  shared_ptr<long> id{};
  shared_ptr<bool> isExpired{};
  shared_ptr<long> maxCanBuy{};
  shared_ptr<long> movieId{};
  shared_ptr<string> movieVersion{};
  shared_ptr<long> price{};
  shared_ptr<string> releaseDate{};
  shared_ptr<string> scheduleArea{};
  shared_ptr<string> sectionId{};
  shared_ptr<long> serviceFee{};
  shared_ptr<string> sessionEndingTime{};
  shared_ptr<string> sessionStartingTime{};

  QueryMovieSchedulesResponseBodySchedulesSchedule() {}

  explicit QueryMovieSchedulesResponseBodySchedulesSchedule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cinemaId) {
      res["CinemaId"] = boost::any(*cinemaId);
    }
    if (hallName) {
      res["HallName"] = boost::any(*hallName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isExpired) {
      res["IsExpired"] = boost::any(*isExpired);
    }
    if (maxCanBuy) {
      res["MaxCanBuy"] = boost::any(*maxCanBuy);
    }
    if (movieId) {
      res["MovieId"] = boost::any(*movieId);
    }
    if (movieVersion) {
      res["MovieVersion"] = boost::any(*movieVersion);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (releaseDate) {
      res["ReleaseDate"] = boost::any(*releaseDate);
    }
    if (scheduleArea) {
      res["ScheduleArea"] = boost::any(*scheduleArea);
    }
    if (sectionId) {
      res["SectionId"] = boost::any(*sectionId);
    }
    if (serviceFee) {
      res["ServiceFee"] = boost::any(*serviceFee);
    }
    if (sessionEndingTime) {
      res["SessionEndingTime"] = boost::any(*sessionEndingTime);
    }
    if (sessionStartingTime) {
      res["SessionStartingTime"] = boost::any(*sessionStartingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CinemaId") != m.end() && !m["CinemaId"].empty()) {
      cinemaId = make_shared<long>(boost::any_cast<long>(m["CinemaId"]));
    }
    if (m.find("HallName") != m.end() && !m["HallName"].empty()) {
      hallName = make_shared<string>(boost::any_cast<string>(m["HallName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsExpired") != m.end() && !m["IsExpired"].empty()) {
      isExpired = make_shared<bool>(boost::any_cast<bool>(m["IsExpired"]));
    }
    if (m.find("MaxCanBuy") != m.end() && !m["MaxCanBuy"].empty()) {
      maxCanBuy = make_shared<long>(boost::any_cast<long>(m["MaxCanBuy"]));
    }
    if (m.find("MovieId") != m.end() && !m["MovieId"].empty()) {
      movieId = make_shared<long>(boost::any_cast<long>(m["MovieId"]));
    }
    if (m.find("MovieVersion") != m.end() && !m["MovieVersion"].empty()) {
      movieVersion = make_shared<string>(boost::any_cast<string>(m["MovieVersion"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<long>(boost::any_cast<long>(m["Price"]));
    }
    if (m.find("ReleaseDate") != m.end() && !m["ReleaseDate"].empty()) {
      releaseDate = make_shared<string>(boost::any_cast<string>(m["ReleaseDate"]));
    }
    if (m.find("ScheduleArea") != m.end() && !m["ScheduleArea"].empty()) {
      scheduleArea = make_shared<string>(boost::any_cast<string>(m["ScheduleArea"]));
    }
    if (m.find("SectionId") != m.end() && !m["SectionId"].empty()) {
      sectionId = make_shared<string>(boost::any_cast<string>(m["SectionId"]));
    }
    if (m.find("ServiceFee") != m.end() && !m["ServiceFee"].empty()) {
      serviceFee = make_shared<long>(boost::any_cast<long>(m["ServiceFee"]));
    }
    if (m.find("SessionEndingTime") != m.end() && !m["SessionEndingTime"].empty()) {
      sessionEndingTime = make_shared<string>(boost::any_cast<string>(m["SessionEndingTime"]));
    }
    if (m.find("SessionStartingTime") != m.end() && !m["SessionStartingTime"].empty()) {
      sessionStartingTime = make_shared<string>(boost::any_cast<string>(m["SessionStartingTime"]));
    }
  }


  virtual ~QueryMovieSchedulesResponseBodySchedulesSchedule() = default;
};
class QueryMovieSchedulesResponseBodySchedules : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMovieSchedulesResponseBodySchedulesSchedule>> schedule{};

  QueryMovieSchedulesResponseBodySchedules() {}

  explicit QueryMovieSchedulesResponseBodySchedules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedule) {
      vector<boost::any> temp1;
      for(auto item1:*schedule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Schedule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      if (typeid(vector<boost::any>) == m["Schedule"].type()) {
        vector<QueryMovieSchedulesResponseBodySchedulesSchedule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Schedule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMovieSchedulesResponseBodySchedulesSchedule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedule = make_shared<vector<QueryMovieSchedulesResponseBodySchedulesSchedule>>(expect1);
      }
    }
  }


  virtual ~QueryMovieSchedulesResponseBodySchedules() = default;
};
class QueryMovieSchedulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMovieSchedulesResponseBodySchedules> schedules{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryMovieSchedulesResponseBody() {}

  explicit QueryMovieSchedulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schedules) {
      res["Schedules"] = schedules ? boost::any(schedules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schedules") != m.end() && !m["Schedules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schedules"].type()) {
        QueryMovieSchedulesResponseBodySchedules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schedules"]));
        schedules = make_shared<QueryMovieSchedulesResponseBodySchedules>(model1);
      }
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMovieSchedulesResponseBody() = default;
};
class QueryMovieSchedulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMovieSchedulesResponseBody> body{};

  QueryMovieSchedulesResponse() {}

  explicit QueryMovieSchedulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMovieSchedulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMovieSchedulesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMovieSchedulesResponse() = default;
};
class QueryMovieSeatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJson{};
  shared_ptr<long> scheduleId{};

  QueryMovieSeatsRequest() {}

  explicit QueryMovieSeatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (scheduleId) {
      res["ScheduleId"] = boost::any(*scheduleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ScheduleId") != m.end() && !m["ScheduleId"].empty()) {
      scheduleId = make_shared<long>(boost::any_cast<long>(m["ScheduleId"]));
    }
  }


  virtual ~QueryMovieSeatsRequest() = default;
};
class QueryMovieSeatsResponseBodySeatMapSeatsSeat : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<long> column{};
  shared_ptr<string> extId{};
  shared_ptr<long> flag{};
  shared_ptr<long> leftPx{};
  shared_ptr<string> name{};
  shared_ptr<long> row{};
  shared_ptr<string> rowName{};
  shared_ptr<long> status{};
  shared_ptr<long> topPx{};

  QueryMovieSeatsResponseBodySeatMapSeatsSeat() {}

  explicit QueryMovieSeatsResponseBodySeatMapSeatsSeat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (column) {
      res["Column"] = boost::any(*column);
    }
    if (extId) {
      res["ExtId"] = boost::any(*extId);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (leftPx) {
      res["LeftPx"] = boost::any(*leftPx);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (row) {
      res["Row"] = boost::any(*row);
    }
    if (rowName) {
      res["RowName"] = boost::any(*rowName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (topPx) {
      res["TopPx"] = boost::any(*topPx);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      column = make_shared<long>(boost::any_cast<long>(m["Column"]));
    }
    if (m.find("ExtId") != m.end() && !m["ExtId"].empty()) {
      extId = make_shared<string>(boost::any_cast<string>(m["ExtId"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("LeftPx") != m.end() && !m["LeftPx"].empty()) {
      leftPx = make_shared<long>(boost::any_cast<long>(m["LeftPx"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      row = make_shared<long>(boost::any_cast<long>(m["Row"]));
    }
    if (m.find("RowName") != m.end() && !m["RowName"].empty()) {
      rowName = make_shared<string>(boost::any_cast<string>(m["RowName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TopPx") != m.end() && !m["TopPx"].empty()) {
      topPx = make_shared<long>(boost::any_cast<long>(m["TopPx"]));
    }
  }


  virtual ~QueryMovieSeatsResponseBodySeatMapSeatsSeat() = default;
};
class QueryMovieSeatsResponseBodySeatMapSeats : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMovieSeatsResponseBodySeatMapSeatsSeat>> seat{};

  QueryMovieSeatsResponseBodySeatMapSeats() {}

  explicit QueryMovieSeatsResponseBodySeatMapSeats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (seat) {
      vector<boost::any> temp1;
      for(auto item1:*seat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Seat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Seat") != m.end() && !m["Seat"].empty()) {
      if (typeid(vector<boost::any>) == m["Seat"].type()) {
        vector<QueryMovieSeatsResponseBodySeatMapSeatsSeat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Seat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMovieSeatsResponseBodySeatMapSeatsSeat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        seat = make_shared<vector<QueryMovieSeatsResponseBodySeatMapSeatsSeat>>(expect1);
      }
    }
  }


  virtual ~QueryMovieSeatsResponseBodySeatMapSeats() = default;
};
class QueryMovieSeatsResponseBodySeatMap : public Darabonba::Model {
public:
  shared_ptr<long> maxCanBuy{};
  shared_ptr<long> maxColumn{};
  shared_ptr<long> maxLeftPx{};
  shared_ptr<long> maxRow{};
  shared_ptr<long> maxTopPx{};
  shared_ptr<long> minColumn{};
  shared_ptr<long> minLeftPx{};
  shared_ptr<long> minRow{};
  shared_ptr<long> minTopPx{};
  shared_ptr<string> notice{};
  shared_ptr<bool> regular{};
  shared_ptr<long> seatCount{};
  shared_ptr<QueryMovieSeatsResponseBodySeatMapSeats> seats{};
  shared_ptr<long> soldCount{};
  shared_ptr<string> tipMessage{};

  QueryMovieSeatsResponseBodySeatMap() {}

  explicit QueryMovieSeatsResponseBodySeatMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCanBuy) {
      res["MaxCanBuy"] = boost::any(*maxCanBuy);
    }
    if (maxColumn) {
      res["MaxColumn"] = boost::any(*maxColumn);
    }
    if (maxLeftPx) {
      res["MaxLeftPx"] = boost::any(*maxLeftPx);
    }
    if (maxRow) {
      res["MaxRow"] = boost::any(*maxRow);
    }
    if (maxTopPx) {
      res["MaxTopPx"] = boost::any(*maxTopPx);
    }
    if (minColumn) {
      res["MinColumn"] = boost::any(*minColumn);
    }
    if (minLeftPx) {
      res["MinLeftPx"] = boost::any(*minLeftPx);
    }
    if (minRow) {
      res["MinRow"] = boost::any(*minRow);
    }
    if (minTopPx) {
      res["MinTopPx"] = boost::any(*minTopPx);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (regular) {
      res["Regular"] = boost::any(*regular);
    }
    if (seatCount) {
      res["SeatCount"] = boost::any(*seatCount);
    }
    if (seats) {
      res["Seats"] = seats ? boost::any(seats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (soldCount) {
      res["SoldCount"] = boost::any(*soldCount);
    }
    if (tipMessage) {
      res["TipMessage"] = boost::any(*tipMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCanBuy") != m.end() && !m["MaxCanBuy"].empty()) {
      maxCanBuy = make_shared<long>(boost::any_cast<long>(m["MaxCanBuy"]));
    }
    if (m.find("MaxColumn") != m.end() && !m["MaxColumn"].empty()) {
      maxColumn = make_shared<long>(boost::any_cast<long>(m["MaxColumn"]));
    }
    if (m.find("MaxLeftPx") != m.end() && !m["MaxLeftPx"].empty()) {
      maxLeftPx = make_shared<long>(boost::any_cast<long>(m["MaxLeftPx"]));
    }
    if (m.find("MaxRow") != m.end() && !m["MaxRow"].empty()) {
      maxRow = make_shared<long>(boost::any_cast<long>(m["MaxRow"]));
    }
    if (m.find("MaxTopPx") != m.end() && !m["MaxTopPx"].empty()) {
      maxTopPx = make_shared<long>(boost::any_cast<long>(m["MaxTopPx"]));
    }
    if (m.find("MinColumn") != m.end() && !m["MinColumn"].empty()) {
      minColumn = make_shared<long>(boost::any_cast<long>(m["MinColumn"]));
    }
    if (m.find("MinLeftPx") != m.end() && !m["MinLeftPx"].empty()) {
      minLeftPx = make_shared<long>(boost::any_cast<long>(m["MinLeftPx"]));
    }
    if (m.find("MinRow") != m.end() && !m["MinRow"].empty()) {
      minRow = make_shared<long>(boost::any_cast<long>(m["MinRow"]));
    }
    if (m.find("MinTopPx") != m.end() && !m["MinTopPx"].empty()) {
      minTopPx = make_shared<long>(boost::any_cast<long>(m["MinTopPx"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<string>(boost::any_cast<string>(m["Notice"]));
    }
    if (m.find("Regular") != m.end() && !m["Regular"].empty()) {
      regular = make_shared<bool>(boost::any_cast<bool>(m["Regular"]));
    }
    if (m.find("SeatCount") != m.end() && !m["SeatCount"].empty()) {
      seatCount = make_shared<long>(boost::any_cast<long>(m["SeatCount"]));
    }
    if (m.find("Seats") != m.end() && !m["Seats"].empty()) {
      if (typeid(map<string, boost::any>) == m["Seats"].type()) {
        QueryMovieSeatsResponseBodySeatMapSeats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Seats"]));
        seats = make_shared<QueryMovieSeatsResponseBodySeatMapSeats>(model1);
      }
    }
    if (m.find("SoldCount") != m.end() && !m["SoldCount"].empty()) {
      soldCount = make_shared<long>(boost::any_cast<long>(m["SoldCount"]));
    }
    if (m.find("TipMessage") != m.end() && !m["TipMessage"].empty()) {
      tipMessage = make_shared<string>(boost::any_cast<string>(m["TipMessage"]));
    }
  }


  virtual ~QueryMovieSeatsResponseBodySeatMap() = default;
};
class QueryMovieSeatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryMovieSeatsResponseBodySeatMap> seatMap{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryMovieSeatsResponseBody() {}

  explicit QueryMovieSeatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (seatMap) {
      res["SeatMap"] = seatMap ? boost::any(seatMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SeatMap") != m.end() && !m["SeatMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["SeatMap"].type()) {
        QueryMovieSeatsResponseBodySeatMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SeatMap"]));
        seatMap = make_shared<QueryMovieSeatsResponseBodySeatMap>(model1);
      }
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMovieSeatsResponseBody() = default;
};
class QueryMovieSeatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMovieSeatsResponseBody> body{};

  QueryMovieSeatsResponse() {}

  explicit QueryMovieSeatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMovieSeatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMovieSeatsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMovieSeatsResponse() = default;
};
class QueryMovieTicketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> orderId{};

  QueryMovieTicketsRequest() {}

  explicit QueryMovieTicketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~QueryMovieTicketsRequest() = default;
};
class QueryMovieTicketsResponseBodyMovieTicket : public Darabonba::Model {
public:
  shared_ptr<string> returnMessage{};
  shared_ptr<string> status{};
  shared_ptr<string> tbOrderId{};
  shared_ptr<string> ticketContents{};

  QueryMovieTicketsResponseBodyMovieTicket() {}

  explicit QueryMovieTicketsResponseBodyMovieTicket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (returnMessage) {
      res["ReturnMessage"] = boost::any(*returnMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    if (ticketContents) {
      res["TicketContents"] = boost::any(*ticketContents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReturnMessage") != m.end() && !m["ReturnMessage"].empty()) {
      returnMessage = make_shared<string>(boost::any_cast<string>(m["ReturnMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<string>(boost::any_cast<string>(m["TbOrderId"]));
    }
    if (m.find("TicketContents") != m.end() && !m["TicketContents"].empty()) {
      ticketContents = make_shared<string>(boost::any_cast<string>(m["TicketContents"]));
    }
  }


  virtual ~QueryMovieTicketsResponseBodyMovieTicket() = default;
};
class QueryMovieTicketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryMovieTicketsResponseBodyMovieTicket> movieTicket{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  QueryMovieTicketsResponseBody() {}

  explicit QueryMovieTicketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (movieTicket) {
      res["MovieTicket"] = movieTicket ? boost::any(movieTicket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MovieTicket") != m.end() && !m["MovieTicket"].empty()) {
      if (typeid(map<string, boost::any>) == m["MovieTicket"].type()) {
        QueryMovieTicketsResponseBodyMovieTicket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MovieTicket"]));
        movieTicket = make_shared<QueryMovieTicketsResponseBodyMovieTicket>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMovieTicketsResponseBody() = default;
};
class QueryMovieTicketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMovieTicketsResponseBody> body{};

  QueryMovieTicketsResponse() {}

  explicit QueryMovieTicketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMovieTicketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMovieTicketsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMovieTicketsResponse() = default;
};
class QueryOrderAndPaymentListRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> filterOption{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderAndPaymentListRequest() {}

  explicit QueryOrderAndPaymentListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (filterOption) {
      res["FilterOption"] = boost::any(*filterOption);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("FilterOption") != m.end() && !m["FilterOption"].empty()) {
      filterOption = make_shared<string>(boost::any_cast<string>(m["FilterOption"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderAndPaymentListRequest() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels>> fundStructureModels{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundStructureModels) {
      vector<boost::any> temp1;
      for(auto item1:*fundStructureModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FundStructureModels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FundStructureModels"].type()) {
        vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FundStructureModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fundStructureModels = make_shared<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels>>(expect1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList>> itemPriceList{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*itemPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPriceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPriceList"].type()) {
        vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPriceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPriceList = make_shared<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList : public Darabonba::Model {
public:
  shared_ptr<long> enableStatus{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemPic{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList> itemPriceList{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> number{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<long> tbOrderId{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemPic) {
      res["ItemPic"] = boost::any(*itemPic);
    }
    if (itemPriceList) {
      res["ItemPriceList"] = itemPriceList ? boost::any(itemPriceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemPic") != m.end() && !m["ItemPic"].empty()) {
      itemPic = make_shared<string>(boost::any_cast<string>(m["ItemPic"]));
    }
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemPriceList"].type()) {
        QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemPriceList"]));
        itemPriceList = make_shared<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList>(model1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList>> subOrderList{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*subOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubOrderList"].type()) {
        vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrderList = make_shared<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<long> enableStatus{};
  shared_ptr<string> extJson{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels> fundStructureModels{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> lmPaymentId{};
  shared_ptr<long> logisticsStatus{};
  shared_ptr<long> orderAmount{};
  shared_ptr<long> orderStatus{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee> postFee{};
  shared_ptr<string> shopName{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList> subOrderList{};
  shared_ptr<long> tbOrderId{};

  QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (fundStructureModels) {
      res["FundStructureModels"] = fundStructureModels ? boost::any(fundStructureModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (lmPaymentId) {
      res["LmPaymentId"] = boost::any(*lmPaymentId);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    if (orderAmount) {
      res["OrderAmount"] = boost::any(*orderAmount);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (subOrderList) {
      res["SubOrderList"] = subOrderList ? boost::any(subOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FundStructureModels"].type()) {
        QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FundStructureModels"]));
        fundStructureModels = make_shared<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListFundStructureModels>(model1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LmPaymentId") != m.end() && !m["LmPaymentId"].empty()) {
      lmPaymentId = make_shared<string>(boost::any_cast<string>(m["LmPaymentId"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<long>(boost::any_cast<long>(m["LogisticsStatus"]));
    }
    if (m.find("OrderAmount") != m.end() && !m["OrderAmount"].empty()) {
      orderAmount = make_shared<long>(boost::any_cast<long>(m["OrderAmount"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListPostFee>(model1);
      }
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubOrderList"].type()) {
        QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubOrderList"]));
        subOrderList = make_shared<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderListSubOrderList>(model1);
      }
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList() = default;
};
class QueryOrderAndPaymentListResponseBodyLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList>> lmOrderList{};

  QueryOrderAndPaymentListResponseBodyLmOrderList() {}

  explicit QueryOrderAndPaymentListResponseBodyLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<QueryOrderAndPaymentListResponseBodyLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyLmOrderList() = default;
};
class QueryOrderAndPaymentListResponseBodyPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListResponseBodyPostFee() {}

  explicit QueryOrderAndPaymentListResponseBodyPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBodyPostFee() = default;
};
class QueryOrderAndPaymentListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyLmOrderList> lmOrderList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<QueryOrderAndPaymentListResponseBodyPostFee> postFee{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryOrderAndPaymentListResponseBody() {}

  explicit QueryOrderAndPaymentListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        QueryOrderAndPaymentListResponseBodyLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<QueryOrderAndPaymentListResponseBodyLmOrderList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderAndPaymentListResponseBodyPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderAndPaymentListResponseBodyPostFee>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryOrderAndPaymentListResponseBody() = default;
};
class QueryOrderAndPaymentListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderAndPaymentListResponseBody> body{};

  QueryOrderAndPaymentListResponse() {}

  explicit QueryOrderAndPaymentListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderAndPaymentListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderAndPaymentListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListResponse() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> filterOption{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryOrderAndPaymentListWithDesignatedTbUidRequest() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (filterOption) {
      res["FilterOption"] = boost::any(*filterOption);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FilterOption") != m.end() && !m["FilterOption"].empty()) {
      filterOption = make_shared<string>(boost::any_cast<string>(m["FilterOption"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidRequest() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList : public Darabonba::Model {
public:
  shared_ptr<long> enableStatus{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemPic{};
  shared_ptr<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList>> itemPriceList{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> number{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<long> tbOrderId{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemPic) {
      res["ItemPic"] = boost::any(*itemPic);
    }
    if (itemPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*itemPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPriceList"] = boost::any(temp1);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemPic") != m.end() && !m["ItemPic"].empty()) {
      itemPic = make_shared<string>(boost::any_cast<string>(m["ItemPic"]));
    }
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPriceList"].type()) {
        vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPriceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPriceList = make_shared<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList>>(expect1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<string>(boost::any_cast<string>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> enableStatus{};
  shared_ptr<string> extJson{};
  shared_ptr<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels>> fundStructureModels{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> lmPaymentId{};
  shared_ptr<long> logisticsStatus{};
  shared_ptr<long> orderAmount{};
  shared_ptr<long> orderStatus{};
  shared_ptr<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee> postFee{};
  shared_ptr<string> shopName{};
  shared_ptr<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList>> subOrderList{};
  shared_ptr<long> tbOrderId{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (fundStructureModels) {
      vector<boost::any> temp1;
      for(auto item1:*fundStructureModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FundStructureModels"] = boost::any(temp1);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (lmPaymentId) {
      res["LmPaymentId"] = boost::any(*lmPaymentId);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    if (orderAmount) {
      res["OrderAmount"] = boost::any(*orderAmount);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (subOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*subOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubOrderList"] = boost::any(temp1);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FundStructureModels"].type()) {
        vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FundStructureModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fundStructureModels = make_shared<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelFundStructureModels>>(expect1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LmPaymentId") != m.end() && !m["LmPaymentId"].empty()) {
      lmPaymentId = make_shared<string>(boost::any_cast<string>(m["LmPaymentId"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<long>(boost::any_cast<long>(m["LogisticsStatus"]));
    }
    if (m.find("OrderAmount") != m.end() && !m["OrderAmount"].empty()) {
      orderAmount = make_shared<long>(boost::any_cast<long>(m["OrderAmount"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelPostFee>(model1);
      }
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubOrderList"].type()) {
        vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrderList = make_shared<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModelSubOrderList>>(expect1);
      }
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponseBody() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryOrderAndPaymentListWithDesignatedTbUidResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponseBody() = default;
};
class QueryOrderAndPaymentListWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderAndPaymentListWithDesignatedTbUidResponseBody> body{};

  QueryOrderAndPaymentListWithDesignatedTbUidResponse() {}

  explicit QueryOrderAndPaymentListWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderAndPaymentListWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderAndPaymentListWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderAndPaymentListWithDesignatedTbUidResponse() = default;
};
class QueryOrderCommissionRateRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderCommissionRateRequest() {}

  explicit QueryOrderCommissionRateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderCommissionRateRequest() = default;
};
class QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs : public Darabonba::Model {
public:
  shared_ptr<long> value{};
  shared_ptr<string> valueUnit{};

  QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs() {}

  explicit QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueUnit) {
      res["ValueUnit"] = boost::any(*valueUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
    if (m.find("ValueUnit") != m.end() && !m["ValueUnit"].empty()) {
      valueUnit = make_shared<string>(boost::any_cast<string>(m["ValueUnit"]));
    }
  }


  virtual ~QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs() = default;
};
class QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs>> configs{};

  QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig() {}

  explicit QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfigConfigs>>(expect1);
      }
    }
  }


  virtual ~QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig() = default;
};
class QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo : public Darabonba::Model {
public:
  shared_ptr<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig> rateConfig{};
  shared_ptr<string> rateType{};

  QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo() {}

  explicit QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rateConfig) {
      res["RateConfig"] = rateConfig ? boost::any(rateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rateType) {
      res["RateType"] = boost::any(*rateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RateConfig") != m.end() && !m["RateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RateConfig"].type()) {
        QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RateConfig"]));
        rateConfig = make_shared<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfoRateConfig>(model1);
      }
    }
    if (m.find("RateType") != m.end() && !m["RateType"].empty()) {
      rateType = make_shared<string>(boost::any_cast<string>(m["RateType"]));
    }
  }


  virtual ~QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo() = default;
};
class QueryOrderCommissionRateResponseBodyCommissionModels : public Darabonba::Model {
public:
  shared_ptr<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo> commissionInfo{};
  shared_ptr<long> lmOrderId{};

  QueryOrderCommissionRateResponseBodyCommissionModels() {}

  explicit QueryOrderCommissionRateResponseBodyCommissionModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commissionInfo) {
      res["CommissionInfo"] = commissionInfo ? boost::any(commissionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommissionInfo") != m.end() && !m["CommissionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommissionInfo"].type()) {
        QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommissionInfo"]));
        commissionInfo = make_shared<QueryOrderCommissionRateResponseBodyCommissionModelsCommissionInfo>(model1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
  }


  virtual ~QueryOrderCommissionRateResponseBodyCommissionModels() = default;
};
class QueryOrderCommissionRateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryOrderCommissionRateResponseBodyCommissionModels>> commissionModels{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryOrderCommissionRateResponseBody() {}

  explicit QueryOrderCommissionRateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (commissionModels) {
      vector<boost::any> temp1;
      for(auto item1:*commissionModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CommissionModels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CommissionModels") != m.end() && !m["CommissionModels"].empty()) {
      if (typeid(vector<boost::any>) == m["CommissionModels"].type()) {
        vector<QueryOrderCommissionRateResponseBodyCommissionModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CommissionModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderCommissionRateResponseBodyCommissionModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        commissionModels = make_shared<vector<QueryOrderCommissionRateResponseBodyCommissionModels>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderCommissionRateResponseBody() = default;
};
class QueryOrderCommissionRateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderCommissionRateResponseBody> body{};

  QueryOrderCommissionRateResponse() {}

  explicit QueryOrderCommissionRateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderCommissionRateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderCommissionRateResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderCommissionRateResponse() = default;
};
class QueryOrderDetailInnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> filterOption{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderDetailInnerRequest() {}

  explicit QueryOrderDetailInnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (filterOption) {
      res["FilterOption"] = boost::any(*filterOption);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("FilterOption") != m.end() && !m["FilterOption"].empty()) {
      filterOption = make_shared<string>(boost::any_cast<string>(m["FilterOption"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderDetailInnerRequest() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> tbSubOrderId{};

  QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbSubOrderId) {
      res["TbSubOrderId"] = boost::any(*tbSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbSubOrderId") != m.end() && !m["TbSubOrderId"].empty()) {
      tbSubOrderId = make_shared<long>(boost::any_cast<long>(m["TbSubOrderId"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure>> fundStructure{};

  QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundStructure) {
      vector<boost::any> temp1;
      for(auto item1:*fundStructure){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FundStructure"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundStructure") != m.end() && !m["FundStructure"].empty()) {
      if (typeid(vector<boost::any>) == m["FundStructure"].type()) {
        vector<QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FundStructure"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fundStructure = make_shared<vector<QueryOrderDetailInnerResponseBodyModelOrderFundStructureModelsFundStructure>>(expect1);
      }
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> tbSubOrderId{};

  QueryOrderDetailInnerResponseBodyModelOrderPostFee() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbSubOrderId) {
      res["TbSubOrderId"] = boost::any(*tbSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbSubOrderId") != m.end() && !m["TbSubOrderId"].empty()) {
      tbSubOrderId = make_shared<long>(boost::any_cast<long>(m["TbSubOrderId"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderPostFee() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};
  shared_ptr<long> tbOrderId{};
  shared_ptr<long> tbSubOrderId{};

  QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    if (tbSubOrderId) {
      res["TbSubOrderId"] = boost::any(*tbSubOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
    if (m.find("TbSubOrderId") != m.end() && !m["TbSubOrderId"].empty()) {
      tbSubOrderId = make_shared<long>(boost::any_cast<long>(m["TbSubOrderId"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice>> itemPrice{};

  QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemPrice) {
      vector<boost::any> temp1;
      for(auto item1:*itemPrice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPrice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemPrice") != m.end() && !m["ItemPrice"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPrice"].type()) {
        vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPrice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPrice = make_shared<vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceListItemPrice>>(expect1);
      }
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder : public Darabonba::Model {
public:
  shared_ptr<string> channelCode{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemPic{};
  shared_ptr<string> itemPriceInfo{};
  shared_ptr<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList> itemPriceList{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> number{};
  shared_ptr<long> payStatus{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<long> tbSubOrderId{};
  shared_ptr<string> totalPaymentInfo{};

  QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCode) {
      res["ChannelCode"] = boost::any(*channelCode);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemPic) {
      res["ItemPic"] = boost::any(*itemPic);
    }
    if (itemPriceInfo) {
      res["ItemPriceInfo"] = boost::any(*itemPriceInfo);
    }
    if (itemPriceList) {
      res["ItemPriceList"] = itemPriceList ? boost::any(itemPriceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (payStatus) {
      res["PayStatus"] = boost::any(*payStatus);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbSubOrderId) {
      res["TbSubOrderId"] = boost::any(*tbSubOrderId);
    }
    if (totalPaymentInfo) {
      res["TotalPaymentInfo"] = boost::any(*totalPaymentInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCode") != m.end() && !m["ChannelCode"].empty()) {
      channelCode = make_shared<string>(boost::any_cast<string>(m["ChannelCode"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemPic") != m.end() && !m["ItemPic"].empty()) {
      itemPic = make_shared<string>(boost::any_cast<string>(m["ItemPic"]));
    }
    if (m.find("ItemPriceInfo") != m.end() && !m["ItemPriceInfo"].empty()) {
      itemPriceInfo = make_shared<string>(boost::any_cast<string>(m["ItemPriceInfo"]));
    }
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemPriceList"].type()) {
        QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemPriceList"]));
        itemPriceList = make_shared<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrderItemPriceList>(model1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("PayStatus") != m.end() && !m["PayStatus"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["PayStatus"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbSubOrderId") != m.end() && !m["TbSubOrderId"].empty()) {
      tbSubOrderId = make_shared<long>(boost::any_cast<long>(m["TbSubOrderId"]));
    }
    if (m.find("TotalPaymentInfo") != m.end() && !m["TotalPaymentInfo"].empty()) {
      totalPaymentInfo = make_shared<string>(boost::any_cast<string>(m["TotalPaymentInfo"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder>> subItemOrder{};

  QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subItemOrder) {
      vector<boost::any> temp1;
      for(auto item1:*subItemOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubItemOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubItemOrder") != m.end() && !m["SubItemOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["SubItemOrder"].type()) {
        vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubItemOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subItemOrder = make_shared<vector<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderListSubItemOrder>>(expect1);
      }
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList() = default;
};
class QueryOrderDetailInnerResponseBodyModelOrder : public Darabonba::Model {
public:
  shared_ptr<string> channelBizType{};
  shared_ptr<string> channelCode{};
  shared_ptr<string> channelOrderId{};
  shared_ptr<string> createDate{};
  shared_ptr<long> enableStatus{};
  shared_ptr<long> endTime{};
  shared_ptr<bool> eticket{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels> fundStructureModels{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> logisticsAddress{};
  shared_ptr<string> logisticsCompName{};
  shared_ptr<string> logisticsMobilePhone{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<long> logisticsStatus{};
  shared_ptr<string> logisticsStatusDesc{};
  shared_ptr<string> logisticsUserName{};
  shared_ptr<long> orderAmount{};
  shared_ptr<string> orderPayInfo{};
  shared_ptr<long> payStatus{};
  shared_ptr<long> payWaterStatus{};
  shared_ptr<QueryOrderDetailInnerResponseBodyModelOrderPostFee> postFee{};
  shared_ptr<long> refundStatus{};
  shared_ptr<string> resExtInfo{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<string> shipping{};
  shared_ptr<string> shopName{};
  shared_ptr<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList> subItemOrderList{};
  shared_ptr<string> tbOrderId{};

  QueryOrderDetailInnerResponseBodyModelOrder() {}

  explicit QueryOrderDetailInnerResponseBodyModelOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelBizType) {
      res["ChannelBizType"] = boost::any(*channelBizType);
    }
    if (channelCode) {
      res["ChannelCode"] = boost::any(*channelCode);
    }
    if (channelOrderId) {
      res["ChannelOrderId"] = boost::any(*channelOrderId);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eticket) {
      res["Eticket"] = boost::any(*eticket);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (fundStructureModels) {
      res["FundStructureModels"] = fundStructureModels ? boost::any(fundStructureModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (logisticsAddress) {
      res["LogisticsAddress"] = boost::any(*logisticsAddress);
    }
    if (logisticsCompName) {
      res["LogisticsCompName"] = boost::any(*logisticsCompName);
    }
    if (logisticsMobilePhone) {
      res["LogisticsMobilePhone"] = boost::any(*logisticsMobilePhone);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    if (logisticsStatusDesc) {
      res["LogisticsStatusDesc"] = boost::any(*logisticsStatusDesc);
    }
    if (logisticsUserName) {
      res["LogisticsUserName"] = boost::any(*logisticsUserName);
    }
    if (orderAmount) {
      res["OrderAmount"] = boost::any(*orderAmount);
    }
    if (orderPayInfo) {
      res["OrderPayInfo"] = boost::any(*orderPayInfo);
    }
    if (payStatus) {
      res["PayStatus"] = boost::any(*payStatus);
    }
    if (payWaterStatus) {
      res["PayWaterStatus"] = boost::any(*payWaterStatus);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (refundStatus) {
      res["RefundStatus"] = boost::any(*refundStatus);
    }
    if (resExtInfo) {
      res["ResExtInfo"] = boost::any(*resExtInfo);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (shipping) {
      res["Shipping"] = boost::any(*shipping);
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (subItemOrderList) {
      res["SubItemOrderList"] = subItemOrderList ? boost::any(subItemOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelBizType") != m.end() && !m["ChannelBizType"].empty()) {
      channelBizType = make_shared<string>(boost::any_cast<string>(m["ChannelBizType"]));
    }
    if (m.find("ChannelCode") != m.end() && !m["ChannelCode"].empty()) {
      channelCode = make_shared<string>(boost::any_cast<string>(m["ChannelCode"]));
    }
    if (m.find("ChannelOrderId") != m.end() && !m["ChannelOrderId"].empty()) {
      channelOrderId = make_shared<string>(boost::any_cast<string>(m["ChannelOrderId"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Eticket") != m.end() && !m["Eticket"].empty()) {
      eticket = make_shared<bool>(boost::any_cast<bool>(m["Eticket"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FundStructureModels"].type()) {
        QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FundStructureModels"]));
        fundStructureModels = make_shared<QueryOrderDetailInnerResponseBodyModelOrderFundStructureModels>(model1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LogisticsAddress") != m.end() && !m["LogisticsAddress"].empty()) {
      logisticsAddress = make_shared<string>(boost::any_cast<string>(m["LogisticsAddress"]));
    }
    if (m.find("LogisticsCompName") != m.end() && !m["LogisticsCompName"].empty()) {
      logisticsCompName = make_shared<string>(boost::any_cast<string>(m["LogisticsCompName"]));
    }
    if (m.find("LogisticsMobilePhone") != m.end() && !m["LogisticsMobilePhone"].empty()) {
      logisticsMobilePhone = make_shared<string>(boost::any_cast<string>(m["LogisticsMobilePhone"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<long>(boost::any_cast<long>(m["LogisticsStatus"]));
    }
    if (m.find("LogisticsStatusDesc") != m.end() && !m["LogisticsStatusDesc"].empty()) {
      logisticsStatusDesc = make_shared<string>(boost::any_cast<string>(m["LogisticsStatusDesc"]));
    }
    if (m.find("LogisticsUserName") != m.end() && !m["LogisticsUserName"].empty()) {
      logisticsUserName = make_shared<string>(boost::any_cast<string>(m["LogisticsUserName"]));
    }
    if (m.find("OrderAmount") != m.end() && !m["OrderAmount"].empty()) {
      orderAmount = make_shared<long>(boost::any_cast<long>(m["OrderAmount"]));
    }
    if (m.find("OrderPayInfo") != m.end() && !m["OrderPayInfo"].empty()) {
      orderPayInfo = make_shared<string>(boost::any_cast<string>(m["OrderPayInfo"]));
    }
    if (m.find("PayStatus") != m.end() && !m["PayStatus"].empty()) {
      payStatus = make_shared<long>(boost::any_cast<long>(m["PayStatus"]));
    }
    if (m.find("PayWaterStatus") != m.end() && !m["PayWaterStatus"].empty()) {
      payWaterStatus = make_shared<long>(boost::any_cast<long>(m["PayWaterStatus"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderDetailInnerResponseBodyModelOrderPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderDetailInnerResponseBodyModelOrderPostFee>(model1);
      }
    }
    if (m.find("RefundStatus") != m.end() && !m["RefundStatus"].empty()) {
      refundStatus = make_shared<long>(boost::any_cast<long>(m["RefundStatus"]));
    }
    if (m.find("ResExtInfo") != m.end() && !m["ResExtInfo"].empty()) {
      resExtInfo = make_shared<string>(boost::any_cast<string>(m["ResExtInfo"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("Shipping") != m.end() && !m["Shipping"].empty()) {
      shipping = make_shared<string>(boost::any_cast<string>(m["Shipping"]));
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("SubItemOrderList") != m.end() && !m["SubItemOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubItemOrderList"].type()) {
        QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubItemOrderList"]));
        subItemOrderList = make_shared<QueryOrderDetailInnerResponseBodyModelOrderSubItemOrderList>(model1);
      }
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<string>(boost::any_cast<string>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModelOrder() = default;
};
class QueryOrderDetailInnerResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<QueryOrderDetailInnerResponseBodyModelOrder> order{};

  QueryOrderDetailInnerResponseBodyModel() {}

  explicit QueryOrderDetailInnerResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["order"] = order ? boost::any(order->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("order") != m.end() && !m["order"].empty()) {
      if (typeid(map<string, boost::any>) == m["order"].type()) {
        QueryOrderDetailInnerResponseBodyModelOrder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["order"]));
        order = make_shared<QueryOrderDetailInnerResponseBodyModelOrder>(model1);
      }
    }
  }


  virtual ~QueryOrderDetailInnerResponseBodyModel() = default;
};
class QueryOrderDetailInnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryOrderDetailInnerResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QueryOrderDetailInnerResponseBody() {}

  explicit QueryOrderDetailInnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryOrderDetailInnerResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryOrderDetailInnerResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderDetailInnerResponseBody() = default;
};
class QueryOrderDetailInnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderDetailInnerResponseBody> body{};

  QueryOrderDetailInnerResponse() {}

  explicit QueryOrderDetailInnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderDetailInnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderDetailInnerResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderDetailInnerResponse() = default;
};
class QueryOrderIdByPayIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> paymentId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderIdByPayIdRequest() {}

  explicit QueryOrderIdByPayIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (paymentId) {
      res["PaymentId"] = boost::any(*paymentId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("PaymentId") != m.end() && !m["PaymentId"].empty()) {
      paymentId = make_shared<string>(boost::any_cast<string>(m["PaymentId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderIdByPayIdRequest() = default;
};
class QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds : public Darabonba::Model {
public:
  shared_ptr<long> lmOrderId{};

  QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds() {}

  explicit QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
  }


  virtual ~QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds() = default;
};
class QueryOrderIdByPayIdResponseBodyLmOrderIds : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds>> lmOrderIds{};

  QueryOrderIdByPayIdResponseBodyLmOrderIds() {}

  explicit QueryOrderIdByPayIdResponseBodyLmOrderIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderIds) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderIds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderIds") != m.end() && !m["LmOrderIds"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderIds"].type()) {
        vector<QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderIds = make_shared<vector<QueryOrderIdByPayIdResponseBodyLmOrderIdsLmOrderIds>>(expect1);
      }
    }
  }


  virtual ~QueryOrderIdByPayIdResponseBodyLmOrderIds() = default;
};
class QueryOrderIdByPayIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryOrderIdByPayIdResponseBodyLmOrderIds> lmOrderIds{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryOrderIdByPayIdResponseBody() {}

  explicit QueryOrderIdByPayIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmOrderIds) {
      res["LmOrderIds"] = lmOrderIds ? boost::any(lmOrderIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmOrderIds") != m.end() && !m["LmOrderIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderIds"].type()) {
        QueryOrderIdByPayIdResponseBodyLmOrderIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderIds"]));
        lmOrderIds = make_shared<QueryOrderIdByPayIdResponseBodyLmOrderIds>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderIdByPayIdResponseBody() = default;
};
class QueryOrderIdByPayIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderIdByPayIdResponseBody> body{};

  QueryOrderIdByPayIdResponse() {}

  explicit QueryOrderIdByPayIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderIdByPayIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderIdByPayIdResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderIdByPayIdResponse() = default;
};
class QueryOrderInfoAfterSaleRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> channelUserId{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderInfoAfterSaleRequest() {}

  explicit QueryOrderInfoAfterSaleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (channelUserId) {
      res["ChannelUserId"] = boost::any(*channelUserId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ChannelUserId") != m.end() && !m["ChannelUserId"].empty()) {
      channelUserId = make_shared<string>(boost::any_cast<string>(m["ChannelUserId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderInfoAfterSaleRequest() = default;
};
class QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics : public Darabonba::Model {
public:
  shared_ptr<string> logisticsCompanyCode{};
  shared_ptr<string> logisticsCompanyName{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> logisticsStatus{};

  QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics() {}

  explicit QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logisticsCompanyCode) {
      res["LogisticsCompanyCode"] = boost::any(*logisticsCompanyCode);
    }
    if (logisticsCompanyName) {
      res["LogisticsCompanyName"] = boost::any(*logisticsCompanyName);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogisticsCompanyCode") != m.end() && !m["LogisticsCompanyCode"].empty()) {
      logisticsCompanyCode = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyCode"]));
    }
    if (m.find("LogisticsCompanyName") != m.end() && !m["LogisticsCompanyName"].empty()) {
      logisticsCompanyName = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyName"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<string>(boost::any_cast<string>(m["LogisticsStatus"]));
    }
  }


  virtual ~QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics() = default;
};
class QueryOrderInfoAfterSaleResponseBodyModelLogisticsList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics>> logistics{};

  QueryOrderInfoAfterSaleResponseBodyModelLogisticsList() {}

  explicit QueryOrderInfoAfterSaleResponseBodyModelLogisticsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logistics) {
      vector<boost::any> temp1;
      for(auto item1:*logistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logistics") != m.end() && !m["Logistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Logistics"].type()) {
        vector<QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logistics = make_shared<vector<QueryOrderInfoAfterSaleResponseBodyModelLogisticsListLogistics>>(expect1);
      }
    }
  }


  virtual ~QueryOrderInfoAfterSaleResponseBodyModelLogisticsList() = default;
};
class QueryOrderInfoAfterSaleResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> cashAmount{};
  shared_ptr<string> createDate{};
  shared_ptr<string> extJson{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<QueryOrderInfoAfterSaleResponseBodyModelLogisticsList> logisticsList{};
  shared_ptr<string> orderStatus{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> refundAmount{};
  shared_ptr<long> refundPoints{};
  shared_ptr<string> refundRate{};
  shared_ptr<string> refundStatus{};
  shared_ptr<string> shopName{};
  shared_ptr<string> shopServiceTelephone{};
  shared_ptr<long> tbOrderId{};
  shared_ptr<string> xiaomiCode{};

  QueryOrderInfoAfterSaleResponseBodyModel() {}

  explicit QueryOrderInfoAfterSaleResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cashAmount) {
      res["CashAmount"] = boost::any(*cashAmount);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (logisticsList) {
      res["LogisticsList"] = logisticsList ? boost::any(logisticsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (refundAmount) {
      res["RefundAmount"] = boost::any(*refundAmount);
    }
    if (refundPoints) {
      res["RefundPoints"] = boost::any(*refundPoints);
    }
    if (refundRate) {
      res["RefundRate"] = boost::any(*refundRate);
    }
    if (refundStatus) {
      res["RefundStatus"] = boost::any(*refundStatus);
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (shopServiceTelephone) {
      res["ShopServiceTelephone"] = boost::any(*shopServiceTelephone);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    if (xiaomiCode) {
      res["XiaomiCode"] = boost::any(*xiaomiCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CashAmount") != m.end() && !m["CashAmount"].empty()) {
      cashAmount = make_shared<string>(boost::any_cast<string>(m["CashAmount"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LogisticsList") != m.end() && !m["LogisticsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogisticsList"].type()) {
        QueryOrderInfoAfterSaleResponseBodyModelLogisticsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogisticsList"]));
        logisticsList = make_shared<QueryOrderInfoAfterSaleResponseBodyModelLogisticsList>(model1);
      }
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<string>(boost::any_cast<string>(m["OrderStatus"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("RefundAmount") != m.end() && !m["RefundAmount"].empty()) {
      refundAmount = make_shared<long>(boost::any_cast<long>(m["RefundAmount"]));
    }
    if (m.find("RefundPoints") != m.end() && !m["RefundPoints"].empty()) {
      refundPoints = make_shared<long>(boost::any_cast<long>(m["RefundPoints"]));
    }
    if (m.find("RefundRate") != m.end() && !m["RefundRate"].empty()) {
      refundRate = make_shared<string>(boost::any_cast<string>(m["RefundRate"]));
    }
    if (m.find("RefundStatus") != m.end() && !m["RefundStatus"].empty()) {
      refundStatus = make_shared<string>(boost::any_cast<string>(m["RefundStatus"]));
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("ShopServiceTelephone") != m.end() && !m["ShopServiceTelephone"].empty()) {
      shopServiceTelephone = make_shared<string>(boost::any_cast<string>(m["ShopServiceTelephone"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
    if (m.find("XiaomiCode") != m.end() && !m["XiaomiCode"].empty()) {
      xiaomiCode = make_shared<string>(boost::any_cast<string>(m["XiaomiCode"]));
    }
  }


  virtual ~QueryOrderInfoAfterSaleResponseBodyModel() = default;
};
class QueryOrderInfoAfterSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryOrderInfoAfterSaleResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QueryOrderInfoAfterSaleResponseBody() {}

  explicit QueryOrderInfoAfterSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryOrderInfoAfterSaleResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryOrderInfoAfterSaleResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderInfoAfterSaleResponseBody() = default;
};
class QueryOrderInfoAfterSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderInfoAfterSaleResponseBody> body{};

  QueryOrderInfoAfterSaleResponse() {}

  explicit QueryOrderInfoAfterSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderInfoAfterSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderInfoAfterSaleResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderInfoAfterSaleResponse() = default;
};
class QueryOrderItemInfoByPaymentIdForAiZhanYouRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> paymentId{};

  QueryOrderItemInfoByPaymentIdForAiZhanYouRequest() {}

  explicit QueryOrderItemInfoByPaymentIdForAiZhanYouRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (paymentId) {
      res["PaymentId"] = boost::any(*paymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("PaymentId") != m.end() && !m["PaymentId"].empty()) {
      paymentId = make_shared<string>(boost::any_cast<string>(m["PaymentId"]));
    }
  }


  virtual ~QueryOrderItemInfoByPaymentIdForAiZhanYouRequest() = default;
};
class QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};

  QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList() {}

  explicit QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
  }


  virtual ~QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList() = default;
};
class QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList>> lmOrderList{};

  QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList() {}

  explicit QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList() = default;
};
class QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList> lmOrderList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody() {}

  explicit QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBodyLmOrderList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody() = default;
};
class QueryOrderItemInfoByPaymentIdForAiZhanYouResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody> body{};

  QueryOrderItemInfoByPaymentIdForAiZhanYouResponse() {}

  explicit QueryOrderItemInfoByPaymentIdForAiZhanYouResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderItemInfoByPaymentIdForAiZhanYouResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderItemInfoByPaymentIdForAiZhanYouResponse() = default;
};
class QueryOrderListRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> filterOption{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderListRequest() {}

  explicit QueryOrderListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (filterOption) {
      res["FilterOption"] = boost::any(*filterOption);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("FilterOption") != m.end() && !m["FilterOption"].empty()) {
      filterOption = make_shared<string>(boost::any_cast<string>(m["FilterOption"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderListRequest() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels>> fundStructureModels{};

  QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundStructureModels) {
      vector<boost::any> temp1;
      for(auto item1:*fundStructureModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FundStructureModels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FundStructureModels"].type()) {
        vector<QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FundStructureModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fundStructureModels = make_shared<vector<QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModelsFundStructureModels>>(expect1);
      }
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListResponseBodyLmOrderListLmOrderListPostFee() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListPostFee() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList>> itemPriceList{};

  QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*itemPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPriceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPriceList"].type()) {
        vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPriceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPriceList = make_shared<vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceListItemPriceList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList : public Darabonba::Model {
public:
  shared_ptr<long> enableStatus{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemPic{};
  shared_ptr<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList> itemPriceList{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> number{};
  shared_ptr<long> orderStatus{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<long> tbOrderId{};

  QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemPic) {
      res["ItemPic"] = boost::any(*itemPic);
    }
    if (itemPriceList) {
      res["ItemPriceList"] = itemPriceList ? boost::any(itemPriceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemPic") != m.end() && !m["ItemPic"].empty()) {
      itemPic = make_shared<string>(boost::any_cast<string>(m["ItemPic"]));
    }
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ItemPriceList"].type()) {
        QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ItemPriceList"]));
        itemPriceList = make_shared<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderListItemPriceList>(model1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList>> subOrderList{};

  QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*subOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubOrderList"].type()) {
        vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrderList = make_shared<vector<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderListSubOrderList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList() = default;
};
class QueryOrderListResponseBodyLmOrderListLmOrderList : public Darabonba::Model {
public:
  shared_ptr<string> createDate{};
  shared_ptr<long> enableStatus{};
  shared_ptr<string> extJson{};
  shared_ptr<QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels> fundStructureModels{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> logisticsStatus{};
  shared_ptr<long> orderAmount{};
  shared_ptr<long> orderStatus{};
  shared_ptr<QueryOrderListResponseBodyLmOrderListLmOrderListPostFee> postFee{};
  shared_ptr<string> shopName{};
  shared_ptr<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList> subOrderList{};
  shared_ptr<long> tbOrderId{};

  QueryOrderListResponseBodyLmOrderListLmOrderList() {}

  explicit QueryOrderListResponseBodyLmOrderListLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (fundStructureModels) {
      res["FundStructureModels"] = fundStructureModels ? boost::any(fundStructureModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    if (orderAmount) {
      res["OrderAmount"] = boost::any(*orderAmount);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (subOrderList) {
      res["SubOrderList"] = subOrderList ? boost::any(subOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FundStructureModels"].type()) {
        QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FundStructureModels"]));
        fundStructureModels = make_shared<QueryOrderListResponseBodyLmOrderListLmOrderListFundStructureModels>(model1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<long>(boost::any_cast<long>(m["LogisticsStatus"]));
    }
    if (m.find("OrderAmount") != m.end() && !m["OrderAmount"].empty()) {
      orderAmount = make_shared<long>(boost::any_cast<long>(m["OrderAmount"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderListResponseBodyLmOrderListLmOrderListPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderListResponseBodyLmOrderListLmOrderListPostFee>(model1);
      }
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubOrderList"].type()) {
        QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubOrderList"]));
        subOrderList = make_shared<QueryOrderListResponseBodyLmOrderListLmOrderListSubOrderList>(model1);
      }
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderListLmOrderList() = default;
};
class QueryOrderListResponseBodyLmOrderList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderListResponseBodyLmOrderListLmOrderList>> lmOrderList{};

  QueryOrderListResponseBodyLmOrderList() {}

  explicit QueryOrderListResponseBodyLmOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*lmOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmOrderList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmOrderList"].type()) {
        vector<QueryOrderListResponseBodyLmOrderListLmOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListResponseBodyLmOrderListLmOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmOrderList = make_shared<vector<QueryOrderListResponseBodyLmOrderListLmOrderList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderListResponseBodyLmOrderList() = default;
};
class QueryOrderListResponseBodyPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListResponseBodyPostFee() {}

  explicit QueryOrderListResponseBodyPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListResponseBodyPostFee() = default;
};
class QueryOrderListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryOrderListResponseBodyLmOrderList> lmOrderList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<QueryOrderListResponseBodyPostFee> postFee{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryOrderListResponseBody() {}

  explicit QueryOrderListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmOrderList) {
      res["LmOrderList"] = lmOrderList ? boost::any(lmOrderList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmOrderList") != m.end() && !m["LmOrderList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmOrderList"].type()) {
        QueryOrderListResponseBodyLmOrderList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmOrderList"]));
        lmOrderList = make_shared<QueryOrderListResponseBodyLmOrderList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderListResponseBodyPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderListResponseBodyPostFee>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryOrderListResponseBody() = default;
};
class QueryOrderListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderListResponseBody> body{};

  QueryOrderListResponse() {}

  explicit QueryOrderListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderListResponse() = default;
};
class QueryOrderListWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> filterOption{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryOrderListWithDesignatedTbUidRequest() {}

  explicit QueryOrderListWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (filterOption) {
      res["FilterOption"] = boost::any(*filterOption);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("FilterOption") != m.end() && !m["FilterOption"].empty()) {
      filterOption = make_shared<string>(boost::any_cast<string>(m["FilterOption"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidRequest() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList : public Darabonba::Model {
public:
  shared_ptr<long> fundAmount{};
  shared_ptr<long> fundAmountMoney{};
  shared_ptr<string> fundType{};

  QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundAmount) {
      res["FundAmount"] = boost::any(*fundAmount);
    }
    if (fundAmountMoney) {
      res["FundAmountMoney"] = boost::any(*fundAmountMoney);
    }
    if (fundType) {
      res["FundType"] = boost::any(*fundType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundAmount") != m.end() && !m["FundAmount"].empty()) {
      fundAmount = make_shared<long>(boost::any_cast<long>(m["FundAmount"]));
    }
    if (m.find("FundAmountMoney") != m.end() && !m["FundAmountMoney"].empty()) {
      fundAmountMoney = make_shared<long>(boost::any_cast<long>(m["FundAmountMoney"]));
    }
    if (m.find("FundType") != m.end() && !m["FundType"].empty()) {
      fundType = make_shared<string>(boost::any_cast<string>(m["FundType"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList : public Darabonba::Model {
public:
  shared_ptr<long> enableStatus{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemPic{};
  shared_ptr<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList>> itemPriceList{};
  shared_ptr<string> itemTitle{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> number{};
  shared_ptr<long> orderStatus{};
  shared_ptr<string> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<long> tbOrderId{};

  QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemPic) {
      res["ItemPic"] = boost::any(*itemPic);
    }
    if (itemPriceList) {
      vector<boost::any> temp1;
      for(auto item1:*itemPriceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPriceList"] = boost::any(temp1);
    }
    if (itemTitle) {
      res["ItemTitle"] = boost::any(*itemTitle);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemPic") != m.end() && !m["ItemPic"].empty()) {
      itemPic = make_shared<string>(boost::any_cast<string>(m["ItemPic"]));
    }
    if (m.find("ItemPriceList") != m.end() && !m["ItemPriceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPriceList"].type()) {
        vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPriceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPriceList = make_shared<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderListItemPriceList>>(expect1);
      }
    }
    if (m.find("ItemTitle") != m.end() && !m["ItemTitle"].empty()) {
      itemTitle = make_shared<string>(boost::any_cast<string>(m["ItemTitle"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<string>(boost::any_cast<string>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> enableStatus{};
  shared_ptr<string> extJson{};
  shared_ptr<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels>> fundStructureModels{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<long> logisticsStatus{};
  shared_ptr<long> orderAmount{};
  shared_ptr<long> orderStatus{};
  shared_ptr<QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee> postFee{};
  shared_ptr<string> shopName{};
  shared_ptr<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList>> subOrderList{};
  shared_ptr<long> tbOrderId{};

  QueryOrderListWithDesignatedTbUidResponseBodyModel() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (fundStructureModels) {
      vector<boost::any> temp1;
      for(auto item1:*fundStructureModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FundStructureModels"] = boost::any(temp1);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (logisticsStatus) {
      res["LogisticsStatus"] = boost::any(*logisticsStatus);
    }
    if (orderAmount) {
      res["OrderAmount"] = boost::any(*orderAmount);
    }
    if (orderStatus) {
      res["OrderStatus"] = boost::any(*orderStatus);
    }
    if (postFee) {
      res["PostFee"] = postFee ? boost::any(postFee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (shopName) {
      res["ShopName"] = boost::any(*shopName);
    }
    if (subOrderList) {
      vector<boost::any> temp1;
      for(auto item1:*subOrderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubOrderList"] = boost::any(temp1);
    }
    if (tbOrderId) {
      res["TbOrderId"] = boost::any(*tbOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<long>(boost::any_cast<long>(m["EnableStatus"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("FundStructureModels") != m.end() && !m["FundStructureModels"].empty()) {
      if (typeid(vector<boost::any>) == m["FundStructureModels"].type()) {
        vector<QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FundStructureModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fundStructureModels = make_shared<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelFundStructureModels>>(expect1);
      }
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("LogisticsStatus") != m.end() && !m["LogisticsStatus"].empty()) {
      logisticsStatus = make_shared<long>(boost::any_cast<long>(m["LogisticsStatus"]));
    }
    if (m.find("OrderAmount") != m.end() && !m["OrderAmount"].empty()) {
      orderAmount = make_shared<long>(boost::any_cast<long>(m["OrderAmount"]));
    }
    if (m.find("OrderStatus") != m.end() && !m["OrderStatus"].empty()) {
      orderStatus = make_shared<long>(boost::any_cast<long>(m["OrderStatus"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostFee"].type()) {
        QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostFee"]));
        postFee = make_shared<QueryOrderListWithDesignatedTbUidResponseBodyModelPostFee>(model1);
      }
    }
    if (m.find("ShopName") != m.end() && !m["ShopName"].empty()) {
      shopName = make_shared<string>(boost::any_cast<string>(m["ShopName"]));
    }
    if (m.find("SubOrderList") != m.end() && !m["SubOrderList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubOrderList"].type()) {
        vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubOrderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subOrderList = make_shared<vector<QueryOrderListWithDesignatedTbUidResponseBodyModelSubOrderList>>(expect1);
      }
    }
    if (m.find("TbOrderId") != m.end() && !m["TbOrderId"].empty()) {
      tbOrderId = make_shared<long>(boost::any_cast<long>(m["TbOrderId"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBodyModel() = default;
};
class QueryOrderListWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryOrderListWithDesignatedTbUidResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryOrderListWithDesignatedTbUidResponseBody() {}

  explicit QueryOrderListWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryOrderListWithDesignatedTbUidResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderListWithDesignatedTbUidResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryOrderListWithDesignatedTbUidResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponseBody() = default;
};
class QueryOrderListWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderListWithDesignatedTbUidResponseBody> body{};

  QueryOrderListWithDesignatedTbUidResponse() {}

  explicit QueryOrderListWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderListWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderListWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderListWithDesignatedTbUidResponse() = default;
};
class QueryOrderLogisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryOrderLogisticsRequest() {}

  explicit QueryOrderLogisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryOrderLogisticsRequest() = default;
};
class QueryOrderLogisticsResponseBodyOrderLogisticsFetcher : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> name{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> zipCode{};

  QueryOrderLogisticsResponseBodyOrderLogisticsFetcher() {}

  explicit QueryOrderLogisticsResponseBodyOrderLogisticsFetcher(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (zipCode) {
      res["ZipCode"] = boost::any(*zipCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ZipCode") != m.end() && !m["ZipCode"].empty()) {
      zipCode = make_shared<string>(boost::any_cast<string>(m["ZipCode"]));
    }
  }


  virtual ~QueryOrderLogisticsResponseBodyOrderLogisticsFetcher() = default;
};
class QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList : public Darabonba::Model {
public:
  shared_ptr<string> ocurrTimeStr{};
  shared_ptr<string> standerdDesc{};
  shared_ptr<string> statusIcon{};

  QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList() {}

  explicit QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ocurrTimeStr) {
      res["OcurrTimeStr"] = boost::any(*ocurrTimeStr);
    }
    if (standerdDesc) {
      res["StanderdDesc"] = boost::any(*standerdDesc);
    }
    if (statusIcon) {
      res["StatusIcon"] = boost::any(*statusIcon);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OcurrTimeStr") != m.end() && !m["OcurrTimeStr"].empty()) {
      ocurrTimeStr = make_shared<string>(boost::any_cast<string>(m["OcurrTimeStr"]));
    }
    if (m.find("StanderdDesc") != m.end() && !m["StanderdDesc"].empty()) {
      standerdDesc = make_shared<string>(boost::any_cast<string>(m["StanderdDesc"]));
    }
    if (m.find("StatusIcon") != m.end() && !m["StatusIcon"].empty()) {
      statusIcon = make_shared<string>(boost::any_cast<string>(m["StatusIcon"]));
    }
  }


  virtual ~QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList() = default;
};
class QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList>> logisticsDetailList{};

  QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList() {}

  explicit QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logisticsDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*logisticsDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogisticsDetailList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogisticsDetailList") != m.end() && !m["LogisticsDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogisticsDetailList"].type()) {
        vector<QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogisticsDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logisticsDetailList = make_shared<vector<QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailListLogisticsDetailList>>(expect1);
      }
    }
  }


  virtual ~QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList() = default;
};
class QueryOrderLogisticsResponseBodyOrderLogisticsReceiver : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> name{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> zipCode{};

  QueryOrderLogisticsResponseBodyOrderLogisticsReceiver() {}

  explicit QueryOrderLogisticsResponseBodyOrderLogisticsReceiver(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (zipCode) {
      res["ZipCode"] = boost::any(*zipCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ZipCode") != m.end() && !m["ZipCode"].empty()) {
      zipCode = make_shared<string>(boost::any_cast<string>(m["ZipCode"]));
    }
  }


  virtual ~QueryOrderLogisticsResponseBodyOrderLogisticsReceiver() = default;
};
class QueryOrderLogisticsResponseBodyOrderLogistics : public Darabonba::Model {
public:
  shared_ptr<string> dataProvider{};
  shared_ptr<string> dataProviderTitle{};
  shared_ptr<QueryOrderLogisticsResponseBodyOrderLogisticsFetcher> fetcher{};
  shared_ptr<string> logisticsCompanyCode{};
  shared_ptr<string> logisticsCompanyName{};
  shared_ptr<QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList> logisticsDetailList{};
  shared_ptr<QueryOrderLogisticsResponseBodyOrderLogisticsReceiver> receiver{};

  QueryOrderLogisticsResponseBodyOrderLogistics() {}

  explicit QueryOrderLogisticsResponseBodyOrderLogistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataProvider) {
      res["DataProvider"] = boost::any(*dataProvider);
    }
    if (dataProviderTitle) {
      res["DataProviderTitle"] = boost::any(*dataProviderTitle);
    }
    if (fetcher) {
      res["Fetcher"] = fetcher ? boost::any(fetcher->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logisticsCompanyCode) {
      res["LogisticsCompanyCode"] = boost::any(*logisticsCompanyCode);
    }
    if (logisticsCompanyName) {
      res["LogisticsCompanyName"] = boost::any(*logisticsCompanyName);
    }
    if (logisticsDetailList) {
      res["LogisticsDetailList"] = logisticsDetailList ? boost::any(logisticsDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (receiver) {
      res["Receiver"] = receiver ? boost::any(receiver->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataProvider") != m.end() && !m["DataProvider"].empty()) {
      dataProvider = make_shared<string>(boost::any_cast<string>(m["DataProvider"]));
    }
    if (m.find("DataProviderTitle") != m.end() && !m["DataProviderTitle"].empty()) {
      dataProviderTitle = make_shared<string>(boost::any_cast<string>(m["DataProviderTitle"]));
    }
    if (m.find("Fetcher") != m.end() && !m["Fetcher"].empty()) {
      if (typeid(map<string, boost::any>) == m["Fetcher"].type()) {
        QueryOrderLogisticsResponseBodyOrderLogisticsFetcher model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Fetcher"]));
        fetcher = make_shared<QueryOrderLogisticsResponseBodyOrderLogisticsFetcher>(model1);
      }
    }
    if (m.find("LogisticsCompanyCode") != m.end() && !m["LogisticsCompanyCode"].empty()) {
      logisticsCompanyCode = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyCode"]));
    }
    if (m.find("LogisticsCompanyName") != m.end() && !m["LogisticsCompanyName"].empty()) {
      logisticsCompanyName = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyName"]));
    }
    if (m.find("LogisticsDetailList") != m.end() && !m["LogisticsDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogisticsDetailList"].type()) {
        QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogisticsDetailList"]));
        logisticsDetailList = make_shared<QueryOrderLogisticsResponseBodyOrderLogisticsLogisticsDetailList>(model1);
      }
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      if (typeid(map<string, boost::any>) == m["Receiver"].type()) {
        QueryOrderLogisticsResponseBodyOrderLogisticsReceiver model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Receiver"]));
        receiver = make_shared<QueryOrderLogisticsResponseBodyOrderLogisticsReceiver>(model1);
      }
    }
  }


  virtual ~QueryOrderLogisticsResponseBodyOrderLogistics() = default;
};
class QueryOrderLogisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryOrderLogisticsResponseBodyOrderLogistics> orderLogistics{};
  shared_ptr<string> requestId{};

  QueryOrderLogisticsResponseBody() {}

  explicit QueryOrderLogisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (orderLogistics) {
      res["OrderLogistics"] = orderLogistics ? boost::any(orderLogistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OrderLogistics") != m.end() && !m["OrderLogistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrderLogistics"].type()) {
        QueryOrderLogisticsResponseBodyOrderLogistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrderLogistics"]));
        orderLogistics = make_shared<QueryOrderLogisticsResponseBodyOrderLogistics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderLogisticsResponseBody() = default;
};
class QueryOrderLogisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderLogisticsResponseBody> body{};

  QueryOrderLogisticsResponse() {}

  explicit QueryOrderLogisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderLogisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderLogisticsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderLogisticsResponse() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryOrderLogisticsWithDesignatedTbUidRequest() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidRequest() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> name{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<string> zipCode{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zipCode) {
      res["ZipCode"] = boost::any(*zipCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ZipCode") != m.end() && !m["ZipCode"].empty()) {
      zipCode = make_shared<string>(boost::any_cast<string>(m["ZipCode"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList : public Darabonba::Model {
public:
  shared_ptr<string> ocurrTimeStr{};
  shared_ptr<string> requestId{};
  shared_ptr<string> standerdDesc{};
  shared_ptr<string> statusIcon{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ocurrTimeStr) {
      res["OcurrTimeStr"] = boost::any(*ocurrTimeStr);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standerdDesc) {
      res["StanderdDesc"] = boost::any(*standerdDesc);
    }
    if (statusIcon) {
      res["StatusIcon"] = boost::any(*statusIcon);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OcurrTimeStr") != m.end() && !m["OcurrTimeStr"].empty()) {
      ocurrTimeStr = make_shared<string>(boost::any_cast<string>(m["OcurrTimeStr"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StanderdDesc") != m.end() && !m["StanderdDesc"].empty()) {
      standerdDesc = make_shared<string>(boost::any_cast<string>(m["StanderdDesc"]));
    }
    if (m.find("StatusIcon") != m.end() && !m["StatusIcon"].empty()) {
      statusIcon = make_shared<string>(boost::any_cast<string>(m["StatusIcon"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> name{};
  shared_ptr<long> quantity{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> name{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<string> zipCode{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zipCode) {
      res["ZipCode"] = boost::any(*zipCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ZipCode") != m.end() && !m["ZipCode"].empty()) {
      zipCode = make_shared<string>(boost::any_cast<string>(m["ZipCode"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> dataProvider{};
  shared_ptr<string> dataProviderTitle{};
  shared_ptr<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher> fetcher{};
  shared_ptr<string> logisticsCompanyCode{};
  shared_ptr<string> logisticsCompanyName{};
  shared_ptr<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList>> logisticsDetailList{};
  shared_ptr<string> mailNo{};
  shared_ptr<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems>> packageGoodItems{};
  shared_ptr<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver> receiver{};
  shared_ptr<string> requestId{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataProvider) {
      res["DataProvider"] = boost::any(*dataProvider);
    }
    if (dataProviderTitle) {
      res["DataProviderTitle"] = boost::any(*dataProviderTitle);
    }
    if (fetcher) {
      res["Fetcher"] = fetcher ? boost::any(fetcher->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logisticsCompanyCode) {
      res["LogisticsCompanyCode"] = boost::any(*logisticsCompanyCode);
    }
    if (logisticsCompanyName) {
      res["LogisticsCompanyName"] = boost::any(*logisticsCompanyName);
    }
    if (logisticsDetailList) {
      vector<boost::any> temp1;
      for(auto item1:*logisticsDetailList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogisticsDetailList"] = boost::any(temp1);
    }
    if (mailNo) {
      res["MailNo"] = boost::any(*mailNo);
    }
    if (packageGoodItems) {
      vector<boost::any> temp1;
      for(auto item1:*packageGoodItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageGoodItems"] = boost::any(temp1);
    }
    if (receiver) {
      res["Receiver"] = receiver ? boost::any(receiver->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataProvider") != m.end() && !m["DataProvider"].empty()) {
      dataProvider = make_shared<string>(boost::any_cast<string>(m["DataProvider"]));
    }
    if (m.find("DataProviderTitle") != m.end() && !m["DataProviderTitle"].empty()) {
      dataProviderTitle = make_shared<string>(boost::any_cast<string>(m["DataProviderTitle"]));
    }
    if (m.find("Fetcher") != m.end() && !m["Fetcher"].empty()) {
      if (typeid(map<string, boost::any>) == m["Fetcher"].type()) {
        QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Fetcher"]));
        fetcher = make_shared<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelFetcher>(model1);
      }
    }
    if (m.find("LogisticsCompanyCode") != m.end() && !m["LogisticsCompanyCode"].empty()) {
      logisticsCompanyCode = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyCode"]));
    }
    if (m.find("LogisticsCompanyName") != m.end() && !m["LogisticsCompanyName"].empty()) {
      logisticsCompanyName = make_shared<string>(boost::any_cast<string>(m["LogisticsCompanyName"]));
    }
    if (m.find("LogisticsDetailList") != m.end() && !m["LogisticsDetailList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogisticsDetailList"].type()) {
        vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogisticsDetailList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logisticsDetailList = make_shared<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelLogisticsDetailList>>(expect1);
      }
    }
    if (m.find("MailNo") != m.end() && !m["MailNo"].empty()) {
      mailNo = make_shared<string>(boost::any_cast<string>(m["MailNo"]));
    }
    if (m.find("PackageGoodItems") != m.end() && !m["PackageGoodItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageGoodItems"].type()) {
        vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageGoodItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageGoodItems = make_shared<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelPackageGoodItems>>(expect1);
      }
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      if (typeid(map<string, boost::any>) == m["Receiver"].type()) {
        QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Receiver"]));
        receiver = make_shared<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModelReceiver>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel>> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryOrderLogisticsWithDesignatedTbUidResponseBody() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<QueryOrderLogisticsWithDesignatedTbUidResponseBodyModel>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponseBody() = default;
};
class QueryOrderLogisticsWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrderLogisticsWithDesignatedTbUidResponseBody> body{};

  QueryOrderLogisticsWithDesignatedTbUidResponse() {}

  explicit QueryOrderLogisticsWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrderLogisticsWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrderLogisticsWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrderLogisticsWithDesignatedTbUidResponse() = default;
};
class QueryRealTbAccountSupportRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};

  QueryRealTbAccountSupportRequest() {}

  explicit QueryRealTbAccountSupportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
  }


  virtual ~QueryRealTbAccountSupportRequest() = default;
};
class QueryRealTbAccountSupportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<bool> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryRealTbAccountSupportResponseBody() {}

  explicit QueryRealTbAccountSupportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<bool>(boost::any_cast<bool>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryRealTbAccountSupportResponseBody() = default;
};
class QueryRealTbAccountSupportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRealTbAccountSupportResponseBody> body{};

  QueryRealTbAccountSupportResponse() {}

  explicit QueryRealTbAccountSupportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRealTbAccountSupportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRealTbAccountSupportResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRealTbAccountSupportResponse() = default;
};
class QueryRefundApplicationDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  QueryRefundApplicationDetailRequest() {}

  explicit QueryRefundApplicationDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~QueryRefundApplicationDetailRequest() = default;
};
class QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText : public Darabonba::Model {
public:
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};

  QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText() {}

  explicit QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
  }


  virtual ~QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText() = default;
};
class QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData() {}

  explicit QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData() = default;
};
class QueryRefundApplicationDetailResponseBodyRefundApplicationDetail : public Darabonba::Model {
public:
  shared_ptr<string> applyDisputeDesc{};
  shared_ptr<QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText> applyReasonText{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> disputeCreateTime{};
  shared_ptr<string> disputeDesc{};
  shared_ptr<string> disputeEndTime{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<long> orderLogisticsStatus{};
  shared_ptr<long> realRefundFee{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> refunderAddress{};
  shared_ptr<string> refunderName{};
  shared_ptr<string> refunderTel{};
  shared_ptr<string> refunderZipCode{};
  shared_ptr<long> returnGoodCount{};
  shared_ptr<long> returnGoodLogisticsStatus{};
  shared_ptr<string> sellerAgreeMsg{};
  shared_ptr<string> sellerRefuseAgreementMessage{};
  shared_ptr<string> sellerRefuseReason{};
  shared_ptr<string> subLmOrderId{};

  QueryRefundApplicationDetailResponseBodyRefundApplicationDetail() {}

  explicit QueryRefundApplicationDetailResponseBodyRefundApplicationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDisputeDesc) {
      res["ApplyDisputeDesc"] = boost::any(*applyDisputeDesc);
    }
    if (applyReasonText) {
      res["ApplyReasonText"] = applyReasonText ? boost::any(applyReasonText->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (disputeCreateTime) {
      res["DisputeCreateTime"] = boost::any(*disputeCreateTime);
    }
    if (disputeDesc) {
      res["DisputeDesc"] = boost::any(*disputeDesc);
    }
    if (disputeEndTime) {
      res["DisputeEndTime"] = boost::any(*disputeEndTime);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderLogisticsStatus) {
      res["OrderLogisticsStatus"] = boost::any(*orderLogisticsStatus);
    }
    if (realRefundFee) {
      res["RealRefundFee"] = boost::any(*realRefundFee);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (refunderAddress) {
      res["RefunderAddress"] = boost::any(*refunderAddress);
    }
    if (refunderName) {
      res["RefunderName"] = boost::any(*refunderName);
    }
    if (refunderTel) {
      res["RefunderTel"] = boost::any(*refunderTel);
    }
    if (refunderZipCode) {
      res["RefunderZipCode"] = boost::any(*refunderZipCode);
    }
    if (returnGoodCount) {
      res["ReturnGoodCount"] = boost::any(*returnGoodCount);
    }
    if (returnGoodLogisticsStatus) {
      res["ReturnGoodLogisticsStatus"] = boost::any(*returnGoodLogisticsStatus);
    }
    if (sellerAgreeMsg) {
      res["SellerAgreeMsg"] = boost::any(*sellerAgreeMsg);
    }
    if (sellerRefuseAgreementMessage) {
      res["SellerRefuseAgreementMessage"] = boost::any(*sellerRefuseAgreementMessage);
    }
    if (sellerRefuseReason) {
      res["SellerRefuseReason"] = boost::any(*sellerRefuseReason);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDisputeDesc") != m.end() && !m["ApplyDisputeDesc"].empty()) {
      applyDisputeDesc = make_shared<string>(boost::any_cast<string>(m["ApplyDisputeDesc"]));
    }
    if (m.find("ApplyReasonText") != m.end() && !m["ApplyReasonText"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyReasonText"].type()) {
        QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyReasonText"]));
        applyReasonText = make_shared<QueryRefundApplicationDetailResponseBodyRefundApplicationDetailApplyReasonText>(model1);
      }
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("DisputeCreateTime") != m.end() && !m["DisputeCreateTime"].empty()) {
      disputeCreateTime = make_shared<string>(boost::any_cast<string>(m["DisputeCreateTime"]));
    }
    if (m.find("DisputeDesc") != m.end() && !m["DisputeDesc"].empty()) {
      disputeDesc = make_shared<string>(boost::any_cast<string>(m["DisputeDesc"]));
    }
    if (m.find("DisputeEndTime") != m.end() && !m["DisputeEndTime"].empty()) {
      disputeEndTime = make_shared<string>(boost::any_cast<string>(m["DisputeEndTime"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<QueryRefundApplicationDetailResponseBodyRefundApplicationDetailMaxRefundFeeData>(model1);
      }
    }
    if (m.find("OrderLogisticsStatus") != m.end() && !m["OrderLogisticsStatus"].empty()) {
      orderLogisticsStatus = make_shared<long>(boost::any_cast<long>(m["OrderLogisticsStatus"]));
    }
    if (m.find("RealRefundFee") != m.end() && !m["RealRefundFee"].empty()) {
      realRefundFee = make_shared<long>(boost::any_cast<long>(m["RealRefundFee"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("RefunderAddress") != m.end() && !m["RefunderAddress"].empty()) {
      refunderAddress = make_shared<string>(boost::any_cast<string>(m["RefunderAddress"]));
    }
    if (m.find("RefunderName") != m.end() && !m["RefunderName"].empty()) {
      refunderName = make_shared<string>(boost::any_cast<string>(m["RefunderName"]));
    }
    if (m.find("RefunderTel") != m.end() && !m["RefunderTel"].empty()) {
      refunderTel = make_shared<string>(boost::any_cast<string>(m["RefunderTel"]));
    }
    if (m.find("RefunderZipCode") != m.end() && !m["RefunderZipCode"].empty()) {
      refunderZipCode = make_shared<string>(boost::any_cast<string>(m["RefunderZipCode"]));
    }
    if (m.find("ReturnGoodCount") != m.end() && !m["ReturnGoodCount"].empty()) {
      returnGoodCount = make_shared<long>(boost::any_cast<long>(m["ReturnGoodCount"]));
    }
    if (m.find("ReturnGoodLogisticsStatus") != m.end() && !m["ReturnGoodLogisticsStatus"].empty()) {
      returnGoodLogisticsStatus = make_shared<long>(boost::any_cast<long>(m["ReturnGoodLogisticsStatus"]));
    }
    if (m.find("SellerAgreeMsg") != m.end() && !m["SellerAgreeMsg"].empty()) {
      sellerAgreeMsg = make_shared<string>(boost::any_cast<string>(m["SellerAgreeMsg"]));
    }
    if (m.find("SellerRefuseAgreementMessage") != m.end() && !m["SellerRefuseAgreementMessage"].empty()) {
      sellerRefuseAgreementMessage = make_shared<string>(boost::any_cast<string>(m["SellerRefuseAgreementMessage"]));
    }
    if (m.find("SellerRefuseReason") != m.end() && !m["SellerRefuseReason"].empty()) {
      sellerRefuseReason = make_shared<string>(boost::any_cast<string>(m["SellerRefuseReason"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~QueryRefundApplicationDetailResponseBodyRefundApplicationDetail() = default;
};
class QueryRefundApplicationDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryRefundApplicationDetailResponseBodyRefundApplicationDetail> refundApplicationDetail{};
  shared_ptr<string> requestId{};

  QueryRefundApplicationDetailResponseBody() {}

  explicit QueryRefundApplicationDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (refundApplicationDetail) {
      res["RefundApplicationDetail"] = refundApplicationDetail ? boost::any(refundApplicationDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RefundApplicationDetail") != m.end() && !m["RefundApplicationDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundApplicationDetail"].type()) {
        QueryRefundApplicationDetailResponseBodyRefundApplicationDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundApplicationDetail"]));
        refundApplicationDetail = make_shared<QueryRefundApplicationDetailResponseBodyRefundApplicationDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryRefundApplicationDetailResponseBody() = default;
};
class QueryRefundApplicationDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRefundApplicationDetailResponseBody> body{};

  QueryRefundApplicationDetailResponse() {}

  explicit QueryRefundApplicationDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRefundApplicationDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRefundApplicationDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRefundApplicationDetailResponse() = default;
};
class QueryRefundApplyWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryRefundApplyWithDesignatedTbUidRequest() {}

  explicit QueryRefundApplyWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidRequest() = default;
};
class QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText : public Darabonba::Model {
public:
  shared_ptr<bool> proofRequired{};
  shared_ptr<long> reasonTextId{};
  shared_ptr<string> reasonTips{};
  shared_ptr<bool> refundDescRequired{};

  QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText() {}

  explicit QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (proofRequired) {
      res["ProofRequired"] = boost::any(*proofRequired);
    }
    if (reasonTextId) {
      res["ReasonTextId"] = boost::any(*reasonTextId);
    }
    if (reasonTips) {
      res["ReasonTips"] = boost::any(*reasonTips);
    }
    if (refundDescRequired) {
      res["RefundDescRequired"] = boost::any(*refundDescRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProofRequired") != m.end() && !m["ProofRequired"].empty()) {
      proofRequired = make_shared<bool>(boost::any_cast<bool>(m["ProofRequired"]));
    }
    if (m.find("ReasonTextId") != m.end() && !m["ReasonTextId"].empty()) {
      reasonTextId = make_shared<long>(boost::any_cast<long>(m["ReasonTextId"]));
    }
    if (m.find("ReasonTips") != m.end() && !m["ReasonTips"].empty()) {
      reasonTips = make_shared<string>(boost::any_cast<string>(m["ReasonTips"]));
    }
    if (m.find("RefundDescRequired") != m.end() && !m["RefundDescRequired"].empty()) {
      refundDescRequired = make_shared<bool>(boost::any_cast<bool>(m["RefundDescRequired"]));
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText() = default;
};
class QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData : public Darabonba::Model {
public:
  shared_ptr<long> maxRefundFee{};
  shared_ptr<long> minRefundFee{};

  QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() {}

  explicit QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxRefundFee) {
      res["MaxRefundFee"] = boost::any(*maxRefundFee);
    }
    if (minRefundFee) {
      res["MinRefundFee"] = boost::any(*minRefundFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxRefundFee") != m.end() && !m["MaxRefundFee"].empty()) {
      maxRefundFee = make_shared<long>(boost::any_cast<long>(m["MaxRefundFee"]));
    }
    if (m.find("MinRefundFee") != m.end() && !m["MinRefundFee"].empty()) {
      minRefundFee = make_shared<long>(boost::any_cast<long>(m["MinRefundFee"]));
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData() = default;
};
class QueryRefundApplyWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> applyDisputeDesc{};
  shared_ptr<QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText> applyReasonText{};
  shared_ptr<long> bizClaimType{};
  shared_ptr<string> disputeCreateTime{};
  shared_ptr<string> disputeDesc{};
  shared_ptr<string> disputeEndTime{};
  shared_ptr<long> disputeId{};
  shared_ptr<long> disputeStatus{};
  shared_ptr<long> disputeType{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData> maxRefundFeeData{};
  shared_ptr<long> orderLogisticsStatus{};
  shared_ptr<long> realRefundFee{};
  shared_ptr<long> refundFee{};
  shared_ptr<string> refunderAddress{};
  shared_ptr<string> refunderName{};
  shared_ptr<string> refunderTel{};
  shared_ptr<string> refunderZipCode{};
  shared_ptr<long> returnGoodCount{};
  shared_ptr<long> returnGoodLogisticsStatus{};
  shared_ptr<string> sellerAgreeMsg{};
  shared_ptr<string> sellerRefuseAgreementMessage{};
  shared_ptr<string> sellerRefuseReason{};
  shared_ptr<string> subLmOrderId{};

  QueryRefundApplyWithDesignatedTbUidResponseBodyModel() {}

  explicit QueryRefundApplyWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyDisputeDesc) {
      res["ApplyDisputeDesc"] = boost::any(*applyDisputeDesc);
    }
    if (applyReasonText) {
      res["ApplyReasonText"] = applyReasonText ? boost::any(applyReasonText->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizClaimType) {
      res["BizClaimType"] = boost::any(*bizClaimType);
    }
    if (disputeCreateTime) {
      res["DisputeCreateTime"] = boost::any(*disputeCreateTime);
    }
    if (disputeDesc) {
      res["DisputeDesc"] = boost::any(*disputeDesc);
    }
    if (disputeEndTime) {
      res["DisputeEndTime"] = boost::any(*disputeEndTime);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (disputeStatus) {
      res["DisputeStatus"] = boost::any(*disputeStatus);
    }
    if (disputeType) {
      res["DisputeType"] = boost::any(*disputeType);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (maxRefundFeeData) {
      res["MaxRefundFeeData"] = maxRefundFeeData ? boost::any(maxRefundFeeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderLogisticsStatus) {
      res["OrderLogisticsStatus"] = boost::any(*orderLogisticsStatus);
    }
    if (realRefundFee) {
      res["RealRefundFee"] = boost::any(*realRefundFee);
    }
    if (refundFee) {
      res["RefundFee"] = boost::any(*refundFee);
    }
    if (refunderAddress) {
      res["RefunderAddress"] = boost::any(*refunderAddress);
    }
    if (refunderName) {
      res["RefunderName"] = boost::any(*refunderName);
    }
    if (refunderTel) {
      res["RefunderTel"] = boost::any(*refunderTel);
    }
    if (refunderZipCode) {
      res["RefunderZipCode"] = boost::any(*refunderZipCode);
    }
    if (returnGoodCount) {
      res["ReturnGoodCount"] = boost::any(*returnGoodCount);
    }
    if (returnGoodLogisticsStatus) {
      res["ReturnGoodLogisticsStatus"] = boost::any(*returnGoodLogisticsStatus);
    }
    if (sellerAgreeMsg) {
      res["SellerAgreeMsg"] = boost::any(*sellerAgreeMsg);
    }
    if (sellerRefuseAgreementMessage) {
      res["SellerRefuseAgreementMessage"] = boost::any(*sellerRefuseAgreementMessage);
    }
    if (sellerRefuseReason) {
      res["SellerRefuseReason"] = boost::any(*sellerRefuseReason);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyDisputeDesc") != m.end() && !m["ApplyDisputeDesc"].empty()) {
      applyDisputeDesc = make_shared<string>(boost::any_cast<string>(m["ApplyDisputeDesc"]));
    }
    if (m.find("ApplyReasonText") != m.end() && !m["ApplyReasonText"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyReasonText"].type()) {
        QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyReasonText"]));
        applyReasonText = make_shared<QueryRefundApplyWithDesignatedTbUidResponseBodyModelApplyReasonText>(model1);
      }
    }
    if (m.find("BizClaimType") != m.end() && !m["BizClaimType"].empty()) {
      bizClaimType = make_shared<long>(boost::any_cast<long>(m["BizClaimType"]));
    }
    if (m.find("DisputeCreateTime") != m.end() && !m["DisputeCreateTime"].empty()) {
      disputeCreateTime = make_shared<string>(boost::any_cast<string>(m["DisputeCreateTime"]));
    }
    if (m.find("DisputeDesc") != m.end() && !m["DisputeDesc"].empty()) {
      disputeDesc = make_shared<string>(boost::any_cast<string>(m["DisputeDesc"]));
    }
    if (m.find("DisputeEndTime") != m.end() && !m["DisputeEndTime"].empty()) {
      disputeEndTime = make_shared<string>(boost::any_cast<string>(m["DisputeEndTime"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("DisputeStatus") != m.end() && !m["DisputeStatus"].empty()) {
      disputeStatus = make_shared<long>(boost::any_cast<long>(m["DisputeStatus"]));
    }
    if (m.find("DisputeType") != m.end() && !m["DisputeType"].empty()) {
      disputeType = make_shared<long>(boost::any_cast<long>(m["DisputeType"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("MaxRefundFeeData") != m.end() && !m["MaxRefundFeeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaxRefundFeeData"].type()) {
        QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaxRefundFeeData"]));
        maxRefundFeeData = make_shared<QueryRefundApplyWithDesignatedTbUidResponseBodyModelMaxRefundFeeData>(model1);
      }
    }
    if (m.find("OrderLogisticsStatus") != m.end() && !m["OrderLogisticsStatus"].empty()) {
      orderLogisticsStatus = make_shared<long>(boost::any_cast<long>(m["OrderLogisticsStatus"]));
    }
    if (m.find("RealRefundFee") != m.end() && !m["RealRefundFee"].empty()) {
      realRefundFee = make_shared<long>(boost::any_cast<long>(m["RealRefundFee"]));
    }
    if (m.find("RefundFee") != m.end() && !m["RefundFee"].empty()) {
      refundFee = make_shared<long>(boost::any_cast<long>(m["RefundFee"]));
    }
    if (m.find("RefunderAddress") != m.end() && !m["RefunderAddress"].empty()) {
      refunderAddress = make_shared<string>(boost::any_cast<string>(m["RefunderAddress"]));
    }
    if (m.find("RefunderName") != m.end() && !m["RefunderName"].empty()) {
      refunderName = make_shared<string>(boost::any_cast<string>(m["RefunderName"]));
    }
    if (m.find("RefunderTel") != m.end() && !m["RefunderTel"].empty()) {
      refunderTel = make_shared<string>(boost::any_cast<string>(m["RefunderTel"]));
    }
    if (m.find("RefunderZipCode") != m.end() && !m["RefunderZipCode"].empty()) {
      refunderZipCode = make_shared<string>(boost::any_cast<string>(m["RefunderZipCode"]));
    }
    if (m.find("ReturnGoodCount") != m.end() && !m["ReturnGoodCount"].empty()) {
      returnGoodCount = make_shared<long>(boost::any_cast<long>(m["ReturnGoodCount"]));
    }
    if (m.find("ReturnGoodLogisticsStatus") != m.end() && !m["ReturnGoodLogisticsStatus"].empty()) {
      returnGoodLogisticsStatus = make_shared<long>(boost::any_cast<long>(m["ReturnGoodLogisticsStatus"]));
    }
    if (m.find("SellerAgreeMsg") != m.end() && !m["SellerAgreeMsg"].empty()) {
      sellerAgreeMsg = make_shared<string>(boost::any_cast<string>(m["SellerAgreeMsg"]));
    }
    if (m.find("SellerRefuseAgreementMessage") != m.end() && !m["SellerRefuseAgreementMessage"].empty()) {
      sellerRefuseAgreementMessage = make_shared<string>(boost::any_cast<string>(m["SellerRefuseAgreementMessage"]));
    }
    if (m.find("SellerRefuseReason") != m.end() && !m["SellerRefuseReason"].empty()) {
      sellerRefuseReason = make_shared<string>(boost::any_cast<string>(m["SellerRefuseReason"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidResponseBodyModel() = default;
};
class QueryRefundApplyWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryRefundApplyWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryRefundApplyWithDesignatedTbUidResponseBody() {}

  explicit QueryRefundApplyWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryRefundApplyWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryRefundApplyWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidResponseBody() = default;
};
class QueryRefundApplyWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRefundApplyWithDesignatedTbUidResponseBody> body{};

  QueryRefundApplyWithDesignatedTbUidResponse() {}

  explicit QueryRefundApplyWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRefundApplyWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRefundApplyWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRefundApplyWithDesignatedTbUidResponse() = default;
};
class QuerySellerLicenseRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> sellerId{};
  shared_ptr<string> tenantId{};

  QuerySellerLicenseRequest() {}

  explicit QuerySellerLicenseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["SellerId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~QuerySellerLicenseRequest() = default;
};
class QuerySellerLicenseResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> licenseUrl{};
  shared_ptr<string> sellerId{};

  QuerySellerLicenseResponseBodyModel() {}

  explicit QuerySellerLicenseResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (licenseUrl) {
      res["LicenseUrl"] = boost::any(*licenseUrl);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LicenseUrl") != m.end() && !m["LicenseUrl"].empty()) {
      licenseUrl = make_shared<string>(boost::any_cast<string>(m["LicenseUrl"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["SellerId"]));
    }
  }


  virtual ~QuerySellerLicenseResponseBodyModel() = default;
};
class QuerySellerLicenseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QuerySellerLicenseResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QuerySellerLicenseResponseBody() {}

  explicit QuerySellerLicenseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QuerySellerLicenseResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QuerySellerLicenseResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySellerLicenseResponseBody() = default;
};
class QuerySellerLicenseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySellerLicenseResponseBody> body{};

  QuerySellerLicenseResponse() {}

  explicit QuerySellerLicenseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySellerLicenseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySellerLicenseResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySellerLicenseResponse() = default;
};
class QueryStatementsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> currency{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> payeeIds{};
  shared_ptr<string> settleNoes{};
  shared_ptr<string> settleStatus{};
  shared_ptr<string> settleType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  QueryStatementsRequest() {}

  explicit QueryStatementsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (payeeIds) {
      res["PayeeIds"] = boost::any(*payeeIds);
    }
    if (settleNoes) {
      res["SettleNoes"] = boost::any(*settleNoes);
    }
    if (settleStatus) {
      res["SettleStatus"] = boost::any(*settleStatus);
    }
    if (settleType) {
      res["SettleType"] = boost::any(*settleType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PayeeIds") != m.end() && !m["PayeeIds"].empty()) {
      payeeIds = make_shared<string>(boost::any_cast<string>(m["PayeeIds"]));
    }
    if (m.find("SettleNoes") != m.end() && !m["SettleNoes"].empty()) {
      settleNoes = make_shared<string>(boost::any_cast<string>(m["SettleNoes"]));
    }
    if (m.find("SettleStatus") != m.end() && !m["SettleStatus"].empty()) {
      settleStatus = make_shared<string>(boost::any_cast<string>(m["SettleStatus"]));
    }
    if (m.find("SettleType") != m.end() && !m["SettleType"].empty()) {
      settleType = make_shared<string>(boost::any_cast<string>(m["SettleType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~QueryStatementsRequest() = default;
};
class QueryStatementsResponseBodyModelStatementList : public Darabonba::Model {
public:
  shared_ptr<string> attributes{};
  shared_ptr<string> createDate{};
  shared_ptr<string> currency{};
  shared_ptr<string> endTime{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> kpNoGenerateTime{};
  shared_ptr<string> modifiedDate{};
  shared_ptr<string> payeeAccountId{};
  shared_ptr<string> payeeAccountName{};
  shared_ptr<string> payeeAccountNo{};
  shared_ptr<string> payeeId{};
  shared_ptr<string> payeeName{};
  shared_ptr<string> settleAmount{};
  shared_ptr<string> settleNo{};
  shared_ptr<string> settleStatus{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statusMessage{};
  shared_ptr<string> tenantId{};

  QueryStatementsResponseBodyModelStatementList() {}

  explicit QueryStatementsResponseBodyModelStatementList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (createDate) {
      res["CreateDate"] = boost::any(*createDate);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (kpNoGenerateTime) {
      res["KpNoGenerateTime"] = boost::any(*kpNoGenerateTime);
    }
    if (modifiedDate) {
      res["ModifiedDate"] = boost::any(*modifiedDate);
    }
    if (payeeAccountId) {
      res["PayeeAccountId"] = boost::any(*payeeAccountId);
    }
    if (payeeAccountName) {
      res["PayeeAccountName"] = boost::any(*payeeAccountName);
    }
    if (payeeAccountNo) {
      res["PayeeAccountNo"] = boost::any(*payeeAccountNo);
    }
    if (payeeId) {
      res["PayeeId"] = boost::any(*payeeId);
    }
    if (payeeName) {
      res["PayeeName"] = boost::any(*payeeName);
    }
    if (settleAmount) {
      res["SettleAmount"] = boost::any(*settleAmount);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    if (settleStatus) {
      res["SettleStatus"] = boost::any(*settleStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusMessage) {
      res["StatusMessage"] = boost::any(*statusMessage);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("CreateDate") != m.end() && !m["CreateDate"].empty()) {
      createDate = make_shared<string>(boost::any_cast<string>(m["CreateDate"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("KpNoGenerateTime") != m.end() && !m["KpNoGenerateTime"].empty()) {
      kpNoGenerateTime = make_shared<string>(boost::any_cast<string>(m["KpNoGenerateTime"]));
    }
    if (m.find("ModifiedDate") != m.end() && !m["ModifiedDate"].empty()) {
      modifiedDate = make_shared<string>(boost::any_cast<string>(m["ModifiedDate"]));
    }
    if (m.find("PayeeAccountId") != m.end() && !m["PayeeAccountId"].empty()) {
      payeeAccountId = make_shared<string>(boost::any_cast<string>(m["PayeeAccountId"]));
    }
    if (m.find("PayeeAccountName") != m.end() && !m["PayeeAccountName"].empty()) {
      payeeAccountName = make_shared<string>(boost::any_cast<string>(m["PayeeAccountName"]));
    }
    if (m.find("PayeeAccountNo") != m.end() && !m["PayeeAccountNo"].empty()) {
      payeeAccountNo = make_shared<string>(boost::any_cast<string>(m["PayeeAccountNo"]));
    }
    if (m.find("PayeeId") != m.end() && !m["PayeeId"].empty()) {
      payeeId = make_shared<string>(boost::any_cast<string>(m["PayeeId"]));
    }
    if (m.find("PayeeName") != m.end() && !m["PayeeName"].empty()) {
      payeeName = make_shared<string>(boost::any_cast<string>(m["PayeeName"]));
    }
    if (m.find("SettleAmount") != m.end() && !m["SettleAmount"].empty()) {
      settleAmount = make_shared<string>(boost::any_cast<string>(m["SettleAmount"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
    if (m.find("SettleStatus") != m.end() && !m["SettleStatus"].empty()) {
      settleStatus = make_shared<string>(boost::any_cast<string>(m["SettleStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StatusMessage") != m.end() && !m["StatusMessage"].empty()) {
      statusMessage = make_shared<string>(boost::any_cast<string>(m["StatusMessage"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~QueryStatementsResponseBodyModelStatementList() = default;
};
class QueryStatementsResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryStatementsResponseBodyModelStatementList>> statementList{};
  shared_ptr<long> totalCount{};

  QueryStatementsResponseBodyModel() {}

  explicit QueryStatementsResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statementList) {
      vector<boost::any> temp1;
      for(auto item1:*statementList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatementList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatementList") != m.end() && !m["StatementList"].empty()) {
      if (typeid(vector<boost::any>) == m["StatementList"].type()) {
        vector<QueryStatementsResponseBodyModelStatementList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatementList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryStatementsResponseBodyModelStatementList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statementList = make_shared<vector<QueryStatementsResponseBodyModelStatementList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryStatementsResponseBodyModel() = default;
};
class QueryStatementsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryStatementsResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryStatementsResponseBody() {}

  explicit QueryStatementsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryStatementsResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryStatementsResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryStatementsResponseBody() = default;
};
class QueryStatementsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStatementsResponseBody> body{};

  QueryStatementsResponse() {}

  explicit QueryStatementsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStatementsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStatementsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStatementsResponse() = default;
};
class QuerySupplierItemBillDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> billPeriod{};
  shared_ptr<string> billStatus{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizName{};
  shared_ptr<long> lmShopId{};
  shared_ptr<string> lmShopName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QuerySupplierItemBillDownloadUrlRequest() {}

  explicit QuerySupplierItemBillDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (billPeriod) {
      res["BillPeriod"] = boost::any(*billPeriod);
    }
    if (billStatus) {
      res["BillStatus"] = boost::any(*billStatus);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (lmShopName) {
      res["LmShopName"] = boost::any(*lmShopName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("BillPeriod") != m.end() && !m["BillPeriod"].empty()) {
      billPeriod = make_shared<string>(boost::any_cast<string>(m["BillPeriod"]));
    }
    if (m.find("BillStatus") != m.end() && !m["BillStatus"].empty()) {
      billStatus = make_shared<string>(boost::any_cast<string>(m["BillStatus"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("LmShopName") != m.end() && !m["LmShopName"].empty()) {
      lmShopName = make_shared<string>(boost::any_cast<string>(m["LmShopName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QuerySupplierItemBillDownloadUrlRequest() = default;
};
class QuerySupplierItemBillDownloadUrlResponseBodyModelData : public Darabonba::Model {
public:
  shared_ptr<string> billId{};
  shared_ptr<string> fileDownloadUrl{};
  shared_ptr<string> message{};

  QuerySupplierItemBillDownloadUrlResponseBodyModelData() {}

  explicit QuerySupplierItemBillDownloadUrlResponseBodyModelData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billId) {
      res["BillId"] = boost::any(*billId);
    }
    if (fileDownloadUrl) {
      res["FileDownloadUrl"] = boost::any(*fileDownloadUrl);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillId") != m.end() && !m["BillId"].empty()) {
      billId = make_shared<string>(boost::any_cast<string>(m["BillId"]));
    }
    if (m.find("FileDownloadUrl") != m.end() && !m["FileDownloadUrl"].empty()) {
      fileDownloadUrl = make_shared<string>(boost::any_cast<string>(m["FileDownloadUrl"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QuerySupplierItemBillDownloadUrlResponseBodyModelData() = default;
};
class QuerySupplierItemBillDownloadUrlResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySupplierItemBillDownloadUrlResponseBodyModelData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  QuerySupplierItemBillDownloadUrlResponseBodyModel() {}

  explicit QuerySupplierItemBillDownloadUrlResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QuerySupplierItemBillDownloadUrlResponseBodyModelData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySupplierItemBillDownloadUrlResponseBodyModelData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QuerySupplierItemBillDownloadUrlResponseBodyModelData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~QuerySupplierItemBillDownloadUrlResponseBodyModel() = default;
};
class QuerySupplierItemBillDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QuerySupplierItemBillDownloadUrlResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QuerySupplierItemBillDownloadUrlResponseBody() {}

  explicit QuerySupplierItemBillDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QuerySupplierItemBillDownloadUrlResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QuerySupplierItemBillDownloadUrlResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QuerySupplierItemBillDownloadUrlResponseBody() = default;
};
class QuerySupplierItemBillDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySupplierItemBillDownloadUrlResponseBody> body{};

  QuerySupplierItemBillDownloadUrlResponse() {}

  explicit QuerySupplierItemBillDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySupplierItemBillDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySupplierItemBillDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySupplierItemBillDownloadUrlResponse() = default;
};
class QueryUnfinishedActivitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryUnfinishedActivitiesRequest() {}

  explicit QueryUnfinishedActivitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryUnfinishedActivitiesRequest() = default;
};
class QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayDate{};
  shared_ptr<string> endDate{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> lmSessionId{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subBizCode{};

  QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel() {}

  explicit QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmSessionId) {
      res["LmSessionId"] = boost::any(*lmSessionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<string>(boost::any_cast<string>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmSessionId") != m.end() && !m["LmSessionId"].empty()) {
      lmSessionId = make_shared<long>(boost::any_cast<long>(m["LmSessionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel() = default;
};
class QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel>> lmActivitySessionModel{};

  QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels() {}

  explicit QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivitySessionModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivitySessionModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivitySessionModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivitySessionModel") != m.end() && !m["LmActivitySessionModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivitySessionModel"].type()) {
        vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivitySessionModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivitySessionModel = make_shared<vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModelsLmActivitySessionModel>>(expect1);
      }
    }
  }


  virtual ~QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels() = default;
};
class QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext : public Darabonba::Model {
public:
  shared_ptr<string> activityPicUrl{};
  shared_ptr<string> bizId{};
  shared_ptr<string> description{};
  shared_ptr<string> endDate{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels> lmActivitySessionModels{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};

  QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext() {}

  explicit QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityPicUrl) {
      res["ActivityPicUrl"] = boost::any(*activityPicUrl);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmActivitySessionModels) {
      res["LmActivitySessionModels"] = lmActivitySessionModels ? boost::any(lmActivitySessionModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityPicUrl") != m.end() && !m["ActivityPicUrl"].empty()) {
      activityPicUrl = make_shared<string>(boost::any_cast<string>(m["ActivityPicUrl"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmActivitySessionModels") != m.end() && !m["LmActivitySessionModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivitySessionModels"].type()) {
        QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivitySessionModels"]));
        lmActivitySessionModels = make_shared<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2ExtLmActivitySessionModels>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
  }


  virtual ~QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext() = default;
};
class QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext>> lmActivityModelV2Ext{};

  QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList() {}

  explicit QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivityModelV2Ext) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivityModelV2Ext){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivityModelV2Ext"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivityModelV2Ext") != m.end() && !m["LmActivityModelV2Ext"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivityModelV2Ext"].type()) {
        vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivityModelV2Ext"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivityModelV2Ext = make_shared<vector<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtListLmActivityModelV2Ext>>(expect1);
      }
    }
  }


  virtual ~QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList() = default;
};
class QueryUnfinishedActivitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList> lmActivityModelExtList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryUnfinishedActivitiesResponseBody() {}

  explicit QueryUnfinishedActivitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmActivityModelExtList) {
      res["LmActivityModelExtList"] = lmActivityModelExtList ? boost::any(lmActivityModelExtList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmActivityModelExtList") != m.end() && !m["LmActivityModelExtList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivityModelExtList"].type()) {
        QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivityModelExtList"]));
        lmActivityModelExtList = make_shared<QueryUnfinishedActivitiesResponseBodyLmActivityModelExtList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryUnfinishedActivitiesResponseBody() = default;
};
class QueryUnfinishedActivitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUnfinishedActivitiesResponseBody> body{};

  QueryUnfinishedActivitiesResponse() {}

  explicit QueryUnfinishedActivitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUnfinishedActivitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUnfinishedActivitiesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUnfinishedActivitiesResponse() = default;
};
class QueryUnfinishedSessionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> queryTime{};

  QueryUnfinishedSessionsRequest() {}

  explicit QueryUnfinishedSessionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<long>(boost::any_cast<long>(m["QueryTime"]));
    }
  }


  virtual ~QueryUnfinishedSessionsRequest() = default;
};
class QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayDate{};
  shared_ptr<string> endDate{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> lmSessionId{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subBizCode{};

  QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel() {}

  explicit QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmSessionId) {
      res["LmSessionId"] = boost::any(*lmSessionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<string>(boost::any_cast<string>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmSessionId") != m.end() && !m["LmSessionId"].empty()) {
      lmSessionId = make_shared<long>(boost::any_cast<long>(m["LmSessionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel() = default;
};
class QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel>> lmActivitySessionModel{};

  QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList() {}

  explicit QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivitySessionModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivitySessionModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivitySessionModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivitySessionModel") != m.end() && !m["LmActivitySessionModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivitySessionModel"].type()) {
        vector<QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivitySessionModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivitySessionModel = make_shared<vector<QueryUnfinishedSessionsResponseBodyLmActivitySessionModelListLmActivitySessionModel>>(expect1);
      }
    }
  }


  virtual ~QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList() = default;
};
class QueryUnfinishedSessionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList> lmActivitySessionModelList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryUnfinishedSessionsResponseBody() {}

  explicit QueryUnfinishedSessionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmActivitySessionModelList) {
      res["LmActivitySessionModelList"] = lmActivitySessionModelList ? boost::any(lmActivitySessionModelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmActivitySessionModelList") != m.end() && !m["LmActivitySessionModelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivitySessionModelList"].type()) {
        QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivitySessionModelList"]));
        lmActivitySessionModelList = make_shared<QueryUnfinishedSessionsResponseBodyLmActivitySessionModelList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryUnfinishedSessionsResponseBody() = default;
};
class QueryUnfinishedSessionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUnfinishedSessionsResponseBody> body{};

  QueryUnfinishedSessionsResponse() {}

  explicit QueryUnfinishedSessionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUnfinishedSessionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUnfinishedSessionsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUnfinishedSessionsResponse() = default;
};
class QueryUnfinishedSessions4ItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> itemIds{};
  shared_ptr<map<string, boost::any>> lmItemIds{};
  shared_ptr<long> queryTime{};

  QueryUnfinishedSessions4ItemsRequest() {}

  explicit QueryUnfinishedSessions4ItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lmItemIds) {
      res["LmItemIds"] = boost::any(*lmItemIds);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      itemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LmItemIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lmItemIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<long>(boost::any_cast<long>(m["QueryTime"]));
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsRequest() = default;
};
class QueryUnfinishedSessions4ItemsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemIdsShrink{};
  shared_ptr<string> lmItemIdsShrink{};
  shared_ptr<long> queryTime{};

  QueryUnfinishedSessions4ItemsShrinkRequest() {}

  explicit QueryUnfinishedSessions4ItemsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemIdsShrink) {
      res["ItemIds"] = boost::any(*itemIdsShrink);
    }
    if (lmItemIdsShrink) {
      res["LmItemIds"] = boost::any(*lmItemIdsShrink);
    }
    if (queryTime) {
      res["QueryTime"] = boost::any(*queryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      itemIdsShrink = make_shared<string>(boost::any_cast<string>(m["ItemIds"]));
    }
    if (m.find("LmItemIds") != m.end() && !m["LmItemIds"].empty()) {
      lmItemIdsShrink = make_shared<string>(boost::any_cast<string>(m["LmItemIds"]));
    }
    if (m.find("QueryTime") != m.end() && !m["QueryTime"].empty()) {
      queryTime = make_shared<long>(boost::any_cast<long>(m["QueryTime"]));
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsShrinkRequest() = default;
};
class QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayDate{};
  shared_ptr<string> endDate{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<long> lmActivityId{};
  shared_ptr<long> lmSessionId{};
  shared_ptr<string> name{};
  shared_ptr<string> startDate{};
  shared_ptr<string> subBizCode{};

  QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel() {}

  explicit QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayDate) {
      res["DisplayDate"] = boost::any(*displayDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmActivityId) {
      res["LmActivityId"] = boost::any(*lmActivityId);
    }
    if (lmSessionId) {
      res["LmSessionId"] = boost::any(*lmSessionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayDate") != m.end() && !m["DisplayDate"].empty()) {
      displayDate = make_shared<string>(boost::any_cast<string>(m["DisplayDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmActivityId") != m.end() && !m["LmActivityId"].empty()) {
      lmActivityId = make_shared<long>(boost::any_cast<long>(m["LmActivityId"]));
    }
    if (m.find("LmSessionId") != m.end() && !m["LmSessionId"].empty()) {
      lmSessionId = make_shared<long>(boost::any_cast<long>(m["LmSessionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel() = default;
};
class QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel>> lmActivitySessionModel{};

  QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels() {}

  explicit QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmActivitySessionModel) {
      vector<boost::any> temp1;
      for(auto item1:*lmActivitySessionModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmActivitySessionModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmActivitySessionModel") != m.end() && !m["LmActivitySessionModel"].empty()) {
      if (typeid(vector<boost::any>) == m["LmActivitySessionModel"].type()) {
        vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmActivitySessionModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmActivitySessionModel = make_shared<vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModelsLmActivitySessionModel>>(expect1);
      }
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels() = default;
};
class QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels> lmActivitySessionModels{};
  shared_ptr<string> lmItemId{};

  QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList() {}

  explicit QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmActivitySessionModels) {
      res["LmActivitySessionModels"] = lmActivitySessionModels ? boost::any(lmActivitySessionModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmActivitySessionModels") != m.end() && !m["LmActivitySessionModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmActivitySessionModels"].type()) {
        QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmActivitySessionModels"]));
        lmActivitySessionModels = make_shared<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelListLmActivitySessionModels>(model1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList() = default;
};
class QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList>> lmItemActivitySessionModelList{};

  QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList() {}

  explicit QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmItemActivitySessionModelList) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemActivitySessionModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemActivitySessionModelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmItemActivitySessionModelList") != m.end() && !m["LmItemActivitySessionModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemActivitySessionModelList"].type()) {
        vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemActivitySessionModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemActivitySessionModelList = make_shared<vector<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListListLmItemActivitySessionModelList>>(expect1);
      }
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList() = default;
};
class QueryUnfinishedSessions4ItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList> lmItemActivitySessionModelListList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  QueryUnfinishedSessions4ItemsResponseBody() {}

  explicit QueryUnfinishedSessions4ItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (lmItemActivitySessionModelListList) {
      res["LmItemActivitySessionModelListList"] = lmItemActivitySessionModelListList ? boost::any(lmItemActivitySessionModelListList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LmItemActivitySessionModelListList") != m.end() && !m["LmItemActivitySessionModelListList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmItemActivitySessionModelListList"].type()) {
        QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmItemActivitySessionModelListList"]));
        lmItemActivitySessionModelListList = make_shared<QueryUnfinishedSessions4ItemsResponseBodyLmItemActivitySessionModelListList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponseBody() = default;
};
class QueryUnfinishedSessions4ItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUnfinishedSessions4ItemsResponseBody> body{};

  QueryUnfinishedSessions4ItemsResponse() {}

  explicit QueryUnfinishedSessions4ItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUnfinishedSessions4ItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUnfinishedSessions4ItemsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUnfinishedSessions4ItemsResponse() = default;
};
class QueryUpcomingMoviesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> cityCode{};
  shared_ptr<map<string, boost::any>> extJson{};

  QueryUpcomingMoviesRequest() {}

  explicit QueryUpcomingMoviesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extJson = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~QueryUpcomingMoviesRequest() = default;
};
class QueryUpcomingMoviesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<long> cityCode{};
  shared_ptr<string> extJsonShrink{};

  QueryUpcomingMoviesShrinkRequest() {}

  explicit QueryUpcomingMoviesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cityCode) {
      res["CityCode"] = boost::any(*cityCode);
    }
    if (extJsonShrink) {
      res["ExtJson"] = boost::any(*extJsonShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CityCode") != m.end() && !m["CityCode"].empty()) {
      cityCode = make_shared<long>(boost::any_cast<long>(m["CityCode"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJsonShrink = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
  }


  virtual ~QueryUpcomingMoviesShrinkRequest() = default;
};
class QueryUpcomingMoviesResponseBodyMoviesMovie : public Darabonba::Model {
public:
  shared_ptr<string> backgroundPicture{};
  shared_ptr<string> country{};
  shared_ptr<string> description{};
  shared_ptr<string> director{};
  shared_ptr<long> duration{};
  shared_ptr<string> highlight{};
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<string> leadingRole{};
  shared_ptr<string> movieName{};
  shared_ptr<string> movieNameEn{};
  shared_ptr<string> movieTypeList{};
  shared_ptr<string> movieVersion{};
  shared_ptr<string> openDay{};
  shared_ptr<string> openTime{};
  shared_ptr<string> poster{};
  shared_ptr<string> remark{};
  shared_ptr<string> trailerList{};
  shared_ptr<string> type{};

  QueryUpcomingMoviesResponseBodyMoviesMovie() {}

  explicit QueryUpcomingMoviesResponseBodyMoviesMovie(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundPicture) {
      res["BackgroundPicture"] = boost::any(*backgroundPicture);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (director) {
      res["Director"] = boost::any(*director);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (highlight) {
      res["Highlight"] = boost::any(*highlight);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (leadingRole) {
      res["LeadingRole"] = boost::any(*leadingRole);
    }
    if (movieName) {
      res["MovieName"] = boost::any(*movieName);
    }
    if (movieNameEn) {
      res["MovieNameEn"] = boost::any(*movieNameEn);
    }
    if (movieTypeList) {
      res["MovieTypeList"] = boost::any(*movieTypeList);
    }
    if (movieVersion) {
      res["MovieVersion"] = boost::any(*movieVersion);
    }
    if (openDay) {
      res["OpenDay"] = boost::any(*openDay);
    }
    if (openTime) {
      res["OpenTime"] = boost::any(*openTime);
    }
    if (poster) {
      res["Poster"] = boost::any(*poster);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (trailerList) {
      res["TrailerList"] = boost::any(*trailerList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundPicture") != m.end() && !m["BackgroundPicture"].empty()) {
      backgroundPicture = make_shared<string>(boost::any_cast<string>(m["BackgroundPicture"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Director") != m.end() && !m["Director"].empty()) {
      director = make_shared<string>(boost::any_cast<string>(m["Director"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Highlight") != m.end() && !m["Highlight"].empty()) {
      highlight = make_shared<string>(boost::any_cast<string>(m["Highlight"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LeadingRole") != m.end() && !m["LeadingRole"].empty()) {
      leadingRole = make_shared<string>(boost::any_cast<string>(m["LeadingRole"]));
    }
    if (m.find("MovieName") != m.end() && !m["MovieName"].empty()) {
      movieName = make_shared<string>(boost::any_cast<string>(m["MovieName"]));
    }
    if (m.find("MovieNameEn") != m.end() && !m["MovieNameEn"].empty()) {
      movieNameEn = make_shared<string>(boost::any_cast<string>(m["MovieNameEn"]));
    }
    if (m.find("MovieTypeList") != m.end() && !m["MovieTypeList"].empty()) {
      movieTypeList = make_shared<string>(boost::any_cast<string>(m["MovieTypeList"]));
    }
    if (m.find("MovieVersion") != m.end() && !m["MovieVersion"].empty()) {
      movieVersion = make_shared<string>(boost::any_cast<string>(m["MovieVersion"]));
    }
    if (m.find("OpenDay") != m.end() && !m["OpenDay"].empty()) {
      openDay = make_shared<string>(boost::any_cast<string>(m["OpenDay"]));
    }
    if (m.find("OpenTime") != m.end() && !m["OpenTime"].empty()) {
      openTime = make_shared<string>(boost::any_cast<string>(m["OpenTime"]));
    }
    if (m.find("Poster") != m.end() && !m["Poster"].empty()) {
      poster = make_shared<string>(boost::any_cast<string>(m["Poster"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TrailerList") != m.end() && !m["TrailerList"].empty()) {
      trailerList = make_shared<string>(boost::any_cast<string>(m["TrailerList"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryUpcomingMoviesResponseBodyMoviesMovie() = default;
};
class QueryUpcomingMoviesResponseBodyMovies : public Darabonba::Model {
public:
  shared_ptr<vector<QueryUpcomingMoviesResponseBodyMoviesMovie>> movie{};

  QueryUpcomingMoviesResponseBodyMovies() {}

  explicit QueryUpcomingMoviesResponseBodyMovies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (movie) {
      vector<boost::any> temp1;
      for(auto item1:*movie){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Movie"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Movie") != m.end() && !m["Movie"].empty()) {
      if (typeid(vector<boost::any>) == m["Movie"].type()) {
        vector<QueryUpcomingMoviesResponseBodyMoviesMovie> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Movie"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryUpcomingMoviesResponseBodyMoviesMovie model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        movie = make_shared<vector<QueryUpcomingMoviesResponseBodyMoviesMovie>>(expect1);
      }
    }
  }


  virtual ~QueryUpcomingMoviesResponseBodyMovies() = default;
};
class QueryUpcomingMoviesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryUpcomingMoviesResponseBodyMovies> movies{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryUpcomingMoviesResponseBody() {}

  explicit QueryUpcomingMoviesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (movies) {
      res["Movies"] = movies ? boost::any(movies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Movies") != m.end() && !m["Movies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Movies"].type()) {
        QueryUpcomingMoviesResponseBodyMovies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Movies"]));
        movies = make_shared<QueryUpcomingMoviesResponseBodyMovies>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryUpcomingMoviesResponseBody() = default;
};
class QueryUpcomingMoviesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUpcomingMoviesResponseBody> body{};

  QueryUpcomingMoviesResponse() {}

  explicit QueryUpcomingMoviesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUpcomingMoviesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUpcomingMoviesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUpcomingMoviesResponse() = default;
};
class QueryUserAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryUserAccountRequest() {}

  explicit QueryUserAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryUserAccountRequest() = default;
};
class QueryUserAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> CUserId{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> lmUid{};
  shared_ptr<string> requestId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};

  QueryUserAccountResponseBodyModel() {}

  explicit QueryUserAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (CUserId) {
      res["CUserId"] = boost::any(*CUserId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmUid) {
      res["LmUid"] = boost::any(*lmUid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CUserId") != m.end() && !m["CUserId"].empty()) {
      CUserId = make_shared<string>(boost::any_cast<string>(m["CUserId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("LmUid") != m.end() && !m["LmUid"].empty()) {
      lmUid = make_shared<long>(boost::any_cast<long>(m["LmUid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
  }


  virtual ~QueryUserAccountResponseBodyModel() = default;
};
class QueryUserAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<QueryUserAccountResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  QueryUserAccountResponseBody() {}

  explicit QueryUserAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryUserAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryUserAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryUserAccountResponseBody() = default;
};
class QueryUserAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUserAccountResponseBody> body{};

  QueryUserAccountResponse() {}

  explicit QueryUserAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUserAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUserAccountResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUserAccountResponse() = default;
};
class QueryUserGameProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> processId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryUserGameProcessRequest() {}

  explicit QueryUserGameProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryUserGameProcessRequest() = default;
};
class QueryUserGameProcessShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> processId{};
  shared_ptr<string> thirdPartyUserId{};

  QueryUserGameProcessShrinkRequest() {}

  explicit QueryUserGameProcessShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryUserGameProcessShrinkRequest() = default;
};
class QueryUserGameProcessResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> currentShowContent{};
  shared_ptr<string> currentStepId{};
  shared_ptr<string> currentStepStatus{};
  shared_ptr<string> desc{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> processId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  QueryUserGameProcessResponseBodyModel() {}

  explicit QueryUserGameProcessResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentShowContent) {
      res["CurrentShowContent"] = boost::any(*currentShowContent);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (currentStepStatus) {
      res["CurrentStepStatus"] = boost::any(*currentStepStatus);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CurrentShowContent") != m.end() && !m["CurrentShowContent"].empty()) {
      currentShowContent = make_shared<string>(boost::any_cast<string>(m["CurrentShowContent"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("CurrentStepStatus") != m.end() && !m["CurrentStepStatus"].empty()) {
      currentStepStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStepStatus"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryUserGameProcessResponseBodyModel() = default;
};
class QueryUserGameProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryUserGameProcessResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QueryUserGameProcessResponseBody() {}

  explicit QueryUserGameProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryUserGameProcessResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryUserGameProcessResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryUserGameProcessResponseBody() = default;
};
class QueryUserGameProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUserGameProcessResponseBody> body{};

  QueryUserGameProcessResponse() {}

  explicit QueryUserGameProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUserGameProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUserGameProcessResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUserGameProcessResponse() = default;
};
class QueryUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> thirdPartyUserId{};

  QueryUserPointRequest() {}

  explicit QueryUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryUserPointRequest() = default;
};
class QueryUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> thirdPartyUserId{};

  QueryUserPointShrinkRequest() {}

  explicit QueryUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~QueryUserPointShrinkRequest() = default;
};
class QueryUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> createTime{};
  shared_ptr<long> currentAmount{};
  shared_ptr<long> frozenAmount{};
  shared_ptr<long> historyAmount{};
  shared_ptr<string> level{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> status{};

  QueryUserPointResponseBodyModel() {}

  explicit QueryUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentAmount) {
      res["CurrentAmount"] = boost::any(*currentAmount);
    }
    if (frozenAmount) {
      res["FrozenAmount"] = boost::any(*frozenAmount);
    }
    if (historyAmount) {
      res["HistoryAmount"] = boost::any(*historyAmount);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CurrentAmount") != m.end() && !m["CurrentAmount"].empty()) {
      currentAmount = make_shared<long>(boost::any_cast<long>(m["CurrentAmount"]));
    }
    if (m.find("FrozenAmount") != m.end() && !m["FrozenAmount"].empty()) {
      frozenAmount = make_shared<long>(boost::any_cast<long>(m["FrozenAmount"]));
    }
    if (m.find("HistoryAmount") != m.end() && !m["HistoryAmount"].empty()) {
      historyAmount = make_shared<long>(boost::any_cast<long>(m["HistoryAmount"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QueryUserPointResponseBodyModel() = default;
};
class QueryUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  QueryUserPointResponseBody() {}

  explicit QueryUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        QueryUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<QueryUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryUserPointResponseBody() = default;
};
class QueryUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryUserPointResponseBody> body{};

  QueryUserPointResponse() {}

  explicit QueryUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~QueryUserPointResponse() = default;
};
class QueryWithholdTradeRequest : public Darabonba::Model {
public:
  shared_ptr<string> merchantId{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> tradeNo{};

  QueryWithholdTradeRequest() {}

  explicit QueryWithholdTradeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~QueryWithholdTradeRequest() = default;
};
class QueryWithholdTradeResponseBodyQueryWithholdTradeResponse : public Darabonba::Model {
public:
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> paymentDate{};
  shared_ptr<string> settleStatus{};
  shared_ptr<string> totalAmount{};
  shared_ptr<string> tradeNo{};
  shared_ptr<string> tradeStatus{};

  QueryWithholdTradeResponseBodyQueryWithholdTradeResponse() {}

  explicit QueryWithholdTradeResponseBodyQueryWithholdTradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (paymentDate) {
      res["PaymentDate"] = boost::any(*paymentDate);
    }
    if (settleStatus) {
      res["SettleStatus"] = boost::any(*settleStatus);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    if (tradeStatus) {
      res["TradeStatus"] = boost::any(*tradeStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("PaymentDate") != m.end() && !m["PaymentDate"].empty()) {
      paymentDate = make_shared<string>(boost::any_cast<string>(m["PaymentDate"]));
    }
    if (m.find("SettleStatus") != m.end() && !m["SettleStatus"].empty()) {
      settleStatus = make_shared<string>(boost::any_cast<string>(m["SettleStatus"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<string>(boost::any_cast<string>(m["TotalAmount"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
    if (m.find("TradeStatus") != m.end() && !m["TradeStatus"].empty()) {
      tradeStatus = make_shared<string>(boost::any_cast<string>(m["TradeStatus"]));
    }
  }


  virtual ~QueryWithholdTradeResponseBodyQueryWithholdTradeResponse() = default;
};
class QueryWithholdTradeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<QueryWithholdTradeResponseBodyQueryWithholdTradeResponse> queryWithholdTradeResponse{};
  shared_ptr<string> requestId{};

  QueryWithholdTradeResponseBody() {}

  explicit QueryWithholdTradeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (queryWithholdTradeResponse) {
      res["QueryWithholdTradeResponse"] = queryWithholdTradeResponse ? boost::any(queryWithholdTradeResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("QueryWithholdTradeResponse") != m.end() && !m["QueryWithholdTradeResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["QueryWithholdTradeResponse"].type()) {
        QueryWithholdTradeResponseBodyQueryWithholdTradeResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QueryWithholdTradeResponse"]));
        queryWithholdTradeResponse = make_shared<QueryWithholdTradeResponseBodyQueryWithholdTradeResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryWithholdTradeResponseBody() = default;
};
class QueryWithholdTradeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryWithholdTradeResponseBody> body{};

  QueryWithholdTradeResponse() {}

  explicit QueryWithholdTradeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryWithholdTradeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryWithholdTradeResponseBody>(model1);
      }
    }
  }


  virtual ~QueryWithholdTradeResponse() = default;
};
class RebindTbAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  RebindTbAccountRequest() {}

  explicit RebindTbAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RebindTbAccountRequest() = default;
};
class RebindTbAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> CUserId{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> lmUid{};
  shared_ptr<string> requestId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};

  RebindTbAccountResponseBodyModel() {}

  explicit RebindTbAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (CUserId) {
      res["CUserId"] = boost::any(*CUserId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmUid) {
      res["LmUid"] = boost::any(*lmUid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CUserId") != m.end() && !m["CUserId"].empty()) {
      CUserId = make_shared<string>(boost::any_cast<string>(m["CUserId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("LmUid") != m.end() && !m["LmUid"].empty()) {
      lmUid = make_shared<long>(boost::any_cast<long>(m["LmUid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
  }


  virtual ~RebindTbAccountResponseBodyModel() = default;
};
class RebindTbAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RebindTbAccountResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RebindTbAccountResponseBody() {}

  explicit RebindTbAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RebindTbAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RebindTbAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RebindTbAccountResponseBody() = default;
};
class RebindTbAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebindTbAccountResponseBody> body{};

  RebindTbAccountResponse() {}

  explicit RebindTbAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebindTbAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebindTbAccountResponseBody>(model1);
      }
    }
  }


  virtual ~RebindTbAccountResponse() = default;
};
class RefreshSettlementOrderAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> tenantId{};

  RefreshSettlementOrderAccountRequest() {}

  explicit RefreshSettlementOrderAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~RefreshSettlementOrderAccountRequest() = default;
};
class RefreshSettlementOrderAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountNo{};
  shared_ptr<string> message{};
  shared_ptr<string> result{};
  shared_ptr<string> settleNo{};

  RefreshSettlementOrderAccountResponseBodyModel() {}

  explicit RefreshSettlementOrderAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountNo) {
      res["AccountNo"] = boost::any(*accountNo);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (settleNo) {
      res["SettleNo"] = boost::any(*settleNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountNo") != m.end() && !m["AccountNo"].empty()) {
      accountNo = make_shared<string>(boost::any_cast<string>(m["AccountNo"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SettleNo") != m.end() && !m["SettleNo"].empty()) {
      settleNo = make_shared<string>(boost::any_cast<string>(m["SettleNo"]));
    }
  }


  virtual ~RefreshSettlementOrderAccountResponseBodyModel() = default;
};
class RefreshSettlementOrderAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<vector<RefreshSettlementOrderAccountResponseBodyModel>> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  RefreshSettlementOrderAccountResponseBody() {}

  explicit RefreshSettlementOrderAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      vector<boost::any> temp1;
      for(auto item1:*model){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Model"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(vector<boost::any>) == m["Model"].type()) {
        vector<RefreshSettlementOrderAccountResponseBodyModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Model"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RefreshSettlementOrderAccountResponseBodyModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        model = make_shared<vector<RefreshSettlementOrderAccountResponseBodyModel>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefreshSettlementOrderAccountResponseBody() = default;
};
class RefreshSettlementOrderAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshSettlementOrderAccountResponseBody> body{};

  RefreshSettlementOrderAccountResponse() {}

  explicit RefreshSettlementOrderAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshSettlementOrderAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshSettlementOrderAccountResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshSettlementOrderAccountResponse() = default;
};
class RefundOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> extInfo{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> refundAmount{};
  shared_ptr<string> refundReason{};
  shared_ptr<string> refundRoyaltyParameters{};
  shared_ptr<string> tradeNo{};

  RefundOrderRequest() {}

  explicit RefundOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (refundAmount) {
      res["RefundAmount"] = boost::any(*refundAmount);
    }
    if (refundReason) {
      res["RefundReason"] = boost::any(*refundReason);
    }
    if (refundRoyaltyParameters) {
      res["RefundRoyaltyParameters"] = boost::any(*refundRoyaltyParameters);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("RefundAmount") != m.end() && !m["RefundAmount"].empty()) {
      refundAmount = make_shared<string>(boost::any_cast<string>(m["RefundAmount"]));
    }
    if (m.find("RefundReason") != m.end() && !m["RefundReason"].empty()) {
      refundReason = make_shared<string>(boost::any_cast<string>(m["RefundReason"]));
    }
    if (m.find("RefundRoyaltyParameters") != m.end() && !m["RefundRoyaltyParameters"].empty()) {
      refundRoyaltyParameters = make_shared<string>(boost::any_cast<string>(m["RefundRoyaltyParameters"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~RefundOrderRequest() = default;
};
class RefundOrderResponseBodyRefundResponse : public Darabonba::Model {
public:
  shared_ptr<string> fundChange{};
  shared_ptr<string> gmtRefundPay{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> tradeNo{};

  RefundOrderResponseBodyRefundResponse() {}

  explicit RefundOrderResponseBodyRefundResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fundChange) {
      res["FundChange"] = boost::any(*fundChange);
    }
    if (gmtRefundPay) {
      res["GmtRefundPay"] = boost::any(*gmtRefundPay);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FundChange") != m.end() && !m["FundChange"].empty()) {
      fundChange = make_shared<string>(boost::any_cast<string>(m["FundChange"]));
    }
    if (m.find("GmtRefundPay") != m.end() && !m["GmtRefundPay"].empty()) {
      gmtRefundPay = make_shared<string>(boost::any_cast<string>(m["GmtRefundPay"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~RefundOrderResponseBodyRefundResponse() = default;
};
class RefundOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<RefundOrderResponseBodyRefundResponse> refundResponse{};
  shared_ptr<string> requestId{};

  RefundOrderResponseBody() {}

  explicit RefundOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (refundResponse) {
      res["RefundResponse"] = refundResponse ? boost::any(refundResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RefundResponse") != m.end() && !m["RefundResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["RefundResponse"].type()) {
        RefundOrderResponseBodyRefundResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RefundResponse"]));
        refundResponse = make_shared<RefundOrderResponseBodyRefundResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefundOrderResponseBody() = default;
};
class RefundOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefundOrderResponseBody> body{};

  RefundOrderResponse() {}

  explicit RefundOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefundOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefundOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RefundOrderResponse() = default;
};
class RefundPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> lmOrderId{};
  shared_ptr<string> reason{};
  shared_ptr<string> sellerId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RefundPointRequest() {}

  explicit RefundPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<string>(boost::any_cast<string>(m["LmOrderId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<string>(boost::any_cast<string>(m["SellerId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RefundPointRequest() = default;
};
class RefundPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RefundPointResponseBody() {}

  explicit RefundPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefundPointResponseBody() = default;
};
class RefundPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefundPointResponseBody> body{};

  RefundPointResponse() {}

  explicit RefundPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefundPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefundPointResponseBody>(model1);
      }
    }
  }


  virtual ~RefundPointResponse() = default;
};
class RefundUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> originRecordId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  RefundUserPointRequest() {}

  explicit RefundUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (originRecordId) {
      res["OriginRecordId"] = boost::any(*originRecordId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OriginRecordId") != m.end() && !m["OriginRecordId"].empty()) {
      originRecordId = make_shared<string>(boost::any_cast<string>(m["OriginRecordId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~RefundUserPointRequest() = default;
};
class RefundUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> originRecordId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  RefundUserPointShrinkRequest() {}

  explicit RefundUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (originRecordId) {
      res["OriginRecordId"] = boost::any(*originRecordId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OriginRecordId") != m.end() && !m["OriginRecordId"].empty()) {
      originRecordId = make_shared<string>(boost::any_cast<string>(m["OriginRecordId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~RefundUserPointShrinkRequest() = default;
};
class RefundUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  RefundUserPointResponseBodyModel() {}

  explicit RefundUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~RefundUserPointResponseBodyModel() = default;
};
class RefundUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<RefundUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  RefundUserPointResponseBody() {}

  explicit RefundUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RefundUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RefundUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefundUserPointResponseBody() = default;
};
class RefundUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefundUserPointResponseBody> body{};

  RefundUserPointResponse() {}

  explicit RefundUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefundUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefundUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~RefundUserPointResponse() = default;
};
class RefuseMerchantSyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<string> taskId{};
  shared_ptr<long> timeStamp{};

  RefuseMerchantSyncTaskRequest() {}

  explicit RefuseMerchantSyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~RefuseMerchantSyncTaskRequest() = default;
};
class RefuseMerchantSyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RefuseMerchantSyncTaskResponseBody() {}

  explicit RefuseMerchantSyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefuseMerchantSyncTaskResponseBody() = default;
};
class RefuseMerchantSyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefuseMerchantSyncTaskResponseBody> body{};

  RefuseMerchantSyncTaskResponse() {}

  explicit RefuseMerchantSyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefuseMerchantSyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefuseMerchantSyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~RefuseMerchantSyncTaskResponse() = default;
};
class RegistAnonymousTbAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};

  RegistAnonymousTbAccountRequest() {}

  explicit RegistAnonymousTbAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RegistAnonymousTbAccountRequest() = default;
};
class RegistAnonymousTbAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RegistAnonymousTbAccountResponseBody() {}

  explicit RegistAnonymousTbAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegistAnonymousTbAccountResponseBody() = default;
};
class RegistAnonymousTbAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegistAnonymousTbAccountResponseBody> body{};

  RegistAnonymousTbAccountResponse() {}

  explicit RegistAnonymousTbAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegistAnonymousTbAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegistAnonymousTbAccountResponseBody>(model1);
      }
    }
  }


  virtual ~RegistAnonymousTbAccountResponse() = default;
};
class RegisterSettleAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountChannel{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountNo{};
  shared_ptr<string> accountPayType{};
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> countryOrAreaCode{};
  shared_ptr<string> currency{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> idempotentId{};

  RegisterSettleAccountRequest() {}

  explicit RegisterSettleAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountChannel) {
      res["AccountChannel"] = boost::any(*accountChannel);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountNo) {
      res["AccountNo"] = boost::any(*accountNo);
    }
    if (accountPayType) {
      res["AccountPayType"] = boost::any(*accountPayType);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (countryOrAreaCode) {
      res["CountryOrAreaCode"] = boost::any(*countryOrAreaCode);
    }
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountChannel") != m.end() && !m["AccountChannel"].empty()) {
      accountChannel = make_shared<string>(boost::any_cast<string>(m["AccountChannel"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountNo") != m.end() && !m["AccountNo"].empty()) {
      accountNo = make_shared<string>(boost::any_cast<string>(m["AccountNo"]));
    }
    if (m.find("AccountPayType") != m.end() && !m["AccountPayType"].empty()) {
      accountPayType = make_shared<string>(boost::any_cast<string>(m["AccountPayType"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CountryOrAreaCode") != m.end() && !m["CountryOrAreaCode"].empty()) {
      countryOrAreaCode = make_shared<string>(boost::any_cast<string>(m["CountryOrAreaCode"]));
    }
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
  }


  virtual ~RegisterSettleAccountRequest() = default;
};
class RegisterSettleAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> accountNo{};
  shared_ptr<string> id{};

  RegisterSettleAccountResponseBodyModel() {}

  explicit RegisterSettleAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountNo) {
      res["AccountNo"] = boost::any(*accountNo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountNo") != m.end() && !m["AccountNo"].empty()) {
      accountNo = make_shared<string>(boost::any_cast<string>(m["AccountNo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~RegisterSettleAccountResponseBodyModel() = default;
};
class RegisterSettleAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RegisterSettleAccountResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  RegisterSettleAccountResponseBody() {}

  explicit RegisterSettleAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RegisterSettleAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RegisterSettleAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RegisterSettleAccountResponseBody() = default;
};
class RegisterSettleAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterSettleAccountResponseBody> body{};

  RegisterSettleAccountResponse() {}

  explicit RegisterSettleAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterSettleAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterSettleAccountResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterSettleAccountResponse() = default;
};
class RegisterUserAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  RegisterUserAccountRequest() {}

  explicit RegisterUserAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RegisterUserAccountRequest() = default;
};
class RegisterUserAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> CUserId{};
  shared_ptr<string> extInfo{};
  shared_ptr<long> lmUid{};
  shared_ptr<string> requestId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};

  RegisterUserAccountResponseBodyModel() {}

  explicit RegisterUserAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (CUserId) {
      res["CUserId"] = boost::any(*CUserId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmUid) {
      res["LmUid"] = boost::any(*lmUid);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CUserId") != m.end() && !m["CUserId"].empty()) {
      CUserId = make_shared<string>(boost::any_cast<string>(m["CUserId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("LmUid") != m.end() && !m["LmUid"].empty()) {
      lmUid = make_shared<long>(boost::any_cast<long>(m["LmUid"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
  }


  virtual ~RegisterUserAccountResponseBodyModel() = default;
};
class RegisterUserAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RegisterUserAccountResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RegisterUserAccountResponseBody() {}

  explicit RegisterUserAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RegisterUserAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RegisterUserAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RegisterUserAccountResponseBody() = default;
};
class RegisterUserAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterUserAccountResponseBody> body{};

  RegisterUserAccountResponse() {}

  explicit RegisterUserAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterUserAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterUserAccountResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterUserAccountResponse() = default;
};
class ReleaseMovieSeatRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> lockSeatApplyKey{};

  ReleaseMovieSeatRequest() {}

  explicit ReleaseMovieSeatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lockSeatApplyKey) {
      res["LockSeatApplyKey"] = boost::any(*lockSeatApplyKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LockSeatApplyKey") != m.end() && !m["LockSeatApplyKey"].empty()) {
      lockSeatApplyKey = make_shared<string>(boost::any_cast<string>(m["LockSeatApplyKey"]));
    }
  }


  virtual ~ReleaseMovieSeatRequest() = default;
};
class ReleaseMovieSeatResponseBodyActionResult : public Darabonba::Model {
public:
  shared_ptr<string> returnCode{};
  shared_ptr<string> returnMessage{};
  shared_ptr<string> returnValue{};

  ReleaseMovieSeatResponseBodyActionResult() {}

  explicit ReleaseMovieSeatResponseBodyActionResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (returnCode) {
      res["ReturnCode"] = boost::any(*returnCode);
    }
    if (returnMessage) {
      res["ReturnMessage"] = boost::any(*returnMessage);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReturnCode") != m.end() && !m["ReturnCode"].empty()) {
      returnCode = make_shared<string>(boost::any_cast<string>(m["ReturnCode"]));
    }
    if (m.find("ReturnMessage") != m.end() && !m["ReturnMessage"].empty()) {
      returnMessage = make_shared<string>(boost::any_cast<string>(m["ReturnMessage"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
  }


  virtual ~ReleaseMovieSeatResponseBodyActionResult() = default;
};
class ReleaseMovieSeatResponseBody : public Darabonba::Model {
public:
  shared_ptr<ReleaseMovieSeatResponseBodyActionResult> actionResult{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  ReleaseMovieSeatResponseBody() {}

  explicit ReleaseMovieSeatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionResult) {
      res["ActionResult"] = actionResult ? boost::any(actionResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionResult") != m.end() && !m["ActionResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionResult"].type()) {
        ReleaseMovieSeatResponseBodyActionResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionResult"]));
        actionResult = make_shared<ReleaseMovieSeatResponseBodyActionResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReleaseMovieSeatResponseBody() = default;
};
class ReleaseMovieSeatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseMovieSeatResponseBody> body{};

  ReleaseMovieSeatResponse() {}

  explicit ReleaseMovieSeatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseMovieSeatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseMovieSeatResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseMovieSeatResponse() = default;
};
class RemoveAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressInfo{};
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RemoveAddressRequest() {}

  explicit RemoveAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfo) {
      res["AddressInfo"] = boost::any(*addressInfo);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfo") != m.end() && !m["AddressInfo"].empty()) {
      addressInfo = make_shared<string>(boost::any_cast<string>(m["AddressInfo"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RemoveAddressRequest() = default;
};
class RemoveAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveAddressResponseBody() {}

  explicit RemoveAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAddressResponseBody() = default;
};
class RemoveAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAddressResponseBody> body{};

  RemoveAddressResponse() {}

  explicit RemoveAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAddressResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAddressResponse() = default;
};
class RemoveMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJson{};
  shared_ptr<string> messageIds{};

  RemoveMessagesRequest() {}

  explicit RemoveMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (messageIds) {
      res["MessageIds"] = boost::any(*messageIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("MessageIds") != m.end() && !m["MessageIds"].empty()) {
      messageIds = make_shared<string>(boost::any_cast<string>(m["MessageIds"]));
    }
  }


  virtual ~RemoveMessagesRequest() = default;
};
class RemoveMessagesResponseBodyActionResult : public Darabonba::Model {
public:
  shared_ptr<string> returnCode{};
  shared_ptr<string> returnMessage{};
  shared_ptr<string> returnValue{};

  RemoveMessagesResponseBodyActionResult() {}

  explicit RemoveMessagesResponseBodyActionResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (returnCode) {
      res["ReturnCode"] = boost::any(*returnCode);
    }
    if (returnMessage) {
      res["ReturnMessage"] = boost::any(*returnMessage);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReturnCode") != m.end() && !m["ReturnCode"].empty()) {
      returnCode = make_shared<string>(boost::any_cast<string>(m["ReturnCode"]));
    }
    if (m.find("ReturnMessage") != m.end() && !m["ReturnMessage"].empty()) {
      returnMessage = make_shared<string>(boost::any_cast<string>(m["ReturnMessage"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
  }


  virtual ~RemoveMessagesResponseBodyActionResult() = default;
};
class RemoveMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveMessagesResponseBodyActionResult> actionResult{};
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  RemoveMessagesResponseBody() {}

  explicit RemoveMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionResult) {
      res["ActionResult"] = actionResult ? boost::any(actionResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionResult") != m.end() && !m["ActionResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ActionResult"].type()) {
        RemoveMessagesResponseBodyActionResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ActionResult"]));
        actionResult = make_shared<RemoveMessagesResponseBodyActionResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveMessagesResponseBody() = default;
};
class RemoveMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveMessagesResponseBody> body{};

  RemoveMessagesResponse() {}

  explicit RemoveMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveMessagesResponse() = default;
};
class RenderH5OrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> buyOrderRequestModel{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RenderH5OrderRequest() {}

  explicit RenderH5OrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (buyOrderRequestModel) {
      res["BuyOrderRequestModel"] = boost::any(*buyOrderRequestModel);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("BuyOrderRequestModel") != m.end() && !m["BuyOrderRequestModel"].empty()) {
      buyOrderRequestModel = make_shared<string>(boost::any_cast<string>(m["BuyOrderRequestModel"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RenderH5OrderRequest() = default;
};
class RenderH5OrderResponseBodyModelAddressInfoList : public Darabonba::Model {
public:
  shared_ptr<string> addressDetail{};
  shared_ptr<long> addressId{};
  shared_ptr<bool> default_{};
  shared_ptr<string> divisionCode{};
  shared_ptr<string> receiver{};
  shared_ptr<string> receiverPhone{};

  RenderH5OrderResponseBodyModelAddressInfoList() {}

  explicit RenderH5OrderResponseBodyModelAddressInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressDetail) {
      res["AddressDetail"] = boost::any(*addressDetail);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (default_) {
      res["Default"] = boost::any(*default_);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (receiverPhone) {
      res["ReceiverPhone"] = boost::any(*receiverPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressDetail") != m.end() && !m["AddressDetail"].empty()) {
      addressDetail = make_shared<string>(boost::any_cast<string>(m["AddressDetail"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<long>(boost::any_cast<long>(m["AddressId"]));
    }
    if (m.find("Default") != m.end() && !m["Default"].empty()) {
      default_ = make_shared<bool>(boost::any_cast<bool>(m["Default"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("ReceiverPhone") != m.end() && !m["ReceiverPhone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["ReceiverPhone"]));
    }
  }


  virtual ~RenderH5OrderResponseBodyModelAddressInfoList() = default;
};
class RenderH5OrderResponseBodyModelDeliveryInfoList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<long> postFee{};
  shared_ptr<long> serviceType{};

  RenderH5OrderResponseBodyModelDeliveryInfoList() {}

  explicit RenderH5OrderResponseBodyModelDeliveryInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (postFee) {
      res["PostFee"] = boost::any(*postFee);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      postFee = make_shared<long>(boost::any_cast<long>(m["PostFee"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
  }


  virtual ~RenderH5OrderResponseBodyModelDeliveryInfoList() = default;
};
class RenderH5OrderResponseBodyModelInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> type{};

  RenderH5OrderResponseBodyModelInvoiceInfo() {}

  explicit RenderH5OrderResponseBodyModelInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RenderH5OrderResponseBodyModelInvoiceInfo() = default;
};
class RenderH5OrderResponseBodyModelLmItemInfoList : public Darabonba::Model {
public:
  shared_ptr<long> actualPrice{};
  shared_ptr<bool> canSell{};
  shared_ptr<long> cash{};
  shared_ptr<map<string, boost::any>> features{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemPicUrl{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> message{};
  shared_ptr<long> points{};
  shared_ptr<long> quantity{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<string> tbShopName{};
  shared_ptr<string> virtualItemType{};

  RenderH5OrderResponseBodyModelLmItemInfoList() {}

  explicit RenderH5OrderResponseBodyModelLmItemInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPrice) {
      res["ActualPrice"] = boost::any(*actualPrice);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (cash) {
      res["Cash"] = boost::any(*cash);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemPicUrl) {
      res["ItemPicUrl"] = boost::any(*itemPicUrl);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (virtualItemType) {
      res["VirtualItemType"] = boost::any(*virtualItemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualPrice") != m.end() && !m["ActualPrice"].empty()) {
      actualPrice = make_shared<long>(boost::any_cast<long>(m["ActualPrice"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("Cash") != m.end() && !m["Cash"].empty()) {
      cash = make_shared<long>(boost::any_cast<long>(m["Cash"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Features"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      features = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemPicUrl") != m.end() && !m["ItemPicUrl"].empty()) {
      itemPicUrl = make_shared<string>(boost::any_cast<string>(m["ItemPicUrl"]));
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("VirtualItemType") != m.end() && !m["VirtualItemType"].empty()) {
      virtualItemType = make_shared<string>(boost::any_cast<string>(m["VirtualItemType"]));
    }
  }


  virtual ~RenderH5OrderResponseBodyModelLmItemInfoList() = default;
};
class RenderH5OrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<RenderH5OrderResponseBodyModelAddressInfoList>> addressInfoList{};
  shared_ptr<long> buyerCurrentPoints{};
  shared_ptr<vector<RenderH5OrderResponseBodyModelDeliveryInfoList>> deliveryInfoList{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<RenderH5OrderResponseBodyModelInvoiceInfo> invoiceInfo{};
  shared_ptr<vector<RenderH5OrderResponseBodyModelLmItemInfoList>> lmItemInfoList{};

  RenderH5OrderResponseBodyModel() {}

  explicit RenderH5OrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*addressInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressInfoList"] = boost::any(temp1);
    }
    if (buyerCurrentPoints) {
      res["BuyerCurrentPoints"] = boost::any(*buyerCurrentPoints);
    }
    if (deliveryInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryInfoList"] = boost::any(temp1);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (invoiceInfo) {
      res["InvoiceInfo"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfoList") != m.end() && !m["AddressInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressInfoList"].type()) {
        vector<RenderH5OrderResponseBodyModelAddressInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderH5OrderResponseBodyModelAddressInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressInfoList = make_shared<vector<RenderH5OrderResponseBodyModelAddressInfoList>>(expect1);
      }
    }
    if (m.find("BuyerCurrentPoints") != m.end() && !m["BuyerCurrentPoints"].empty()) {
      buyerCurrentPoints = make_shared<long>(boost::any_cast<long>(m["BuyerCurrentPoints"]));
    }
    if (m.find("DeliveryInfoList") != m.end() && !m["DeliveryInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryInfoList"].type()) {
        vector<RenderH5OrderResponseBodyModelDeliveryInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderH5OrderResponseBodyModelDeliveryInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryInfoList = make_shared<vector<RenderH5OrderResponseBodyModelDeliveryInfoList>>(expect1);
      }
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InvoiceInfo") != m.end() && !m["InvoiceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvoiceInfo"].type()) {
        RenderH5OrderResponseBodyModelInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvoiceInfo"]));
        invoiceInfo = make_shared<RenderH5OrderResponseBodyModelInvoiceInfo>(model1);
      }
    }
    if (m.find("LmItemInfoList") != m.end() && !m["LmItemInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemInfoList"].type()) {
        vector<RenderH5OrderResponseBodyModelLmItemInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderH5OrderResponseBodyModelLmItemInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemInfoList = make_shared<vector<RenderH5OrderResponseBodyModelLmItemInfoList>>(expect1);
      }
    }
  }


  virtual ~RenderH5OrderResponseBodyModel() = default;
};
class RenderH5OrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RenderH5OrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RenderH5OrderResponseBody() {}

  explicit RenderH5OrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RenderH5OrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RenderH5OrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RenderH5OrderResponseBody() = default;
};
class RenderH5OrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenderH5OrderResponseBody> body{};

  RenderH5OrderResponse() {}

  explicit RenderH5OrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenderH5OrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenderH5OrderResponseBody>(model1);
      }
    }
  }


  virtual ~RenderH5OrderResponse() = default;
};
class RenderOrderRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  RenderOrderRequestItemList() {}

  explicit RenderOrderRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~RenderOrderRequestItemList() = default;
};
class RenderOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> extJson{};
  shared_ptr<vector<RenderOrderRequestItemList>> itemList{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RenderOrderRequest() {}

  explicit RenderOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<RenderOrderRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<RenderOrderRequestItemList>>(expect1);
      }
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RenderOrderRequest() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<long> postFee{};
  shared_ptr<long> serviceType{};

  RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (postFee) {
      res["PostFee"] = boost::any(*postFee);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      postFee = make_shared<long>(boost::any_cast<long>(m["PostFee"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos>> deliveryInfos{};

  RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryInfos") != m.end() && !m["DeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryInfos"].type()) {
        vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryInfos = make_shared<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfosDeliveryInfos>>(expect1);
      }
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos : public Darabonba::Model {
public:
  shared_ptr<long> actualPrice{};
  shared_ptr<bool> canSell{};
  shared_ptr<long> cash{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemPicUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> message{};
  shared_ptr<long> points{};
  shared_ptr<long> quantity{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};

  RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPrice) {
      res["ActualPrice"] = boost::any(*actualPrice);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (cash) {
      res["Cash"] = boost::any(*cash);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemPicUrl) {
      res["ItemPicUrl"] = boost::any(*itemPicUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualPrice") != m.end() && !m["ActualPrice"].empty()) {
      actualPrice = make_shared<long>(boost::any_cast<long>(m["ActualPrice"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("Cash") != m.end() && !m["Cash"].empty()) {
      cash = make_shared<long>(boost::any_cast<long>(m["Cash"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemPicUrl") != m.end() && !m["ItemPicUrl"].empty()) {
      itemPicUrl = make_shared<string>(boost::any_cast<string>(m["ItemPicUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos>> lmItemInfos{};

  RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lmItemInfos) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LmItemInfos") != m.end() && !m["LmItemInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemInfos"].type()) {
        vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemInfos = make_shared<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfosLmItemInfos>>(expect1);
      }
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos : public Darabonba::Model {
public:
  shared_ptr<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos> deliveryInfos{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos> lmItemInfos{};

  RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryInfos) {
      res["DeliveryInfos"] = deliveryInfos ? boost::any(deliveryInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (lmItemInfos) {
      res["LmItemInfos"] = lmItemInfos ? boost::any(lmItemInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryInfos") != m.end() && !m["DeliveryInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeliveryInfos"].type()) {
        RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeliveryInfos"]));
        deliveryInfos = make_shared<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosDeliveryInfos>(model1);
      }
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LmItemInfos") != m.end() && !m["LmItemInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LmItemInfos"].type()) {
        RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LmItemInfos"]));
        lmItemInfos = make_shared<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfosLmItemInfos>(model1);
      }
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos() = default;
};
class RenderOrderResponseBodyModelRenderOrderInfos : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos>> renderOrderInfos{};

  RenderOrderResponseBodyModelRenderOrderInfos() {}

  explicit RenderOrderResponseBodyModelRenderOrderInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderOrderInfos) {
      vector<boost::any> temp1;
      for(auto item1:*renderOrderInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderOrderInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderOrderInfos") != m.end() && !m["RenderOrderInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderOrderInfos"].type()) {
        vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderOrderInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderOrderInfos = make_shared<vector<RenderOrderResponseBodyModelRenderOrderInfosRenderOrderInfos>>(expect1);
      }
    }
  }


  virtual ~RenderOrderResponseBodyModelRenderOrderInfos() = default;
};
class RenderOrderResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<RenderOrderResponseBodyModelRenderOrderInfos> renderOrderInfos{};

  RenderOrderResponseBodyModel() {}

  explicit RenderOrderResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (renderOrderInfos) {
      res["RenderOrderInfos"] = renderOrderInfos ? boost::any(renderOrderInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RenderOrderInfos") != m.end() && !m["RenderOrderInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["RenderOrderInfos"].type()) {
        RenderOrderResponseBodyModelRenderOrderInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RenderOrderInfos"]));
        renderOrderInfos = make_shared<RenderOrderResponseBodyModelRenderOrderInfos>(model1);
      }
    }
  }


  virtual ~RenderOrderResponseBodyModel() = default;
};
class RenderOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RenderOrderResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RenderOrderResponseBody() {}

  explicit RenderOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RenderOrderResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RenderOrderResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RenderOrderResponseBody() = default;
};
class RenderOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenderOrderResponseBody> body{};

  RenderOrderResponse() {}

  explicit RenderOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenderOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenderOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RenderOrderResponse() = default;
};
class RenderOrderWithDesignatedTbUidRequestItemList : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> quantity{};
  shared_ptr<long> skuId{};

  RenderOrderWithDesignatedTbUidRequestItemList() {}

  explicit RenderOrderWithDesignatedTbUidRequestItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidRequestItemList() = default;
};
class RenderOrderWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidRequestItemList>> itemList{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  RenderOrderWithDesignatedTbUidRequest() {}

  explicit RenderOrderWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<RenderOrderWithDesignatedTbUidRequestItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidRequestItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<RenderOrderWithDesignatedTbUidRequestItemList>>(expect1);
      }
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidRequest() = default;
};
class RenderOrderWithDesignatedTbUidShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> deliveryAddress{};
  shared_ptr<string> itemListShrink{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  RenderOrderWithDesignatedTbUidShrinkRequest() {}

  explicit RenderOrderWithDesignatedTbUidShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (deliveryAddress) {
      res["DeliveryAddress"] = boost::any(*deliveryAddress);
    }
    if (itemListShrink) {
      res["ItemList"] = boost::any(*itemListShrink);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("DeliveryAddress") != m.end() && !m["DeliveryAddress"].empty()) {
      deliveryAddress = make_shared<string>(boost::any_cast<string>(m["DeliveryAddress"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      itemListShrink = make_shared<string>(boost::any_cast<string>(m["ItemList"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidShrinkRequest() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos : public Darabonba::Model {
public:
  shared_ptr<string> addressDetail{};
  shared_ptr<long> addressId{};
  shared_ptr<string> divisionCode{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> receiver{};
  shared_ptr<string> receiverPhone{};
  shared_ptr<string> townDivisionCode{};

  RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressDetail) {
      res["AddressDetail"] = boost::any(*addressDetail);
    }
    if (addressId) {
      res["AddressId"] = boost::any(*addressId);
    }
    if (divisionCode) {
      res["DivisionCode"] = boost::any(*divisionCode);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (receiver) {
      res["Receiver"] = boost::any(*receiver);
    }
    if (receiverPhone) {
      res["ReceiverPhone"] = boost::any(*receiverPhone);
    }
    if (townDivisionCode) {
      res["TownDivisionCode"] = boost::any(*townDivisionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressDetail") != m.end() && !m["AddressDetail"].empty()) {
      addressDetail = make_shared<string>(boost::any_cast<string>(m["AddressDetail"]));
    }
    if (m.find("AddressId") != m.end() && !m["AddressId"].empty()) {
      addressId = make_shared<long>(boost::any_cast<long>(m["AddressId"]));
    }
    if (m.find("DivisionCode") != m.end() && !m["DivisionCode"].empty()) {
      divisionCode = make_shared<string>(boost::any_cast<string>(m["DivisionCode"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("Receiver") != m.end() && !m["Receiver"].empty()) {
      receiver = make_shared<string>(boost::any_cast<string>(m["Receiver"]));
    }
    if (m.find("ReceiverPhone") != m.end() && !m["ReceiverPhone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["ReceiverPhone"]));
    }
    if (m.find("TownDivisionCode") != m.end() && !m["TownDivisionCode"].empty()) {
      townDivisionCode = make_shared<string>(boost::any_cast<string>(m["TownDivisionCode"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<long> postFee{};
  shared_ptr<long> serviceType{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (postFee) {
      res["PostFee"] = boost::any(*postFee);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      postFee = make_shared<long>(boost::any_cast<long>(m["PostFee"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> type{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmShopId{};
  shared_ptr<long> number{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> removed{};
  shared_ptr<long> skuId{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> userPayFee{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (removed) {
      res["Removed"] = boost::any(*removed);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (userPayFee) {
      res["UserPayFee"] = boost::any(*userPayFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Removed") != m.end() && !m["Removed"].empty()) {
      removed = make_shared<bool>(boost::any_cast<bool>(m["Removed"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("UserPayFee") != m.end() && !m["UserPayFee"].empty()) {
      userPayFee = make_shared<long>(boost::any_cast<long>(m["UserPayFee"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems>> availableItems{};
  shared_ptr<bool> canUse{};
  shared_ptr<long> discountPrice{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionType{};
  shared_ptr<string> reason{};
  shared_ptr<bool> selected{};
  shared_ptr<vector<long>> skuIds{};
  shared_ptr<long> specialPrice{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> thresholdPrice{};
  shared_ptr<long> useStartTime{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableItems) {
      vector<boost::any> temp1;
      for(auto item1:*availableItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableItems"] = boost::any(temp1);
    }
    if (canUse) {
      res["CanUse"] = boost::any(*canUse);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionType) {
      res["PromotionType"] = boost::any(*promotionType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    if (skuIds) {
      res["SkuIds"] = boost::any(*skuIds);
    }
    if (specialPrice) {
      res["SpecialPrice"] = boost::any(*specialPrice);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (thresholdPrice) {
      res["ThresholdPrice"] = boost::any(*thresholdPrice);
    }
    if (useStartTime) {
      res["UseStartTime"] = boost::any(*useStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableItems") != m.end() && !m["AvailableItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableItems"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableItems = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems>>(expect1);
      }
    }
    if (m.find("CanUse") != m.end() && !m["CanUse"].empty()) {
      canUse = make_shared<bool>(boost::any_cast<bool>(m["CanUse"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["DiscountPrice"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionType") != m.end() && !m["PromotionType"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["PromotionType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
    if (m.find("SkuIds") != m.end() && !m["SkuIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      skuIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SpecialPrice") != m.end() && !m["SpecialPrice"].empty()) {
      specialPrice = make_shared<long>(boost::any_cast<long>(m["SpecialPrice"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("ThresholdPrice") != m.end() && !m["ThresholdPrice"].empty()) {
      thresholdPrice = make_shared<long>(boost::any_cast<long>(m["ThresholdPrice"]));
    }
    if (m.find("UseStartTime") != m.end() && !m["UseStartTime"].empty()) {
      useStartTime = make_shared<long>(boost::any_cast<long>(m["UseStartTime"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos : public Darabonba::Model {
public:
  shared_ptr<long> actualPrice{};
  shared_ptr<bool> canSell{};
  shared_ptr<long> cash{};
  shared_ptr<map<string, string>> features{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemPicUrl{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS>> itemPromInstVOS{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> message{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> promotionFee{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<string> tbShopName{};
  shared_ptr<string> virtualItemType{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPrice) {
      res["ActualPrice"] = boost::any(*actualPrice);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (cash) {
      res["Cash"] = boost::any(*cash);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemPicUrl) {
      res["ItemPicUrl"] = boost::any(*itemPicUrl);
    }
    if (itemPromInstVOS) {
      vector<boost::any> temp1;
      for(auto item1:*itemPromInstVOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPromInstVOS"] = boost::any(temp1);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (promotionFee) {
      res["PromotionFee"] = boost::any(*promotionFee);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (virtualItemType) {
      res["VirtualItemType"] = boost::any(*virtualItemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualPrice") != m.end() && !m["ActualPrice"].empty()) {
      actualPrice = make_shared<long>(boost::any_cast<long>(m["ActualPrice"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("Cash") != m.end() && !m["Cash"].empty()) {
      cash = make_shared<long>(boost::any_cast<long>(m["Cash"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Features"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      features = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemPicUrl") != m.end() && !m["ItemPicUrl"].empty()) {
      itemPicUrl = make_shared<string>(boost::any_cast<string>(m["ItemPicUrl"]));
    }
    if (m.find("ItemPromInstVOS") != m.end() && !m["ItemPromInstVOS"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPromInstVOS"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPromInstVOS"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPromInstVOS = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfosItemPromInstVOS>>(expect1);
      }
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PromotionFee") != m.end() && !m["PromotionFee"].empty()) {
      promotionFee = make_shared<long>(boost::any_cast<long>(m["PromotionFee"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("VirtualItemType") != m.end() && !m["VirtualItemType"].empty()) {
      virtualItemType = make_shared<string>(boost::any_cast<string>(m["VirtualItemType"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmShopId{};
  shared_ptr<long> number{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> removed{};
  shared_ptr<long> skuId{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> userPayFee{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (removed) {
      res["Removed"] = boost::any(*removed);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (userPayFee) {
      res["UserPayFee"] = boost::any(*userPayFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Removed") != m.end() && !m["Removed"].empty()) {
      removed = make_shared<bool>(boost::any_cast<bool>(m["Removed"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("UserPayFee") != m.end() && !m["UserPayFee"].empty()) {
      userPayFee = make_shared<long>(boost::any_cast<long>(m["UserPayFee"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems>> availableItems{};
  shared_ptr<bool> canUse{};
  shared_ptr<long> discountPrice{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionType{};
  shared_ptr<string> reason{};
  shared_ptr<bool> selected{};
  shared_ptr<vector<long>> skuIds{};
  shared_ptr<long> specialPrice{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> thresholdPrice{};
  shared_ptr<long> useStartTime{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableItems) {
      vector<boost::any> temp1;
      for(auto item1:*availableItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableItems"] = boost::any(temp1);
    }
    if (canUse) {
      res["CanUse"] = boost::any(*canUse);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionType) {
      res["PromotionType"] = boost::any(*promotionType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    if (skuIds) {
      res["SkuIds"] = boost::any(*skuIds);
    }
    if (specialPrice) {
      res["SpecialPrice"] = boost::any(*specialPrice);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (thresholdPrice) {
      res["ThresholdPrice"] = boost::any(*thresholdPrice);
    }
    if (useStartTime) {
      res["UseStartTime"] = boost::any(*useStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableItems") != m.end() && !m["AvailableItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableItems"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableItems = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOSAvailableItems>>(expect1);
      }
    }
    if (m.find("CanUse") != m.end() && !m["CanUse"].empty()) {
      canUse = make_shared<bool>(boost::any_cast<bool>(m["CanUse"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["DiscountPrice"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionType") != m.end() && !m["PromotionType"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["PromotionType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
    if (m.find("SkuIds") != m.end() && !m["SkuIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      skuIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SpecialPrice") != m.end() && !m["SpecialPrice"].empty()) {
      specialPrice = make_shared<long>(boost::any_cast<long>(m["SpecialPrice"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("ThresholdPrice") != m.end() && !m["ThresholdPrice"].empty()) {
      thresholdPrice = make_shared<long>(boost::any_cast<long>(m["ThresholdPrice"]));
    }
    if (m.find("UseStartTime") != m.end() && !m["UseStartTime"].empty()) {
      useStartTime = make_shared<long>(boost::any_cast<long>(m["UseStartTime"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos>> deliveryInfos{};
  shared_ptr<map<string, string>> extInfo{};
  shared_ptr<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo> invoiceInfo{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos>> lmItemInfos{};
  shared_ptr<string> message{};
  shared_ptr<long> sellerId{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS>> shopPromInstVOS{};
  shared_ptr<string> tbShopName{};

  RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (deliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryInfos"] = boost::any(temp1);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (invoiceInfo) {
      res["InvoiceInfo"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemInfos) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemInfos"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (shopPromInstVOS) {
      vector<boost::any> temp1;
      for(auto item1:*shopPromInstVOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ShopPromInstVOS"] = boost::any(temp1);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("DeliveryInfos") != m.end() && !m["DeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosDeliveryInfos>>(expect1);
      }
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtInfo"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("InvoiceInfo") != m.end() && !m["InvoiceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvoiceInfo"].type()) {
        RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvoiceInfo"]));
        invoiceInfo = make_shared<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosInvoiceInfo>(model1);
      }
    }
    if (m.find("LmItemInfos") != m.end() && !m["LmItemInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosLmItemInfos>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("ShopPromInstVOS") != m.end() && !m["ShopPromInstVOS"].empty()) {
      if (typeid(vector<boost::any>) == m["ShopPromInstVOS"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ShopPromInstVOS"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        shopPromInstVOS = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfosShopPromInstVOS>>(expect1);
      }
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};
  shared_ptr<long> postFee{};
  shared_ptr<long> serviceType{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (postFee) {
      res["PostFee"] = boost::any(*postFee);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("PostFee") != m.end() && !m["PostFee"].empty()) {
      postFee = make_shared<long>(boost::any_cast<long>(m["PostFee"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<long>(boost::any_cast<long>(m["ServiceType"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> type{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmShopId{};
  shared_ptr<long> number{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> removed{};
  shared_ptr<long> skuId{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> userPayFee{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (removed) {
      res["Removed"] = boost::any(*removed);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (userPayFee) {
      res["UserPayFee"] = boost::any(*userPayFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Removed") != m.end() && !m["Removed"].empty()) {
      removed = make_shared<bool>(boost::any_cast<bool>(m["Removed"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("UserPayFee") != m.end() && !m["UserPayFee"].empty()) {
      userPayFee = make_shared<long>(boost::any_cast<long>(m["UserPayFee"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems>> availableItems{};
  shared_ptr<bool> canUse{};
  shared_ptr<long> discountPrice{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionType{};
  shared_ptr<string> reason{};
  shared_ptr<bool> selected{};
  shared_ptr<vector<long>> skuIds{};
  shared_ptr<long> specialPrice{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> thresholdPrice{};
  shared_ptr<long> useStartTime{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableItems) {
      vector<boost::any> temp1;
      for(auto item1:*availableItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableItems"] = boost::any(temp1);
    }
    if (canUse) {
      res["CanUse"] = boost::any(*canUse);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionType) {
      res["PromotionType"] = boost::any(*promotionType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    if (skuIds) {
      res["SkuIds"] = boost::any(*skuIds);
    }
    if (specialPrice) {
      res["SpecialPrice"] = boost::any(*specialPrice);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (thresholdPrice) {
      res["ThresholdPrice"] = boost::any(*thresholdPrice);
    }
    if (useStartTime) {
      res["UseStartTime"] = boost::any(*useStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableItems") != m.end() && !m["AvailableItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableItems"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableItems = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOSAvailableItems>>(expect1);
      }
    }
    if (m.find("CanUse") != m.end() && !m["CanUse"].empty()) {
      canUse = make_shared<bool>(boost::any_cast<bool>(m["CanUse"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["DiscountPrice"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionType") != m.end() && !m["PromotionType"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["PromotionType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
    if (m.find("SkuIds") != m.end() && !m["SkuIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      skuIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SpecialPrice") != m.end() && !m["SpecialPrice"].empty()) {
      specialPrice = make_shared<long>(boost::any_cast<long>(m["SpecialPrice"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("ThresholdPrice") != m.end() && !m["ThresholdPrice"].empty()) {
      thresholdPrice = make_shared<long>(boost::any_cast<long>(m["ThresholdPrice"]));
    }
    if (m.find("UseStartTime") != m.end() && !m["UseStartTime"].empty()) {
      useStartTime = make_shared<long>(boost::any_cast<long>(m["UseStartTime"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos : public Darabonba::Model {
public:
  shared_ptr<long> actualPrice{};
  shared_ptr<bool> canSell{};
  shared_ptr<long> cash{};
  shared_ptr<map<string, string>> features{};
  shared_ptr<long> itemId{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemPicUrl{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS>> itemPromInstVOS{};
  shared_ptr<string> itemUrl{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> message{};
  shared_ptr<long> pointPrice{};
  shared_ptr<long> points{};
  shared_ptr<long> promotionFee{};
  shared_ptr<long> quantity{};
  shared_ptr<long> reservePrice{};
  shared_ptr<long> sellerId{};
  shared_ptr<string> sellerNick{};
  shared_ptr<long> skuId{};
  shared_ptr<string> skuName{};
  shared_ptr<string> tbShopName{};
  shared_ptr<string> virtualItemType{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualPrice) {
      res["ActualPrice"] = boost::any(*actualPrice);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (cash) {
      res["Cash"] = boost::any(*cash);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemPicUrl) {
      res["ItemPicUrl"] = boost::any(*itemPicUrl);
    }
    if (itemPromInstVOS) {
      vector<boost::any> temp1;
      for(auto item1:*itemPromInstVOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemPromInstVOS"] = boost::any(temp1);
    }
    if (itemUrl) {
      res["ItemUrl"] = boost::any(*itemUrl);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pointPrice) {
      res["PointPrice"] = boost::any(*pointPrice);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (promotionFee) {
      res["PromotionFee"] = boost::any(*promotionFee);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (reservePrice) {
      res["ReservePrice"] = boost::any(*reservePrice);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (skuName) {
      res["SkuName"] = boost::any(*skuName);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    if (virtualItemType) {
      res["VirtualItemType"] = boost::any(*virtualItemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualPrice") != m.end() && !m["ActualPrice"].empty()) {
      actualPrice = make_shared<long>(boost::any_cast<long>(m["ActualPrice"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("Cash") != m.end() && !m["Cash"].empty()) {
      cash = make_shared<long>(boost::any_cast<long>(m["Cash"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Features"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      features = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemPicUrl") != m.end() && !m["ItemPicUrl"].empty()) {
      itemPicUrl = make_shared<string>(boost::any_cast<string>(m["ItemPicUrl"]));
    }
    if (m.find("ItemPromInstVOS") != m.end() && !m["ItemPromInstVOS"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemPromInstVOS"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemPromInstVOS"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemPromInstVOS = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfosItemPromInstVOS>>(expect1);
      }
    }
    if (m.find("ItemUrl") != m.end() && !m["ItemUrl"].empty()) {
      itemUrl = make_shared<string>(boost::any_cast<string>(m["ItemUrl"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PointPrice") != m.end() && !m["PointPrice"].empty()) {
      pointPrice = make_shared<long>(boost::any_cast<long>(m["PointPrice"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PromotionFee") != m.end() && !m["PromotionFee"].empty()) {
      promotionFee = make_shared<long>(boost::any_cast<long>(m["PromotionFee"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("ReservePrice") != m.end() && !m["ReservePrice"].empty()) {
      reservePrice = make_shared<long>(boost::any_cast<long>(m["ReservePrice"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("SkuName") != m.end() && !m["SkuName"].empty()) {
      skuName = make_shared<string>(boost::any_cast<string>(m["SkuName"]));
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
    if (m.find("VirtualItemType") != m.end() && !m["VirtualItemType"].empty()) {
      virtualItemType = make_shared<string>(boost::any_cast<string>(m["VirtualItemType"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lmItemId{};
  shared_ptr<long> lmShopId{};
  shared_ptr<long> number{};
  shared_ptr<long> points{};
  shared_ptr<long> pointsAmount{};
  shared_ptr<long> priceCent{};
  shared_ptr<bool> removed{};
  shared_ptr<long> skuId{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> userPayFee{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (lmShopId) {
      res["LmShopId"] = boost::any(*lmShopId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (pointsAmount) {
      res["PointsAmount"] = boost::any(*pointsAmount);
    }
    if (priceCent) {
      res["PriceCent"] = boost::any(*priceCent);
    }
    if (removed) {
      res["Removed"] = boost::any(*removed);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (userPayFee) {
      res["UserPayFee"] = boost::any(*userPayFee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("LmShopId") != m.end() && !m["LmShopId"].empty()) {
      lmShopId = make_shared<long>(boost::any_cast<long>(m["LmShopId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("PointsAmount") != m.end() && !m["PointsAmount"].empty()) {
      pointsAmount = make_shared<long>(boost::any_cast<long>(m["PointsAmount"]));
    }
    if (m.find("PriceCent") != m.end() && !m["PriceCent"].empty()) {
      priceCent = make_shared<long>(boost::any_cast<long>(m["PriceCent"]));
    }
    if (m.find("Removed") != m.end() && !m["Removed"].empty()) {
      removed = make_shared<bool>(boost::any_cast<bool>(m["Removed"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<long>(boost::any_cast<long>(m["SkuId"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("UserPayFee") != m.end() && !m["UserPayFee"].empty()) {
      userPayFee = make_shared<long>(boost::any_cast<long>(m["UserPayFee"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems>> availableItems{};
  shared_ptr<bool> canUse{};
  shared_ptr<long> discountPrice{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> lmItemId{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionType{};
  shared_ptr<string> reason{};
  shared_ptr<bool> selected{};
  shared_ptr<vector<long>> skuIds{};
  shared_ptr<long> specialPrice{};
  shared_ptr<string> subBizCode{};
  shared_ptr<long> tbSellerId{};
  shared_ptr<long> thresholdPrice{};
  shared_ptr<long> useStartTime{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableItems) {
      vector<boost::any> temp1;
      for(auto item1:*availableItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableItems"] = boost::any(temp1);
    }
    if (canUse) {
      res["CanUse"] = boost::any(*canUse);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lmItemId) {
      res["LmItemId"] = boost::any(*lmItemId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionType) {
      res["PromotionType"] = boost::any(*promotionType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    if (skuIds) {
      res["SkuIds"] = boost::any(*skuIds);
    }
    if (specialPrice) {
      res["SpecialPrice"] = boost::any(*specialPrice);
    }
    if (subBizCode) {
      res["SubBizCode"] = boost::any(*subBizCode);
    }
    if (tbSellerId) {
      res["TbSellerId"] = boost::any(*tbSellerId);
    }
    if (thresholdPrice) {
      res["ThresholdPrice"] = boost::any(*thresholdPrice);
    }
    if (useStartTime) {
      res["UseStartTime"] = boost::any(*useStartTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableItems") != m.end() && !m["AvailableItems"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableItems"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableItems = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOSAvailableItems>>(expect1);
      }
    }
    if (m.find("CanUse") != m.end() && !m["CanUse"].empty()) {
      canUse = make_shared<bool>(boost::any_cast<bool>(m["CanUse"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<long>(boost::any_cast<long>(m["DiscountPrice"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LmItemId") != m.end() && !m["LmItemId"].empty()) {
      lmItemId = make_shared<string>(boost::any_cast<string>(m["LmItemId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionType") != m.end() && !m["PromotionType"].empty()) {
      promotionType = make_shared<string>(boost::any_cast<string>(m["PromotionType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
    if (m.find("SkuIds") != m.end() && !m["SkuIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SkuIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkuIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      skuIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SpecialPrice") != m.end() && !m["SpecialPrice"].empty()) {
      specialPrice = make_shared<long>(boost::any_cast<long>(m["SpecialPrice"]));
    }
    if (m.find("SubBizCode") != m.end() && !m["SubBizCode"].empty()) {
      subBizCode = make_shared<string>(boost::any_cast<string>(m["SubBizCode"]));
    }
    if (m.find("TbSellerId") != m.end() && !m["TbSellerId"].empty()) {
      tbSellerId = make_shared<long>(boost::any_cast<long>(m["TbSellerId"]));
    }
    if (m.find("ThresholdPrice") != m.end() && !m["ThresholdPrice"].empty()) {
      thresholdPrice = make_shared<long>(boost::any_cast<long>(m["ThresholdPrice"]));
    }
    if (m.find("UseStartTime") != m.end() && !m["UseStartTime"].empty()) {
      useStartTime = make_shared<long>(boost::any_cast<long>(m["UseStartTime"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos : public Darabonba::Model {
public:
  shared_ptr<bool> canSell{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos>> deliveryInfos{};
  shared_ptr<map<string, string>> extInfo{};
  shared_ptr<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo> invoiceInfo{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos>> lmItemInfos{};
  shared_ptr<string> message{};
  shared_ptr<long> sellerId{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS>> shopPromInstVOS{};
  shared_ptr<string> tbShopName{};

  RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (deliveryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryInfos"] = boost::any(temp1);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (invoiceInfo) {
      res["InvoiceInfo"] = invoiceInfo ? boost::any(invoiceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lmItemInfos) {
      vector<boost::any> temp1;
      for(auto item1:*lmItemInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LmItemInfos"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (sellerId) {
      res["SellerId"] = boost::any(*sellerId);
    }
    if (shopPromInstVOS) {
      vector<boost::any> temp1;
      for(auto item1:*shopPromInstVOS){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ShopPromInstVOS"] = boost::any(temp1);
    }
    if (tbShopName) {
      res["TbShopName"] = boost::any(*tbShopName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("DeliveryInfos") != m.end() && !m["DeliveryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosDeliveryInfos>>(expect1);
      }
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtInfo"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("InvoiceInfo") != m.end() && !m["InvoiceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvoiceInfo"].type()) {
        RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvoiceInfo"]));
        invoiceInfo = make_shared<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosInvoiceInfo>(model1);
      }
    }
    if (m.find("LmItemInfos") != m.end() && !m["LmItemInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["LmItemInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LmItemInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lmItemInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosLmItemInfos>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("SellerId") != m.end() && !m["SellerId"].empty()) {
      sellerId = make_shared<long>(boost::any_cast<long>(m["SellerId"]));
    }
    if (m.find("ShopPromInstVOS") != m.end() && !m["ShopPromInstVOS"].empty()) {
      if (typeid(vector<boost::any>) == m["ShopPromInstVOS"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ShopPromInstVOS"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        shopPromInstVOS = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfosShopPromInstVOS>>(expect1);
      }
    }
    if (m.find("TbShopName") != m.end() && !m["TbShopName"].empty()) {
      tbShopName = make_shared<string>(boost::any_cast<string>(m["TbShopName"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos() = default;
};
class RenderOrderWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos>> addressInfos{};
  shared_ptr<long> buyerCurrentPoints{};
  shared_ptr<bool> canSell{};
  shared_ptr<map<string, string>> extInfo{};
  shared_ptr<string> message{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos>> renderOrderInfos{};
  shared_ptr<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos>> unsellableRenderOrderInfos{};

  RenderOrderWithDesignatedTbUidResponseBodyModel() {}

  explicit RenderOrderWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfos) {
      vector<boost::any> temp1;
      for(auto item1:*addressInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddressInfos"] = boost::any(temp1);
    }
    if (buyerCurrentPoints) {
      res["BuyerCurrentPoints"] = boost::any(*buyerCurrentPoints);
    }
    if (canSell) {
      res["CanSell"] = boost::any(*canSell);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (renderOrderInfos) {
      vector<boost::any> temp1;
      for(auto item1:*renderOrderInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RenderOrderInfos"] = boost::any(temp1);
    }
    if (unsellableRenderOrderInfos) {
      vector<boost::any> temp1;
      for(auto item1:*unsellableRenderOrderInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UnsellableRenderOrderInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfos") != m.end() && !m["AddressInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AddressInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddressInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addressInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelAddressInfos>>(expect1);
      }
    }
    if (m.find("BuyerCurrentPoints") != m.end() && !m["BuyerCurrentPoints"].empty()) {
      buyerCurrentPoints = make_shared<long>(boost::any_cast<long>(m["BuyerCurrentPoints"]));
    }
    if (m.find("CanSell") != m.end() && !m["CanSell"].empty()) {
      canSell = make_shared<bool>(boost::any_cast<bool>(m["CanSell"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ExtInfo"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RenderOrderInfos") != m.end() && !m["RenderOrderInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RenderOrderInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RenderOrderInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        renderOrderInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelRenderOrderInfos>>(expect1);
      }
    }
    if (m.find("UnsellableRenderOrderInfos") != m.end() && !m["UnsellableRenderOrderInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["UnsellableRenderOrderInfos"].type()) {
        vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UnsellableRenderOrderInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unsellableRenderOrderInfos = make_shared<vector<RenderOrderWithDesignatedTbUidResponseBodyModelUnsellableRenderOrderInfos>>(expect1);
      }
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBodyModel() = default;
};
class RenderOrderWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RenderOrderWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RenderOrderWithDesignatedTbUidResponseBody() {}

  explicit RenderOrderWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RenderOrderWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RenderOrderWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponseBody() = default;
};
class RenderOrderWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenderOrderWithDesignatedTbUidResponseBody> body{};

  RenderOrderWithDesignatedTbUidResponse() {}

  explicit RenderOrderWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenderOrderWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenderOrderWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~RenderOrderWithDesignatedTbUidResponse() = default;
};
class RepayForPayUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RepayForPayUrlRequest() {}

  explicit RepayForPayUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RepayForPayUrlRequest() = default;
};
class RepayForPayUrlResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> frontUrl{};

  RepayForPayUrlResponseBodyModel() {}

  explicit RepayForPayUrlResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontUrl) {
      res["FrontUrl"] = boost::any(*frontUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontUrl") != m.end() && !m["FrontUrl"].empty()) {
      frontUrl = make_shared<string>(boost::any_cast<string>(m["FrontUrl"]));
    }
  }


  virtual ~RepayForPayUrlResponseBodyModel() = default;
};
class RepayForPayUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<RepayForPayUrlResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  RepayForPayUrlResponseBody() {}

  explicit RepayForPayUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RepayForPayUrlResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RepayForPayUrlResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RepayForPayUrlResponseBody() = default;
};
class RepayForPayUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RepayForPayUrlResponseBody> body{};

  RepayForPayUrlResponse() {}

  explicit RepayForPayUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RepayForPayUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RepayForPayUrlResponseBody>(model1);
      }
    }
  }


  virtual ~RepayForPayUrlResponse() = default;
};
class RepayOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  RepayOrderRequest() {}

  explicit RepayOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~RepayOrderRequest() = default;
};
class RepayOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RepayOrderResponseBody() {}

  explicit RepayOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RepayOrderResponseBody() = default;
};
class RepayOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RepayOrderResponseBody> body{};

  RepayOrderResponse() {}

  explicit RepayOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RepayOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RepayOrderResponseBody>(model1);
      }
    }
  }


  virtual ~RepayOrderResponse() = default;
};
class RepayWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> extJson{};
  shared_ptr<long> lmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  RepayWithDesignatedTbUidRequest() {}

  explicit RepayWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (lmOrderId) {
      res["LmOrderId"] = boost::any(*lmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("LmOrderId") != m.end() && !m["LmOrderId"].empty()) {
      lmOrderId = make_shared<long>(boost::any_cast<long>(m["LmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~RepayWithDesignatedTbUidRequest() = default;
};
class RepayWithDesignatedTbUidResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> frontUrl{};
  shared_ptr<bool> isOnlyPaidPoint{};

  RepayWithDesignatedTbUidResponseBodyModel() {}

  explicit RepayWithDesignatedTbUidResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (frontUrl) {
      res["FrontUrl"] = boost::any(*frontUrl);
    }
    if (isOnlyPaidPoint) {
      res["IsOnlyPaidPoint"] = boost::any(*isOnlyPaidPoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("FrontUrl") != m.end() && !m["FrontUrl"].empty()) {
      frontUrl = make_shared<string>(boost::any_cast<string>(m["FrontUrl"]));
    }
    if (m.find("IsOnlyPaidPoint") != m.end() && !m["IsOnlyPaidPoint"].empty()) {
      isOnlyPaidPoint = make_shared<bool>(boost::any_cast<bool>(m["IsOnlyPaidPoint"]));
    }
  }


  virtual ~RepayWithDesignatedTbUidResponseBodyModel() = default;
};
class RepayWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<RepayWithDesignatedTbUidResponseBodyModel> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RepayWithDesignatedTbUidResponseBody() {}

  explicit RepayWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        RepayWithDesignatedTbUidResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<RepayWithDesignatedTbUidResponseBodyModel>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RepayWithDesignatedTbUidResponseBody() = default;
};
class RepayWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RepayWithDesignatedTbUidResponseBody> body{};

  RepayWithDesignatedTbUidResponse() {}

  explicit RepayWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RepayWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RepayWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~RepayWithDesignatedTbUidResponse() = default;
};
class ReserveMovieSeatRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> mobile{};
  shared_ptr<long> scheduleId{};
  shared_ptr<string> seatIds{};
  shared_ptr<string> seatNames{};

  ReserveMovieSeatRequest() {}

  explicit ReserveMovieSeatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (scheduleId) {
      res["ScheduleId"] = boost::any(*scheduleId);
    }
    if (seatIds) {
      res["SeatIds"] = boost::any(*seatIds);
    }
    if (seatNames) {
      res["SeatNames"] = boost::any(*seatNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("ScheduleId") != m.end() && !m["ScheduleId"].empty()) {
      scheduleId = make_shared<long>(boost::any_cast<long>(m["ScheduleId"]));
    }
    if (m.find("SeatIds") != m.end() && !m["SeatIds"].empty()) {
      seatIds = make_shared<string>(boost::any_cast<string>(m["SeatIds"]));
    }
    if (m.find("SeatNames") != m.end() && !m["SeatNames"].empty()) {
      seatNames = make_shared<string>(boost::any_cast<string>(m["SeatNames"]));
    }
  }


  virtual ~ReserveMovieSeatRequest() = default;
};
class ReserveMovieSeatResponseBodyReservedSeat : public Darabonba::Model {
public:
  shared_ptr<string> applyKey{};
  shared_ptr<long> defaultLockSecond{};
  shared_ptr<long> reservedTime{};
  shared_ptr<string> status{};

  ReserveMovieSeatResponseBodyReservedSeat() {}

  explicit ReserveMovieSeatResponseBodyReservedSeat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyKey) {
      res["ApplyKey"] = boost::any(*applyKey);
    }
    if (defaultLockSecond) {
      res["DefaultLockSecond"] = boost::any(*defaultLockSecond);
    }
    if (reservedTime) {
      res["ReservedTime"] = boost::any(*reservedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyKey") != m.end() && !m["ApplyKey"].empty()) {
      applyKey = make_shared<string>(boost::any_cast<string>(m["ApplyKey"]));
    }
    if (m.find("DefaultLockSecond") != m.end() && !m["DefaultLockSecond"].empty()) {
      defaultLockSecond = make_shared<long>(boost::any_cast<long>(m["DefaultLockSecond"]));
    }
    if (m.find("ReservedTime") != m.end() && !m["ReservedTime"].empty()) {
      reservedTime = make_shared<long>(boost::any_cast<long>(m["ReservedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ReserveMovieSeatResponseBodyReservedSeat() = default;
};
class ReserveMovieSeatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ReserveMovieSeatResponseBodyReservedSeat> reservedSeat{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};

  ReserveMovieSeatResponseBody() {}

  explicit ReserveMovieSeatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reservedSeat) {
      res["ReservedSeat"] = reservedSeat ? boost::any(reservedSeat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReservedSeat") != m.end() && !m["ReservedSeat"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReservedSeat"].type()) {
        ReserveMovieSeatResponseBodyReservedSeat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReservedSeat"]));
        reservedSeat = make_shared<ReserveMovieSeatResponseBodyReservedSeat>(model1);
      }
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReserveMovieSeatResponseBody() = default;
};
class ReserveMovieSeatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReserveMovieSeatResponseBody> body{};

  ReserveMovieSeatResponse() {}

  explicit ReserveMovieSeatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReserveMovieSeatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReserveMovieSeatResponseBody>(model1);
      }
    }
  }


  virtual ~ReserveMovieSeatResponse() = default;
};
class SettleOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> extInfo{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> outTradeNo{};
  shared_ptr<string> royaltyParameters{};
  shared_ptr<string> tradeNo{};

  SettleOrderRequest() {}

  explicit SettleOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (outTradeNo) {
      res["OutTradeNo"] = boost::any(*outTradeNo);
    }
    if (royaltyParameters) {
      res["RoyaltyParameters"] = boost::any(*royaltyParameters);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("OutTradeNo") != m.end() && !m["OutTradeNo"].empty()) {
      outTradeNo = make_shared<string>(boost::any_cast<string>(m["OutTradeNo"]));
    }
    if (m.find("RoyaltyParameters") != m.end() && !m["RoyaltyParameters"].empty()) {
      royaltyParameters = make_shared<string>(boost::any_cast<string>(m["RoyaltyParameters"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~SettleOrderRequest() = default;
};
class SettleOrderResponseBodyTradeOrderSettleResponse : public Darabonba::Model {
public:
  shared_ptr<string> outRequestNo{};
  shared_ptr<string> tradeNo{};

  SettleOrderResponseBodyTradeOrderSettleResponse() {}

  explicit SettleOrderResponseBodyTradeOrderSettleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    if (tradeNo) {
      res["TradeNo"] = boost::any(*tradeNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
    if (m.find("TradeNo") != m.end() && !m["TradeNo"].empty()) {
      tradeNo = make_shared<string>(boost::any_cast<string>(m["TradeNo"]));
    }
  }


  virtual ~SettleOrderResponseBodyTradeOrderSettleResponse() = default;
};
class SettleOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<SettleOrderResponseBodyTradeOrderSettleResponse> tradeOrderSettleResponse{};

  SettleOrderResponseBody() {}

  explicit SettleOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tradeOrderSettleResponse) {
      res["TradeOrderSettleResponse"] = tradeOrderSettleResponse ? boost::any(tradeOrderSettleResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TradeOrderSettleResponse") != m.end() && !m["TradeOrderSettleResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["TradeOrderSettleResponse"].type()) {
        SettleOrderResponseBodyTradeOrderSettleResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TradeOrderSettleResponse"]));
        tradeOrderSettleResponse = make_shared<SettleOrderResponseBodyTradeOrderSettleResponse>(model1);
      }
    }
  }


  virtual ~SettleOrderResponseBody() = default;
};
class SettleOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SettleOrderResponseBody> body{};

  SettleOrderResponse() {}

  explicit SettleOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SettleOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SettleOrderResponseBody>(model1);
      }
    }
  }


  virtual ~SettleOrderResponse() = default;
};
class StartUserGameRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> userApp{};

  StartUserGameRequest() {}

  explicit StartUserGameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (userApp) {
      res["UserApp"] = boost::any(*userApp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UserApp") != m.end() && !m["UserApp"].empty()) {
      userApp = make_shared<string>(boost::any_cast<string>(m["UserApp"]));
    }
  }


  virtual ~StartUserGameRequest() = default;
};
class StartUserGameShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> gameId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> userApp{};

  StartUserGameShrinkRequest() {}

  explicit StartUserGameShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (userApp) {
      res["UserApp"] = boost::any(*userApp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UserApp") != m.end() && !m["UserApp"].empty()) {
      userApp = make_shared<string>(boost::any_cast<string>(m["UserApp"]));
    }
  }


  virtual ~StartUserGameShrinkRequest() = default;
};
class StartUserGameResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> activityId{};
  shared_ptr<string> bizId{};
  shared_ptr<string> currentShowContent{};
  shared_ptr<string> currentStepId{};
  shared_ptr<string> currentStepStatus{};
  shared_ptr<string> desc{};
  shared_ptr<string> extInfo{};
  shared_ptr<string> gameId{};
  shared_ptr<string> name{};
  shared_ptr<string> processId{};
  shared_ptr<string> routeId{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  StartUserGameResponseBodyModel() {}

  explicit StartUserGameResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityId) {
      res["ActivityId"] = boost::any(*activityId);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (currentShowContent) {
      res["CurrentShowContent"] = boost::any(*currentShowContent);
    }
    if (currentStepId) {
      res["CurrentStepId"] = boost::any(*currentStepId);
    }
    if (currentStepStatus) {
      res["CurrentStepStatus"] = boost::any(*currentStepStatus);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (gameId) {
      res["GameId"] = boost::any(*gameId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityId") != m.end() && !m["ActivityId"].empty()) {
      activityId = make_shared<string>(boost::any_cast<string>(m["ActivityId"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CurrentShowContent") != m.end() && !m["CurrentShowContent"].empty()) {
      currentShowContent = make_shared<string>(boost::any_cast<string>(m["CurrentShowContent"]));
    }
    if (m.find("CurrentStepId") != m.end() && !m["CurrentStepId"].empty()) {
      currentStepId = make_shared<string>(boost::any_cast<string>(m["CurrentStepId"]));
    }
    if (m.find("CurrentStepStatus") != m.end() && !m["CurrentStepStatus"].empty()) {
      currentStepStatus = make_shared<string>(boost::any_cast<string>(m["CurrentStepStatus"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfo = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("GameId") != m.end() && !m["GameId"].empty()) {
      gameId = make_shared<string>(boost::any_cast<string>(m["GameId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~StartUserGameResponseBodyModel() = default;
};
class StartUserGameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<StartUserGameResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  StartUserGameResponseBody() {}

  explicit StartUserGameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        StartUserGameResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<StartUserGameResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartUserGameResponseBody() = default;
};
class StartUserGameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartUserGameResponseBody> body{};

  StartUserGameResponse() {}

  explicit StartUserGameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartUserGameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartUserGameResponseBody>(model1);
      }
    }
  }


  virtual ~StartUserGameResponse() = default;
};
class SubmitReturnGoodLogisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> cpCode{};
  shared_ptr<long> disputeId{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  SubmitReturnGoodLogisticsRequest() {}

  explicit SubmitReturnGoodLogisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (cpCode) {
      res["CpCode"] = boost::any(*cpCode);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("CpCode") != m.end() && !m["CpCode"].empty()) {
      cpCode = make_shared<string>(boost::any_cast<string>(m["CpCode"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~SubmitReturnGoodLogisticsRequest() = default;
};
class SubmitReturnGoodLogisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SubmitReturnGoodLogisticsResponseBody() {}

  explicit SubmitReturnGoodLogisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitReturnGoodLogisticsResponseBody() = default;
};
class SubmitReturnGoodLogisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitReturnGoodLogisticsResponseBody> body{};

  SubmitReturnGoodLogisticsResponse() {}

  explicit SubmitReturnGoodLogisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitReturnGoodLogisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitReturnGoodLogisticsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitReturnGoodLogisticsResponse() = default;
};
class SubmitReturnGoodLogisticsWithDesignatedTbUidRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> cpCode{};
  shared_ptr<long> disputeId{};
  shared_ptr<string> logisticsNo{};
  shared_ptr<string> subLmOrderId{};
  shared_ptr<string> tbAccountType{};
  shared_ptr<long> tbUserId{};
  shared_ptr<string> thirdPartyUserId{};

  SubmitReturnGoodLogisticsWithDesignatedTbUidRequest() {}

  explicit SubmitReturnGoodLogisticsWithDesignatedTbUidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (cpCode) {
      res["CpCode"] = boost::any(*cpCode);
    }
    if (disputeId) {
      res["DisputeId"] = boost::any(*disputeId);
    }
    if (logisticsNo) {
      res["LogisticsNo"] = boost::any(*logisticsNo);
    }
    if (subLmOrderId) {
      res["SubLmOrderId"] = boost::any(*subLmOrderId);
    }
    if (tbAccountType) {
      res["TbAccountType"] = boost::any(*tbAccountType);
    }
    if (tbUserId) {
      res["TbUserId"] = boost::any(*tbUserId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("CpCode") != m.end() && !m["CpCode"].empty()) {
      cpCode = make_shared<string>(boost::any_cast<string>(m["CpCode"]));
    }
    if (m.find("DisputeId") != m.end() && !m["DisputeId"].empty()) {
      disputeId = make_shared<long>(boost::any_cast<long>(m["DisputeId"]));
    }
    if (m.find("LogisticsNo") != m.end() && !m["LogisticsNo"].empty()) {
      logisticsNo = make_shared<string>(boost::any_cast<string>(m["LogisticsNo"]));
    }
    if (m.find("SubLmOrderId") != m.end() && !m["SubLmOrderId"].empty()) {
      subLmOrderId = make_shared<string>(boost::any_cast<string>(m["SubLmOrderId"]));
    }
    if (m.find("TbAccountType") != m.end() && !m["TbAccountType"].empty()) {
      tbAccountType = make_shared<string>(boost::any_cast<string>(m["TbAccountType"]));
    }
    if (m.find("TbUserId") != m.end() && !m["TbUserId"].empty()) {
      tbUserId = make_shared<long>(boost::any_cast<long>(m["TbUserId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
  }


  virtual ~SubmitReturnGoodLogisticsWithDesignatedTbUidRequest() = default;
};
class SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<boost::any> model{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody() {}

  explicit SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<boost::any>(boost::any_cast<boost::any>(m["Model"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody() = default;
};
class SubmitReturnGoodLogisticsWithDesignatedTbUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody> body{};

  SubmitReturnGoodLogisticsWithDesignatedTbUidResponse() {}

  explicit SubmitReturnGoodLogisticsWithDesignatedTbUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitReturnGoodLogisticsWithDesignatedTbUidResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitReturnGoodLogisticsWithDesignatedTbUidResponse() = default;
};
class SyncMerchantInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> itemList{};
  shared_ptr<string> sellerNick{};
  shared_ptr<string> taskId{};
  shared_ptr<long> timeStamp{};

  SyncMerchantInfoRequest() {}

  explicit SyncMerchantInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (itemList) {
      res["ItemList"] = boost::any(*itemList);
    }
    if (sellerNick) {
      res["SellerNick"] = boost::any(*sellerNick);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      itemList = make_shared<string>(boost::any_cast<string>(m["ItemList"]));
    }
    if (m.find("SellerNick") != m.end() && !m["SellerNick"].empty()) {
      sellerNick = make_shared<string>(boost::any_cast<string>(m["SellerNick"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SyncMerchantInfoRequest() = default;
};
class SyncMerchantInfoResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> url{};

  SyncMerchantInfoResponseBodyModel() {}

  explicit SyncMerchantInfoResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SyncMerchantInfoResponseBodyModel() = default;
};
class SyncMerchantInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<SyncMerchantInfoResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  SyncMerchantInfoResponseBody() {}

  explicit SyncMerchantInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        SyncMerchantInfoResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<SyncMerchantInfoResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncMerchantInfoResponseBody() = default;
};
class SyncMerchantInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncMerchantInfoResponseBody> body{};

  SyncMerchantInfoResponse() {}

  explicit SyncMerchantInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncMerchantInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncMerchantInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SyncMerchantInfoResponse() = default;
};
class UnFreezeUserPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  UnFreezeUserPointRequest() {}

  explicit UnFreezeUserPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UnFreezeUserPointRequest() = default;
};
class UnFreezeUserPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> extInfoShrink{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<string> title{};

  UnFreezeUserPointShrinkRequest() {}

  explicit UnFreezeUserPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (extInfoShrink) {
      res["ExtInfo"] = boost::any(*extInfoShrink);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      extInfoShrink = make_shared<string>(boost::any_cast<string>(m["ExtInfo"]));
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UnFreezeUserPointShrinkRequest() = default;
};
class UnFreezeUserPointResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> action{};
  shared_ptr<long> amount{};
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> extInfo{};
  shared_ptr<string> idempotentId{};
  shared_ptr<string> name{};
  shared_ptr<string> recordId{};
  shared_ptr<long> rest{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> status{};

  UnFreezeUserPointResponseBodyModel() {}

  explicit UnFreezeUserPointResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extInfo) {
      res["ExtInfo"] = boost::any(*extInfo);
    }
    if (idempotentId) {
      res["IdempotentId"] = boost::any(*idempotentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtInfo") != m.end() && !m["ExtInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IdempotentId") != m.end() && !m["IdempotentId"].empty()) {
      idempotentId = make_shared<string>(boost::any_cast<string>(m["IdempotentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<long>(boost::any_cast<long>(m["Rest"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UnFreezeUserPointResponseBodyModel() = default;
};
class UnFreezeUserPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<UnFreezeUserPointResponseBodyModel> model{};
  shared_ptr<string> requestId{};

  UnFreezeUserPointResponseBody() {}

  explicit UnFreezeUserPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        UnFreezeUserPointResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<UnFreezeUserPointResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnFreezeUserPointResponseBody() = default;
};
class UnFreezeUserPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnFreezeUserPointResponseBody> body{};

  UnFreezeUserPointResponse() {}

  explicit UnFreezeUserPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnFreezeUserPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnFreezeUserPointResponseBody>(model1);
      }
    }
  }


  virtual ~UnFreezeUserPointResponse() = default;
};
class UnsignWithholdAgreementRequest : public Darabonba::Model {
public:
  shared_ptr<string> agreementNo{};
  shared_ptr<string> externalAgreementNo{};
  shared_ptr<string> merchantId{};
  shared_ptr<string> outRequestNo{};

  UnsignWithholdAgreementRequest() {}

  explicit UnsignWithholdAgreementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementNo) {
      res["AgreementNo"] = boost::any(*agreementNo);
    }
    if (externalAgreementNo) {
      res["ExternalAgreementNo"] = boost::any(*externalAgreementNo);
    }
    if (merchantId) {
      res["MerchantId"] = boost::any(*merchantId);
    }
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementNo") != m.end() && !m["AgreementNo"].empty()) {
      agreementNo = make_shared<string>(boost::any_cast<string>(m["AgreementNo"]));
    }
    if (m.find("ExternalAgreementNo") != m.end() && !m["ExternalAgreementNo"].empty()) {
      externalAgreementNo = make_shared<string>(boost::any_cast<string>(m["ExternalAgreementNo"]));
    }
    if (m.find("MerchantId") != m.end() && !m["MerchantId"].empty()) {
      merchantId = make_shared<string>(boost::any_cast<string>(m["MerchantId"]));
    }
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
  }


  virtual ~UnsignWithholdAgreementRequest() = default;
};
class UnsignWithholdAgreementResponseBodyWithholdSignResponse : public Darabonba::Model {
public:
  shared_ptr<string> outRequestNo{};

  UnsignWithholdAgreementResponseBodyWithholdSignResponse() {}

  explicit UnsignWithholdAgreementResponseBodyWithholdSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outRequestNo) {
      res["OutRequestNo"] = boost::any(*outRequestNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutRequestNo") != m.end() && !m["OutRequestNo"].empty()) {
      outRequestNo = make_shared<string>(boost::any_cast<string>(m["OutRequestNo"]));
    }
  }


  virtual ~UnsignWithholdAgreementResponseBodyWithholdSignResponse() = default;
};
class UnsignWithholdAgreementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<UnsignWithholdAgreementResponseBodyWithholdSignResponse> withholdSignResponse{};

  UnsignWithholdAgreementResponseBody() {}

  explicit UnsignWithholdAgreementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (withholdSignResponse) {
      res["WithholdSignResponse"] = withholdSignResponse ? boost::any(withholdSignResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WithholdSignResponse") != m.end() && !m["WithholdSignResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["WithholdSignResponse"].type()) {
        UnsignWithholdAgreementResponseBodyWithholdSignResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WithholdSignResponse"]));
        withholdSignResponse = make_shared<UnsignWithholdAgreementResponseBodyWithholdSignResponse>(model1);
      }
    }
  }


  virtual ~UnsignWithholdAgreementResponseBody() = default;
};
class UnsignWithholdAgreementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnsignWithholdAgreementResponseBody> body{};

  UnsignWithholdAgreementResponse() {}

  explicit UnsignWithholdAgreementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnsignWithholdAgreementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnsignWithholdAgreementResponseBody>(model1);
      }
    }
  }


  virtual ~UnsignWithholdAgreementResponse() = default;
};
class UpdateAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressInfo{};
  shared_ptr<string> bizId{};
  shared_ptr<string> thirdPartyUserId{};
  shared_ptr<bool> useAnonymousTbAccount{};

  UpdateAddressRequest() {}

  explicit UpdateAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressInfo) {
      res["AddressInfo"] = boost::any(*addressInfo);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (thirdPartyUserId) {
      res["ThirdPartyUserId"] = boost::any(*thirdPartyUserId);
    }
    if (useAnonymousTbAccount) {
      res["UseAnonymousTbAccount"] = boost::any(*useAnonymousTbAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressInfo") != m.end() && !m["AddressInfo"].empty()) {
      addressInfo = make_shared<string>(boost::any_cast<string>(m["AddressInfo"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("ThirdPartyUserId") != m.end() && !m["ThirdPartyUserId"].empty()) {
      thirdPartyUserId = make_shared<string>(boost::any_cast<string>(m["ThirdPartyUserId"]));
    }
    if (m.find("UseAnonymousTbAccount") != m.end() && !m["UseAnonymousTbAccount"].empty()) {
      useAnonymousTbAccount = make_shared<bool>(boost::any_cast<bool>(m["UseAnonymousTbAccount"]));
    }
  }


  virtual ~UpdateAddressRequest() = default;
};
class UpdateAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateAddressResponseBody() {}

  explicit UpdateAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAddressResponseBody() = default;
};
class UpdateAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAddressResponseBody> body{};

  UpdateAddressResponse() {}

  explicit UpdateAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAddressResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAddressResponse() = default;
};
class ValidateTaobaoAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> bizUid{};
  shared_ptr<string> extJson{};
  shared_ptr<string> mobileNo{};
  shared_ptr<string> tbUserNick{};

  ValidateTaobaoAccountRequest() {}

  explicit ValidateTaobaoAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (bizUid) {
      res["BizUid"] = boost::any(*bizUid);
    }
    if (extJson) {
      res["ExtJson"] = boost::any(*extJson);
    }
    if (mobileNo) {
      res["MobileNo"] = boost::any(*mobileNo);
    }
    if (tbUserNick) {
      res["TbUserNick"] = boost::any(*tbUserNick);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("BizUid") != m.end() && !m["BizUid"].empty()) {
      bizUid = make_shared<string>(boost::any_cast<string>(m["BizUid"]));
    }
    if (m.find("ExtJson") != m.end() && !m["ExtJson"].empty()) {
      extJson = make_shared<string>(boost::any_cast<string>(m["ExtJson"]));
    }
    if (m.find("MobileNo") != m.end() && !m["MobileNo"].empty()) {
      mobileNo = make_shared<string>(boost::any_cast<string>(m["MobileNo"]));
    }
    if (m.find("TbUserNick") != m.end() && !m["TbUserNick"].empty()) {
      tbUserNick = make_shared<string>(boost::any_cast<string>(m["TbUserNick"]));
    }
  }


  virtual ~ValidateTaobaoAccountRequest() = default;
};
class ValidateTaobaoAccountResponseBodyModel : public Darabonba::Model {
public:
  shared_ptr<bool> match{};

  ValidateTaobaoAccountResponseBodyModel() {}

  explicit ValidateTaobaoAccountResponseBodyModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (match) {
      res["Match"] = boost::any(*match);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      match = make_shared<bool>(boost::any_cast<bool>(m["Match"]));
    }
  }


  virtual ~ValidateTaobaoAccountResponseBodyModel() = default;
};
class ValidateTaobaoAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logsId{};
  shared_ptr<string> message{};
  shared_ptr<ValidateTaobaoAccountResponseBodyModel> model{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subCode{};
  shared_ptr<string> subMessage{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ValidateTaobaoAccountResponseBody() {}

  explicit ValidateTaobaoAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logsId) {
      res["LogsId"] = boost::any(*logsId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = model ? boost::any(model->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCode) {
      res["SubCode"] = boost::any(*subCode);
    }
    if (subMessage) {
      res["SubMessage"] = boost::any(*subMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogsId") != m.end() && !m["LogsId"].empty()) {
      logsId = make_shared<string>(boost::any_cast<string>(m["LogsId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      if (typeid(map<string, boost::any>) == m["Model"].type()) {
        ValidateTaobaoAccountResponseBodyModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Model"]));
        model = make_shared<ValidateTaobaoAccountResponseBodyModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCode") != m.end() && !m["SubCode"].empty()) {
      subCode = make_shared<string>(boost::any_cast<string>(m["SubCode"]));
    }
    if (m.find("SubMessage") != m.end() && !m["SubMessage"].empty()) {
      subMessage = make_shared<string>(boost::any_cast<string>(m["SubMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ValidateTaobaoAccountResponseBody() = default;
};
class ValidateTaobaoAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateTaobaoAccountResponseBody> body{};

  ValidateTaobaoAccountResponse() {}

  explicit ValidateTaobaoAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateTaobaoAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateTaobaoAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateTaobaoAccountResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAddressResponse addAddressWithOptions(shared_ptr<AddAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAddressResponse addAddress(shared_ptr<AddAddressRequest> request);
  AddItemLimitRuleResponse addItemLimitRuleWithOptions(shared_ptr<AddItemLimitRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddItemLimitRuleResponse addItemLimitRule(shared_ptr<AddItemLimitRuleRequest> request);
  AddItemToSubBizsResponse addItemToSubBizsWithOptions(shared_ptr<AddItemToSubBizsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddItemToSubBizsResponse addItemToSubBizs(shared_ptr<AddItemToSubBizsRequest> request);
  AddSupplierNewItemsResponse addSupplierNewItemsWithOptions(shared_ptr<AddSupplierNewItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSupplierNewItemsResponse addSupplierNewItems(shared_ptr<AddSupplierNewItemsRequest> request);
  ApplyRefundResponse applyRefundWithOptions(shared_ptr<ApplyRefundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyRefundResponse applyRefund(shared_ptr<ApplyRefundRequest> request);
  ApplyRefundWithDesignatedTbUidResponse applyRefundWithDesignatedTbUidWithOptions(shared_ptr<ApplyRefundWithDesignatedTbUidRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyRefundWithDesignatedTbUidResponse applyRefundWithDesignatedTbUid(shared_ptr<ApplyRefundWithDesignatedTbUidRequest> request);
  BatchRegistAnonymousTbAccountResponse batchRegistAnonymousTbAccountWithOptions(shared_ptr<BatchRegistAnonymousTbAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchRegistAnonymousTbAccountResponse batchRegistAnonymousTbAccount(shared_ptr<BatchRegistAnonymousTbAccountRequest> request);
  CancelOrderResponse cancelOrderWithOptions(shared_ptr<CancelOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOrderResponse cancelOrder(shared_ptr<CancelOrderRequest> request);
  CancelOrderWithDesignatedTbUidResponse cancelOrderWithDesignatedTbUidWithOptions(shared_ptr<CancelOrderWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOrderWithDesignatedTbUidResponse cancelOrderWithDesignatedTbUid(shared_ptr<CancelOrderWithDesignatedTbUidRequest> request);
  CancelRealTbAccountSupportResponse cancelRealTbAccountSupportWithOptions(shared_ptr<CancelRealTbAccountSupportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelRealTbAccountSupportResponse cancelRealTbAccountSupport(shared_ptr<CancelRealTbAccountSupportRequest> request);
  CancelRefundResponse cancelRefundWithOptions(shared_ptr<CancelRefundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelRefundResponse cancelRefund(shared_ptr<CancelRefundRequest> request);
  CancelRefundWithDesignatedTbUidResponse cancelRefundWithDesignatedTbUidWithOptions(shared_ptr<CancelRefundWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelRefundWithDesignatedTbUidResponse cancelRefundWithDesignatedTbUid(shared_ptr<CancelRefundWithDesignatedTbUidRequest> request);
  ConfirmDisburseResponse confirmDisburseWithOptions(shared_ptr<ConfirmDisburseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmDisburseResponse confirmDisburse(shared_ptr<ConfirmDisburseRequest> request);
  ConfirmDisburseWithDesignatedTbUidResponse confirmDisburseWithDesignatedTbUidWithOptions(shared_ptr<ConfirmDisburseWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmDisburseWithDesignatedTbUidResponse confirmDisburseWithDesignatedTbUid(shared_ptr<ConfirmDisburseWithDesignatedTbUidRequest> request);
  CreateMovieTicketOrderResponse createMovieTicketOrderWithOptions(shared_ptr<CreateMovieTicketOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMovieTicketOrderResponse createMovieTicketOrder(shared_ptr<CreateMovieTicketOrderRequest> request);
  CreateOrderResponse createOrderWithOptions(shared_ptr<CreateOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderResponse createOrder(shared_ptr<CreateOrderRequest> request);
  CreateOrderPayUrlForOutDiscountResponse createOrderPayUrlForOutDiscountWithOptions(shared_ptr<CreateOrderPayUrlForOutDiscountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderPayUrlForOutDiscountResponse createOrderPayUrlForOutDiscount(shared_ptr<CreateOrderPayUrlForOutDiscountRequest> request);
  CreateOrderTransactionDetailFileResponse createOrderTransactionDetailFileWithOptions(shared_ptr<CreateOrderTransactionDetailFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderTransactionDetailFileResponse createOrderTransactionDetailFile(shared_ptr<CreateOrderTransactionDetailFileRequest> request);
  CreateOrderV2Response createOrderV2WithOptions(shared_ptr<CreateOrderV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderV2Response createOrderV2(shared_ptr<CreateOrderV2Request> request);
  CreateOrderWithDesignatedTbUidResponse createOrderWithDesignatedTbUidWithOptions(shared_ptr<CreateOrderWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrderWithDesignatedTbUidResponse createOrderWithDesignatedTbUid(shared_ptr<CreateOrderWithDesignatedTbUidRequest> request);
  CreateOutDiscountOrderWithDesignatedTbUidResponse createOutDiscountOrderWithDesignatedTbUidWithOptions(shared_ptr<CreateOutDiscountOrderWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOutDiscountOrderWithDesignatedTbUidResponse createOutDiscountOrderWithDesignatedTbUid(shared_ptr<CreateOutDiscountOrderWithDesignatedTbUidRequest> request);
  CreatePayUrlResponse createPayUrlWithOptions(shared_ptr<CreatePayUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePayUrlResponse createPayUrl(shared_ptr<CreatePayUrlRequest> request);
  CreateSettleConfirmResponse createSettleConfirmWithOptions(shared_ptr<CreateSettleConfirmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSettleConfirmResponse createSettleConfirm(shared_ptr<CreateSettleConfirmRequest> request);
  CreateVirtualProductOrderResponse createVirtualProductOrderWithOptions(shared_ptr<CreateVirtualProductOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVirtualProductOrderResponse createVirtualProductOrder(shared_ptr<CreateVirtualProductOrderRequest> request);
  CreateWithholdTradeResponse createWithholdTradeWithOptions(shared_ptr<CreateWithholdTradeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateWithholdTradeResponse createWithholdTrade(shared_ptr<CreateWithholdTradeRequest> request);
  DeductUserPointResponse deductUserPointWithOptions(shared_ptr<DeductUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeductUserPointResponse deductUserPoint(shared_ptr<DeductUserPointRequest> request);
  DeleteBizItemsResponse deleteBizItemsWithOptions(shared_ptr<DeleteBizItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBizItemsResponse deleteBizItems(shared_ptr<DeleteBizItemsRequest> request);
  DeleteItemLimitRuleResponse deleteItemLimitRuleWithOptions(shared_ptr<DeleteItemLimitRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteItemLimitRuleResponse deleteItemLimitRule(shared_ptr<DeleteItemLimitRuleRequest> request);
  DownloadCpsBillFileResponse downloadCpsBillFileWithOptions(shared_ptr<DownloadCpsBillFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadCpsBillFileResponse downloadCpsBillFile(shared_ptr<DownloadCpsBillFileRequest> request);
  DownloadItemBillFileResponse downloadItemBillFileWithOptions(shared_ptr<DownloadItemBillFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadItemBillFileResponse downloadItemBillFile(shared_ptr<DownloadItemBillFileRequest> request);
  DownloadOrderTransactionDetailFileResponse downloadOrderTransactionDetailFileWithOptions(shared_ptr<DownloadOrderTransactionDetailFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadOrderTransactionDetailFileResponse downloadOrderTransactionDetailFile(shared_ptr<DownloadOrderTransactionDetailFileRequest> request);
  EnableOrderResponse enableOrderWithOptions(shared_ptr<EnableOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableOrderResponse enableOrder(shared_ptr<EnableOrderRequest> request);
  EnableOrderWithDesignatedTbUidResponse enableOrderWithDesignatedTbUidWithOptions(shared_ptr<EnableOrderWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableOrderWithDesignatedTbUidResponse enableOrderWithDesignatedTbUid(shared_ptr<EnableOrderWithDesignatedTbUidRequest> request);
  ExecuteNodeResponse executeNodeWithOptions(shared_ptr<ExecuteNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteNodeResponse executeNode(shared_ptr<ExecuteNodeRequest> request);
  FreezeUserPointResponse freezeUserPointWithOptions(shared_ptr<FreezeUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FreezeUserPointResponse freezeUserPoint(shared_ptr<FreezeUserPointRequest> request);
  GetActivityGameInfoResponse getActivityGameInfoWithOptions(shared_ptr<GetActivityGameInfoRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetActivityGameInfoResponse getActivityGameInfo(shared_ptr<GetActivityGameInfoRequest> request);
  GetCategoryChainResponse getCategoryChainWithOptions(shared_ptr<GetCategoryChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoryChainResponse getCategoryChain(shared_ptr<GetCategoryChainRequest> request);
  GetCategoryListResponse getCategoryListWithOptions(shared_ptr<GetCategoryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoryListResponse getCategoryList(shared_ptr<GetCategoryListRequest> request);
  GetCustomServiceUrlResponse getCustomServiceUrlWithOptions(shared_ptr<GetCustomServiceUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomServiceUrlResponse getCustomServiceUrl(shared_ptr<GetCustomServiceUrlRequest> request);
  GetGuidePageResponse getGuidePageWithOptions(shared_ptr<GetGuidePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGuidePageResponse getGuidePage(shared_ptr<GetGuidePageRequest> request);
  GetItemPromotionResponse getItemPromotionWithOptions(shared_ptr<GetItemPromotionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetItemPromotionResponse getItemPromotion(shared_ptr<GetItemPromotionRequest> request);
  GetLoginPageResponse getLoginPageWithOptions(shared_ptr<GetLoginPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoginPageResponse getLoginPage(shared_ptr<GetLoginPageRequest> request);
  GetSwitchUrlResponse getSwitchUrlWithOptions(shared_ptr<GetSwitchUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSwitchUrlResponse getSwitchUrl(shared_ptr<GetSwitchUrlRequest> request);
  GetUserInfoResponse getUserInfoWithOptions(shared_ptr<GetUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserInfoResponse getUserInfo(shared_ptr<GetUserInfoRequest> request);
  GetUserTokenPageResponse getUserTokenPageWithOptions(shared_ptr<GetUserTokenPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserTokenPageResponse getUserTokenPage(shared_ptr<GetUserTokenPageRequest> request);
  GetWithholdSignPageUrlResponse getWithholdSignPageUrlWithOptions(shared_ptr<GetWithholdSignPageUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWithholdSignPageUrlResponse getWithholdSignPageUrl(shared_ptr<GetWithholdSignPageUrlRequest> request);
  GiveUserPointResponse giveUserPointWithOptions(shared_ptr<GiveUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GiveUserPointResponse giveUserPoint(shared_ptr<GiveUserPointRequest> request);
  GrantPromotionToUserResponse grantPromotionToUserWithOptions(shared_ptr<GrantPromotionToUserRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantPromotionToUserResponse grantPromotionToUser(shared_ptr<GrantPromotionToUserRequest> request);
  GrantUserPointResponse grantUserPointWithOptions(shared_ptr<GrantUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantUserPointResponse grantUserPoint(shared_ptr<GrantUserPointRequest> request);
  InitApplyRefundResponse initApplyRefundWithOptions(shared_ptr<InitApplyRefundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitApplyRefundResponse initApplyRefund(shared_ptr<InitApplyRefundRequest> request);
  InitApplyRefundWithDesignatedTbUidResponse initApplyRefundWithDesignatedTbUidWithOptions(shared_ptr<InitApplyRefundWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitApplyRefundWithDesignatedTbUidResponse initApplyRefundWithDesignatedTbUid(shared_ptr<InitApplyRefundWithDesignatedTbUidRequest> request);
  InitModifyRefundResponse initModifyRefundWithOptions(shared_ptr<InitModifyRefundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitModifyRefundResponse initModifyRefund(shared_ptr<InitModifyRefundRequest> request);
  InitModifyRefundWithDesignatedTbUidResponse initModifyRefundWithDesignatedTbUidWithOptions(shared_ptr<InitModifyRefundWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitModifyRefundWithDesignatedTbUidResponse initModifyRefundWithDesignatedTbUid(shared_ptr<InitModifyRefundWithDesignatedTbUidRequest> request);
  ListActivityAtmosphereResponse listActivityAtmosphereWithOptions(shared_ptr<ListActivityAtmosphereRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListActivityAtmosphereResponse listActivityAtmosphere(shared_ptr<ListActivityAtmosphereRequest> request);
  ListActivityGameInfoResponse listActivityGameInfoWithOptions(shared_ptr<ListActivityGameInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListActivityGameInfoResponse listActivityGameInfo(shared_ptr<ListActivityGameInfoRequest> request);
  ListItemActivitiesResponse listItemActivitiesWithOptions(shared_ptr<ListItemActivitiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListItemActivitiesResponse listItemActivities(shared_ptr<ListItemActivitiesRequest> request);
  ListUserGameProcessResponse listUserGameProcessWithOptions(shared_ptr<ListUserGameProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserGameProcessResponse listUserGameProcess(shared_ptr<ListUserGameProcessRequest> request);
  ListUserPointRecordsResponse listUserPointRecordsWithOptions(shared_ptr<ListUserPointRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserPointRecordsResponse listUserPointRecords(shared_ptr<ListUserPointRecordsRequest> request);
  ModifyBasicAndBizItemsResponse modifyBasicAndBizItemsWithOptions(shared_ptr<ModifyBasicAndBizItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBasicAndBizItemsResponse modifyBasicAndBizItems(shared_ptr<ModifyBasicAndBizItemsRequest> request);
  ModifyBasicItemSupplierPriceResponse modifyBasicItemSupplierPriceWithOptions(shared_ptr<ModifyBasicItemSupplierPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBasicItemSupplierPriceResponse modifyBasicItemSupplierPrice(shared_ptr<ModifyBasicItemSupplierPriceRequest> request);
  ModifyBizItemsResponse modifyBizItemsWithOptions(shared_ptr<ModifyBizItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBizItemsResponse modifyBizItems(shared_ptr<ModifyBizItemsRequest> request);
  ModifyItemLimitRuleResponse modifyItemLimitRuleWithOptions(shared_ptr<ModifyItemLimitRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyItemLimitRuleResponse modifyItemLimitRule(shared_ptr<ModifyItemLimitRuleRequest> request);
  ModifyOrderDeliveryAddressResponse modifyOrderDeliveryAddressWithOptions(shared_ptr<ModifyOrderDeliveryAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOrderDeliveryAddressResponse modifyOrderDeliveryAddress(shared_ptr<ModifyOrderDeliveryAddressRequest> request);
  ModifyRefundResponse modifyRefundWithOptions(shared_ptr<ModifyRefundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRefundResponse modifyRefund(shared_ptr<ModifyRefundRequest> request);
  ModifyRefundWithDesignatedTbUidResponse modifyRefundWithDesignatedTbUidWithOptions(shared_ptr<ModifyRefundWithDesignatedTbUidRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRefundWithDesignatedTbUidResponse modifyRefundWithDesignatedTbUid(shared_ptr<ModifyRefundWithDesignatedTbUidRequest> request);
  ModifySettleAccountResponse modifySettleAccountWithOptions(shared_ptr<ModifySettleAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySettleAccountResponse modifySettleAccount(shared_ptr<ModifySettleAccountRequest> request);
  ModifySupplierPriceAndPriceCentResponse modifySupplierPriceAndPriceCentWithOptions(shared_ptr<ModifySupplierPriceAndPriceCentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySupplierPriceAndPriceCentResponse modifySupplierPriceAndPriceCent(shared_ptr<ModifySupplierPriceAndPriceCentRequest> request);
  NotifyPayOrderStatusResponse notifyPayOrderStatusWithOptions(shared_ptr<NotifyPayOrderStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  NotifyPayOrderStatusResponse notifyPayOrderStatus(shared_ptr<NotifyPayOrderStatusRequest> request);
  NotifyWithholdFundResponse notifyWithholdFundWithOptions(shared_ptr<NotifyWithholdFundRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  NotifyWithholdFundResponse notifyWithholdFund(shared_ptr<NotifyWithholdFundRequest> request);
  OpenRealTbAccountSupportResponse openRealTbAccountSupportWithOptions(shared_ptr<OpenRealTbAccountSupportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenRealTbAccountSupportResponse openRealTbAccountSupport(shared_ptr<OpenRealTbAccountSupportRequest> request);
  PushUserGameProcessResponse pushUserGameProcessWithOptions(shared_ptr<PushUserGameProcessRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushUserGameProcessResponse pushUserGameProcess(shared_ptr<PushUserGameProcessRequest> request);
  QueryActivityItemsResponse queryActivityItemsWithOptions(shared_ptr<QueryActivityItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryActivityItemsResponse queryActivityItems(shared_ptr<QueryActivityItemsRequest> request);
  QueryAddressResponse queryAddressWithOptions(shared_ptr<QueryAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAddressResponse queryAddress(shared_ptr<QueryAddressRequest> request);
  QueryAddressDetailResponse queryAddressDetailWithOptions(shared_ptr<QueryAddressDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAddressDetailResponse queryAddressDetail(shared_ptr<QueryAddressDetailRequest> request);
  QueryAddressListResponse queryAddressListWithOptions(shared_ptr<QueryAddressListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAddressListResponse queryAddressList(shared_ptr<QueryAddressListRequest> request);
  QueryAdvertisementSettleInfoResponse queryAdvertisementSettleInfoWithOptions(shared_ptr<QueryAdvertisementSettleInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAdvertisementSettleInfoResponse queryAdvertisementSettleInfo(shared_ptr<QueryAdvertisementSettleInfoRequest> request);
  QueryAgreementResponse queryAgreementWithOptions(shared_ptr<QueryAgreementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAgreementResponse queryAgreement(shared_ptr<QueryAgreementRequest> request);
  QueryAllCinemasResponse queryAllCinemasWithOptions(shared_ptr<QueryAllCinemasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAllCinemasResponse queryAllCinemas(shared_ptr<QueryAllCinemasRequest> request);
  QueryAllCitiesResponse queryAllCitiesWithOptions(shared_ptr<QueryAllCitiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAllCitiesResponse queryAllCities(shared_ptr<QueryAllCitiesRequest> request);
  QueryBatchRegistAnonymousTbAccountResultResponse queryBatchRegistAnonymousTbAccountResultWithOptions(shared_ptr<QueryBatchRegistAnonymousTbAccountResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBatchRegistAnonymousTbAccountResultResponse queryBatchRegistAnonymousTbAccountResult(shared_ptr<QueryBatchRegistAnonymousTbAccountResultRequest> request);
  QueryBestSession4ItemsResponse queryBestSession4ItemsWithOptions(shared_ptr<QueryBestSession4ItemsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBestSession4ItemsResponse queryBestSession4Items(shared_ptr<QueryBestSession4ItemsRequest> request);
  QueryBizItemListResponse queryBizItemListWithOptions(shared_ptr<QueryBizItemListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBizItemListResponse queryBizItemList(shared_ptr<QueryBizItemListRequest> request);
  QueryBizItemListV2Response queryBizItemListV2WithOptions(shared_ptr<QueryBizItemListV2Request> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBizItemListV2Response queryBizItemListV2(shared_ptr<QueryBizItemListV2Request> request);
  QueryBizItemListWithCacheResponse queryBizItemListWithCacheWithOptions(shared_ptr<QueryBizItemListWithCacheRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBizItemListWithCacheResponse queryBizItemListWithCache(shared_ptr<QueryBizItemListWithCacheRequest> request);
  QueryBizItemsResponse queryBizItemsWithOptions(shared_ptr<QueryBizItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBizItemsResponse queryBizItems(shared_ptr<QueryBizItemsRequest> request);
  QueryBizItemsWithActivityResponse queryBizItemsWithActivityWithOptions(shared_ptr<QueryBizItemsWithActivityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBizItemsWithActivityResponse queryBizItemsWithActivity(shared_ptr<QueryBizItemsWithActivityRequest> request);
  QueryBudgetTicketItemListByBizIdResponse queryBudgetTicketItemListByBizIdWithOptions(shared_ptr<QueryBudgetTicketItemListByBizIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBudgetTicketItemListByBizIdResponse queryBudgetTicketItemListByBizId(shared_ptr<QueryBudgetTicketItemListByBizIdRequest> request);
  QueryChannelItemBillDownloadUrlResponse queryChannelItemBillDownloadUrlWithOptions(shared_ptr<QueryChannelItemBillDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryChannelItemBillDownloadUrlResponse queryChannelItemBillDownloadUrl(shared_ptr<QueryChannelItemBillDownloadUrlRequest> request);
  QueryGuideItemGroupResponse queryGuideItemGroupWithOptions(shared_ptr<QueryGuideItemGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGuideItemGroupResponse queryGuideItemGroup(shared_ptr<QueryGuideItemGroupRequest> request);
  QueryGuideItemGroupForCrowdOperationResponse queryGuideItemGroupForCrowdOperationWithOptions(shared_ptr<QueryGuideItemGroupForCrowdOperationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGuideItemGroupForCrowdOperationResponse queryGuideItemGroupForCrowdOperation(shared_ptr<QueryGuideItemGroupForCrowdOperationRequest> request);
  QueryGuideItemGroupWithOutInventoryResponse queryGuideItemGroupWithOutInventoryWithOptions(shared_ptr<QueryGuideItemGroupWithOutInventoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGuideItemGroupWithOutInventoryResponse queryGuideItemGroupWithOutInventory(shared_ptr<QueryGuideItemGroupWithOutInventoryRequest> request);
  QueryHotMoviesResponse queryHotMoviesWithOptions(shared_ptr<QueryHotMoviesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryHotMoviesResponse queryHotMovies(shared_ptr<QueryHotMoviesRequest> request);
  QueryInventoryOfItemsInBizItemGroupResponse queryInventoryOfItemsInBizItemGroupWithOptions(shared_ptr<QueryInventoryOfItemsInBizItemGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInventoryOfItemsInBizItemGroupResponse queryInventoryOfItemsInBizItemGroup(shared_ptr<QueryInventoryOfItemsInBizItemGroupRequest> request);
  QueryItemDetailResponse queryItemDetailWithOptions(shared_ptr<QueryItemDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemDetailResponse queryItemDetail(shared_ptr<QueryItemDetailRequest> request);
  QueryItemDetailInnerResponse queryItemDetailInnerWithOptions(shared_ptr<QueryItemDetailInnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemDetailInnerResponse queryItemDetailInner(shared_ptr<QueryItemDetailInnerRequest> request);
  QueryItemDetailTeaResponse queryItemDetailTeaWithOptions(shared_ptr<QueryItemDetailTeaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemDetailTeaResponse queryItemDetailTea(shared_ptr<QueryItemDetailTeaRequest> request);
  QueryItemInSubBizsResponse queryItemInSubBizsWithOptions(shared_ptr<QueryItemInSubBizsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemInSubBizsResponse queryItemInSubBizs(shared_ptr<QueryItemInSubBizsRequest> request);
  QueryItemInventoryResponse queryItemInventoryWithOptions(shared_ptr<QueryItemInventoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemInventoryResponse queryItemInventory(shared_ptr<QueryItemInventoryRequest> request);
  QueryItemInventoryV2Response queryItemInventoryV2WithOptions(shared_ptr<QueryItemInventoryV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemInventoryV2Response queryItemInventoryV2(shared_ptr<QueryItemInventoryV2Request> request);
  QueryItemNextCycleRestrictionResponse queryItemNextCycleRestrictionWithOptions(shared_ptr<QueryItemNextCycleRestrictionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryItemNextCycleRestrictionResponse queryItemNextCycleRestriction(shared_ptr<QueryItemNextCycleRestrictionRequest> request);
  QueryLogisticsResponse queryLogisticsWithOptions(shared_ptr<QueryLogisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLogisticsResponse queryLogistics(shared_ptr<QueryLogisticsRequest> request);
  QueryMediaSettleInfoResponse queryMediaSettleInfoWithOptions(shared_ptr<QueryMediaSettleInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaSettleInfoResponse queryMediaSettleInfo(shared_ptr<QueryMediaSettleInfoRequest> request);
  QueryMessagesResponse queryMessagesWithOptions(shared_ptr<QueryMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMessagesResponse queryMessages(shared_ptr<QueryMessagesRequest> request);
  QueryMovieCommentsResponse queryMovieCommentsWithOptions(shared_ptr<QueryMovieCommentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMovieCommentsResponse queryMovieComments(shared_ptr<QueryMovieCommentsRequest> request);
  QueryMovieSchedulesResponse queryMovieSchedulesWithOptions(shared_ptr<QueryMovieSchedulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMovieSchedulesResponse queryMovieSchedules(shared_ptr<QueryMovieSchedulesRequest> request);
  QueryMovieSeatsResponse queryMovieSeatsWithOptions(shared_ptr<QueryMovieSeatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMovieSeatsResponse queryMovieSeats(shared_ptr<QueryMovieSeatsRequest> request);
  QueryMovieTicketsResponse queryMovieTicketsWithOptions(shared_ptr<QueryMovieTicketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMovieTicketsResponse queryMovieTickets(shared_ptr<QueryMovieTicketsRequest> request);
  QueryOrderAndPaymentListResponse queryOrderAndPaymentListWithOptions(shared_ptr<QueryOrderAndPaymentListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderAndPaymentListResponse queryOrderAndPaymentList(shared_ptr<QueryOrderAndPaymentListRequest> request);
  QueryOrderAndPaymentListWithDesignatedTbUidResponse queryOrderAndPaymentListWithDesignatedTbUidWithOptions(shared_ptr<QueryOrderAndPaymentListWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderAndPaymentListWithDesignatedTbUidResponse queryOrderAndPaymentListWithDesignatedTbUid(shared_ptr<QueryOrderAndPaymentListWithDesignatedTbUidRequest> request);
  QueryOrderCommissionRateResponse queryOrderCommissionRateWithOptions(shared_ptr<QueryOrderCommissionRateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderCommissionRateResponse queryOrderCommissionRate(shared_ptr<QueryOrderCommissionRateRequest> request);
  QueryOrderDetailInnerResponse queryOrderDetailInnerWithOptions(shared_ptr<QueryOrderDetailInnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderDetailInnerResponse queryOrderDetailInner(shared_ptr<QueryOrderDetailInnerRequest> request);
  QueryOrderIdByPayIdResponse queryOrderIdByPayIdWithOptions(shared_ptr<QueryOrderIdByPayIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderIdByPayIdResponse queryOrderIdByPayId(shared_ptr<QueryOrderIdByPayIdRequest> request);
  QueryOrderInfoAfterSaleResponse queryOrderInfoAfterSaleWithOptions(shared_ptr<QueryOrderInfoAfterSaleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderInfoAfterSaleResponse queryOrderInfoAfterSale(shared_ptr<QueryOrderInfoAfterSaleRequest> request);
  QueryOrderItemInfoByPaymentIdForAiZhanYouResponse queryOrderItemInfoByPaymentIdForAiZhanYouWithOptions(shared_ptr<QueryOrderItemInfoByPaymentIdForAiZhanYouRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderItemInfoByPaymentIdForAiZhanYouResponse queryOrderItemInfoByPaymentIdForAiZhanYou(shared_ptr<QueryOrderItemInfoByPaymentIdForAiZhanYouRequest> request);
  QueryOrderListResponse queryOrderListWithOptions(shared_ptr<QueryOrderListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderListResponse queryOrderList(shared_ptr<QueryOrderListRequest> request);
  QueryOrderListWithDesignatedTbUidResponse queryOrderListWithDesignatedTbUidWithOptions(shared_ptr<QueryOrderListWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderListWithDesignatedTbUidResponse queryOrderListWithDesignatedTbUid(shared_ptr<QueryOrderListWithDesignatedTbUidRequest> request);
  QueryOrderLogisticsResponse queryOrderLogisticsWithOptions(shared_ptr<QueryOrderLogisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderLogisticsResponse queryOrderLogistics(shared_ptr<QueryOrderLogisticsRequest> request);
  QueryOrderLogisticsWithDesignatedTbUidResponse queryOrderLogisticsWithDesignatedTbUidWithOptions(shared_ptr<QueryOrderLogisticsWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrderLogisticsWithDesignatedTbUidResponse queryOrderLogisticsWithDesignatedTbUid(shared_ptr<QueryOrderLogisticsWithDesignatedTbUidRequest> request);
  QueryRealTbAccountSupportResponse queryRealTbAccountSupportWithOptions(shared_ptr<QueryRealTbAccountSupportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRealTbAccountSupportResponse queryRealTbAccountSupport(shared_ptr<QueryRealTbAccountSupportRequest> request);
  QueryRefundApplicationDetailResponse queryRefundApplicationDetailWithOptions(shared_ptr<QueryRefundApplicationDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRefundApplicationDetailResponse queryRefundApplicationDetail(shared_ptr<QueryRefundApplicationDetailRequest> request);
  QueryRefundApplyWithDesignatedTbUidResponse queryRefundApplyWithDesignatedTbUidWithOptions(shared_ptr<QueryRefundApplyWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRefundApplyWithDesignatedTbUidResponse queryRefundApplyWithDesignatedTbUid(shared_ptr<QueryRefundApplyWithDesignatedTbUidRequest> request);
  QuerySellerLicenseResponse querySellerLicenseWithOptions(shared_ptr<QuerySellerLicenseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySellerLicenseResponse querySellerLicense(shared_ptr<QuerySellerLicenseRequest> request);
  QueryStatementsResponse queryStatementsWithOptions(shared_ptr<QueryStatementsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStatementsResponse queryStatements(shared_ptr<QueryStatementsRequest> request);
  QuerySupplierItemBillDownloadUrlResponse querySupplierItemBillDownloadUrlWithOptions(shared_ptr<QuerySupplierItemBillDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySupplierItemBillDownloadUrlResponse querySupplierItemBillDownloadUrl(shared_ptr<QuerySupplierItemBillDownloadUrlRequest> request);
  QueryUnfinishedActivitiesResponse queryUnfinishedActivitiesWithOptions(shared_ptr<QueryUnfinishedActivitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUnfinishedActivitiesResponse queryUnfinishedActivities(shared_ptr<QueryUnfinishedActivitiesRequest> request);
  QueryUnfinishedSessionsResponse queryUnfinishedSessionsWithOptions(shared_ptr<QueryUnfinishedSessionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUnfinishedSessionsResponse queryUnfinishedSessions(shared_ptr<QueryUnfinishedSessionsRequest> request);
  QueryUnfinishedSessions4ItemsResponse queryUnfinishedSessions4ItemsWithOptions(shared_ptr<QueryUnfinishedSessions4ItemsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUnfinishedSessions4ItemsResponse queryUnfinishedSessions4Items(shared_ptr<QueryUnfinishedSessions4ItemsRequest> request);
  QueryUpcomingMoviesResponse queryUpcomingMoviesWithOptions(shared_ptr<QueryUpcomingMoviesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUpcomingMoviesResponse queryUpcomingMovies(shared_ptr<QueryUpcomingMoviesRequest> request);
  QueryUserAccountResponse queryUserAccountWithOptions(shared_ptr<QueryUserAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUserAccountResponse queryUserAccount(shared_ptr<QueryUserAccountRequest> request);
  QueryUserGameProcessResponse queryUserGameProcessWithOptions(shared_ptr<QueryUserGameProcessRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUserGameProcessResponse queryUserGameProcess(shared_ptr<QueryUserGameProcessRequest> request);
  QueryUserPointResponse queryUserPointWithOptions(shared_ptr<QueryUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryUserPointResponse queryUserPoint(shared_ptr<QueryUserPointRequest> request);
  QueryWithholdTradeResponse queryWithholdTradeWithOptions(shared_ptr<QueryWithholdTradeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryWithholdTradeResponse queryWithholdTrade(shared_ptr<QueryWithholdTradeRequest> request);
  RebindTbAccountResponse rebindTbAccountWithOptions(shared_ptr<RebindTbAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebindTbAccountResponse rebindTbAccount(shared_ptr<RebindTbAccountRequest> request);
  RefreshSettlementOrderAccountResponse refreshSettlementOrderAccountWithOptions(shared_ptr<RefreshSettlementOrderAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshSettlementOrderAccountResponse refreshSettlementOrderAccount(shared_ptr<RefreshSettlementOrderAccountRequest> request);
  RefundOrderResponse refundOrderWithOptions(shared_ptr<RefundOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefundOrderResponse refundOrder(shared_ptr<RefundOrderRequest> request);
  RefundPointResponse refundPointWithOptions(shared_ptr<RefundPointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefundPointResponse refundPoint(shared_ptr<RefundPointRequest> request);
  RefundUserPointResponse refundUserPointWithOptions(shared_ptr<RefundUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefundUserPointResponse refundUserPoint(shared_ptr<RefundUserPointRequest> request);
  RefuseMerchantSyncTaskResponse refuseMerchantSyncTaskWithOptions(shared_ptr<RefuseMerchantSyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefuseMerchantSyncTaskResponse refuseMerchantSyncTask(shared_ptr<RefuseMerchantSyncTaskRequest> request);
  RegistAnonymousTbAccountResponse registAnonymousTbAccountWithOptions(shared_ptr<RegistAnonymousTbAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegistAnonymousTbAccountResponse registAnonymousTbAccount(shared_ptr<RegistAnonymousTbAccountRequest> request);
  RegisterSettleAccountResponse registerSettleAccountWithOptions(shared_ptr<RegisterSettleAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterSettleAccountResponse registerSettleAccount(shared_ptr<RegisterSettleAccountRequest> request);
  RegisterUserAccountResponse registerUserAccountWithOptions(shared_ptr<RegisterUserAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterUserAccountResponse registerUserAccount(shared_ptr<RegisterUserAccountRequest> request);
  ReleaseMovieSeatResponse releaseMovieSeatWithOptions(shared_ptr<ReleaseMovieSeatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseMovieSeatResponse releaseMovieSeat(shared_ptr<ReleaseMovieSeatRequest> request);
  RemoveAddressResponse removeAddressWithOptions(shared_ptr<RemoveAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAddressResponse removeAddress(shared_ptr<RemoveAddressRequest> request);
  RemoveMessagesResponse removeMessagesWithOptions(shared_ptr<RemoveMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveMessagesResponse removeMessages(shared_ptr<RemoveMessagesRequest> request);
  RenderH5OrderResponse renderH5OrderWithOptions(shared_ptr<RenderH5OrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenderH5OrderResponse renderH5Order(shared_ptr<RenderH5OrderRequest> request);
  RenderOrderResponse renderOrderWithOptions(shared_ptr<RenderOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenderOrderResponse renderOrder(shared_ptr<RenderOrderRequest> request);
  RenderOrderWithDesignatedTbUidResponse renderOrderWithDesignatedTbUidWithOptions(shared_ptr<RenderOrderWithDesignatedTbUidRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenderOrderWithDesignatedTbUidResponse renderOrderWithDesignatedTbUid(shared_ptr<RenderOrderWithDesignatedTbUidRequest> request);
  RepayForPayUrlResponse repayForPayUrlWithOptions(shared_ptr<RepayForPayUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RepayForPayUrlResponse repayForPayUrl(shared_ptr<RepayForPayUrlRequest> request);
  RepayOrderResponse repayOrderWithOptions(shared_ptr<RepayOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RepayOrderResponse repayOrder(shared_ptr<RepayOrderRequest> request);
  RepayWithDesignatedTbUidResponse repayWithDesignatedTbUidWithOptions(shared_ptr<RepayWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RepayWithDesignatedTbUidResponse repayWithDesignatedTbUid(shared_ptr<RepayWithDesignatedTbUidRequest> request);
  ReserveMovieSeatResponse reserveMovieSeatWithOptions(shared_ptr<ReserveMovieSeatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReserveMovieSeatResponse reserveMovieSeat(shared_ptr<ReserveMovieSeatRequest> request);
  SettleOrderResponse settleOrderWithOptions(shared_ptr<SettleOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SettleOrderResponse settleOrder(shared_ptr<SettleOrderRequest> request);
  StartUserGameResponse startUserGameWithOptions(shared_ptr<StartUserGameRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartUserGameResponse startUserGame(shared_ptr<StartUserGameRequest> request);
  SubmitReturnGoodLogisticsResponse submitReturnGoodLogisticsWithOptions(shared_ptr<SubmitReturnGoodLogisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitReturnGoodLogisticsResponse submitReturnGoodLogistics(shared_ptr<SubmitReturnGoodLogisticsRequest> request);
  SubmitReturnGoodLogisticsWithDesignatedTbUidResponse submitReturnGoodLogisticsWithDesignatedTbUidWithOptions(shared_ptr<SubmitReturnGoodLogisticsWithDesignatedTbUidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitReturnGoodLogisticsWithDesignatedTbUidResponse submitReturnGoodLogisticsWithDesignatedTbUid(shared_ptr<SubmitReturnGoodLogisticsWithDesignatedTbUidRequest> request);
  SyncMerchantInfoResponse syncMerchantInfoWithOptions(shared_ptr<SyncMerchantInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncMerchantInfoResponse syncMerchantInfo(shared_ptr<SyncMerchantInfoRequest> request);
  UnFreezeUserPointResponse unFreezeUserPointWithOptions(shared_ptr<UnFreezeUserPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnFreezeUserPointResponse unFreezeUserPoint(shared_ptr<UnFreezeUserPointRequest> request);
  UnsignWithholdAgreementResponse unsignWithholdAgreementWithOptions(shared_ptr<UnsignWithholdAgreementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnsignWithholdAgreementResponse unsignWithholdAgreement(shared_ptr<UnsignWithholdAgreementRequest> request);
  UpdateAddressResponse updateAddressWithOptions(shared_ptr<UpdateAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAddressResponse updateAddress(shared_ptr<UpdateAddressRequest> request);
  ValidateTaobaoAccountResponse validateTaobaoAccountWithOptions(shared_ptr<ValidateTaobaoAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateTaobaoAccountResponse validateTaobaoAccount(shared_ptr<ValidateTaobaoAccountRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Linkedmall20180116

#endif
