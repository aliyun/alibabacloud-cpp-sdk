// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DTS20200101_H_
#define ALIBABACLOUD_DTS20200101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dts20200101 {
class ConfigureDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> dataCheckConfigure{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<string> dbList{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<bool> delayNotice{};
  shared_ptr<string> delayPhone{};
  shared_ptr<long> delayRuleTime{};
  shared_ptr<string> destCaCertificateOssUrl{};
  shared_ptr<string> destCaCertificatePassword{};
  shared_ptr<string> destinationEndpointDataBaseName{};
  shared_ptr<string> destinationEndpointEngineName{};
  shared_ptr<string> destinationEndpointIP{};
  shared_ptr<string> destinationEndpointInstanceID{};
  shared_ptr<string> destinationEndpointInstanceType{};
  shared_ptr<string> destinationEndpointOracleSID{};
  shared_ptr<string> destinationEndpointOwnerID{};
  shared_ptr<string> destinationEndpointPassword{};
  shared_ptr<string> destinationEndpointPort{};
  shared_ptr<string> destinationEndpointRegion{};
  shared_ptr<string> destinationEndpointRole{};
  shared_ptr<string> destinationEndpointUserName{};
  shared_ptr<bool> disasterRecoveryJob{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<bool> errorNotice{};
  shared_ptr<string> errorPhone{};
  shared_ptr<string> fileOssUrl{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<double> minDu{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserve{};
  shared_ptr<string> sourceEndpointDatabaseName{};
  shared_ptr<string> sourceEndpointEngineName{};
  shared_ptr<string> sourceEndpointIP{};
  shared_ptr<string> sourceEndpointInstanceID{};
  shared_ptr<string> sourceEndpointInstanceType{};
  shared_ptr<string> sourceEndpointOracleSID{};
  shared_ptr<string> sourceEndpointOwnerID{};
  shared_ptr<string> sourceEndpointPassword{};
  shared_ptr<string> sourceEndpointPort{};
  shared_ptr<string> sourceEndpointRegion{};
  shared_ptr<string> sourceEndpointRole{};
  shared_ptr<string> sourceEndpointUserName{};
  shared_ptr<string> sourceEndpointVSwitchID{};
  shared_ptr<string> srcCaCertificateOssUrl{};
  shared_ptr<string> srcCaCertificatePassword{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};

  ConfigureDtsJobRequest() {}

  explicit ConfigureDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dataCheckConfigure) {
      res["DataCheckConfigure"] = boost::any(*dataCheckConfigure);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delayNotice) {
      res["DelayNotice"] = boost::any(*delayNotice);
    }
    if (delayPhone) {
      res["DelayPhone"] = boost::any(*delayPhone);
    }
    if (delayRuleTime) {
      res["DelayRuleTime"] = boost::any(*delayRuleTime);
    }
    if (destCaCertificateOssUrl) {
      res["DestCaCertificateOssUrl"] = boost::any(*destCaCertificateOssUrl);
    }
    if (destCaCertificatePassword) {
      res["DestCaCertificatePassword"] = boost::any(*destCaCertificatePassword);
    }
    if (destinationEndpointDataBaseName) {
      res["DestinationEndpointDataBaseName"] = boost::any(*destinationEndpointDataBaseName);
    }
    if (destinationEndpointEngineName) {
      res["DestinationEndpointEngineName"] = boost::any(*destinationEndpointEngineName);
    }
    if (destinationEndpointIP) {
      res["DestinationEndpointIP"] = boost::any(*destinationEndpointIP);
    }
    if (destinationEndpointInstanceID) {
      res["DestinationEndpointInstanceID"] = boost::any(*destinationEndpointInstanceID);
    }
    if (destinationEndpointInstanceType) {
      res["DestinationEndpointInstanceType"] = boost::any(*destinationEndpointInstanceType);
    }
    if (destinationEndpointOracleSID) {
      res["DestinationEndpointOracleSID"] = boost::any(*destinationEndpointOracleSID);
    }
    if (destinationEndpointOwnerID) {
      res["DestinationEndpointOwnerID"] = boost::any(*destinationEndpointOwnerID);
    }
    if (destinationEndpointPassword) {
      res["DestinationEndpointPassword"] = boost::any(*destinationEndpointPassword);
    }
    if (destinationEndpointPort) {
      res["DestinationEndpointPort"] = boost::any(*destinationEndpointPort);
    }
    if (destinationEndpointRegion) {
      res["DestinationEndpointRegion"] = boost::any(*destinationEndpointRegion);
    }
    if (destinationEndpointRole) {
      res["DestinationEndpointRole"] = boost::any(*destinationEndpointRole);
    }
    if (destinationEndpointUserName) {
      res["DestinationEndpointUserName"] = boost::any(*destinationEndpointUserName);
    }
    if (disasterRecoveryJob) {
      res["DisasterRecoveryJob"] = boost::any(*disasterRecoveryJob);
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (errorNotice) {
      res["ErrorNotice"] = boost::any(*errorNotice);
    }
    if (errorPhone) {
      res["ErrorPhone"] = boost::any(*errorPhone);
    }
    if (fileOssUrl) {
      res["FileOssUrl"] = boost::any(*fileOssUrl);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserve) {
      res["Reserve"] = boost::any(*reserve);
    }
    if (sourceEndpointDatabaseName) {
      res["SourceEndpointDatabaseName"] = boost::any(*sourceEndpointDatabaseName);
    }
    if (sourceEndpointEngineName) {
      res["SourceEndpointEngineName"] = boost::any(*sourceEndpointEngineName);
    }
    if (sourceEndpointIP) {
      res["SourceEndpointIP"] = boost::any(*sourceEndpointIP);
    }
    if (sourceEndpointInstanceID) {
      res["SourceEndpointInstanceID"] = boost::any(*sourceEndpointInstanceID);
    }
    if (sourceEndpointInstanceType) {
      res["SourceEndpointInstanceType"] = boost::any(*sourceEndpointInstanceType);
    }
    if (sourceEndpointOracleSID) {
      res["SourceEndpointOracleSID"] = boost::any(*sourceEndpointOracleSID);
    }
    if (sourceEndpointOwnerID) {
      res["SourceEndpointOwnerID"] = boost::any(*sourceEndpointOwnerID);
    }
    if (sourceEndpointPassword) {
      res["SourceEndpointPassword"] = boost::any(*sourceEndpointPassword);
    }
    if (sourceEndpointPort) {
      res["SourceEndpointPort"] = boost::any(*sourceEndpointPort);
    }
    if (sourceEndpointRegion) {
      res["SourceEndpointRegion"] = boost::any(*sourceEndpointRegion);
    }
    if (sourceEndpointRole) {
      res["SourceEndpointRole"] = boost::any(*sourceEndpointRole);
    }
    if (sourceEndpointUserName) {
      res["SourceEndpointUserName"] = boost::any(*sourceEndpointUserName);
    }
    if (sourceEndpointVSwitchID) {
      res["SourceEndpointVSwitchID"] = boost::any(*sourceEndpointVSwitchID);
    }
    if (srcCaCertificateOssUrl) {
      res["SrcCaCertificateOssUrl"] = boost::any(*srcCaCertificateOssUrl);
    }
    if (srcCaCertificatePassword) {
      res["SrcCaCertificatePassword"] = boost::any(*srcCaCertificatePassword);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DataCheckConfigure") != m.end() && !m["DataCheckConfigure"].empty()) {
      dataCheckConfigure = make_shared<string>(boost::any_cast<string>(m["DataCheckConfigure"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      dbList = make_shared<string>(boost::any_cast<string>(m["DbList"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DelayNotice") != m.end() && !m["DelayNotice"].empty()) {
      delayNotice = make_shared<bool>(boost::any_cast<bool>(m["DelayNotice"]));
    }
    if (m.find("DelayPhone") != m.end() && !m["DelayPhone"].empty()) {
      delayPhone = make_shared<string>(boost::any_cast<string>(m["DelayPhone"]));
    }
    if (m.find("DelayRuleTime") != m.end() && !m["DelayRuleTime"].empty()) {
      delayRuleTime = make_shared<long>(boost::any_cast<long>(m["DelayRuleTime"]));
    }
    if (m.find("DestCaCertificateOssUrl") != m.end() && !m["DestCaCertificateOssUrl"].empty()) {
      destCaCertificateOssUrl = make_shared<string>(boost::any_cast<string>(m["DestCaCertificateOssUrl"]));
    }
    if (m.find("DestCaCertificatePassword") != m.end() && !m["DestCaCertificatePassword"].empty()) {
      destCaCertificatePassword = make_shared<string>(boost::any_cast<string>(m["DestCaCertificatePassword"]));
    }
    if (m.find("DestinationEndpointDataBaseName") != m.end() && !m["DestinationEndpointDataBaseName"].empty()) {
      destinationEndpointDataBaseName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointDataBaseName"]));
    }
    if (m.find("DestinationEndpointEngineName") != m.end() && !m["DestinationEndpointEngineName"].empty()) {
      destinationEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointEngineName"]));
    }
    if (m.find("DestinationEndpointIP") != m.end() && !m["DestinationEndpointIP"].empty()) {
      destinationEndpointIP = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointIP"]));
    }
    if (m.find("DestinationEndpointInstanceID") != m.end() && !m["DestinationEndpointInstanceID"].empty()) {
      destinationEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceID"]));
    }
    if (m.find("DestinationEndpointInstanceType") != m.end() && !m["DestinationEndpointInstanceType"].empty()) {
      destinationEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceType"]));
    }
    if (m.find("DestinationEndpointOracleSID") != m.end() && !m["DestinationEndpointOracleSID"].empty()) {
      destinationEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointOracleSID"]));
    }
    if (m.find("DestinationEndpointOwnerID") != m.end() && !m["DestinationEndpointOwnerID"].empty()) {
      destinationEndpointOwnerID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointOwnerID"]));
    }
    if (m.find("DestinationEndpointPassword") != m.end() && !m["DestinationEndpointPassword"].empty()) {
      destinationEndpointPassword = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPassword"]));
    }
    if (m.find("DestinationEndpointPort") != m.end() && !m["DestinationEndpointPort"].empty()) {
      destinationEndpointPort = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPort"]));
    }
    if (m.find("DestinationEndpointRegion") != m.end() && !m["DestinationEndpointRegion"].empty()) {
      destinationEndpointRegion = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRegion"]));
    }
    if (m.find("DestinationEndpointRole") != m.end() && !m["DestinationEndpointRole"].empty()) {
      destinationEndpointRole = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRole"]));
    }
    if (m.find("DestinationEndpointUserName") != m.end() && !m["DestinationEndpointUserName"].empty()) {
      destinationEndpointUserName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointUserName"]));
    }
    if (m.find("DisasterRecoveryJob") != m.end() && !m["DisasterRecoveryJob"].empty()) {
      disasterRecoveryJob = make_shared<bool>(boost::any_cast<bool>(m["DisasterRecoveryJob"]));
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("ErrorNotice") != m.end() && !m["ErrorNotice"].empty()) {
      errorNotice = make_shared<bool>(boost::any_cast<bool>(m["ErrorNotice"]));
    }
    if (m.find("ErrorPhone") != m.end() && !m["ErrorPhone"].empty()) {
      errorPhone = make_shared<string>(boost::any_cast<string>(m["ErrorPhone"]));
    }
    if (m.find("FileOssUrl") != m.end() && !m["FileOssUrl"].empty()) {
      fileOssUrl = make_shared<string>(boost::any_cast<string>(m["FileOssUrl"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserve") != m.end() && !m["Reserve"].empty()) {
      reserve = make_shared<string>(boost::any_cast<string>(m["Reserve"]));
    }
    if (m.find("SourceEndpointDatabaseName") != m.end() && !m["SourceEndpointDatabaseName"].empty()) {
      sourceEndpointDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointDatabaseName"]));
    }
    if (m.find("SourceEndpointEngineName") != m.end() && !m["SourceEndpointEngineName"].empty()) {
      sourceEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointEngineName"]));
    }
    if (m.find("SourceEndpointIP") != m.end() && !m["SourceEndpointIP"].empty()) {
      sourceEndpointIP = make_shared<string>(boost::any_cast<string>(m["SourceEndpointIP"]));
    }
    if (m.find("SourceEndpointInstanceID") != m.end() && !m["SourceEndpointInstanceID"].empty()) {
      sourceEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceID"]));
    }
    if (m.find("SourceEndpointInstanceType") != m.end() && !m["SourceEndpointInstanceType"].empty()) {
      sourceEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceType"]));
    }
    if (m.find("SourceEndpointOracleSID") != m.end() && !m["SourceEndpointOracleSID"].empty()) {
      sourceEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOracleSID"]));
    }
    if (m.find("SourceEndpointOwnerID") != m.end() && !m["SourceEndpointOwnerID"].empty()) {
      sourceEndpointOwnerID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOwnerID"]));
    }
    if (m.find("SourceEndpointPassword") != m.end() && !m["SourceEndpointPassword"].empty()) {
      sourceEndpointPassword = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPassword"]));
    }
    if (m.find("SourceEndpointPort") != m.end() && !m["SourceEndpointPort"].empty()) {
      sourceEndpointPort = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPort"]));
    }
    if (m.find("SourceEndpointRegion") != m.end() && !m["SourceEndpointRegion"].empty()) {
      sourceEndpointRegion = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRegion"]));
    }
    if (m.find("SourceEndpointRole") != m.end() && !m["SourceEndpointRole"].empty()) {
      sourceEndpointRole = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRole"]));
    }
    if (m.find("SourceEndpointUserName") != m.end() && !m["SourceEndpointUserName"].empty()) {
      sourceEndpointUserName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointUserName"]));
    }
    if (m.find("SourceEndpointVSwitchID") != m.end() && !m["SourceEndpointVSwitchID"].empty()) {
      sourceEndpointVSwitchID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointVSwitchID"]));
    }
    if (m.find("SrcCaCertificateOssUrl") != m.end() && !m["SrcCaCertificateOssUrl"].empty()) {
      srcCaCertificateOssUrl = make_shared<string>(boost::any_cast<string>(m["SrcCaCertificateOssUrl"]));
    }
    if (m.find("SrcCaCertificatePassword") != m.end() && !m["SrcCaCertificatePassword"].empty()) {
      srcCaCertificatePassword = make_shared<string>(boost::any_cast<string>(m["SrcCaCertificatePassword"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ConfigureDtsJobRequest() = default;
};
class ConfigureDtsJobAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> dataCheckConfigure{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<string> dbList{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<bool> delayNotice{};
  shared_ptr<string> delayPhone{};
  shared_ptr<long> delayRuleTime{};
  shared_ptr<string> destCaCertificateOssUrl{};
  shared_ptr<string> destCaCertificatePassword{};
  shared_ptr<string> destinationEndpointDataBaseName{};
  shared_ptr<string> destinationEndpointEngineName{};
  shared_ptr<string> destinationEndpointIP{};
  shared_ptr<string> destinationEndpointInstanceID{};
  shared_ptr<string> destinationEndpointInstanceType{};
  shared_ptr<string> destinationEndpointOracleSID{};
  shared_ptr<string> destinationEndpointOwnerID{};
  shared_ptr<string> destinationEndpointPassword{};
  shared_ptr<string> destinationEndpointPort{};
  shared_ptr<string> destinationEndpointRegion{};
  shared_ptr<string> destinationEndpointRole{};
  shared_ptr<string> destinationEndpointUserName{};
  shared_ptr<bool> disasterRecoveryJob{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<bool> errorNotice{};
  shared_ptr<string> errorPhone{};
  shared_ptr<Darabonba::Stream> fileOssUrlObject{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<double> minDu{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserve{};
  shared_ptr<string> sourceEndpointDatabaseName{};
  shared_ptr<string> sourceEndpointEngineName{};
  shared_ptr<string> sourceEndpointIP{};
  shared_ptr<string> sourceEndpointInstanceID{};
  shared_ptr<string> sourceEndpointInstanceType{};
  shared_ptr<string> sourceEndpointOracleSID{};
  shared_ptr<string> sourceEndpointOwnerID{};
  shared_ptr<string> sourceEndpointPassword{};
  shared_ptr<string> sourceEndpointPort{};
  shared_ptr<string> sourceEndpointRegion{};
  shared_ptr<string> sourceEndpointRole{};
  shared_ptr<string> sourceEndpointUserName{};
  shared_ptr<string> sourceEndpointVSwitchID{};
  shared_ptr<string> srcCaCertificateOssUrl{};
  shared_ptr<string> srcCaCertificatePassword{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};

  ConfigureDtsJobAdvanceRequest() {}

  explicit ConfigureDtsJobAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dataCheckConfigure) {
      res["DataCheckConfigure"] = boost::any(*dataCheckConfigure);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delayNotice) {
      res["DelayNotice"] = boost::any(*delayNotice);
    }
    if (delayPhone) {
      res["DelayPhone"] = boost::any(*delayPhone);
    }
    if (delayRuleTime) {
      res["DelayRuleTime"] = boost::any(*delayRuleTime);
    }
    if (destCaCertificateOssUrl) {
      res["DestCaCertificateOssUrl"] = boost::any(*destCaCertificateOssUrl);
    }
    if (destCaCertificatePassword) {
      res["DestCaCertificatePassword"] = boost::any(*destCaCertificatePassword);
    }
    if (destinationEndpointDataBaseName) {
      res["DestinationEndpointDataBaseName"] = boost::any(*destinationEndpointDataBaseName);
    }
    if (destinationEndpointEngineName) {
      res["DestinationEndpointEngineName"] = boost::any(*destinationEndpointEngineName);
    }
    if (destinationEndpointIP) {
      res["DestinationEndpointIP"] = boost::any(*destinationEndpointIP);
    }
    if (destinationEndpointInstanceID) {
      res["DestinationEndpointInstanceID"] = boost::any(*destinationEndpointInstanceID);
    }
    if (destinationEndpointInstanceType) {
      res["DestinationEndpointInstanceType"] = boost::any(*destinationEndpointInstanceType);
    }
    if (destinationEndpointOracleSID) {
      res["DestinationEndpointOracleSID"] = boost::any(*destinationEndpointOracleSID);
    }
    if (destinationEndpointOwnerID) {
      res["DestinationEndpointOwnerID"] = boost::any(*destinationEndpointOwnerID);
    }
    if (destinationEndpointPassword) {
      res["DestinationEndpointPassword"] = boost::any(*destinationEndpointPassword);
    }
    if (destinationEndpointPort) {
      res["DestinationEndpointPort"] = boost::any(*destinationEndpointPort);
    }
    if (destinationEndpointRegion) {
      res["DestinationEndpointRegion"] = boost::any(*destinationEndpointRegion);
    }
    if (destinationEndpointRole) {
      res["DestinationEndpointRole"] = boost::any(*destinationEndpointRole);
    }
    if (destinationEndpointUserName) {
      res["DestinationEndpointUserName"] = boost::any(*destinationEndpointUserName);
    }
    if (disasterRecoveryJob) {
      res["DisasterRecoveryJob"] = boost::any(*disasterRecoveryJob);
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (errorNotice) {
      res["ErrorNotice"] = boost::any(*errorNotice);
    }
    if (errorPhone) {
      res["ErrorPhone"] = boost::any(*errorPhone);
    }
    if (fileOssUrlObject) {
      res["FileOssUrl"] = boost::any(*fileOssUrlObject);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserve) {
      res["Reserve"] = boost::any(*reserve);
    }
    if (sourceEndpointDatabaseName) {
      res["SourceEndpointDatabaseName"] = boost::any(*sourceEndpointDatabaseName);
    }
    if (sourceEndpointEngineName) {
      res["SourceEndpointEngineName"] = boost::any(*sourceEndpointEngineName);
    }
    if (sourceEndpointIP) {
      res["SourceEndpointIP"] = boost::any(*sourceEndpointIP);
    }
    if (sourceEndpointInstanceID) {
      res["SourceEndpointInstanceID"] = boost::any(*sourceEndpointInstanceID);
    }
    if (sourceEndpointInstanceType) {
      res["SourceEndpointInstanceType"] = boost::any(*sourceEndpointInstanceType);
    }
    if (sourceEndpointOracleSID) {
      res["SourceEndpointOracleSID"] = boost::any(*sourceEndpointOracleSID);
    }
    if (sourceEndpointOwnerID) {
      res["SourceEndpointOwnerID"] = boost::any(*sourceEndpointOwnerID);
    }
    if (sourceEndpointPassword) {
      res["SourceEndpointPassword"] = boost::any(*sourceEndpointPassword);
    }
    if (sourceEndpointPort) {
      res["SourceEndpointPort"] = boost::any(*sourceEndpointPort);
    }
    if (sourceEndpointRegion) {
      res["SourceEndpointRegion"] = boost::any(*sourceEndpointRegion);
    }
    if (sourceEndpointRole) {
      res["SourceEndpointRole"] = boost::any(*sourceEndpointRole);
    }
    if (sourceEndpointUserName) {
      res["SourceEndpointUserName"] = boost::any(*sourceEndpointUserName);
    }
    if (sourceEndpointVSwitchID) {
      res["SourceEndpointVSwitchID"] = boost::any(*sourceEndpointVSwitchID);
    }
    if (srcCaCertificateOssUrl) {
      res["SrcCaCertificateOssUrl"] = boost::any(*srcCaCertificateOssUrl);
    }
    if (srcCaCertificatePassword) {
      res["SrcCaCertificatePassword"] = boost::any(*srcCaCertificatePassword);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DataCheckConfigure") != m.end() && !m["DataCheckConfigure"].empty()) {
      dataCheckConfigure = make_shared<string>(boost::any_cast<string>(m["DataCheckConfigure"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      dbList = make_shared<string>(boost::any_cast<string>(m["DbList"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DelayNotice") != m.end() && !m["DelayNotice"].empty()) {
      delayNotice = make_shared<bool>(boost::any_cast<bool>(m["DelayNotice"]));
    }
    if (m.find("DelayPhone") != m.end() && !m["DelayPhone"].empty()) {
      delayPhone = make_shared<string>(boost::any_cast<string>(m["DelayPhone"]));
    }
    if (m.find("DelayRuleTime") != m.end() && !m["DelayRuleTime"].empty()) {
      delayRuleTime = make_shared<long>(boost::any_cast<long>(m["DelayRuleTime"]));
    }
    if (m.find("DestCaCertificateOssUrl") != m.end() && !m["DestCaCertificateOssUrl"].empty()) {
      destCaCertificateOssUrl = make_shared<string>(boost::any_cast<string>(m["DestCaCertificateOssUrl"]));
    }
    if (m.find("DestCaCertificatePassword") != m.end() && !m["DestCaCertificatePassword"].empty()) {
      destCaCertificatePassword = make_shared<string>(boost::any_cast<string>(m["DestCaCertificatePassword"]));
    }
    if (m.find("DestinationEndpointDataBaseName") != m.end() && !m["DestinationEndpointDataBaseName"].empty()) {
      destinationEndpointDataBaseName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointDataBaseName"]));
    }
    if (m.find("DestinationEndpointEngineName") != m.end() && !m["DestinationEndpointEngineName"].empty()) {
      destinationEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointEngineName"]));
    }
    if (m.find("DestinationEndpointIP") != m.end() && !m["DestinationEndpointIP"].empty()) {
      destinationEndpointIP = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointIP"]));
    }
    if (m.find("DestinationEndpointInstanceID") != m.end() && !m["DestinationEndpointInstanceID"].empty()) {
      destinationEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceID"]));
    }
    if (m.find("DestinationEndpointInstanceType") != m.end() && !m["DestinationEndpointInstanceType"].empty()) {
      destinationEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceType"]));
    }
    if (m.find("DestinationEndpointOracleSID") != m.end() && !m["DestinationEndpointOracleSID"].empty()) {
      destinationEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointOracleSID"]));
    }
    if (m.find("DestinationEndpointOwnerID") != m.end() && !m["DestinationEndpointOwnerID"].empty()) {
      destinationEndpointOwnerID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointOwnerID"]));
    }
    if (m.find("DestinationEndpointPassword") != m.end() && !m["DestinationEndpointPassword"].empty()) {
      destinationEndpointPassword = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPassword"]));
    }
    if (m.find("DestinationEndpointPort") != m.end() && !m["DestinationEndpointPort"].empty()) {
      destinationEndpointPort = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPort"]));
    }
    if (m.find("DestinationEndpointRegion") != m.end() && !m["DestinationEndpointRegion"].empty()) {
      destinationEndpointRegion = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRegion"]));
    }
    if (m.find("DestinationEndpointRole") != m.end() && !m["DestinationEndpointRole"].empty()) {
      destinationEndpointRole = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRole"]));
    }
    if (m.find("DestinationEndpointUserName") != m.end() && !m["DestinationEndpointUserName"].empty()) {
      destinationEndpointUserName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointUserName"]));
    }
    if (m.find("DisasterRecoveryJob") != m.end() && !m["DisasterRecoveryJob"].empty()) {
      disasterRecoveryJob = make_shared<bool>(boost::any_cast<bool>(m["DisasterRecoveryJob"]));
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("ErrorNotice") != m.end() && !m["ErrorNotice"].empty()) {
      errorNotice = make_shared<bool>(boost::any_cast<bool>(m["ErrorNotice"]));
    }
    if (m.find("ErrorPhone") != m.end() && !m["ErrorPhone"].empty()) {
      errorPhone = make_shared<string>(boost::any_cast<string>(m["ErrorPhone"]));
    }
    if (m.find("FileOssUrl") != m.end() && !m["FileOssUrl"].empty()) {
      fileOssUrlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["FileOssUrl"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserve") != m.end() && !m["Reserve"].empty()) {
      reserve = make_shared<string>(boost::any_cast<string>(m["Reserve"]));
    }
    if (m.find("SourceEndpointDatabaseName") != m.end() && !m["SourceEndpointDatabaseName"].empty()) {
      sourceEndpointDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointDatabaseName"]));
    }
    if (m.find("SourceEndpointEngineName") != m.end() && !m["SourceEndpointEngineName"].empty()) {
      sourceEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointEngineName"]));
    }
    if (m.find("SourceEndpointIP") != m.end() && !m["SourceEndpointIP"].empty()) {
      sourceEndpointIP = make_shared<string>(boost::any_cast<string>(m["SourceEndpointIP"]));
    }
    if (m.find("SourceEndpointInstanceID") != m.end() && !m["SourceEndpointInstanceID"].empty()) {
      sourceEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceID"]));
    }
    if (m.find("SourceEndpointInstanceType") != m.end() && !m["SourceEndpointInstanceType"].empty()) {
      sourceEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceType"]));
    }
    if (m.find("SourceEndpointOracleSID") != m.end() && !m["SourceEndpointOracleSID"].empty()) {
      sourceEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOracleSID"]));
    }
    if (m.find("SourceEndpointOwnerID") != m.end() && !m["SourceEndpointOwnerID"].empty()) {
      sourceEndpointOwnerID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOwnerID"]));
    }
    if (m.find("SourceEndpointPassword") != m.end() && !m["SourceEndpointPassword"].empty()) {
      sourceEndpointPassword = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPassword"]));
    }
    if (m.find("SourceEndpointPort") != m.end() && !m["SourceEndpointPort"].empty()) {
      sourceEndpointPort = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPort"]));
    }
    if (m.find("SourceEndpointRegion") != m.end() && !m["SourceEndpointRegion"].empty()) {
      sourceEndpointRegion = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRegion"]));
    }
    if (m.find("SourceEndpointRole") != m.end() && !m["SourceEndpointRole"].empty()) {
      sourceEndpointRole = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRole"]));
    }
    if (m.find("SourceEndpointUserName") != m.end() && !m["SourceEndpointUserName"].empty()) {
      sourceEndpointUserName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointUserName"]));
    }
    if (m.find("SourceEndpointVSwitchID") != m.end() && !m["SourceEndpointVSwitchID"].empty()) {
      sourceEndpointVSwitchID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointVSwitchID"]));
    }
    if (m.find("SrcCaCertificateOssUrl") != m.end() && !m["SrcCaCertificateOssUrl"].empty()) {
      srcCaCertificateOssUrl = make_shared<string>(boost::any_cast<string>(m["SrcCaCertificateOssUrl"]));
    }
    if (m.find("SrcCaCertificatePassword") != m.end() && !m["SrcCaCertificatePassword"].empty()) {
      srcCaCertificatePassword = make_shared<string>(boost::any_cast<string>(m["SrcCaCertificatePassword"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ConfigureDtsJobAdvanceRequest() = default;
};
class ConfigureDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureDtsJobResponseBody() {}

  explicit ConfigureDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureDtsJobResponseBody() = default;
};
class ConfigureDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureDtsJobResponseBody> body{};

  ConfigureDtsJobResponse() {}

  explicit ConfigureDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureDtsJobResponse() = default;
};
class ConfigureMigrationJobRequestDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> dataBaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> userName{};

  ConfigureMigrationJobRequestDestinationEndpoint() {}

  explicit ConfigureMigrationJobRequestDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataBaseName) {
      res["DataBaseName"] = boost::any(*dataBaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataBaseName") != m.end() && !m["DataBaseName"].empty()) {
      dataBaseName = make_shared<string>(boost::any_cast<string>(m["DataBaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ConfigureMigrationJobRequestDestinationEndpoint() = default;
};
class ConfigureMigrationJobRequestMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataIntialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureIntialization{};

  ConfigureMigrationJobRequestMigrationMode() {}

  explicit ConfigureMigrationJobRequestMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataIntialization) {
      res["DataIntialization"] = boost::any(*dataIntialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureIntialization) {
      res["StructureIntialization"] = boost::any(*structureIntialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataIntialization") != m.end() && !m["DataIntialization"].empty()) {
      dataIntialization = make_shared<bool>(boost::any_cast<bool>(m["DataIntialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureIntialization") != m.end() && !m["StructureIntialization"].empty()) {
      structureIntialization = make_shared<bool>(boost::any_cast<bool>(m["StructureIntialization"]));
    }
  }


  virtual ~ConfigureMigrationJobRequestMigrationMode() = default;
};
class ConfigureMigrationJobRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> ownerID{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> role{};
  shared_ptr<string> userName{};

  ConfigureMigrationJobRequestSourceEndpoint() {}

  explicit ConfigureMigrationJobRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ConfigureMigrationJobRequestSourceEndpoint() = default;
};
class ConfigureMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<ConfigureMigrationJobRequestDestinationEndpoint> destinationEndpoint{};
  shared_ptr<ConfigureMigrationJobRequestMigrationMode> migrationMode{};
  shared_ptr<ConfigureMigrationJobRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> accountId{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> migrationJobName{};
  shared_ptr<string> migrationObject{};
  shared_ptr<string> migrationReserved{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  ConfigureMigrationJobRequest() {}

  explicit ConfigureMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (migrationJobName) {
      res["MigrationJobName"] = boost::any(*migrationJobName);
    }
    if (migrationObject) {
      res["MigrationObject"] = boost::any(*migrationObject);
    }
    if (migrationReserved) {
      res["MigrationReserved"] = boost::any(*migrationReserved);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        ConfigureMigrationJobRequestDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<ConfigureMigrationJobRequestDestinationEndpoint>(model1);
      }
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        ConfigureMigrationJobRequestMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<ConfigureMigrationJobRequestMigrationMode>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        ConfigureMigrationJobRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<ConfigureMigrationJobRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("MigrationJobName") != m.end() && !m["MigrationJobName"].empty()) {
      migrationJobName = make_shared<string>(boost::any_cast<string>(m["MigrationJobName"]));
    }
    if (m.find("MigrationObject") != m.end() && !m["MigrationObject"].empty()) {
      migrationObject = make_shared<string>(boost::any_cast<string>(m["MigrationObject"]));
    }
    if (m.find("MigrationReserved") != m.end() && !m["MigrationReserved"].empty()) {
      migrationReserved = make_shared<string>(boost::any_cast<string>(m["MigrationReserved"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigureMigrationJobRequest() = default;
};
class ConfigureMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureMigrationJobResponseBody() {}

  explicit ConfigureMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureMigrationJobResponseBody() = default;
};
class ConfigureMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureMigrationJobResponseBody> body{};

  ConfigureMigrationJobResponse() {}

  explicit ConfigureMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureMigrationJobResponse() = default;
};
class ConfigureMigrationJobAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  ConfigureMigrationJobAlertRequest() {}

  explicit ConfigureMigrationJobAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigureMigrationJobAlertRequest() = default;
};
class ConfigureMigrationJobAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureMigrationJobAlertResponseBody() {}

  explicit ConfigureMigrationJobAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureMigrationJobAlertResponseBody() = default;
};
class ConfigureMigrationJobAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureMigrationJobAlertResponseBody> body{};

  ConfigureMigrationJobAlertResponse() {}

  explicit ConfigureMigrationJobAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureMigrationJobAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureMigrationJobAlertResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureMigrationJobAlertResponse() = default;
};
class ConfigureSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> dbList{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<bool> delayNotice{};
  shared_ptr<string> delayPhone{};
  shared_ptr<long> delayRuleTime{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<bool> errorNotice{};
  shared_ptr<string> errorPhone{};
  shared_ptr<double> maxDu{};
  shared_ptr<double> minDu{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserve{};
  shared_ptr<string> sourceEndpointDatabaseName{};
  shared_ptr<string> sourceEndpointEngineName{};
  shared_ptr<string> sourceEndpointIP{};
  shared_ptr<string> sourceEndpointInstanceID{};
  shared_ptr<string> sourceEndpointInstanceType{};
  shared_ptr<string> sourceEndpointOracleSID{};
  shared_ptr<string> sourceEndpointOwnerID{};
  shared_ptr<string> sourceEndpointPassword{};
  shared_ptr<string> sourceEndpointPort{};
  shared_ptr<string> sourceEndpointRegion{};
  shared_ptr<string> sourceEndpointRole{};
  shared_ptr<string> sourceEndpointUserName{};
  shared_ptr<bool> subscriptionDataTypeDDL{};
  shared_ptr<bool> subscriptionDataTypeDML{};
  shared_ptr<string> subscriptionInstanceNetworkType{};
  shared_ptr<string> subscriptionInstanceVPCId{};
  shared_ptr<string> subscriptionInstanceVSwitchId{};

  ConfigureSubscriptionRequest() {}

  explicit ConfigureSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delayNotice) {
      res["DelayNotice"] = boost::any(*delayNotice);
    }
    if (delayPhone) {
      res["DelayPhone"] = boost::any(*delayPhone);
    }
    if (delayRuleTime) {
      res["DelayRuleTime"] = boost::any(*delayRuleTime);
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (errorNotice) {
      res["ErrorNotice"] = boost::any(*errorNotice);
    }
    if (errorPhone) {
      res["ErrorPhone"] = boost::any(*errorPhone);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserve) {
      res["Reserve"] = boost::any(*reserve);
    }
    if (sourceEndpointDatabaseName) {
      res["SourceEndpointDatabaseName"] = boost::any(*sourceEndpointDatabaseName);
    }
    if (sourceEndpointEngineName) {
      res["SourceEndpointEngineName"] = boost::any(*sourceEndpointEngineName);
    }
    if (sourceEndpointIP) {
      res["SourceEndpointIP"] = boost::any(*sourceEndpointIP);
    }
    if (sourceEndpointInstanceID) {
      res["SourceEndpointInstanceID"] = boost::any(*sourceEndpointInstanceID);
    }
    if (sourceEndpointInstanceType) {
      res["SourceEndpointInstanceType"] = boost::any(*sourceEndpointInstanceType);
    }
    if (sourceEndpointOracleSID) {
      res["SourceEndpointOracleSID"] = boost::any(*sourceEndpointOracleSID);
    }
    if (sourceEndpointOwnerID) {
      res["SourceEndpointOwnerID"] = boost::any(*sourceEndpointOwnerID);
    }
    if (sourceEndpointPassword) {
      res["SourceEndpointPassword"] = boost::any(*sourceEndpointPassword);
    }
    if (sourceEndpointPort) {
      res["SourceEndpointPort"] = boost::any(*sourceEndpointPort);
    }
    if (sourceEndpointRegion) {
      res["SourceEndpointRegion"] = boost::any(*sourceEndpointRegion);
    }
    if (sourceEndpointRole) {
      res["SourceEndpointRole"] = boost::any(*sourceEndpointRole);
    }
    if (sourceEndpointUserName) {
      res["SourceEndpointUserName"] = boost::any(*sourceEndpointUserName);
    }
    if (subscriptionDataTypeDDL) {
      res["SubscriptionDataTypeDDL"] = boost::any(*subscriptionDataTypeDDL);
    }
    if (subscriptionDataTypeDML) {
      res["SubscriptionDataTypeDML"] = boost::any(*subscriptionDataTypeDML);
    }
    if (subscriptionInstanceNetworkType) {
      res["SubscriptionInstanceNetworkType"] = boost::any(*subscriptionInstanceNetworkType);
    }
    if (subscriptionInstanceVPCId) {
      res["SubscriptionInstanceVPCId"] = boost::any(*subscriptionInstanceVPCId);
    }
    if (subscriptionInstanceVSwitchId) {
      res["SubscriptionInstanceVSwitchId"] = boost::any(*subscriptionInstanceVSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      dbList = make_shared<string>(boost::any_cast<string>(m["DbList"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DelayNotice") != m.end() && !m["DelayNotice"].empty()) {
      delayNotice = make_shared<bool>(boost::any_cast<bool>(m["DelayNotice"]));
    }
    if (m.find("DelayPhone") != m.end() && !m["DelayPhone"].empty()) {
      delayPhone = make_shared<string>(boost::any_cast<string>(m["DelayPhone"]));
    }
    if (m.find("DelayRuleTime") != m.end() && !m["DelayRuleTime"].empty()) {
      delayRuleTime = make_shared<long>(boost::any_cast<long>(m["DelayRuleTime"]));
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("ErrorNotice") != m.end() && !m["ErrorNotice"].empty()) {
      errorNotice = make_shared<bool>(boost::any_cast<bool>(m["ErrorNotice"]));
    }
    if (m.find("ErrorPhone") != m.end() && !m["ErrorPhone"].empty()) {
      errorPhone = make_shared<string>(boost::any_cast<string>(m["ErrorPhone"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserve") != m.end() && !m["Reserve"].empty()) {
      reserve = make_shared<string>(boost::any_cast<string>(m["Reserve"]));
    }
    if (m.find("SourceEndpointDatabaseName") != m.end() && !m["SourceEndpointDatabaseName"].empty()) {
      sourceEndpointDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointDatabaseName"]));
    }
    if (m.find("SourceEndpointEngineName") != m.end() && !m["SourceEndpointEngineName"].empty()) {
      sourceEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointEngineName"]));
    }
    if (m.find("SourceEndpointIP") != m.end() && !m["SourceEndpointIP"].empty()) {
      sourceEndpointIP = make_shared<string>(boost::any_cast<string>(m["SourceEndpointIP"]));
    }
    if (m.find("SourceEndpointInstanceID") != m.end() && !m["SourceEndpointInstanceID"].empty()) {
      sourceEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceID"]));
    }
    if (m.find("SourceEndpointInstanceType") != m.end() && !m["SourceEndpointInstanceType"].empty()) {
      sourceEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceType"]));
    }
    if (m.find("SourceEndpointOracleSID") != m.end() && !m["SourceEndpointOracleSID"].empty()) {
      sourceEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOracleSID"]));
    }
    if (m.find("SourceEndpointOwnerID") != m.end() && !m["SourceEndpointOwnerID"].empty()) {
      sourceEndpointOwnerID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOwnerID"]));
    }
    if (m.find("SourceEndpointPassword") != m.end() && !m["SourceEndpointPassword"].empty()) {
      sourceEndpointPassword = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPassword"]));
    }
    if (m.find("SourceEndpointPort") != m.end() && !m["SourceEndpointPort"].empty()) {
      sourceEndpointPort = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPort"]));
    }
    if (m.find("SourceEndpointRegion") != m.end() && !m["SourceEndpointRegion"].empty()) {
      sourceEndpointRegion = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRegion"]));
    }
    if (m.find("SourceEndpointRole") != m.end() && !m["SourceEndpointRole"].empty()) {
      sourceEndpointRole = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRole"]));
    }
    if (m.find("SourceEndpointUserName") != m.end() && !m["SourceEndpointUserName"].empty()) {
      sourceEndpointUserName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointUserName"]));
    }
    if (m.find("SubscriptionDataTypeDDL") != m.end() && !m["SubscriptionDataTypeDDL"].empty()) {
      subscriptionDataTypeDDL = make_shared<bool>(boost::any_cast<bool>(m["SubscriptionDataTypeDDL"]));
    }
    if (m.find("SubscriptionDataTypeDML") != m.end() && !m["SubscriptionDataTypeDML"].empty()) {
      subscriptionDataTypeDML = make_shared<bool>(boost::any_cast<bool>(m["SubscriptionDataTypeDML"]));
    }
    if (m.find("SubscriptionInstanceNetworkType") != m.end() && !m["SubscriptionInstanceNetworkType"].empty()) {
      subscriptionInstanceNetworkType = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceNetworkType"]));
    }
    if (m.find("SubscriptionInstanceVPCId") != m.end() && !m["SubscriptionInstanceVPCId"].empty()) {
      subscriptionInstanceVPCId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceVPCId"]));
    }
    if (m.find("SubscriptionInstanceVSwitchId") != m.end() && !m["SubscriptionInstanceVSwitchId"].empty()) {
      subscriptionInstanceVSwitchId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceVSwitchId"]));
    }
  }


  virtual ~ConfigureSubscriptionRequest() = default;
};
class ConfigureSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSubscriptionResponseBody() {}

  explicit ConfigureSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSubscriptionResponseBody() = default;
};
class ConfigureSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSubscriptionResponseBody> body{};

  ConfigureSubscriptionResponse() {}

  explicit ConfigureSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSubscriptionResponse() = default;
};
class ConfigureSubscriptionInstanceRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> ownerID{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> role{};
  shared_ptr<string> userName{};

  ConfigureSubscriptionInstanceRequestSourceEndpoint() {}

  explicit ConfigureSubscriptionInstanceRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceRequestSourceEndpoint() = default;
};
class ConfigureSubscriptionInstanceRequestSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> DDL{};
  shared_ptr<bool> DML{};

  ConfigureSubscriptionInstanceRequestSubscriptionDataType() {}

  explicit ConfigureSubscriptionInstanceRequestSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDL) {
      res["DDL"] = boost::any(*DDL);
    }
    if (DML) {
      res["DML"] = boost::any(*DML);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDL") != m.end() && !m["DDL"].empty()) {
      DDL = make_shared<bool>(boost::any_cast<bool>(m["DDL"]));
    }
    if (m.find("DML") != m.end() && !m["DML"].empty()) {
      DML = make_shared<bool>(boost::any_cast<bool>(m["DML"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceRequestSubscriptionDataType() = default;
};
class ConfigureSubscriptionInstanceRequestSubscriptionInstance : public Darabonba::Model {
public:
  shared_ptr<string> VPCId{};
  shared_ptr<string> vSwitchId{};

  ConfigureSubscriptionInstanceRequestSubscriptionInstance() {}

  explicit ConfigureSubscriptionInstanceRequestSubscriptionInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (VPCId) {
      res["VPCId"] = boost::any(*VPCId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VPCId") != m.end() && !m["VPCId"].empty()) {
      VPCId = make_shared<string>(boost::any_cast<string>(m["VPCId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceRequestSubscriptionInstance() = default;
};
class ConfigureSubscriptionInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<ConfigureSubscriptionInstanceRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<ConfigureSubscriptionInstanceRequestSubscriptionDataType> subscriptionDataType{};
  shared_ptr<ConfigureSubscriptionInstanceRequestSubscriptionInstance> subscriptionInstance{};
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};
  shared_ptr<string> subscriptionInstanceName{};
  shared_ptr<string> subscriptionInstanceNetworkType{};
  shared_ptr<string> subscriptionObject{};

  ConfigureSubscriptionInstanceRequest() {}

  explicit ConfigureSubscriptionInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionInstance) {
      res["SubscriptionInstance"] = subscriptionInstance ? boost::any(subscriptionInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    if (subscriptionInstanceName) {
      res["SubscriptionInstanceName"] = boost::any(*subscriptionInstanceName);
    }
    if (subscriptionInstanceNetworkType) {
      res["SubscriptionInstanceNetworkType"] = boost::any(*subscriptionInstanceNetworkType);
    }
    if (subscriptionObject) {
      res["SubscriptionObject"] = boost::any(*subscriptionObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        ConfigureSubscriptionInstanceRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<ConfigureSubscriptionInstanceRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        ConfigureSubscriptionInstanceRequestSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<ConfigureSubscriptionInstanceRequestSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionInstance") != m.end() && !m["SubscriptionInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionInstance"].type()) {
        ConfigureSubscriptionInstanceRequestSubscriptionInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionInstance"]));
        subscriptionInstance = make_shared<ConfigureSubscriptionInstanceRequestSubscriptionInstance>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
    if (m.find("SubscriptionInstanceName") != m.end() && !m["SubscriptionInstanceName"].empty()) {
      subscriptionInstanceName = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceName"]));
    }
    if (m.find("SubscriptionInstanceNetworkType") != m.end() && !m["SubscriptionInstanceNetworkType"].empty()) {
      subscriptionInstanceNetworkType = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceNetworkType"]));
    }
    if (m.find("SubscriptionObject") != m.end() && !m["SubscriptionObject"].empty()) {
      subscriptionObject = make_shared<string>(boost::any_cast<string>(m["SubscriptionObject"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceRequest() = default;
};
class ConfigureSubscriptionInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSubscriptionInstanceResponseBody() {}

  explicit ConfigureSubscriptionInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceResponseBody() = default;
};
class ConfigureSubscriptionInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSubscriptionInstanceResponseBody> body{};

  ConfigureSubscriptionInstanceResponse() {}

  explicit ConfigureSubscriptionInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSubscriptionInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSubscriptionInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSubscriptionInstanceResponse() = default;
};
class ConfigureSubscriptionInstanceAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  ConfigureSubscriptionInstanceAlertRequest() {}

  explicit ConfigureSubscriptionInstanceAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceAlertRequest() = default;
};
class ConfigureSubscriptionInstanceAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSubscriptionInstanceAlertResponseBody() {}

  explicit ConfigureSubscriptionInstanceAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSubscriptionInstanceAlertResponseBody() = default;
};
class ConfigureSubscriptionInstanceAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSubscriptionInstanceAlertResponseBody> body{};

  ConfigureSubscriptionInstanceAlertResponse() {}

  explicit ConfigureSubscriptionInstanceAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSubscriptionInstanceAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSubscriptionInstanceAlertResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSubscriptionInstanceAlertResponse() = default;
};
class ConfigureSynchronizationJobRequestDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> dataBaseName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  ConfigureSynchronizationJobRequestDestinationEndpoint() {}

  explicit ConfigureSynchronizationJobRequestDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataBaseName) {
      res["DataBaseName"] = boost::any(*dataBaseName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataBaseName") != m.end() && !m["DataBaseName"].empty()) {
      dataBaseName = make_shared<string>(boost::any_cast<string>(m["DataBaseName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ConfigureSynchronizationJobRequestDestinationEndpoint() = default;
};
class ConfigureSynchronizationJobRequestPartitionKey : public Darabonba::Model {
public:
  shared_ptr<bool> modifyTimeDay{};
  shared_ptr<bool> modifyTimeHour{};
  shared_ptr<bool> modifyTimeMinute{};
  shared_ptr<bool> modifyTimeMonth{};
  shared_ptr<bool> modifyTimeYear{};

  ConfigureSynchronizationJobRequestPartitionKey() {}

  explicit ConfigureSynchronizationJobRequestPartitionKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyTimeDay) {
      res["ModifyTime_Day"] = boost::any(*modifyTimeDay);
    }
    if (modifyTimeHour) {
      res["ModifyTime_Hour"] = boost::any(*modifyTimeHour);
    }
    if (modifyTimeMinute) {
      res["ModifyTime_Minute"] = boost::any(*modifyTimeMinute);
    }
    if (modifyTimeMonth) {
      res["ModifyTime_Month"] = boost::any(*modifyTimeMonth);
    }
    if (modifyTimeYear) {
      res["ModifyTime_Year"] = boost::any(*modifyTimeYear);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifyTime_Day") != m.end() && !m["ModifyTime_Day"].empty()) {
      modifyTimeDay = make_shared<bool>(boost::any_cast<bool>(m["ModifyTime_Day"]));
    }
    if (m.find("ModifyTime_Hour") != m.end() && !m["ModifyTime_Hour"].empty()) {
      modifyTimeHour = make_shared<bool>(boost::any_cast<bool>(m["ModifyTime_Hour"]));
    }
    if (m.find("ModifyTime_Minute") != m.end() && !m["ModifyTime_Minute"].empty()) {
      modifyTimeMinute = make_shared<bool>(boost::any_cast<bool>(m["ModifyTime_Minute"]));
    }
    if (m.find("ModifyTime_Month") != m.end() && !m["ModifyTime_Month"].empty()) {
      modifyTimeMonth = make_shared<bool>(boost::any_cast<bool>(m["ModifyTime_Month"]));
    }
    if (m.find("ModifyTime_Year") != m.end() && !m["ModifyTime_Year"].empty()) {
      modifyTimeYear = make_shared<bool>(boost::any_cast<bool>(m["ModifyTime_Year"]));
    }
  }


  virtual ~ConfigureSynchronizationJobRequestPartitionKey() = default;
};
class ConfigureSynchronizationJobRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ownerID{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> role{};
  shared_ptr<string> userName{};

  ConfigureSynchronizationJobRequestSourceEndpoint() {}

  explicit ConfigureSynchronizationJobRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ConfigureSynchronizationJobRequestSourceEndpoint() = default;
};
class ConfigureSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<ConfigureSynchronizationJobRequestDestinationEndpoint> destinationEndpoint{};
  shared_ptr<ConfigureSynchronizationJobRequestPartitionKey> partitionKey{};
  shared_ptr<ConfigureSynchronizationJobRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> accountId{};
  shared_ptr<string> checkpoint{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<string> migrationReserved{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> synchronizationJobName{};
  shared_ptr<string> synchronizationObjects{};

  ConfigureSynchronizationJobRequest() {}

  explicit ConfigureSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (partitionKey) {
      res["PartitionKey"] = partitionKey ? boost::any(partitionKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (migrationReserved) {
      res["MigrationReserved"] = boost::any(*migrationReserved);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationJobName) {
      res["SynchronizationJobName"] = boost::any(*synchronizationJobName);
    }
    if (synchronizationObjects) {
      res["SynchronizationObjects"] = boost::any(*synchronizationObjects);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        ConfigureSynchronizationJobRequestDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<ConfigureSynchronizationJobRequestDestinationEndpoint>(model1);
      }
    }
    if (m.find("PartitionKey") != m.end() && !m["PartitionKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["PartitionKey"].type()) {
        ConfigureSynchronizationJobRequestPartitionKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PartitionKey"]));
        partitionKey = make_shared<ConfigureSynchronizationJobRequestPartitionKey>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        ConfigureSynchronizationJobRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<ConfigureSynchronizationJobRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("MigrationReserved") != m.end() && !m["MigrationReserved"].empty()) {
      migrationReserved = make_shared<string>(boost::any_cast<string>(m["MigrationReserved"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationJobName") != m.end() && !m["SynchronizationJobName"].empty()) {
      synchronizationJobName = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobName"]));
    }
    if (m.find("SynchronizationObjects") != m.end() && !m["SynchronizationObjects"].empty()) {
      synchronizationObjects = make_shared<string>(boost::any_cast<string>(m["SynchronizationObjects"]));
    }
  }


  virtual ~ConfigureSynchronizationJobRequest() = default;
};
class ConfigureSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSynchronizationJobResponseBody() {}

  explicit ConfigureSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSynchronizationJobResponseBody() = default;
};
class ConfigureSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSynchronizationJobResponseBody> body{};

  ConfigureSynchronizationJobResponse() {}

  explicit ConfigureSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSynchronizationJobResponse() = default;
};
class ConfigureSynchronizationJobAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  ConfigureSynchronizationJobAlertRequest() {}

  explicit ConfigureSynchronizationJobAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~ConfigureSynchronizationJobAlertRequest() = default;
};
class ConfigureSynchronizationJobAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSynchronizationJobAlertResponseBody() {}

  explicit ConfigureSynchronizationJobAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSynchronizationJobAlertResponseBody() = default;
};
class ConfigureSynchronizationJobAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSynchronizationJobAlertResponseBody> body{};

  ConfigureSynchronizationJobAlertResponse() {}

  explicit ConfigureSynchronizationJobAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSynchronizationJobAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSynchronizationJobAlertResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSynchronizationJobAlertResponse() = default;
};
class ConfigureSynchronizationJobReplicatorCompareRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<bool> synchronizationReplicatorCompareEnable{};

  ConfigureSynchronizationJobReplicatorCompareRequest() {}

  explicit ConfigureSynchronizationJobReplicatorCompareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationReplicatorCompareEnable) {
      res["SynchronizationReplicatorCompareEnable"] = boost::any(*synchronizationReplicatorCompareEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationReplicatorCompareEnable") != m.end() && !m["SynchronizationReplicatorCompareEnable"].empty()) {
      synchronizationReplicatorCompareEnable = make_shared<bool>(boost::any_cast<bool>(m["SynchronizationReplicatorCompareEnable"]));
    }
  }


  virtual ~ConfigureSynchronizationJobReplicatorCompareRequest() = default;
};
class ConfigureSynchronizationJobReplicatorCompareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ConfigureSynchronizationJobReplicatorCompareResponseBody() {}

  explicit ConfigureSynchronizationJobReplicatorCompareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ConfigureSynchronizationJobReplicatorCompareResponseBody() = default;
};
class ConfigureSynchronizationJobReplicatorCompareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigureSynchronizationJobReplicatorCompareResponseBody> body{};

  ConfigureSynchronizationJobReplicatorCompareResponse() {}

  explicit ConfigureSynchronizationJobReplicatorCompareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigureSynchronizationJobReplicatorCompareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigureSynchronizationJobReplicatorCompareResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigureSynchronizationJobReplicatorCompareResponse() = default;
};
class CountJobByConditionRequest : public Darabonba::Model {
public:
  shared_ptr<string> destDbType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> params{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> srcDbType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  CountJobByConditionRequest() {}

  explicit CountJobByConditionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destDbType) {
      res["DestDbType"] = boost::any(*destDbType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (srcDbType) {
      res["SrcDbType"] = boost::any(*srcDbType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestDbType") != m.end() && !m["DestDbType"].empty()) {
      destDbType = make_shared<string>(boost::any_cast<string>(m["DestDbType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SrcDbType") != m.end() && !m["SrcDbType"].empty()) {
      srcDbType = make_shared<string>(boost::any_cast<string>(m["SrcDbType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CountJobByConditionRequest() = default;
};
class CountJobByConditionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  CountJobByConditionResponseBody() {}

  explicit CountJobByConditionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~CountJobByConditionResponseBody() = default;
};
class CountJobByConditionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CountJobByConditionResponseBody> body{};

  CountJobByConditionResponse() {}

  explicit CountJobByConditionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountJobByConditionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountJobByConditionResponseBody>(model1);
      }
    }
  }


  virtual ~CountJobByConditionResponse() = default;
};
class CreateConsumerChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupPassword{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};

  CreateConsumerChannelRequest() {}

  explicit CreateConsumerChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupPassword) {
      res["ConsumerGroupPassword"] = boost::any(*consumerGroupPassword);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupPassword") != m.end() && !m["ConsumerGroupPassword"].empty()) {
      consumerGroupPassword = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupPassword"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateConsumerChannelRequest() = default;
};
class CreateConsumerChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupID{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateConsumerChannelResponseBody() {}

  explicit CreateConsumerChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupID) {
      res["ConsumerGroupID"] = boost::any(*consumerGroupID);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupID") != m.end() && !m["ConsumerGroupID"].empty()) {
      consumerGroupID = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupID"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateConsumerChannelResponseBody() = default;
};
class CreateConsumerChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsumerChannelResponseBody> body{};

  CreateConsumerChannelResponse() {}

  explicit CreateConsumerChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerChannelResponse() = default;
};
class CreateConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupPassword{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  CreateConsumerGroupRequest() {}

  explicit CreateConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupPassword) {
      res["ConsumerGroupPassword"] = boost::any(*consumerGroupPassword);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupPassword") != m.end() && !m["ConsumerGroupPassword"].empty()) {
      consumerGroupPassword = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupPassword"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~CreateConsumerGroupRequest() = default;
};
class CreateConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupID{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateConsumerGroupResponseBody() {}

  explicit CreateConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupID) {
      res["ConsumerGroupID"] = boost::any(*consumerGroupID);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupID") != m.end() && !m["ConsumerGroupID"].empty()) {
      consumerGroupID = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupID"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateConsumerGroupResponseBody() = default;
};
class CreateConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsumerGroupResponseBody> body{};

  CreateConsumerGroupResponse() {}

  explicit CreateConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsumerGroupResponse() = default;
};
class CreateDedicatedClusterMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> cpuAlarmThreshold{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<long> diskAlarmThreshold{};
  shared_ptr<long> duAlarmThreshold{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> memAlarmThreshold{};
  shared_ptr<long> noticeSwitch{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> phones{};
  shared_ptr<string> regionId{};

  CreateDedicatedClusterMonitorRuleRequest() {}

  explicit CreateDedicatedClusterMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuAlarmThreshold) {
      res["CpuAlarmThreshold"] = boost::any(*cpuAlarmThreshold);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (diskAlarmThreshold) {
      res["DiskAlarmThreshold"] = boost::any(*diskAlarmThreshold);
    }
    if (duAlarmThreshold) {
      res["DuAlarmThreshold"] = boost::any(*duAlarmThreshold);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memAlarmThreshold) {
      res["MemAlarmThreshold"] = boost::any(*memAlarmThreshold);
    }
    if (noticeSwitch) {
      res["NoticeSwitch"] = boost::any(*noticeSwitch);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (phones) {
      res["Phones"] = boost::any(*phones);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuAlarmThreshold") != m.end() && !m["CpuAlarmThreshold"].empty()) {
      cpuAlarmThreshold = make_shared<long>(boost::any_cast<long>(m["CpuAlarmThreshold"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DiskAlarmThreshold") != m.end() && !m["DiskAlarmThreshold"].empty()) {
      diskAlarmThreshold = make_shared<long>(boost::any_cast<long>(m["DiskAlarmThreshold"]));
    }
    if (m.find("DuAlarmThreshold") != m.end() && !m["DuAlarmThreshold"].empty()) {
      duAlarmThreshold = make_shared<long>(boost::any_cast<long>(m["DuAlarmThreshold"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MemAlarmThreshold") != m.end() && !m["MemAlarmThreshold"].empty()) {
      memAlarmThreshold = make_shared<long>(boost::any_cast<long>(m["MemAlarmThreshold"]));
    }
    if (m.find("NoticeSwitch") != m.end() && !m["NoticeSwitch"].empty()) {
      noticeSwitch = make_shared<long>(boost::any_cast<long>(m["NoticeSwitch"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Phones") != m.end() && !m["Phones"].empty()) {
      phones = make_shared<string>(boost::any_cast<string>(m["Phones"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDedicatedClusterMonitorRuleRequest() = default;
};
class CreateDedicatedClusterMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateDedicatedClusterMonitorRuleResponseBody() {}

  explicit CreateDedicatedClusterMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateDedicatedClusterMonitorRuleResponseBody() = default;
};
class CreateDedicatedClusterMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDedicatedClusterMonitorRuleResponseBody> body{};

  CreateDedicatedClusterMonitorRuleResponse() {}

  explicit CreateDedicatedClusterMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDedicatedClusterMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDedicatedClusterMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDedicatedClusterMonitorRuleResponse() = default;
};
class CreateDtsInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoStart{};
  shared_ptr<long> computeUnit{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> destinationEndpointEngineName{};
  shared_ptr<string> destinationRegion{};
  shared_ptr<long> du{};
  shared_ptr<string> feeType{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> jobId{};
  shared_ptr<double> maxDu{};
  shared_ptr<double> minDu{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};
  shared_ptr<long> quantity{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sourceEndpointEngineName{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> syncArchitecture{};
  shared_ptr<string> type{};
  shared_ptr<long> usedTime{};

  CreateDtsInstanceRequest() {}

  explicit CreateDtsInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoStart) {
      res["AutoStart"] = boost::any(*autoStart);
    }
    if (computeUnit) {
      res["ComputeUnit"] = boost::any(*computeUnit);
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (destinationEndpointEngineName) {
      res["DestinationEndpointEngineName"] = boost::any(*destinationEndpointEngineName);
    }
    if (destinationRegion) {
      res["DestinationRegion"] = boost::any(*destinationRegion);
    }
    if (du) {
      res["Du"] = boost::any(*du);
    }
    if (feeType) {
      res["FeeType"] = boost::any(*feeType);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sourceEndpointEngineName) {
      res["SourceEndpointEngineName"] = boost::any(*sourceEndpointEngineName);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (syncArchitecture) {
      res["SyncArchitecture"] = boost::any(*syncArchitecture);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoStart") != m.end() && !m["AutoStart"].empty()) {
      autoStart = make_shared<bool>(boost::any_cast<bool>(m["AutoStart"]));
    }
    if (m.find("ComputeUnit") != m.end() && !m["ComputeUnit"].empty()) {
      computeUnit = make_shared<long>(boost::any_cast<long>(m["ComputeUnit"]));
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DestinationEndpointEngineName") != m.end() && !m["DestinationEndpointEngineName"].empty()) {
      destinationEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointEngineName"]));
    }
    if (m.find("DestinationRegion") != m.end() && !m["DestinationRegion"].empty()) {
      destinationRegion = make_shared<string>(boost::any_cast<string>(m["DestinationRegion"]));
    }
    if (m.find("Du") != m.end() && !m["Du"].empty()) {
      du = make_shared<long>(boost::any_cast<long>(m["Du"]));
    }
    if (m.find("FeeType") != m.end() && !m["FeeType"].empty()) {
      feeType = make_shared<string>(boost::any_cast<string>(m["FeeType"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SourceEndpointEngineName") != m.end() && !m["SourceEndpointEngineName"].empty()) {
      sourceEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointEngineName"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SyncArchitecture") != m.end() && !m["SyncArchitecture"].empty()) {
      syncArchitecture = make_shared<string>(boost::any_cast<string>(m["SyncArchitecture"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
  }


  virtual ~CreateDtsInstanceRequest() = default;
};
class CreateDtsInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateDtsInstanceResponseBody() {}

  explicit CreateDtsInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateDtsInstanceResponseBody() = default;
};
class CreateDtsInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDtsInstanceResponseBody> body{};

  CreateDtsInstanceResponse() {}

  explicit CreateDtsInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDtsInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDtsInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDtsInstanceResponse() = default;
};
class CreateJobMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> delayRuleTime{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> noticeValue{};
  shared_ptr<long> period{};
  shared_ptr<string> phone{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<long> times{};
  shared_ptr<string> type{};

  CreateJobMonitorRuleRequest() {}

  explicit CreateJobMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayRuleTime) {
      res["DelayRuleTime"] = boost::any(*delayRuleTime);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (noticeValue) {
      res["NoticeValue"] = boost::any(*noticeValue);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayRuleTime") != m.end() && !m["DelayRuleTime"].empty()) {
      delayRuleTime = make_shared<long>(boost::any_cast<long>(m["DelayRuleTime"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("NoticeValue") != m.end() && !m["NoticeValue"].empty()) {
      noticeValue = make_shared<long>(boost::any_cast<long>(m["NoticeValue"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateJobMonitorRuleRequest() = default;
};
class CreateJobMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateJobMonitorRuleResponseBody() {}

  explicit CreateJobMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateJobMonitorRuleResponseBody() = default;
};
class CreateJobMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJobMonitorRuleResponseBody> body{};

  CreateJobMonitorRuleResponse() {}

  explicit CreateJobMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobMonitorRuleResponse() = default;
};
class CreateMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobClass{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};

  CreateMigrationJobRequest() {}

  explicit CreateMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobClass) {
      res["MigrationJobClass"] = boost::any(*migrationJobClass);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobClass") != m.end() && !m["MigrationJobClass"].empty()) {
      migrationJobClass = make_shared<string>(boost::any_cast<string>(m["MigrationJobClass"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMigrationJobRequest() = default;
};
class CreateMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateMigrationJobResponseBody() {}

  explicit CreateMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateMigrationJobResponseBody() = default;
};
class CreateMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMigrationJobResponseBody> body{};

  CreateMigrationJobResponse() {}

  explicit CreateMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMigrationJobResponse() = default;
};
class CreateReverseDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};

  CreateReverseDtsJobRequest() {}

  explicit CreateReverseDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
  }


  virtual ~CreateReverseDtsJobRequest() = default;
};
class CreateReverseDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateReverseDtsJobResponseBody() {}

  explicit CreateReverseDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateReverseDtsJobResponseBody() = default;
};
class CreateReverseDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateReverseDtsJobResponseBody> body{};

  CreateReverseDtsJobResponse() {}

  explicit CreateReverseDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateReverseDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateReverseDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateReverseDtsJobResponse() = default;
};
class CreateSubscriptionInstanceRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};

  CreateSubscriptionInstanceRequestSourceEndpoint() {}

  explicit CreateSubscriptionInstanceRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~CreateSubscriptionInstanceRequestSourceEndpoint() = default;
};
class CreateSubscriptionInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<CreateSubscriptionInstanceRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<long> usedTime{};

  CreateSubscriptionInstanceRequest() {}

  explicit CreateSubscriptionInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        CreateSubscriptionInstanceRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<CreateSubscriptionInstanceRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
  }


  virtual ~CreateSubscriptionInstanceRequest() = default;
};
class CreateSubscriptionInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subscriptionInstanceId{};
  shared_ptr<string> success{};

  CreateSubscriptionInstanceResponseBody() {}

  explicit CreateSubscriptionInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSubscriptionInstanceResponseBody() = default;
};
class CreateSubscriptionInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSubscriptionInstanceResponseBody> body{};

  CreateSubscriptionInstanceResponse() {}

  explicit CreateSubscriptionInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubscriptionInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubscriptionInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubscriptionInstanceResponse() = default;
};
class CreateSynchronizationJobRequestDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};

  CreateSynchronizationJobRequestDestinationEndpoint() {}

  explicit CreateSynchronizationJobRequestDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~CreateSynchronizationJobRequestDestinationEndpoint() = default;
};
class CreateSynchronizationJobRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> instanceType{};

  CreateSynchronizationJobRequestSourceEndpoint() {}

  explicit CreateSynchronizationJobRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~CreateSynchronizationJobRequestSourceEndpoint() = default;
};
class CreateSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<CreateSynchronizationJobRequestDestinationEndpoint> destinationEndpoint{};
  shared_ptr<CreateSynchronizationJobRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> DBInstanceCount{};
  shared_ptr<string> destRegion{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> payType{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> synchronizationJobClass{};
  shared_ptr<string> topology{};
  shared_ptr<long> usedTime{};
  shared_ptr<string> networkType{};

  CreateSynchronizationJobRequest() {}

  explicit CreateSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (DBInstanceCount) {
      res["DBInstanceCount"] = boost::any(*DBInstanceCount);
    }
    if (destRegion) {
      res["DestRegion"] = boost::any(*destRegion);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (synchronizationJobClass) {
      res["SynchronizationJobClass"] = boost::any(*synchronizationJobClass);
    }
    if (topology) {
      res["Topology"] = boost::any(*topology);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    if (networkType) {
      res["networkType"] = boost::any(*networkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        CreateSynchronizationJobRequestDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<CreateSynchronizationJobRequestDestinationEndpoint>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        CreateSynchronizationJobRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<CreateSynchronizationJobRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DBInstanceCount") != m.end() && !m["DBInstanceCount"].empty()) {
      DBInstanceCount = make_shared<long>(boost::any_cast<long>(m["DBInstanceCount"]));
    }
    if (m.find("DestRegion") != m.end() && !m["DestRegion"].empty()) {
      destRegion = make_shared<string>(boost::any_cast<string>(m["DestRegion"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SynchronizationJobClass") != m.end() && !m["SynchronizationJobClass"].empty()) {
      synchronizationJobClass = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobClass"]));
    }
    if (m.find("Topology") != m.end() && !m["Topology"].empty()) {
      topology = make_shared<string>(boost::any_cast<string>(m["Topology"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<long>(boost::any_cast<long>(m["UsedTime"]));
    }
    if (m.find("networkType") != m.end() && !m["networkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["networkType"]));
    }
  }


  virtual ~CreateSynchronizationJobRequest() = default;
};
class CreateSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchronizationJobId{};

  CreateSynchronizationJobResponseBody() {}

  explicit CreateSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~CreateSynchronizationJobResponseBody() = default;
};
class CreateSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSynchronizationJobResponseBody> body{};

  CreateSynchronizationJobResponse() {}

  explicit CreateSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSynchronizationJobResponse() = default;
};
class DeleteConsumerChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};

  DeleteConsumerChannelRequest() {}

  explicit DeleteConsumerChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteConsumerChannelRequest() = default;
};
class DeleteConsumerChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteConsumerChannelResponseBody() {}

  explicit DeleteConsumerChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteConsumerChannelResponseBody() = default;
};
class DeleteConsumerChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConsumerChannelResponseBody> body{};

  DeleteConsumerChannelResponse() {}

  explicit DeleteConsumerChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerChannelResponse() = default;
};
class DeleteConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> consumerGroupID{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  DeleteConsumerGroupRequest() {}

  explicit DeleteConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (consumerGroupID) {
      res["ConsumerGroupID"] = boost::any(*consumerGroupID);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ConsumerGroupID") != m.end() && !m["ConsumerGroupID"].empty()) {
      consumerGroupID = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupID"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~DeleteConsumerGroupRequest() = default;
};
class DeleteConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteConsumerGroupResponseBody() {}

  explicit DeleteConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteConsumerGroupResponseBody() = default;
};
class DeleteConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConsumerGroupResponseBody> body{};

  DeleteConsumerGroupResponse() {}

  explicit DeleteConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConsumerGroupResponse() = default;
};
class DeleteDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  DeleteDtsJobRequest() {}

  explicit DeleteDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~DeleteDtsJobRequest() = default;
};
class DeleteDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDtsJobResponseBody() {}

  explicit DeleteDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDtsJobResponseBody() = default;
};
class DeleteDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDtsJobResponseBody> body{};

  DeleteDtsJobResponse() {}

  explicit DeleteDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDtsJobResponse() = default;
};
class DeleteDtsJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobIds{};
  shared_ptr<string> regionId{};

  DeleteDtsJobsRequest() {}

  explicit DeleteDtsJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobIds) {
      res["DtsJobIds"] = boost::any(*dtsJobIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobIds") != m.end() && !m["DtsJobIds"].empty()) {
      dtsJobIds = make_shared<string>(boost::any_cast<string>(m["DtsJobIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDtsJobsRequest() = default;
};
class DeleteDtsJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDtsJobsResponseBody() {}

  explicit DeleteDtsJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDtsJobsResponseBody() = default;
};
class DeleteDtsJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDtsJobsResponseBody> body{};

  DeleteDtsJobsResponse() {}

  explicit DeleteDtsJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDtsJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDtsJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDtsJobsResponse() = default;
};
class DeleteMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  DeleteMigrationJobRequest() {}

  explicit DeleteMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMigrationJobRequest() = default;
};
class DeleteMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteMigrationJobResponseBody() {}

  explicit DeleteMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteMigrationJobResponseBody() = default;
};
class DeleteMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMigrationJobResponseBody> body{};

  DeleteMigrationJobResponse() {}

  explicit DeleteMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMigrationJobResponse() = default;
};
class DeleteSubscriptionInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  DeleteSubscriptionInstanceRequest() {}

  explicit DeleteSubscriptionInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~DeleteSubscriptionInstanceRequest() = default;
};
class DeleteSubscriptionInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteSubscriptionInstanceResponseBody() {}

  explicit DeleteSubscriptionInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteSubscriptionInstanceResponseBody() = default;
};
class DeleteSubscriptionInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSubscriptionInstanceResponseBody> body{};

  DeleteSubscriptionInstanceResponse() {}

  explicit DeleteSubscriptionInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubscriptionInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubscriptionInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubscriptionInstanceResponse() = default;
};
class DeleteSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationJobId{};

  DeleteSynchronizationJobRequest() {}

  explicit DeleteSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DeleteSynchronizationJobRequest() = default;
};
class DeleteSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteSynchronizationJobResponseBody() {}

  explicit DeleteSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteSynchronizationJobResponseBody() = default;
};
class DeleteSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSynchronizationJobResponseBody> body{};

  DeleteSynchronizationJobResponse() {}

  explicit DeleteSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSynchronizationJobResponse() = default;
};
class DescribeChannelAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  DescribeChannelAccountRequest() {}

  explicit DescribeChannelAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeChannelAccountRequest() = default;
};
class DescribeChannelAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> password{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> username{};

  DescribeChannelAccountResponseBody() {}

  explicit DescribeChannelAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeChannelAccountResponseBody() = default;
};
class DescribeChannelAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelAccountResponseBody> body{};

  DescribeChannelAccountResponse() {}

  explicit DescribeChannelAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelAccountResponse() = default;
};
class DescribeCheckJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeCheckJobsRequest() {}

  explicit DescribeCheckJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeCheckJobsRequest() = default;
};
class DescribeCheckJobsResponseBodyCheckJobs : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<long> checkPoint{};
  shared_ptr<long> checkType{};
  shared_ptr<long> diffCount{};
  shared_ptr<long> diffSum{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> finishCount{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> jobName{};
  shared_ptr<string> jobStepId{};
  shared_ptr<string> parentJobType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<long> totalCount{};

  DescribeCheckJobsResponseBodyCheckJobs() {}

  explicit DescribeCheckJobsResponseBodyCheckJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (checkPoint) {
      res["CheckPoint"] = boost::any(*checkPoint);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (diffCount) {
      res["DiffCount"] = boost::any(*diffCount);
    }
    if (diffSum) {
      res["DiffSum"] = boost::any(*diffSum);
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobStepId) {
      res["JobStepId"] = boost::any(*jobStepId);
    }
    if (parentJobType) {
      res["ParentJobType"] = boost::any(*parentJobType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CheckPoint") != m.end() && !m["CheckPoint"].empty()) {
      checkPoint = make_shared<long>(boost::any_cast<long>(m["CheckPoint"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("DiffCount") != m.end() && !m["DiffCount"].empty()) {
      diffCount = make_shared<long>(boost::any_cast<long>(m["DiffCount"]));
    }
    if (m.find("DiffSum") != m.end() && !m["DiffSum"].empty()) {
      diffSum = make_shared<long>(boost::any_cast<long>(m["DiffSum"]));
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobStepId") != m.end() && !m["JobStepId"].empty()) {
      jobStepId = make_shared<string>(boost::any_cast<string>(m["JobStepId"]));
    }
    if (m.find("ParentJobType") != m.end() && !m["ParentJobType"].empty()) {
      parentJobType = make_shared<string>(boost::any_cast<string>(m["ParentJobType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCheckJobsResponseBodyCheckJobs() = default;
};
class DescribeCheckJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCheckJobsResponseBodyCheckJobs>> checkJobs{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeCheckJobsResponseBody() {}

  explicit DescribeCheckJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkJobs) {
      vector<boost::any> temp1;
      for(auto item1:*checkJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckJobs"] = boost::any(temp1);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckJobs") != m.end() && !m["CheckJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckJobs"].type()) {
        vector<DescribeCheckJobsResponseBodyCheckJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckJobsResponseBodyCheckJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkJobs = make_shared<vector<DescribeCheckJobsResponseBodyCheckJobs>>(expect1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeCheckJobsResponseBody() = default;
};
class DescribeCheckJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckJobsResponseBody> body{};

  DescribeCheckJobsResponse() {}

  explicit DescribeCheckJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckJobsResponse() = default;
};
class DescribeClusterOperateLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> ownerID{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  DescribeClusterOperateLogsRequest() {}

  explicit DescribeClusterOperateLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeClusterOperateLogsRequest() = default;
};
class DescribeClusterOperateLogsResponseBodyDataPoints : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> id{};
  shared_ptr<long> logDatetime{};
  shared_ptr<string> newValue{};
  shared_ptr<string> oldValue{};
  shared_ptr<string> operationName{};
  shared_ptr<string> operationUser{};
  shared_ptr<long> success{};

  DescribeClusterOperateLogsResponseBodyDataPoints() {}

  explicit DescribeClusterOperateLogsResponseBodyDataPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (logDatetime) {
      res["LogDatetime"] = boost::any(*logDatetime);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (oldValue) {
      res["OldValue"] = boost::any(*oldValue);
    }
    if (operationName) {
      res["OperationName"] = boost::any(*operationName);
    }
    if (operationUser) {
      res["OperationUser"] = boost::any(*operationUser);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LogDatetime") != m.end() && !m["LogDatetime"].empty()) {
      logDatetime = make_shared<long>(boost::any_cast<long>(m["LogDatetime"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("OldValue") != m.end() && !m["OldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["OldValue"]));
    }
    if (m.find("OperationName") != m.end() && !m["OperationName"].empty()) {
      operationName = make_shared<string>(boost::any_cast<string>(m["OperationName"]));
    }
    if (m.find("OperationUser") != m.end() && !m["OperationUser"].empty()) {
      operationUser = make_shared<string>(boost::any_cast<string>(m["OperationUser"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
  }


  virtual ~DescribeClusterOperateLogsResponseBodyDataPoints() = default;
};
class DescribeClusterOperateLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeClusterOperateLogsResponseBodyDataPoints>> dataPoints{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeClusterOperateLogsResponseBody() {}

  explicit DescribeClusterOperateLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataPoints) {
      vector<boost::any> temp1;
      for(auto item1:*dataPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataPoints"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataPoints") != m.end() && !m["DataPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["DataPoints"].type()) {
        vector<DescribeClusterOperateLogsResponseBodyDataPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterOperateLogsResponseBodyDataPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataPoints = make_shared<vector<DescribeClusterOperateLogsResponseBodyDataPoints>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeClusterOperateLogsResponseBody() = default;
};
class DescribeClusterOperateLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterOperateLogsResponseBody> body{};

  DescribeClusterOperateLogsResponse() {}

  explicit DescribeClusterOperateLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterOperateLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterOperateLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterOperateLogsResponse() = default;
};
class DescribeClusterUsedUtilizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> env{};
  shared_ptr<string> metricType{};
  shared_ptr<string> ownerID{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityToken{};

  DescribeClusterUsedUtilizationRequest() {}

  explicit DescribeClusterUsedUtilizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeClusterUsedUtilizationRequest() = default;
};
class DescribeClusterUsedUtilizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<double> cpuTotal{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<double> diskTotal{};
  shared_ptr<double> diskUsed{};
  shared_ptr<long> duTotal{};
  shared_ptr<long> duUsed{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<double> memoryTotal{};
  shared_ptr<double> memoryUsed{};
  shared_ptr<double> memoryUsedPercentage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> taskRunning{};

  DescribeClusterUsedUtilizationResponseBody() {}

  explicit DescribeClusterUsedUtilizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cpuTotal) {
      res["CpuTotal"] = boost::any(*cpuTotal);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (diskTotal) {
      res["DiskTotal"] = boost::any(*diskTotal);
    }
    if (diskUsed) {
      res["DiskUsed"] = boost::any(*diskUsed);
    }
    if (duTotal) {
      res["DuTotal"] = boost::any(*duTotal);
    }
    if (duUsed) {
      res["DuUsed"] = boost::any(*duUsed);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (memoryTotal) {
      res["MemoryTotal"] = boost::any(*memoryTotal);
    }
    if (memoryUsed) {
      res["MemoryUsed"] = boost::any(*memoryUsed);
    }
    if (memoryUsedPercentage) {
      res["MemoryUsedPercentage"] = boost::any(*memoryUsedPercentage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskRunning) {
      res["TaskRunning"] = boost::any(*taskRunning);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CpuTotal") != m.end() && !m["CpuTotal"].empty()) {
      cpuTotal = make_shared<double>(boost::any_cast<double>(m["CpuTotal"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DiskTotal") != m.end() && !m["DiskTotal"].empty()) {
      diskTotal = make_shared<double>(boost::any_cast<double>(m["DiskTotal"]));
    }
    if (m.find("DiskUsed") != m.end() && !m["DiskUsed"].empty()) {
      diskUsed = make_shared<double>(boost::any_cast<double>(m["DiskUsed"]));
    }
    if (m.find("DuTotal") != m.end() && !m["DuTotal"].empty()) {
      duTotal = make_shared<long>(boost::any_cast<long>(m["DuTotal"]));
    }
    if (m.find("DuUsed") != m.end() && !m["DuUsed"].empty()) {
      duUsed = make_shared<long>(boost::any_cast<long>(m["DuUsed"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MemoryTotal") != m.end() && !m["MemoryTotal"].empty()) {
      memoryTotal = make_shared<double>(boost::any_cast<double>(m["MemoryTotal"]));
    }
    if (m.find("MemoryUsed") != m.end() && !m["MemoryUsed"].empty()) {
      memoryUsed = make_shared<double>(boost::any_cast<double>(m["MemoryUsed"]));
    }
    if (m.find("MemoryUsedPercentage") != m.end() && !m["MemoryUsedPercentage"].empty()) {
      memoryUsedPercentage = make_shared<double>(boost::any_cast<double>(m["MemoryUsedPercentage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskRunning") != m.end() && !m["TaskRunning"].empty()) {
      taskRunning = make_shared<long>(boost::any_cast<long>(m["TaskRunning"]));
    }
  }


  virtual ~DescribeClusterUsedUtilizationResponseBody() = default;
};
class DescribeClusterUsedUtilizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterUsedUtilizationResponseBody> body{};

  DescribeClusterUsedUtilizationResponse() {}

  explicit DescribeClusterUsedUtilizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterUsedUtilizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterUsedUtilizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterUsedUtilizationResponse() = default;
};
class DescribeConnectionStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationEndpointArchitecture{};
  shared_ptr<string> destinationEndpointDatabaseName{};
  shared_ptr<string> destinationEndpointEngineName{};
  shared_ptr<string> destinationEndpointIP{};
  shared_ptr<string> destinationEndpointInstanceID{};
  shared_ptr<string> destinationEndpointInstanceType{};
  shared_ptr<string> destinationEndpointOracleSID{};
  shared_ptr<string> destinationEndpointPassword{};
  shared_ptr<string> destinationEndpointPort{};
  shared_ptr<string> destinationEndpointRegion{};
  shared_ptr<string> destinationEndpointUserName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceEndpointArchitecture{};
  shared_ptr<string> sourceEndpointDatabaseName{};
  shared_ptr<string> sourceEndpointEngineName{};
  shared_ptr<string> sourceEndpointIP{};
  shared_ptr<string> sourceEndpointInstanceID{};
  shared_ptr<string> sourceEndpointInstanceType{};
  shared_ptr<string> sourceEndpointOracleSID{};
  shared_ptr<string> sourceEndpointPassword{};
  shared_ptr<string> sourceEndpointPort{};
  shared_ptr<string> sourceEndpointRegion{};
  shared_ptr<string> sourceEndpointUserName{};

  DescribeConnectionStatusRequest() {}

  explicit DescribeConnectionStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationEndpointArchitecture) {
      res["DestinationEndpointArchitecture"] = boost::any(*destinationEndpointArchitecture);
    }
    if (destinationEndpointDatabaseName) {
      res["DestinationEndpointDatabaseName"] = boost::any(*destinationEndpointDatabaseName);
    }
    if (destinationEndpointEngineName) {
      res["DestinationEndpointEngineName"] = boost::any(*destinationEndpointEngineName);
    }
    if (destinationEndpointIP) {
      res["DestinationEndpointIP"] = boost::any(*destinationEndpointIP);
    }
    if (destinationEndpointInstanceID) {
      res["DestinationEndpointInstanceID"] = boost::any(*destinationEndpointInstanceID);
    }
    if (destinationEndpointInstanceType) {
      res["DestinationEndpointInstanceType"] = boost::any(*destinationEndpointInstanceType);
    }
    if (destinationEndpointOracleSID) {
      res["DestinationEndpointOracleSID"] = boost::any(*destinationEndpointOracleSID);
    }
    if (destinationEndpointPassword) {
      res["DestinationEndpointPassword"] = boost::any(*destinationEndpointPassword);
    }
    if (destinationEndpointPort) {
      res["DestinationEndpointPort"] = boost::any(*destinationEndpointPort);
    }
    if (destinationEndpointRegion) {
      res["DestinationEndpointRegion"] = boost::any(*destinationEndpointRegion);
    }
    if (destinationEndpointUserName) {
      res["DestinationEndpointUserName"] = boost::any(*destinationEndpointUserName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceEndpointArchitecture) {
      res["SourceEndpointArchitecture"] = boost::any(*sourceEndpointArchitecture);
    }
    if (sourceEndpointDatabaseName) {
      res["SourceEndpointDatabaseName"] = boost::any(*sourceEndpointDatabaseName);
    }
    if (sourceEndpointEngineName) {
      res["SourceEndpointEngineName"] = boost::any(*sourceEndpointEngineName);
    }
    if (sourceEndpointIP) {
      res["SourceEndpointIP"] = boost::any(*sourceEndpointIP);
    }
    if (sourceEndpointInstanceID) {
      res["SourceEndpointInstanceID"] = boost::any(*sourceEndpointInstanceID);
    }
    if (sourceEndpointInstanceType) {
      res["SourceEndpointInstanceType"] = boost::any(*sourceEndpointInstanceType);
    }
    if (sourceEndpointOracleSID) {
      res["SourceEndpointOracleSID"] = boost::any(*sourceEndpointOracleSID);
    }
    if (sourceEndpointPassword) {
      res["SourceEndpointPassword"] = boost::any(*sourceEndpointPassword);
    }
    if (sourceEndpointPort) {
      res["SourceEndpointPort"] = boost::any(*sourceEndpointPort);
    }
    if (sourceEndpointRegion) {
      res["SourceEndpointRegion"] = boost::any(*sourceEndpointRegion);
    }
    if (sourceEndpointUserName) {
      res["SourceEndpointUserName"] = boost::any(*sourceEndpointUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationEndpointArchitecture") != m.end() && !m["DestinationEndpointArchitecture"].empty()) {
      destinationEndpointArchitecture = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointArchitecture"]));
    }
    if (m.find("DestinationEndpointDatabaseName") != m.end() && !m["DestinationEndpointDatabaseName"].empty()) {
      destinationEndpointDatabaseName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointDatabaseName"]));
    }
    if (m.find("DestinationEndpointEngineName") != m.end() && !m["DestinationEndpointEngineName"].empty()) {
      destinationEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointEngineName"]));
    }
    if (m.find("DestinationEndpointIP") != m.end() && !m["DestinationEndpointIP"].empty()) {
      destinationEndpointIP = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointIP"]));
    }
    if (m.find("DestinationEndpointInstanceID") != m.end() && !m["DestinationEndpointInstanceID"].empty()) {
      destinationEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceID"]));
    }
    if (m.find("DestinationEndpointInstanceType") != m.end() && !m["DestinationEndpointInstanceType"].empty()) {
      destinationEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointInstanceType"]));
    }
    if (m.find("DestinationEndpointOracleSID") != m.end() && !m["DestinationEndpointOracleSID"].empty()) {
      destinationEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointOracleSID"]));
    }
    if (m.find("DestinationEndpointPassword") != m.end() && !m["DestinationEndpointPassword"].empty()) {
      destinationEndpointPassword = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPassword"]));
    }
    if (m.find("DestinationEndpointPort") != m.end() && !m["DestinationEndpointPort"].empty()) {
      destinationEndpointPort = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointPort"]));
    }
    if (m.find("DestinationEndpointRegion") != m.end() && !m["DestinationEndpointRegion"].empty()) {
      destinationEndpointRegion = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRegion"]));
    }
    if (m.find("DestinationEndpointUserName") != m.end() && !m["DestinationEndpointUserName"].empty()) {
      destinationEndpointUserName = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointUserName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceEndpointArchitecture") != m.end() && !m["SourceEndpointArchitecture"].empty()) {
      sourceEndpointArchitecture = make_shared<string>(boost::any_cast<string>(m["SourceEndpointArchitecture"]));
    }
    if (m.find("SourceEndpointDatabaseName") != m.end() && !m["SourceEndpointDatabaseName"].empty()) {
      sourceEndpointDatabaseName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointDatabaseName"]));
    }
    if (m.find("SourceEndpointEngineName") != m.end() && !m["SourceEndpointEngineName"].empty()) {
      sourceEndpointEngineName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointEngineName"]));
    }
    if (m.find("SourceEndpointIP") != m.end() && !m["SourceEndpointIP"].empty()) {
      sourceEndpointIP = make_shared<string>(boost::any_cast<string>(m["SourceEndpointIP"]));
    }
    if (m.find("SourceEndpointInstanceID") != m.end() && !m["SourceEndpointInstanceID"].empty()) {
      sourceEndpointInstanceID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceID"]));
    }
    if (m.find("SourceEndpointInstanceType") != m.end() && !m["SourceEndpointInstanceType"].empty()) {
      sourceEndpointInstanceType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointInstanceType"]));
    }
    if (m.find("SourceEndpointOracleSID") != m.end() && !m["SourceEndpointOracleSID"].empty()) {
      sourceEndpointOracleSID = make_shared<string>(boost::any_cast<string>(m["SourceEndpointOracleSID"]));
    }
    if (m.find("SourceEndpointPassword") != m.end() && !m["SourceEndpointPassword"].empty()) {
      sourceEndpointPassword = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPassword"]));
    }
    if (m.find("SourceEndpointPort") != m.end() && !m["SourceEndpointPort"].empty()) {
      sourceEndpointPort = make_shared<string>(boost::any_cast<string>(m["SourceEndpointPort"]));
    }
    if (m.find("SourceEndpointRegion") != m.end() && !m["SourceEndpointRegion"].empty()) {
      sourceEndpointRegion = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRegion"]));
    }
    if (m.find("SourceEndpointUserName") != m.end() && !m["SourceEndpointUserName"].empty()) {
      sourceEndpointUserName = make_shared<string>(boost::any_cast<string>(m["SourceEndpointUserName"]));
    }
  }


  virtual ~DescribeConnectionStatusRequest() = default;
};
class DescribeConnectionStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> destinationConnectionStatus{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> sourceConnectionStatus{};
  shared_ptr<string> success{};

  DescribeConnectionStatusResponseBody() {}

  explicit DescribeConnectionStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationConnectionStatus) {
      res["DestinationConnectionStatus"] = boost::any(*destinationConnectionStatus);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceConnectionStatus) {
      res["SourceConnectionStatus"] = boost::any(*sourceConnectionStatus);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationConnectionStatus") != m.end() && !m["DestinationConnectionStatus"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DestinationConnectionStatus"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      destinationConnectionStatus = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceConnectionStatus") != m.end() && !m["SourceConnectionStatus"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SourceConnectionStatus"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sourceConnectionStatus = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeConnectionStatusResponseBody() = default;
};
class DescribeConnectionStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConnectionStatusResponseBody> body{};

  DescribeConnectionStatusResponse() {}

  explicit DescribeConnectionStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConnectionStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConnectionStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConnectionStatusResponse() = default;
};
class DescribeConsumerChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentChannelId{};
  shared_ptr<string> regionId{};

  DescribeConsumerChannelRequest() {}

  explicit DescribeConsumerChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentChannelId) {
      res["ParentChannelId"] = boost::any(*parentChannelId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentChannelId") != m.end() && !m["ParentChannelId"].empty()) {
      parentChannelId = make_shared<string>(boost::any_cast<string>(m["ParentChannelId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeConsumerChannelRequest() = default;
};
class DescribeConsumerChannelResponseBodyConsumerChannels : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<long> messageDelay{};
  shared_ptr<long> unconsumedData{};

  DescribeConsumerChannelResponseBodyConsumerChannels() {}

  explicit DescribeConsumerChannelResponseBodyConsumerChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (messageDelay) {
      res["MessageDelay"] = boost::any(*messageDelay);
    }
    if (unconsumedData) {
      res["UnconsumedData"] = boost::any(*unconsumedData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("MessageDelay") != m.end() && !m["MessageDelay"].empty()) {
      messageDelay = make_shared<long>(boost::any_cast<long>(m["MessageDelay"]));
    }
    if (m.find("UnconsumedData") != m.end() && !m["UnconsumedData"].empty()) {
      unconsumedData = make_shared<long>(boost::any_cast<long>(m["UnconsumedData"]));
    }
  }


  virtual ~DescribeConsumerChannelResponseBodyConsumerChannels() = default;
};
class DescribeConsumerChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeConsumerChannelResponseBodyConsumerChannels>> consumerChannels{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeConsumerChannelResponseBody() {}

  explicit DescribeConsumerChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerChannels) {
      vector<boost::any> temp1;
      for(auto item1:*consumerChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumerChannels"] = boost::any(temp1);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerChannels") != m.end() && !m["ConsumerChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumerChannels"].type()) {
        vector<DescribeConsumerChannelResponseBodyConsumerChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumerChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsumerChannelResponseBodyConsumerChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumerChannels = make_shared<vector<DescribeConsumerChannelResponseBodyConsumerChannels>>(expect1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeConsumerChannelResponseBody() = default;
};
class DescribeConsumerChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsumerChannelResponseBody> body{};

  DescribeConsumerChannelResponse() {}

  explicit DescribeConsumerChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsumerChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsumerChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsumerChannelResponse() = default;
};
class DescribeConsumerGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  DescribeConsumerGroupRequest() {}

  explicit DescribeConsumerGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~DescribeConsumerGroupRequest() = default;
};
class DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupID{};
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<long> messageDelay{};
  shared_ptr<long> unconsumedData{};

  DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel() {}

  explicit DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupID) {
      res["ConsumerGroupID"] = boost::any(*consumerGroupID);
    }
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (messageDelay) {
      res["MessageDelay"] = boost::any(*messageDelay);
    }
    if (unconsumedData) {
      res["UnconsumedData"] = boost::any(*unconsumedData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupID") != m.end() && !m["ConsumerGroupID"].empty()) {
      consumerGroupID = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupID"]));
    }
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("MessageDelay") != m.end() && !m["MessageDelay"].empty()) {
      messageDelay = make_shared<long>(boost::any_cast<long>(m["MessageDelay"]));
    }
    if (m.find("UnconsumedData") != m.end() && !m["UnconsumedData"].empty()) {
      unconsumedData = make_shared<long>(boost::any_cast<long>(m["UnconsumedData"]));
    }
  }


  virtual ~DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel() = default;
};
class DescribeConsumerGroupResponseBodyConsumerChannels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel>> describeConsumerChannel{};

  DescribeConsumerGroupResponseBodyConsumerChannels() {}

  explicit DescribeConsumerGroupResponseBodyConsumerChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describeConsumerChannel) {
      vector<boost::any> temp1;
      for(auto item1:*describeConsumerChannel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeConsumerChannel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DescribeConsumerChannel") != m.end() && !m["DescribeConsumerChannel"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeConsumerChannel"].type()) {
        vector<DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeConsumerChannel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeConsumerChannel = make_shared<vector<DescribeConsumerGroupResponseBodyConsumerChannelsDescribeConsumerChannel>>(expect1);
      }
    }
  }


  virtual ~DescribeConsumerGroupResponseBodyConsumerChannels() = default;
};
class DescribeConsumerGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeConsumerGroupResponseBodyConsumerChannels> consumerChannels{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeConsumerGroupResponseBody() {}

  explicit DescribeConsumerGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerChannels) {
      res["ConsumerChannels"] = consumerChannels ? boost::any(consumerChannels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerChannels") != m.end() && !m["ConsumerChannels"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsumerChannels"].type()) {
        DescribeConsumerGroupResponseBodyConsumerChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsumerChannels"]));
        consumerChannels = make_shared<DescribeConsumerGroupResponseBodyConsumerChannels>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeConsumerGroupResponseBody() = default;
};
class DescribeConsumerGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsumerGroupResponseBody> body{};

  DescribeConsumerGroupResponse() {}

  explicit DescribeConsumerGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsumerGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsumerGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsumerGroupResponse() = default;
};
class DescribeDTSIPRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationEndpointRegion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sourceEndpointRegion{};

  DescribeDTSIPRequest() {}

  explicit DescribeDTSIPRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationEndpointRegion) {
      res["DestinationEndpointRegion"] = boost::any(*destinationEndpointRegion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sourceEndpointRegion) {
      res["SourceEndpointRegion"] = boost::any(*sourceEndpointRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationEndpointRegion") != m.end() && !m["DestinationEndpointRegion"].empty()) {
      destinationEndpointRegion = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointRegion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SourceEndpointRegion") != m.end() && !m["SourceEndpointRegion"].empty()) {
      sourceEndpointRegion = make_shared<string>(boost::any_cast<string>(m["SourceEndpointRegion"]));
    }
  }


  virtual ~DescribeDTSIPRequest() = default;
};
class DescribeDTSIPResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeDTSIPResponseBody() {}

  explicit DescribeDTSIPResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeDTSIPResponseBody() = default;
};
class DescribeDTSIPResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDTSIPResponseBody> body{};

  DescribeDTSIPResponse() {}

  explicit DescribeDTSIPResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDTSIPResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDTSIPResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDTSIPResponse() = default;
};
class DescribeDataCheckReportUrlRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkType{};
  shared_ptr<string> dbName{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> tbName{};

  DescribeDataCheckReportUrlRequest() {}

  explicit DescribeDataCheckReportUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (tbName) {
      res["TbName"] = boost::any(*tbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("TbName") != m.end() && !m["TbName"].empty()) {
      tbName = make_shared<string>(boost::any_cast<string>(m["TbName"]));
    }
  }


  virtual ~DescribeDataCheckReportUrlRequest() = default;
};
class DescribeDataCheckReportUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeDataCheckReportUrlResponseBody() {}

  explicit DescribeDataCheckReportUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeDataCheckReportUrlResponseBody() = default;
};
class DescribeDataCheckReportUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataCheckReportUrlResponseBody> body{};

  DescribeDataCheckReportUrlResponse() {}

  explicit DescribeDataCheckReportUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataCheckReportUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataCheckReportUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataCheckReportUrlResponse() = default;
};
class DescribeDataCheckTableDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkType{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> schemaName{};
  shared_ptr<string> status{};
  shared_ptr<string> tableName{};

  DescribeDataCheckTableDetailsRequest() {}

  explicit DescribeDataCheckTableDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeDataCheckTableDetailsRequest() = default;
};
class DescribeDataCheckTableDetailsResponseBodyTableDetails : public Darabonba::Model {
public:
  shared_ptr<string> bootTime{};
  shared_ptr<long> diffCount{};
  shared_ptr<long> errorCode{};
  shared_ptr<long> finishCount{};
  shared_ptr<long> id{};
  shared_ptr<string> sourceDbName{};
  shared_ptr<string> sourceTbName{};
  shared_ptr<string> status{};
  shared_ptr<string> targetDbName{};
  shared_ptr<string> targetTbName{};
  shared_ptr<long> totalCount{};

  DescribeDataCheckTableDetailsResponseBodyTableDetails() {}

  explicit DescribeDataCheckTableDetailsResponseBodyTableDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (diffCount) {
      res["DiffCount"] = boost::any(*diffCount);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sourceDbName) {
      res["SourceDbName"] = boost::any(*sourceDbName);
    }
    if (sourceTbName) {
      res["SourceTbName"] = boost::any(*sourceTbName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetDbName) {
      res["TargetDbName"] = boost::any(*targetDbName);
    }
    if (targetTbName) {
      res["TargetTbName"] = boost::any(*targetTbName);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("DiffCount") != m.end() && !m["DiffCount"].empty()) {
      diffCount = make_shared<long>(boost::any_cast<long>(m["DiffCount"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SourceDbName") != m.end() && !m["SourceDbName"].empty()) {
      sourceDbName = make_shared<string>(boost::any_cast<string>(m["SourceDbName"]));
    }
    if (m.find("SourceTbName") != m.end() && !m["SourceTbName"].empty()) {
      sourceTbName = make_shared<string>(boost::any_cast<string>(m["SourceTbName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetDbName") != m.end() && !m["TargetDbName"].empty()) {
      targetDbName = make_shared<string>(boost::any_cast<string>(m["TargetDbName"]));
    }
    if (m.find("TargetTbName") != m.end() && !m["TargetTbName"].empty()) {
      targetTbName = make_shared<string>(boost::any_cast<string>(m["TargetTbName"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataCheckTableDetailsResponseBodyTableDetails() = default;
};
class DescribeDataCheckTableDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> diffTableCount{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> finishedCount{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<DescribeDataCheckTableDetailsResponseBodyTableDetails>> tableDetails{};
  shared_ptr<long> totalCount{};

  DescribeDataCheckTableDetailsResponseBody() {}

  explicit DescribeDataCheckTableDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diffTableCount) {
      res["DiffTableCount"] = boost::any(*diffTableCount);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (finishedCount) {
      res["FinishedCount"] = boost::any(*finishedCount);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tableDetails) {
      vector<boost::any> temp1;
      for(auto item1:*tableDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableDetails"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiffTableCount") != m.end() && !m["DiffTableCount"].empty()) {
      diffTableCount = make_shared<long>(boost::any_cast<long>(m["DiffTableCount"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("FinishedCount") != m.end() && !m["FinishedCount"].empty()) {
      finishedCount = make_shared<long>(boost::any_cast<long>(m["FinishedCount"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TableDetails") != m.end() && !m["TableDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["TableDetails"].type()) {
        vector<DescribeDataCheckTableDetailsResponseBodyTableDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataCheckTableDetailsResponseBodyTableDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableDetails = make_shared<vector<DescribeDataCheckTableDetailsResponseBodyTableDetails>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataCheckTableDetailsResponseBody() = default;
};
class DescribeDataCheckTableDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataCheckTableDetailsResponseBody> body{};

  DescribeDataCheckTableDetailsResponse() {}

  explicit DescribeDataCheckTableDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataCheckTableDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataCheckTableDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataCheckTableDetailsResponse() = default;
};
class DescribeDataCheckTableDiffDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkType{};
  shared_ptr<string> dbName{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tbName{};

  DescribeDataCheckTableDiffDetailsRequest() {}

  explicit DescribeDataCheckTableDiffDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tbName) {
      res["TbName"] = boost::any(*tbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TbName") != m.end() && !m["TbName"].empty()) {
      tbName = make_shared<string>(boost::any_cast<string>(m["TbName"]));
    }
  }


  virtual ~DescribeDataCheckTableDiffDetailsRequest() = default;
};
class DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails : public Darabonba::Model {
public:
  shared_ptr<string> diff{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<long> id{};

  DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails() {}

  explicit DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diff) {
      res["Diff"] = boost::any(*diff);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Diff") != m.end() && !m["Diff"].empty()) {
      diff = make_shared<string>(boost::any_cast<string>(m["Diff"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails() = default;
};
class DescribeDataCheckTableDiffDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<long> diffCount{};
  shared_ptr<vector<DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails>> diffDetails{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> tbName{};

  DescribeDataCheckTableDiffDetailsResponseBody() {}

  explicit DescribeDataCheckTableDiffDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (diffCount) {
      res["DiffCount"] = boost::any(*diffCount);
    }
    if (diffDetails) {
      vector<boost::any> temp1;
      for(auto item1:*diffDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DiffDetails"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tbName) {
      res["TbName"] = boost::any(*tbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DiffCount") != m.end() && !m["DiffCount"].empty()) {
      diffCount = make_shared<long>(boost::any_cast<long>(m["DiffCount"]));
    }
    if (m.find("DiffDetails") != m.end() && !m["DiffDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["DiffDetails"].type()) {
        vector<DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DiffDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diffDetails = make_shared<vector<DescribeDataCheckTableDiffDetailsResponseBodyDiffDetails>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TbName") != m.end() && !m["TbName"].empty()) {
      tbName = make_shared<string>(boost::any_cast<string>(m["TbName"]));
    }
  }


  virtual ~DescribeDataCheckTableDiffDetailsResponseBody() = default;
};
class DescribeDataCheckTableDiffDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataCheckTableDiffDetailsResponseBody> body{};

  DescribeDataCheckTableDiffDetailsResponse() {}

  explicit DescribeDataCheckTableDiffDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataCheckTableDiffDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataCheckTableDiffDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataCheckTableDiffDetailsResponse() = default;
};
class DescribeDedicatedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  DescribeDedicatedClusterRequest() {}

  explicit DescribeDedicatedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDedicatedClusterRequest() = default;
};
class DescribeDedicatedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> cpuUtilization{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dedicatedClusterName{};
  shared_ptr<long> diskUtilization{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<long> du{};
  shared_ptr<long> duUtilization{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> gmtCreated{};
  shared_ptr<long> gmtFinished{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> memUtilization{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> oversoldDu{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> success{};
  shared_ptr<long> totalCpuCore{};
  shared_ptr<long> totalDiskGBSize{};
  shared_ptr<long> totalMemGBSize{};
  shared_ptr<long> usedCpuCore{};
  shared_ptr<long> usedDiskGBSize{};
  shared_ptr<long> usedDu{};
  shared_ptr<long> usedMemGBSize{};

  DescribeDedicatedClusterResponseBody() {}

  explicit DescribeDedicatedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuUtilization) {
      res["CpuUtilization"] = boost::any(*cpuUtilization);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dedicatedClusterName) {
      res["DedicatedClusterName"] = boost::any(*dedicatedClusterName);
    }
    if (diskUtilization) {
      res["DiskUtilization"] = boost::any(*diskUtilization);
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (du) {
      res["Du"] = boost::any(*du);
    }
    if (duUtilization) {
      res["DuUtilization"] = boost::any(*duUtilization);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtFinished) {
      res["GmtFinished"] = boost::any(*gmtFinished);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (memUtilization) {
      res["MemUtilization"] = boost::any(*memUtilization);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (oversoldDu) {
      res["OversoldDu"] = boost::any(*oversoldDu);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCpuCore) {
      res["TotalCpuCore"] = boost::any(*totalCpuCore);
    }
    if (totalDiskGBSize) {
      res["TotalDiskGBSize"] = boost::any(*totalDiskGBSize);
    }
    if (totalMemGBSize) {
      res["TotalMemGBSize"] = boost::any(*totalMemGBSize);
    }
    if (usedCpuCore) {
      res["UsedCpuCore"] = boost::any(*usedCpuCore);
    }
    if (usedDiskGBSize) {
      res["UsedDiskGBSize"] = boost::any(*usedDiskGBSize);
    }
    if (usedDu) {
      res["UsedDu"] = boost::any(*usedDu);
    }
    if (usedMemGBSize) {
      res["UsedMemGBSize"] = boost::any(*usedMemGBSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuUtilization") != m.end() && !m["CpuUtilization"].empty()) {
      cpuUtilization = make_shared<long>(boost::any_cast<long>(m["CpuUtilization"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DedicatedClusterName") != m.end() && !m["DedicatedClusterName"].empty()) {
      dedicatedClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterName"]));
    }
    if (m.find("DiskUtilization") != m.end() && !m["DiskUtilization"].empty()) {
      diskUtilization = make_shared<long>(boost::any_cast<long>(m["DiskUtilization"]));
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("Du") != m.end() && !m["Du"].empty()) {
      du = make_shared<long>(boost::any_cast<long>(m["Du"]));
    }
    if (m.find("DuUtilization") != m.end() && !m["DuUtilization"].empty()) {
      duUtilization = make_shared<long>(boost::any_cast<long>(m["DuUtilization"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<long>(boost::any_cast<long>(m["GmtCreated"]));
    }
    if (m.find("GmtFinished") != m.end() && !m["GmtFinished"].empty()) {
      gmtFinished = make_shared<long>(boost::any_cast<long>(m["GmtFinished"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      memUtilization = make_shared<long>(boost::any_cast<long>(m["MemUtilization"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("OversoldDu") != m.end() && !m["OversoldDu"].empty()) {
      oversoldDu = make_shared<long>(boost::any_cast<long>(m["OversoldDu"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalCpuCore") != m.end() && !m["TotalCpuCore"].empty()) {
      totalCpuCore = make_shared<long>(boost::any_cast<long>(m["TotalCpuCore"]));
    }
    if (m.find("TotalDiskGBSize") != m.end() && !m["TotalDiskGBSize"].empty()) {
      totalDiskGBSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskGBSize"]));
    }
    if (m.find("TotalMemGBSize") != m.end() && !m["TotalMemGBSize"].empty()) {
      totalMemGBSize = make_shared<long>(boost::any_cast<long>(m["TotalMemGBSize"]));
    }
    if (m.find("UsedCpuCore") != m.end() && !m["UsedCpuCore"].empty()) {
      usedCpuCore = make_shared<long>(boost::any_cast<long>(m["UsedCpuCore"]));
    }
    if (m.find("UsedDiskGBSize") != m.end() && !m["UsedDiskGBSize"].empty()) {
      usedDiskGBSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskGBSize"]));
    }
    if (m.find("UsedDu") != m.end() && !m["UsedDu"].empty()) {
      usedDu = make_shared<long>(boost::any_cast<long>(m["UsedDu"]));
    }
    if (m.find("UsedMemGBSize") != m.end() && !m["UsedMemGBSize"].empty()) {
      usedMemGBSize = make_shared<long>(boost::any_cast<long>(m["UsedMemGBSize"]));
    }
  }


  virtual ~DescribeDedicatedClusterResponseBody() = default;
};
class DescribeDedicatedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedClusterResponseBody> body{};

  DescribeDedicatedClusterResponse() {}

  explicit DescribeDedicatedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedClusterResponse() = default;
};
class DescribeDedicatedClusterMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  DescribeDedicatedClusterMonitorRuleRequest() {}

  explicit DescribeDedicatedClusterMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDedicatedClusterMonitorRuleRequest() = default;
};
class DescribeDedicatedClusterMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cpuAlarmThreshold{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> diskAlarmThreshold{};
  shared_ptr<string> duAlarmThreshold{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> memAlarmThreshold{};
  shared_ptr<string> noticeSwitch{};
  shared_ptr<string> phones{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeDedicatedClusterMonitorRuleResponseBody() {}

  explicit DescribeDedicatedClusterMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuAlarmThreshold) {
      res["CpuAlarmThreshold"] = boost::any(*cpuAlarmThreshold);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (diskAlarmThreshold) {
      res["DiskAlarmThreshold"] = boost::any(*diskAlarmThreshold);
    }
    if (duAlarmThreshold) {
      res["DuAlarmThreshold"] = boost::any(*duAlarmThreshold);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (memAlarmThreshold) {
      res["MemAlarmThreshold"] = boost::any(*memAlarmThreshold);
    }
    if (noticeSwitch) {
      res["NoticeSwitch"] = boost::any(*noticeSwitch);
    }
    if (phones) {
      res["Phones"] = boost::any(*phones);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuAlarmThreshold") != m.end() && !m["CpuAlarmThreshold"].empty()) {
      cpuAlarmThreshold = make_shared<string>(boost::any_cast<string>(m["CpuAlarmThreshold"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DiskAlarmThreshold") != m.end() && !m["DiskAlarmThreshold"].empty()) {
      diskAlarmThreshold = make_shared<string>(boost::any_cast<string>(m["DiskAlarmThreshold"]));
    }
    if (m.find("DuAlarmThreshold") != m.end() && !m["DuAlarmThreshold"].empty()) {
      duAlarmThreshold = make_shared<string>(boost::any_cast<string>(m["DuAlarmThreshold"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("MemAlarmThreshold") != m.end() && !m["MemAlarmThreshold"].empty()) {
      memAlarmThreshold = make_shared<string>(boost::any_cast<string>(m["MemAlarmThreshold"]));
    }
    if (m.find("NoticeSwitch") != m.end() && !m["NoticeSwitch"].empty()) {
      noticeSwitch = make_shared<string>(boost::any_cast<string>(m["NoticeSwitch"]));
    }
    if (m.find("Phones") != m.end() && !m["Phones"].empty()) {
      phones = make_shared<string>(boost::any_cast<string>(m["Phones"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeDedicatedClusterMonitorRuleResponseBody() = default;
};
class DescribeDedicatedClusterMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDedicatedClusterMonitorRuleResponseBody> body{};

  DescribeDedicatedClusterMonitorRuleResponse() {}

  explicit DescribeDedicatedClusterMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDedicatedClusterMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDedicatedClusterMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDedicatedClusterMonitorRuleResponse() = default;
};
class DescribeDtsEtlJobVersionInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeDtsEtlJobVersionInfoRequest() {}

  explicit DescribeDtsEtlJobVersionInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDtsEtlJobVersionInfoRequest() = default;
};
class DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> safeCheckpoint{};
  shared_ptr<string> status{};
  shared_ptr<long> version{};

  DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos() {}

  explicit DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (safeCheckpoint) {
      res["SafeCheckpoint"] = boost::any(*safeCheckpoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("SafeCheckpoint") != m.end() && !m["SafeCheckpoint"].empty()) {
      safeCheckpoint = make_shared<string>(boost::any_cast<string>(m["SafeCheckpoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos() = default;
};
class DescribeDtsEtlJobVersionInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos>> dtsEtlJobVersionInfos{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeDtsEtlJobVersionInfoResponseBody() {}

  explicit DescribeDtsEtlJobVersionInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsEtlJobVersionInfos) {
      vector<boost::any> temp1;
      for(auto item1:*dtsEtlJobVersionInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DtsEtlJobVersionInfos"] = boost::any(temp1);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsEtlJobVersionInfos") != m.end() && !m["DtsEtlJobVersionInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["DtsEtlJobVersionInfos"].type()) {
        vector<DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DtsEtlJobVersionInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dtsEtlJobVersionInfos = make_shared<vector<DescribeDtsEtlJobVersionInfoResponseBodyDtsEtlJobVersionInfos>>(expect1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeDtsEtlJobVersionInfoResponseBody() = default;
};
class DescribeDtsEtlJobVersionInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDtsEtlJobVersionInfoResponseBody> body{};

  DescribeDtsEtlJobVersionInfoResponse() {}

  explicit DescribeDtsEtlJobVersionInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDtsEtlJobVersionInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDtsEtlJobVersionInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDtsEtlJobVersionInfoResponse() = default;
};
class DescribeDtsJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> syncSubJobHistory{};
  shared_ptr<string> synchronizationDirection{};

  DescribeDtsJobDetailRequest() {}

  explicit DescribeDtsJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (syncSubJobHistory) {
      res["SyncSubJobHistory"] = boost::any(*syncSubJobHistory);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SyncSubJobHistory") != m.end() && !m["SyncSubJobHistory"].empty()) {
      syncSubJobHistory = make_shared<bool>(boost::any_cast<bool>(m["SyncSubJobHistory"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~DescribeDtsJobDetailRequest() = default;
};
class DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo : public Darabonba::Model {
public:
  shared_ptr<long> partitionNum{};
  shared_ptr<string> publicDproxyUrl{};
  shared_ptr<string> region{};
  shared_ptr<string> topic{};
  shared_ptr<string> vpcDproxyUrl{};

  DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo() {}

  explicit DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (partitionNum) {
      res["PartitionNum"] = boost::any(*partitionNum);
    }
    if (publicDproxyUrl) {
      res["PublicDproxyUrl"] = boost::any(*publicDproxyUrl);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (vpcDproxyUrl) {
      res["VpcDproxyUrl"] = boost::any(*vpcDproxyUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PartitionNum") != m.end() && !m["PartitionNum"].empty()) {
      partitionNum = make_shared<long>(boost::any_cast<long>(m["PartitionNum"]));
    }
    if (m.find("PublicDproxyUrl") != m.end() && !m["PublicDproxyUrl"].empty()) {
      publicDproxyUrl = make_shared<string>(boost::any_cast<string>(m["PublicDproxyUrl"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("VpcDproxyUrl") != m.end() && !m["VpcDproxyUrl"].empty()) {
      vpcDproxyUrl = make_shared<string>(boost::any_cast<string>(m["VpcDproxyUrl"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo() = default;
};
class DescribeDtsJobDetailResponseBodyDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodyDataSynchronizationStatus() {}

  explicit DescribeDtsJobDetailResponseBodyDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodyDataSynchronizationStatus() = default;
};
class DescribeDtsJobDetailResponseBodyDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<bool> canModifyPassword{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodyDestinationEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodyDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canModifyPassword) {
      res["CanModifyPassword"] = boost::any(*canModifyPassword);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanModifyPassword") != m.end() && !m["CanModifyPassword"].empty()) {
      canModifyPassword = make_shared<bool>(boost::any_cast<bool>(m["CanModifyPassword"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodyDestinationEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodyMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataExtractTransformLoad{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobDetailResponseBodyMigrationMode() {}

  explicit DescribeDtsJobDetailResponseBodyMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExtractTransformLoad) {
      res["DataExtractTransformLoad"] = boost::any(*dataExtractTransformLoad);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExtractTransformLoad") != m.end() && !m["DataExtractTransformLoad"].empty()) {
      dataExtractTransformLoad = make_shared<bool>(boost::any_cast<bool>(m["DataExtractTransformLoad"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodyMigrationMode() = default;
};
class DescribeDtsJobDetailResponseBodyRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobDetailResponseBodyRetryState() {}

  explicit DescribeDtsJobDetailResponseBodyRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodyRetryState() = default;
};
class DescribeDtsJobDetailResponseBodySourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<bool> canModifyPassword{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySourceEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (canModifyPassword) {
      res["CanModifyPassword"] = boost::any(*canModifyPassword);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("CanModifyPassword") != m.end() && !m["CanModifyPassword"].empty()) {
      canModifyPassword = make_shared<bool>(boost::any_cast<bool>(m["CanModifyPassword"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySourceEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataExtractTransformLoad{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExtractTransformLoad) {
      res["DataExtractTransformLoad"] = boost::any(*dataExtractTransformLoad);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExtractTransformLoad") != m.end() && !m["DataExtractTransformLoad"].empty()) {
      dataExtractTransformLoad = make_shared<bool>(boost::any_cast<bool>(m["DataExtractTransformLoad"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobDetailResponseBodySubDistributedJobPerformance() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobPerformance() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobDetailResponseBodySubDistributedJobRetryState() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobRetryState() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataExtractTransformLoad{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExtractTransformLoad) {
      res["DataExtractTransformLoad"] = boost::any(*dataExtractTransformLoad);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExtractTransformLoad") != m.end() && !m["DataExtractTransformLoad"].empty()) {
      dataExtractTransformLoad = make_shared<bool>(boost::any_cast<bool>(m["DataExtractTransformLoad"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> ddl{};
  shared_ptr<bool> dml{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddl) {
      res["Ddl"] = boost::any(*ddl);
    }
    if (dml) {
      res["Dml"] = boost::any(*dml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ddl") != m.end() && !m["Ddl"].empty()) {
      ddl = make_shared<bool>(boost::any_cast<bool>(m["Ddl"]));
    }
    if (m.find("Dml") != m.end() && !m["Dml"].empty()) {
      dml = make_shared<bool>(boost::any_cast<bool>(m["Dml"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> vpcHost{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (vpcHost) {
      res["VpcHost"] = boost::any(*vpcHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VpcHost") != m.end() && !m["VpcHost"].empty()) {
      vpcHost = make_shared<string>(boost::any_cast<string>(m["VpcHost"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<long> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<string> srcRegion{};
  shared_ptr<string> tagCategory{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (srcRegion) {
      res["SrcRegion"] = boost::any(*srcRegion);
    }
    if (tagCategory) {
      res["TagCategory"] = boost::any(*tagCategory);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SrcRegion") != m.end() && !m["SrcRegion"].empty()) {
      srcRegion = make_shared<string>(boost::any_cast<string>(m["SrcRegion"]));
    }
    if (m.find("TagCategory") != m.end() && !m["TagCategory"].empty()) {
      tagCategory = make_shared<string>(boost::any_cast<string>(m["TagCategory"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<string> destNetType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlCalculator{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isDemoJob{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance> performance{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState> retryState{};
  shared_ptr<boost::any> reverseJob{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost> subscriptionHost{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList>> tagList{};
  shared_ptr<string> taskType{};

  DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destNetType) {
      res["DestNetType"] = boost::any(*destNetType);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlCalculator) {
      res["EtlCalculator"] = boost::any(*etlCalculator);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isDemoJob) {
      res["IsDemoJob"] = boost::any(*isDemoJob);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = boost::any(*reverseJob);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestNetType") != m.end() && !m["DestNetType"].empty()) {
      destNetType = make_shared<string>(boost::any_cast<string>(m["DestNetType"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlCalculator") != m.end() && !m["EtlCalculator"].empty()) {
      etlCalculator = make_shared<string>(boost::any_cast<string>(m["EtlCalculator"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsDemoJob") != m.end() && !m["IsDemoJob"].empty()) {
      isDemoJob = make_shared<bool>(boost::any_cast<bool>(m["IsDemoJob"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      reverseJob = make_shared<boost::any>(boost::any_cast<boost::any>(m["ReverseJob"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobStructureInitializationStatus>(model1);
      }
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobSubscriptionHost>(model1);
      }
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJobTagList>>(expect1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> ddl{};
  shared_ptr<bool> dml{};

  DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddl) {
      res["Ddl"] = boost::any(*ddl);
    }
    if (dml) {
      res["Dml"] = boost::any(*dml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ddl") != m.end() && !m["Ddl"].empty()) {
      ddl = make_shared<bool>(boost::any_cast<bool>(m["Ddl"]));
    }
    if (m.find("Dml") != m.end() && !m["Dml"].empty()) {
      dml = make_shared<bool>(boost::any_cast<bool>(m["Dml"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> vpcHost{};

  DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (vpcHost) {
      res["VpcHost"] = boost::any(*vpcHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VpcHost") != m.end() && !m["VpcHost"].empty()) {
      vpcHost = make_shared<string>(boost::any_cast<string>(m["VpcHost"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJobTagList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<long> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<string> srcRegion{};
  shared_ptr<string> tagCategory{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobDetailResponseBodySubDistributedJobTagList() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJobTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (srcRegion) {
      res["SrcRegion"] = boost::any(*srcRegion);
    }
    if (tagCategory) {
      res["TagCategory"] = boost::any(*tagCategory);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SrcRegion") != m.end() && !m["SrcRegion"].empty()) {
      srcRegion = make_shared<string>(boost::any_cast<string>(m["SrcRegion"]));
    }
    if (m.find("TagCategory") != m.end() && !m["TagCategory"].empty()) {
      tagCategory = make_shared<string>(boost::any_cast<string>(m["TagCategory"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJobTagList() = default;
};
class DescribeDtsJobDetailResponseBodySubDistributedJob : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<string> destNetType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlCalculator{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isDemoJob{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobPerformance> performance{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobRetryState> retryState{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob> reverseJob{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<vector<boost::any>> subSyncJob{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost> subscriptionHost{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubDistributedJobTagList>> tagList{};
  shared_ptr<string> taskType{};

  DescribeDtsJobDetailResponseBodySubDistributedJob() {}

  explicit DescribeDtsJobDetailResponseBodySubDistributedJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destNetType) {
      res["DestNetType"] = boost::any(*destNetType);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlCalculator) {
      res["EtlCalculator"] = boost::any(*etlCalculator);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isDemoJob) {
      res["IsDemoJob"] = boost::any(*isDemoJob);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = reverseJob ? boost::any(reverseJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subSyncJob) {
      res["SubSyncJob"] = boost::any(*subSyncJob);
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestNetType") != m.end() && !m["DestNetType"].empty()) {
      destNetType = make_shared<string>(boost::any_cast<string>(m["DestNetType"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlCalculator") != m.end() && !m["EtlCalculator"].empty()) {
      etlCalculator = make_shared<string>(boost::any_cast<string>(m["EtlCalculator"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsDemoJob") != m.end() && !m["IsDemoJob"].empty()) {
      isDemoJob = make_shared<bool>(boost::any_cast<bool>(m["IsDemoJob"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseJob"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseJob"]));
        reverseJob = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobReverseJob>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobStructureInitializationStatus>(model1);
      }
    }
    if (m.find("SubSyncJob") != m.end() && !m["SubSyncJob"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubSyncJob"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubSyncJob"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subSyncJob = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeDtsJobDetailResponseBodySubDistributedJobSubscriptionHost>(model1);
      }
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubDistributedJobTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubDistributedJobTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobDetailResponseBodySubDistributedJobTagList>>(expect1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubDistributedJob() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataExtractTransformLoad{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExtractTransformLoad) {
      res["DataExtractTransformLoad"] = boost::any(*dataExtractTransformLoad);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExtractTransformLoad") != m.end() && !m["DataExtractTransformLoad"].empty()) {
      dataExtractTransformLoad = make_shared<bool>(boost::any_cast<bool>(m["DataExtractTransformLoad"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobDetailResponseBodySubSyncJobPerformance() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobPerformance() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobDetailResponseBodySubSyncJobRetryState() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobRetryState() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataExtractTransformLoad{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataExtractTransformLoad) {
      res["DataExtractTransformLoad"] = boost::any(*dataExtractTransformLoad);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataExtractTransformLoad") != m.end() && !m["DataExtractTransformLoad"].empty()) {
      dataExtractTransformLoad = make_shared<bool>(boost::any_cast<bool>(m["DataExtractTransformLoad"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> ddl{};
  shared_ptr<bool> dml{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddl) {
      res["Ddl"] = boost::any(*ddl);
    }
    if (dml) {
      res["Dml"] = boost::any(*dml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ddl") != m.end() && !m["Ddl"].empty()) {
      ddl = make_shared<bool>(boost::any_cast<bool>(m["Ddl"]));
    }
    if (m.find("Dml") != m.end() && !m["Dml"].empty()) {
      dml = make_shared<bool>(boost::any_cast<bool>(m["Dml"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> vpcHost{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (vpcHost) {
      res["VpcHost"] = boost::any(*vpcHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VpcHost") != m.end() && !m["VpcHost"].empty()) {
      vpcHost = make_shared<string>(boost::any_cast<string>(m["VpcHost"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<long> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<string> srcRegion{};
  shared_ptr<string> tagCategory{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (srcRegion) {
      res["SrcRegion"] = boost::any(*srcRegion);
    }
    if (tagCategory) {
      res["TagCategory"] = boost::any(*tagCategory);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SrcRegion") != m.end() && !m["SrcRegion"].empty()) {
      srcRegion = make_shared<string>(boost::any_cast<string>(m["SrcRegion"]));
    }
    if (m.find("TagCategory") != m.end() && !m["TagCategory"].empty()) {
      tagCategory = make_shared<string>(boost::any_cast<string>(m["TagCategory"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobReverseJob : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<string> destNetType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlCalculator{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isDemoJob{};
  shared_ptr<string> jobType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode> migrationMode{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance> performance{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState> retryState{};
  shared_ptr<boost::any> reverseJob{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost> subscriptionHost{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList>> tagList{};
  shared_ptr<string> taskType{};

  DescribeDtsJobDetailResponseBodySubSyncJobReverseJob() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobReverseJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destNetType) {
      res["DestNetType"] = boost::any(*destNetType);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlCalculator) {
      res["EtlCalculator"] = boost::any(*etlCalculator);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isDemoJob) {
      res["IsDemoJob"] = boost::any(*isDemoJob);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = boost::any(*reverseJob);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestNetType") != m.end() && !m["DestNetType"].empty()) {
      destNetType = make_shared<string>(boost::any_cast<string>(m["DestNetType"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlCalculator") != m.end() && !m["EtlCalculator"].empty()) {
      etlCalculator = make_shared<string>(boost::any_cast<string>(m["EtlCalculator"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsDemoJob") != m.end() && !m["IsDemoJob"].empty()) {
      isDemoJob = make_shared<bool>(boost::any_cast<bool>(m["IsDemoJob"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobMigrationMode>(model1);
      }
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      reverseJob = make_shared<boost::any>(boost::any_cast<boost::any>(m["ReverseJob"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobStructureInitializationStatus>(model1);
      }
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobSubscriptionHost>(model1);
      }
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobDetailResponseBodySubSyncJobReverseJobTagList>>(expect1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobReverseJob() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> roleName{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> ddl{};
  shared_ptr<bool> dml{};

  DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddl) {
      res["Ddl"] = boost::any(*ddl);
    }
    if (dml) {
      res["Dml"] = boost::any(*dml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ddl") != m.end() && !m["Ddl"].empty()) {
      ddl = make_shared<bool>(boost::any_cast<bool>(m["Ddl"]));
    }
    if (m.find("Dml") != m.end() && !m["Dml"].empty()) {
      dml = make_shared<bool>(boost::any_cast<bool>(m["Dml"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> vpcHost{};

  DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (vpcHost) {
      res["VpcHost"] = boost::any(*vpcHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VpcHost") != m.end() && !m["VpcHost"].empty()) {
      vpcHost = make_shared<string>(boost::any_cast<string>(m["VpcHost"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJobTagList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<long> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> scope{};
  shared_ptr<string> srcRegion{};
  shared_ptr<string> tagCategory{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobDetailResponseBodySubSyncJobTagList() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJobTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (srcRegion) {
      res["SrcRegion"] = boost::any(*srcRegion);
    }
    if (tagCategory) {
      res["TagCategory"] = boost::any(*tagCategory);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<long>(boost::any_cast<long>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SrcRegion") != m.end() && !m["SrcRegion"].empty()) {
      srcRegion = make_shared<string>(boost::any_cast<string>(m["SrcRegion"]));
    }
    if (m.find("TagCategory") != m.end() && !m["TagCategory"].empty()) {
      tagCategory = make_shared<string>(boost::any_cast<string>(m["TagCategory"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJobTagList() = default;
};
class DescribeDtsJobDetailResponseBodySubSyncJob : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<string> destNetType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlCalculator{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isDemoJob{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobPerformance> performance{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobRetryState> retryState{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobReverseJob> reverseJob{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<vector<boost::any>> subSyncJob{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost> subscriptionHost{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubSyncJobTagList>> tagList{};
  shared_ptr<string> taskType{};

  DescribeDtsJobDetailResponseBodySubSyncJob() {}

  explicit DescribeDtsJobDetailResponseBodySubSyncJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destNetType) {
      res["DestNetType"] = boost::any(*destNetType);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlCalculator) {
      res["EtlCalculator"] = boost::any(*etlCalculator);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isDemoJob) {
      res["IsDemoJob"] = boost::any(*isDemoJob);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = reverseJob ? boost::any(reverseJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subSyncJob) {
      res["SubSyncJob"] = boost::any(*subSyncJob);
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestNetType") != m.end() && !m["DestNetType"].empty()) {
      destNetType = make_shared<string>(boost::any_cast<string>(m["DestNetType"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlCalculator") != m.end() && !m["EtlCalculator"].empty()) {
      etlCalculator = make_shared<string>(boost::any_cast<string>(m["EtlCalculator"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsDemoJob") != m.end() && !m["IsDemoJob"].empty()) {
      isDemoJob = make_shared<bool>(boost::any_cast<bool>(m["IsDemoJob"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseJob"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobReverseJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseJob"]));
        reverseJob = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobReverseJob>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobStructureInitializationStatus>(model1);
      }
    }
    if (m.find("SubSyncJob") != m.end() && !m["SubSyncJob"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubSyncJob"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubSyncJob"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subSyncJob = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeDtsJobDetailResponseBodySubSyncJobSubscriptionHost>(model1);
      }
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubSyncJobTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubSyncJobTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobDetailResponseBodySubSyncJobTagList>>(expect1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubSyncJob() = default;
};
class DescribeDtsJobDetailResponseBodySubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> ddl{};
  shared_ptr<bool> dml{};

  DescribeDtsJobDetailResponseBodySubscriptionDataType() {}

  explicit DescribeDtsJobDetailResponseBodySubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddl) {
      res["Ddl"] = boost::any(*ddl);
    }
    if (dml) {
      res["Dml"] = boost::any(*dml);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ddl") != m.end() && !m["Ddl"].empty()) {
      ddl = make_shared<bool>(boost::any_cast<bool>(m["Ddl"]));
    }
    if (m.find("Dml") != m.end() && !m["Dml"].empty()) {
      dml = make_shared<bool>(boost::any_cast<bool>(m["Dml"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubscriptionDataType() = default;
};
class DescribeDtsJobDetailResponseBodySubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> vpcHost{};

  DescribeDtsJobDetailResponseBodySubscriptionHost() {}

  explicit DescribeDtsJobDetailResponseBodySubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (vpcHost) {
      res["VpcHost"] = boost::any(*vpcHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VpcHost") != m.end() && !m["VpcHost"].empty()) {
      vpcHost = make_shared<string>(boost::any_cast<string>(m["VpcHost"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBodySubscriptionHost() = default;
};
class DescribeDtsJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> binlog{};
  shared_ptr<string> binlogSite{};
  shared_ptr<string> binlogTime{};
  shared_ptr<string> bootTime{};
  shared_ptr<long> checkpoint{};
  shared_ptr<long> code{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo> dataDeliveryChannelInfo{};
  shared_ptr<DescribeDtsJobDetailResponseBodyDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<long> databaseCount{};
  shared_ptr<string> dbObject{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<long> delay{};
  shared_ptr<bool> demoJob{};
  shared_ptr<string> destNetType{};
  shared_ptr<DescribeDtsJobDetailResponseBodyDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlCalculator{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> jobType{};
  shared_ptr<string> lastUpdateTime{};
  shared_ptr<double> maxDu{};
  shared_ptr<DescribeDtsJobDetailResponseBodyMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> payType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> reserved{};
  shared_ptr<string> resourceGroupDisplayName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeDtsJobDetailResponseBodyRetryState> retryState{};
  shared_ptr<DescribeDtsJobDetailResponseBodySourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubDistributedJob>> subDistributedJob{};
  shared_ptr<vector<DescribeDtsJobDetailResponseBodySubSyncJob>> subSyncJob{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeDtsJobDetailResponseBodySubscriptionHost> subscriptionHost{};
  shared_ptr<bool> success{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> taskType{};

  DescribeDtsJobDetailResponseBody() {}

  explicit DescribeDtsJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (binlog) {
      res["Binlog"] = boost::any(*binlog);
    }
    if (binlogSite) {
      res["BinlogSite"] = boost::any(*binlogSite);
    }
    if (binlogTime) {
      res["BinlogTime"] = boost::any(*binlogTime);
    }
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataDeliveryChannelInfo) {
      res["DataDeliveryChannelInfo"] = dataDeliveryChannelInfo ? boost::any(dataDeliveryChannelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (databaseCount) {
      res["DatabaseCount"] = boost::any(*databaseCount);
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (demoJob) {
      res["DemoJob"] = boost::any(*demoJob);
    }
    if (destNetType) {
      res["DestNetType"] = boost::any(*destNetType);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlCalculator) {
      res["EtlCalculator"] = boost::any(*etlCalculator);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (lastUpdateTime) {
      res["LastUpdateTime"] = boost::any(*lastUpdateTime);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (resourceGroupDisplayName) {
      res["ResourceGroupDisplayName"] = boost::any(*resourceGroupDisplayName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDistributedJob) {
      vector<boost::any> temp1;
      for(auto item1:*subDistributedJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubDistributedJob"] = boost::any(temp1);
    }
    if (subSyncJob) {
      vector<boost::any> temp1;
      for(auto item1:*subSyncJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubSyncJob"] = boost::any(temp1);
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Binlog") != m.end() && !m["Binlog"].empty()) {
      binlog = make_shared<string>(boost::any_cast<string>(m["Binlog"]));
    }
    if (m.find("BinlogSite") != m.end() && !m["BinlogSite"].empty()) {
      binlogSite = make_shared<string>(boost::any_cast<string>(m["BinlogSite"]));
    }
    if (m.find("BinlogTime") != m.end() && !m["BinlogTime"].empty()) {
      binlogTime = make_shared<string>(boost::any_cast<string>(m["BinlogTime"]));
    }
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<long>(boost::any_cast<long>(m["Checkpoint"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataDeliveryChannelInfo") != m.end() && !m["DataDeliveryChannelInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDeliveryChannelInfo"].type()) {
        DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDeliveryChannelInfo"]));
        dataDeliveryChannelInfo = make_shared<DescribeDtsJobDetailResponseBodyDataDeliveryChannelInfo>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobDetailResponseBodyDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobDetailResponseBodyDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DatabaseCount") != m.end() && !m["DatabaseCount"].empty()) {
      databaseCount = make_shared<long>(boost::any_cast<long>(m["DatabaseCount"]));
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DemoJob") != m.end() && !m["DemoJob"].empty()) {
      demoJob = make_shared<bool>(boost::any_cast<bool>(m["DemoJob"]));
    }
    if (m.find("DestNetType") != m.end() && !m["DestNetType"].empty()) {
      destNetType = make_shared<string>(boost::any_cast<string>(m["DestNetType"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodyDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobDetailResponseBodyDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlCalculator") != m.end() && !m["EtlCalculator"].empty()) {
      etlCalculator = make_shared<string>(boost::any_cast<string>(m["EtlCalculator"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("LastUpdateTime") != m.end() && !m["LastUpdateTime"].empty()) {
      lastUpdateTime = make_shared<string>(boost::any_cast<string>(m["LastUpdateTime"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobDetailResponseBodyMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobDetailResponseBodyMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("ResourceGroupDisplayName") != m.end() && !m["ResourceGroupDisplayName"].empty()) {
      resourceGroupDisplayName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupDisplayName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobDetailResponseBodyRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobDetailResponseBodyRetryState>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobDetailResponseBodySourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobDetailResponseBodySourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDistributedJob") != m.end() && !m["SubDistributedJob"].empty()) {
      if (typeid(vector<boost::any>) == m["SubDistributedJob"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubDistributedJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubDistributedJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubDistributedJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subDistributedJob = make_shared<vector<DescribeDtsJobDetailResponseBodySubDistributedJob>>(expect1);
      }
    }
    if (m.find("SubSyncJob") != m.end() && !m["SubSyncJob"].empty()) {
      if (typeid(vector<boost::any>) == m["SubSyncJob"].type()) {
        vector<DescribeDtsJobDetailResponseBodySubSyncJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubSyncJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobDetailResponseBodySubSyncJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subSyncJob = make_shared<vector<DescribeDtsJobDetailResponseBodySubSyncJob>>(expect1);
      }
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeDtsJobDetailResponseBodySubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeDtsJobDetailResponseBodySubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeDtsJobDetailResponseBodySubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeDtsJobDetailResponseBodySubscriptionHost>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeDtsJobDetailResponseBody() = default;
};
class DescribeDtsJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDtsJobDetailResponseBody> body{};

  DescribeDtsJobDetailResponse() {}

  explicit DescribeDtsJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDtsJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDtsJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDtsJobDetailResponse() = default;
};
class DescribeDtsJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> orderColumn{};
  shared_ptr<string> orderDirection{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> params{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};
  shared_ptr<bool> withoutDbList{};

  DescribeDtsJobsRequest() {}

  explicit DescribeDtsJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (orderColumn) {
      res["OrderColumn"] = boost::any(*orderColumn);
    }
    if (orderDirection) {
      res["OrderDirection"] = boost::any(*orderDirection);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (withoutDbList) {
      res["WithoutDbList"] = boost::any(*withoutDbList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("OrderColumn") != m.end() && !m["OrderColumn"].empty()) {
      orderColumn = make_shared<string>(boost::any_cast<string>(m["OrderColumn"]));
    }
    if (m.find("OrderDirection") != m.end() && !m["OrderDirection"].empty()) {
      orderDirection = make_shared<string>(boost::any_cast<string>(m["OrderDirection"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WithoutDbList") != m.end() && !m["WithoutDbList"].empty()) {
      withoutDbList = make_shared<bool>(boost::any_cast<bool>(m["WithoutDbList"]));
    }
  }


  virtual ~DescribeDtsJobsRequest() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> helpUrl{};

  DescribeDtsJobsResponseBodyDtsJobListErrorDetails() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (helpUrl) {
      res["HelpUrl"] = boost::any(*helpUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HelpUrl") != m.end() && !m["HelpUrl"].empty()) {
      helpUrl = make_shared<string>(boost::any_cast<string>(m["HelpUrl"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListErrorDetails() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> fullDataCheck{};
  shared_ptr<bool> incDataCheck{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobsResponseBodyDtsJobListMigrationMode() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (fullDataCheck) {
      res["FullDataCheck"] = boost::any(*fullDataCheck);
    }
    if (incDataCheck) {
      res["IncDataCheck"] = boost::any(*incDataCheck);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("FullDataCheck") != m.end() && !m["FullDataCheck"].empty()) {
      fullDataCheck = make_shared<bool>(boost::any_cast<bool>(m["FullDataCheck"]));
    }
    if (m.find("IncDataCheck") != m.end() && !m["IncDataCheck"].empty()) {
      incDataCheck = make_shared<bool>(boost::any_cast<bool>(m["IncDataCheck"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListMigrationMode() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobsResponseBodyDtsJobListPerformance() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListPerformance() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobListPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> migrationErrCode{};
  shared_ptr<string> migrationErrHelpDocId{};
  shared_ptr<string> migrationErrHelpDocKey{};
  shared_ptr<string> migrationErrMsg{};
  shared_ptr<string> migrationErrType{};
  shared_ptr<string> migrationErrWorkaround{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobsResponseBodyDtsJobListRetryState() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (migrationErrCode) {
      res["MigrationErrCode"] = boost::any(*migrationErrCode);
    }
    if (migrationErrHelpDocId) {
      res["MigrationErrHelpDocId"] = boost::any(*migrationErrHelpDocId);
    }
    if (migrationErrHelpDocKey) {
      res["MigrationErrHelpDocKey"] = boost::any(*migrationErrHelpDocKey);
    }
    if (migrationErrMsg) {
      res["MigrationErrMsg"] = boost::any(*migrationErrMsg);
    }
    if (migrationErrType) {
      res["MigrationErrType"] = boost::any(*migrationErrType);
    }
    if (migrationErrWorkaround) {
      res["MigrationErrWorkaround"] = boost::any(*migrationErrWorkaround);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("MigrationErrCode") != m.end() && !m["MigrationErrCode"].empty()) {
      migrationErrCode = make_shared<string>(boost::any_cast<string>(m["MigrationErrCode"]));
    }
    if (m.find("MigrationErrHelpDocId") != m.end() && !m["MigrationErrHelpDocId"].empty()) {
      migrationErrHelpDocId = make_shared<string>(boost::any_cast<string>(m["MigrationErrHelpDocId"]));
    }
    if (m.find("MigrationErrHelpDocKey") != m.end() && !m["MigrationErrHelpDocKey"].empty()) {
      migrationErrHelpDocKey = make_shared<string>(boost::any_cast<string>(m["MigrationErrHelpDocKey"]));
    }
    if (m.find("MigrationErrMsg") != m.end() && !m["MigrationErrMsg"].empty()) {
      migrationErrMsg = make_shared<string>(boost::any_cast<string>(m["MigrationErrMsg"]));
    }
    if (m.find("MigrationErrType") != m.end() && !m["MigrationErrType"].empty()) {
      migrationErrType = make_shared<string>(boost::any_cast<string>(m["MigrationErrType"]));
    }
    if (m.find("MigrationErrWorkaround") != m.end() && !m["MigrationErrWorkaround"].empty()) {
      migrationErrWorkaround = make_shared<string>(boost::any_cast<string>(m["MigrationErrWorkaround"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListRetryState() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> helpUrl{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (helpUrl) {
      res["HelpUrl"] = boost::any(*helpUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HelpUrl") != m.end() && !m["HelpUrl"].empty()) {
      helpUrl = make_shared<string>(boost::any_cast<string>(m["HelpUrl"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> fullDataCheck{};
  shared_ptr<bool> incDataCheck{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (fullDataCheck) {
      res["FullDataCheck"] = boost::any(*fullDataCheck);
    }
    if (incDataCheck) {
      res["IncDataCheck"] = boost::any(*incDataCheck);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("FullDataCheck") != m.end() && !m["FullDataCheck"].empty()) {
      fullDataCheck = make_shared<bool>(boost::any_cast<bool>(m["FullDataCheck"]));
    }
    if (m.find("IncDataCheck") != m.end() && !m["IncDataCheck"].empty()) {
      incDataCheck = make_shared<bool>(boost::any_cast<bool>(m["IncDataCheck"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListReverseJob : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> cpuUsage{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> dbObject{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<long> delay{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<long> duUsage{};
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails>> errorDetails{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlSafeCheckpoint{};
  shared_ptr<string> expireTime{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus> fullDataCheckStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus> incDataCheckStatus{};
  shared_ptr<double> maxDu{};
  shared_ptr<string> memUsage{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance> performance{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus> structureInitializationStatus{};

  DescribeDtsJobsResponseBodyDtsJobListReverseJob() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListReverseJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (duUsage) {
      res["DuUsage"] = boost::any(*duUsage);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlSafeCheckpoint) {
      res["EtlSafeCheckpoint"] = boost::any(*etlSafeCheckpoint);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullDataCheckStatus) {
      res["FullDataCheckStatus"] = fullDataCheckStatus ? boost::any(fullDataCheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (incDataCheckStatus) {
      res["IncDataCheckStatus"] = incDataCheckStatus ? boost::any(incDataCheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (memUsage) {
      res["MemUsage"] = boost::any(*memUsage);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<string>(boost::any_cast<string>(m["CpuUsage"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("DuUsage") != m.end() && !m["DuUsage"].empty()) {
      duUsage = make_shared<long>(boost::any_cast<long>(m["DuUsage"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobListReverseJobErrorDetails>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlSafeCheckpoint") != m.end() && !m["EtlSafeCheckpoint"].empty()) {
      etlSafeCheckpoint = make_shared<string>(boost::any_cast<string>(m["EtlSafeCheckpoint"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FullDataCheckStatus") != m.end() && !m["FullDataCheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullDataCheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullDataCheckStatus"]));
        fullDataCheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobFullDataCheckStatus>(model1);
      }
    }
    if (m.find("IncDataCheckStatus") != m.end() && !m["IncDataCheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncDataCheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncDataCheckStatus"]));
        incDataCheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobIncDataCheckStatus>(model1);
      }
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MemUsage") != m.end() && !m["MemUsage"].empty()) {
      memUsage = make_shared<string>(boost::any_cast<string>(m["MemUsage"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJobStructureInitializationStatus>(model1);
      }
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListReverseJob() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyDtsJobListTagList : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobsResponseBodyDtsJobListTagList() {}

  explicit DescribeDtsJobsResponseBodyDtsJobListTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobListTagList() = default;
};
class DescribeDtsJobsResponseBodyDtsJobList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> cpuUsage{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus> dataCloudStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> dbObject{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<long> delay{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsBisLabel{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<long> duUsage{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobListErrorDetails>> errorDetails{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlSafeCheckpoint{};
  shared_ptr<string> expireTime{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus> fullDataCheckStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus> incDataCheckStatus{};
  shared_ptr<string> jobType{};
  shared_ptr<double> maxDu{};
  shared_ptr<string> memUsage{};
  shared_ptr<string> migrationErrCode{};
  shared_ptr<string> migrationErrHelpDocId{};
  shared_ptr<string> migrationErrHelpDocKey{};
  shared_ptr<string> migrationErrMsg{};
  shared_ptr<string> migrationErrType{};
  shared_ptr<string> migrationErrWorkaround{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListMigrationMode> migrationMode{};
  shared_ptr<double> minDu{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListPerformance> performance{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<string> resourceGroupDisplayName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListRetryState> retryState{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListReverseJob> reverseJob{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobListTagList>> tagList{};

  DescribeDtsJobsResponseBodyDtsJobList() {}

  explicit DescribeDtsJobsResponseBodyDtsJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (cpuUsage) {
      res["CpuUsage"] = boost::any(*cpuUsage);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataCloudStatus) {
      res["DataCloudStatus"] = dataCloudStatus ? boost::any(dataCloudStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsBisLabel) {
      res["DtsBisLabel"] = boost::any(*dtsBisLabel);
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (duUsage) {
      res["DuUsage"] = boost::any(*duUsage);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlSafeCheckpoint) {
      res["EtlSafeCheckpoint"] = boost::any(*etlSafeCheckpoint);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullDataCheckStatus) {
      res["FullDataCheckStatus"] = fullDataCheckStatus ? boost::any(fullDataCheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (incDataCheckStatus) {
      res["IncDataCheckStatus"] = incDataCheckStatus ? boost::any(incDataCheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxDu) {
      res["MaxDu"] = boost::any(*maxDu);
    }
    if (memUsage) {
      res["MemUsage"] = boost::any(*memUsage);
    }
    if (migrationErrCode) {
      res["MigrationErrCode"] = boost::any(*migrationErrCode);
    }
    if (migrationErrHelpDocId) {
      res["MigrationErrHelpDocId"] = boost::any(*migrationErrHelpDocId);
    }
    if (migrationErrHelpDocKey) {
      res["MigrationErrHelpDocKey"] = boost::any(*migrationErrHelpDocKey);
    }
    if (migrationErrMsg) {
      res["MigrationErrMsg"] = boost::any(*migrationErrMsg);
    }
    if (migrationErrType) {
      res["MigrationErrType"] = boost::any(*migrationErrType);
    }
    if (migrationErrWorkaround) {
      res["MigrationErrWorkaround"] = boost::any(*migrationErrWorkaround);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minDu) {
      res["MinDu"] = boost::any(*minDu);
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (resourceGroupDisplayName) {
      res["ResourceGroupDisplayName"] = boost::any(*resourceGroupDisplayName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = reverseJob ? boost::any(reverseJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CpuUsage") != m.end() && !m["CpuUsage"].empty()) {
      cpuUsage = make_shared<string>(boost::any_cast<string>(m["CpuUsage"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataCloudStatus") != m.end() && !m["DataCloudStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataCloudStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataCloudStatus"]));
        dataCloudStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListDataCloudStatus>(model1);
      }
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobsResponseBodyDtsJobListDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsBisLabel") != m.end() && !m["DtsBisLabel"].empty()) {
      dtsBisLabel = make_shared<string>(boost::any_cast<string>(m["DtsBisLabel"]));
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("DuUsage") != m.end() && !m["DuUsage"].empty()) {
      duUsage = make_shared<long>(boost::any_cast<long>(m["DuUsage"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobListErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobListErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobListErrorDetails>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlSafeCheckpoint") != m.end() && !m["EtlSafeCheckpoint"].empty()) {
      etlSafeCheckpoint = make_shared<string>(boost::any_cast<string>(m["EtlSafeCheckpoint"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FullDataCheckStatus") != m.end() && !m["FullDataCheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullDataCheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullDataCheckStatus"]));
        fullDataCheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListFullDataCheckStatus>(model1);
      }
    }
    if (m.find("IncDataCheckStatus") != m.end() && !m["IncDataCheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncDataCheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncDataCheckStatus"]));
        incDataCheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListIncDataCheckStatus>(model1);
      }
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxDu") != m.end() && !m["MaxDu"].empty()) {
      maxDu = make_shared<double>(boost::any_cast<double>(m["MaxDu"]));
    }
    if (m.find("MemUsage") != m.end() && !m["MemUsage"].empty()) {
      memUsage = make_shared<string>(boost::any_cast<string>(m["MemUsage"]));
    }
    if (m.find("MigrationErrCode") != m.end() && !m["MigrationErrCode"].empty()) {
      migrationErrCode = make_shared<string>(boost::any_cast<string>(m["MigrationErrCode"]));
    }
    if (m.find("MigrationErrHelpDocId") != m.end() && !m["MigrationErrHelpDocId"].empty()) {
      migrationErrHelpDocId = make_shared<string>(boost::any_cast<string>(m["MigrationErrHelpDocId"]));
    }
    if (m.find("MigrationErrHelpDocKey") != m.end() && !m["MigrationErrHelpDocKey"].empty()) {
      migrationErrHelpDocKey = make_shared<string>(boost::any_cast<string>(m["MigrationErrHelpDocKey"]));
    }
    if (m.find("MigrationErrMsg") != m.end() && !m["MigrationErrMsg"].empty()) {
      migrationErrMsg = make_shared<string>(boost::any_cast<string>(m["MigrationErrMsg"]));
    }
    if (m.find("MigrationErrType") != m.end() && !m["MigrationErrType"].empty()) {
      migrationErrType = make_shared<string>(boost::any_cast<string>(m["MigrationErrType"]));
    }
    if (m.find("MigrationErrWorkaround") != m.end() && !m["MigrationErrWorkaround"].empty()) {
      migrationErrWorkaround = make_shared<string>(boost::any_cast<string>(m["MigrationErrWorkaround"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobsResponseBodyDtsJobListMigrationMode>(model1);
      }
    }
    if (m.find("MinDu") != m.end() && !m["MinDu"].empty()) {
      minDu = make_shared<double>(boost::any_cast<double>(m["MinDu"]));
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobsResponseBodyDtsJobListPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("ResourceGroupDisplayName") != m.end() && !m["ResourceGroupDisplayName"].empty()) {
      resourceGroupDisplayName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupDisplayName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobsResponseBodyDtsJobListRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseJob"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListReverseJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseJob"]));
        reverseJob = make_shared<DescribeDtsJobsResponseBodyDtsJobListReverseJob>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobsResponseBodyDtsJobListSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobsResponseBodyDtsJobListStructureInitializationStatus>(model1);
      }
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobListTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobListTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobListTagList>>(expect1);
      }
    }
  }


  virtual ~DescribeDtsJobsResponseBodyDtsJobList() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobsResponseBodyEtlDemoListMigrationMode() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListMigrationMode() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobsResponseBodyEtlDemoListPerformance() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListPerformance() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListRetryState : public Darabonba::Model {
public:
  shared_ptr<string> errMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<long> maxRetryTime{};
  shared_ptr<string> module{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> retryTarget{};
  shared_ptr<long> retryTime{};
  shared_ptr<bool> retrying{};

  DescribeDtsJobsResponseBodyEtlDemoListRetryState() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListRetryState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maxRetryTime) {
      res["MaxRetryTime"] = boost::any(*maxRetryTime);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (retryTarget) {
      res["RetryTarget"] = boost::any(*retryTarget);
    }
    if (retryTime) {
      res["RetryTime"] = boost::any(*retryTime);
    }
    if (retrying) {
      res["Retrying"] = boost::any(*retrying);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaxRetryTime") != m.end() && !m["MaxRetryTime"].empty()) {
      maxRetryTime = make_shared<long>(boost::any_cast<long>(m["MaxRetryTime"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("RetryTarget") != m.end() && !m["RetryTarget"].empty()) {
      retryTarget = make_shared<string>(boost::any_cast<string>(m["RetryTarget"]));
    }
    if (m.find("RetryTime") != m.end() && !m["RetryTime"].empty()) {
      retryTime = make_shared<long>(boost::any_cast<long>(m["RetryTime"]));
    }
    if (m.find("Retrying") != m.end() && !m["Retrying"].empty()) {
      retrying = make_shared<bool>(boost::any_cast<bool>(m["Retrying"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListRetryState() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> needUpgrade{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (needUpgrade) {
      res["NeedUpgrade"] = boost::any(*needUpgrade);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NeedUpgrade") != m.end() && !m["NeedUpgrade"].empty()) {
      needUpgrade = make_shared<bool>(boost::any_cast<bool>(m["NeedUpgrade"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> rps{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (rps) {
      res["Rps"] = boost::any(*rps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("Rps") != m.end() && !m["Rps"].empty()) {
      rps = make_shared<string>(boost::any_cast<string>(m["Rps"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkItemDescription{};
  shared_ptr<string> checkResult{};
  shared_ptr<string> failedReason{};
  shared_ptr<string> repairMethod{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkItemDescription) {
      res["CheckItemDescription"] = boost::any(*checkItemDescription);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (failedReason) {
      res["FailedReason"] = boost::any(*failedReason);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckItemDescription") != m.end() && !m["CheckItemDescription"].empty()) {
      checkItemDescription = make_shared<string>(boost::any_cast<string>(m["CheckItemDescription"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<string>(boost::any_cast<string>(m["CheckResult"]));
    }
    if (m.find("FailedReason") != m.end() && !m["FailedReason"].empty()) {
      failedReason = make_shared<string>(boost::any_cast<string>(m["FailedReason"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail>> detail{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListReverseJob : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlSafeCheckpoint{};
  shared_ptr<string> expireTime{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode> migrationMode{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance> performance{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus> structureInitializationStatus{};

  DescribeDtsJobsResponseBodyEtlDemoListReverseJob() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListReverseJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlSafeCheckpoint) {
      res["EtlSafeCheckpoint"] = boost::any(*etlSafeCheckpoint);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlSafeCheckpoint") != m.end() && !m["EtlSafeCheckpoint"].empty()) {
      etlSafeCheckpoint = make_shared<string>(boost::any_cast<string>(m["EtlSafeCheckpoint"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobMigrationMode>(model1);
      }
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJobStructureInitializationStatus>(model1);
      }
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListReverseJob() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ip{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> region{};
  shared_ptr<string> sslSolutionEnum{};
  shared_ptr<string> userName{};

  DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sslSolutionEnum) {
      res["SslSolutionEnum"] = boost::any(*sslSolutionEnum);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SslSolutionEnum") != m.end() && !m["SslSolutionEnum"].empty()) {
      sslSolutionEnum = make_shared<string>(boost::any_cast<string>(m["SslSolutionEnum"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoListTagList : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeDtsJobsResponseBodyEtlDemoListTagList() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoListTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoListTagList() = default;
};
class DescribeDtsJobsResponseBodyEtlDemoList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> checkpoint{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus> dataEtlStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> dbObject{};
  shared_ptr<long> delay{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<string> dtsJobClass{};
  shared_ptr<string> dtsJobDirection{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> etlSafeCheckpoint{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> jobType{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListMigrationMode> migrationMode{};
  shared_ptr<string> originType{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListPerformance> performance{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus> precheckStatus{};
  shared_ptr<string> reserved{};
  shared_ptr<string> resourceGroupDisplayName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListRetryState> retryState{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListReverseJob> reverseJob{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<vector<DescribeDtsJobsResponseBodyEtlDemoListTagList>> tagList{};

  DescribeDtsJobsResponseBodyEtlDemoList() {}

  explicit DescribeDtsJobsResponseBodyEtlDemoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataEtlStatus) {
      res["DataEtlStatus"] = dataEtlStatus ? boost::any(dataEtlStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dbObject) {
      res["DbObject"] = boost::any(*dbObject);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (dtsJobClass) {
      res["DtsJobClass"] = boost::any(*dtsJobClass);
    }
    if (dtsJobDirection) {
      res["DtsJobDirection"] = boost::any(*dtsJobDirection);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (etlSafeCheckpoint) {
      res["EtlSafeCheckpoint"] = boost::any(*etlSafeCheckpoint);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originType) {
      res["OriginType"] = boost::any(*originType);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (resourceGroupDisplayName) {
      res["ResourceGroupDisplayName"] = boost::any(*resourceGroupDisplayName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (retryState) {
      res["RetryState"] = retryState ? boost::any(retryState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reverseJob) {
      res["ReverseJob"] = reverseJob ? boost::any(reverseJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagList) {
      vector<boost::any> temp1;
      for(auto item1:*tagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataEtlStatus") != m.end() && !m["DataEtlStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataEtlStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataEtlStatus"]));
        dataEtlStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListDataEtlStatus>(model1);
      }
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DbObject") != m.end() && !m["DbObject"].empty()) {
      dbObject = make_shared<string>(boost::any_cast<string>(m["DbObject"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeDtsJobsResponseBodyEtlDemoListDestinationEndpoint>(model1);
      }
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("DtsJobClass") != m.end() && !m["DtsJobClass"].empty()) {
      dtsJobClass = make_shared<string>(boost::any_cast<string>(m["DtsJobClass"]));
    }
    if (m.find("DtsJobDirection") != m.end() && !m["DtsJobDirection"].empty()) {
      dtsJobDirection = make_shared<string>(boost::any_cast<string>(m["DtsJobDirection"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("EtlSafeCheckpoint") != m.end() && !m["EtlSafeCheckpoint"].empty()) {
      etlSafeCheckpoint = make_shared<string>(boost::any_cast<string>(m["EtlSafeCheckpoint"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeDtsJobsResponseBodyEtlDemoListMigrationMode>(model1);
      }
    }
    if (m.find("OriginType") != m.end() && !m["OriginType"].empty()) {
      originType = make_shared<string>(boost::any_cast<string>(m["OriginType"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeDtsJobsResponseBodyEtlDemoListPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListPrecheckStatus>(model1);
      }
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("ResourceGroupDisplayName") != m.end() && !m["ResourceGroupDisplayName"].empty()) {
      resourceGroupDisplayName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupDisplayName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RetryState") != m.end() && !m["RetryState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryState"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListRetryState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryState"]));
        retryState = make_shared<DescribeDtsJobsResponseBodyEtlDemoListRetryState>(model1);
      }
    }
    if (m.find("ReverseJob") != m.end() && !m["ReverseJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseJob"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListReverseJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseJob"]));
        reverseJob = make_shared<DescribeDtsJobsResponseBodyEtlDemoListReverseJob>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeDtsJobsResponseBodyEtlDemoListSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeDtsJobsResponseBodyEtlDemoListStructureInitializationStatus>(model1);
      }
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<DescribeDtsJobsResponseBodyEtlDemoListTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyEtlDemoListTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagList = make_shared<vector<DescribeDtsJobsResponseBodyEtlDemoListTagList>>(expect1);
      }
    }
  }


  virtual ~DescribeDtsJobsResponseBodyEtlDemoList() = default;
};
class DescribeDtsJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDtsJobsResponseBodyDtsJobList>> dtsJobList{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<vector<DescribeDtsJobsResponseBodyEtlDemoList>> etlDemoList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeDtsJobsResponseBody() {}

  explicit DescribeDtsJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobList) {
      vector<boost::any> temp1;
      for(auto item1:*dtsJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DtsJobList"] = boost::any(temp1);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (etlDemoList) {
      vector<boost::any> temp1;
      for(auto item1:*etlDemoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EtlDemoList"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobList") != m.end() && !m["DtsJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["DtsJobList"].type()) {
        vector<DescribeDtsJobsResponseBodyDtsJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DtsJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyDtsJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dtsJobList = make_shared<vector<DescribeDtsJobsResponseBodyDtsJobList>>(expect1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("EtlDemoList") != m.end() && !m["EtlDemoList"].empty()) {
      if (typeid(vector<boost::any>) == m["EtlDemoList"].type()) {
        vector<DescribeDtsJobsResponseBodyEtlDemoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EtlDemoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsJobsResponseBodyEtlDemoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        etlDemoList = make_shared<vector<DescribeDtsJobsResponseBodyEtlDemoList>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeDtsJobsResponseBody() = default;
};
class DescribeDtsJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDtsJobsResponseBody> body{};

  DescribeDtsJobsResponse() {}

  explicit DescribeDtsJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDtsJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDtsJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDtsJobsResponse() = default;
};
class DescribeDtsServiceLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> subJobType{};

  DescribeDtsServiceLogRequest() {}

  explicit DescribeDtsServiceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subJobType) {
      res["SubJobType"] = boost::any(*subJobType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubJobType") != m.end() && !m["SubJobType"].empty()) {
      subJobType = make_shared<string>(boost::any_cast<string>(m["SubJobType"]));
    }
  }


  virtual ~DescribeDtsServiceLogRequest() = default;
};
class DescribeDtsServiceLogResponseBodyServiceLogContexts : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<string> state{};
  shared_ptr<string> time{};

  DescribeDtsServiceLogResponseBodyServiceLogContexts() {}

  explicit DescribeDtsServiceLogResponseBodyServiceLogContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~DescribeDtsServiceLogResponseBodyServiceLogContexts() = default;
};
class DescribeDtsServiceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDtsServiceLogResponseBodyServiceLogContexts>> serviceLogContexts{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeDtsServiceLogResponseBody() {}

  explicit DescribeDtsServiceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceLogContexts) {
      vector<boost::any> temp1;
      for(auto item1:*serviceLogContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceLogContexts"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceLogContexts") != m.end() && !m["ServiceLogContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceLogContexts"].type()) {
        vector<DescribeDtsServiceLogResponseBodyServiceLogContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceLogContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDtsServiceLogResponseBodyServiceLogContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceLogContexts = make_shared<vector<DescribeDtsServiceLogResponseBodyServiceLogContexts>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeDtsServiceLogResponseBody() = default;
};
class DescribeDtsServiceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDtsServiceLogResponseBody> body{};

  DescribeDtsServiceLogResponse() {}

  explicit DescribeDtsServiceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDtsServiceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDtsServiceLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDtsServiceLogResponse() = default;
};
class DescribeEndpointSwitchStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeEndpointSwitchStatusRequest() {}

  explicit DescribeEndpointSwitchStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeEndpointSwitchStatusRequest() = default;
};
class DescribeEndpointSwitchStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> success{};

  DescribeEndpointSwitchStatusResponseBody() {}

  explicit DescribeEndpointSwitchStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeEndpointSwitchStatusResponseBody() = default;
};
class DescribeEndpointSwitchStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEndpointSwitchStatusResponseBody> body{};

  DescribeEndpointSwitchStatusResponse() {}

  explicit DescribeEndpointSwitchStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEndpointSwitchStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEndpointSwitchStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEndpointSwitchStatusResponse() = default;
};
class DescribeEtlJobLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};

  DescribeEtlJobLogsRequest() {}

  explicit DescribeEtlJobLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEtlJobLogsRequest() = default;
};
class DescribeEtlJobLogsResponseBodyEtlRunningLogs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentKey{};
  shared_ptr<string> etlId{};
  shared_ptr<string> logDatetime{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};

  DescribeEtlJobLogsResponseBodyEtlRunningLogs() {}

  explicit DescribeEtlJobLogsResponseBodyEtlRunningLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentKey) {
      res["ContentKey"] = boost::any(*contentKey);
    }
    if (etlId) {
      res["EtlId"] = boost::any(*etlId);
    }
    if (logDatetime) {
      res["LogDatetime"] = boost::any(*logDatetime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentKey") != m.end() && !m["ContentKey"].empty()) {
      contentKey = make_shared<string>(boost::any_cast<string>(m["ContentKey"]));
    }
    if (m.find("EtlId") != m.end() && !m["EtlId"].empty()) {
      etlId = make_shared<string>(boost::any_cast<string>(m["EtlId"]));
    }
    if (m.find("LogDatetime") != m.end() && !m["LogDatetime"].empty()) {
      logDatetime = make_shared<string>(boost::any_cast<string>(m["LogDatetime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeEtlJobLogsResponseBodyEtlRunningLogs() = default;
};
class DescribeEtlJobLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<vector<DescribeEtlJobLogsResponseBodyEtlRunningLogs>> etlRunningLogs{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeEtlJobLogsResponseBody() {}

  explicit DescribeEtlJobLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (etlRunningLogs) {
      vector<boost::any> temp1;
      for(auto item1:*etlRunningLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EtlRunningLogs"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("EtlRunningLogs") != m.end() && !m["EtlRunningLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["EtlRunningLogs"].type()) {
        vector<DescribeEtlJobLogsResponseBodyEtlRunningLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EtlRunningLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEtlJobLogsResponseBodyEtlRunningLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        etlRunningLogs = make_shared<vector<DescribeEtlJobLogsResponseBodyEtlRunningLogs>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEtlJobLogsResponseBody() = default;
};
class DescribeEtlJobLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEtlJobLogsResponseBody> body{};

  DescribeEtlJobLogsResponse() {}

  explicit DescribeEtlJobLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEtlJobLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEtlJobLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEtlJobLogsResponse() = default;
};
class DescribeInitializationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationJobId{};

  DescribeInitializationStatusRequest() {}

  explicit DescribeInitializationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DescribeInitializationStatusRequest() = default;
};
class DescribeInitializationStatusResponseBodyDataInitializationDetails : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> finishRowNum{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};
  shared_ptr<string> tableName{};
  shared_ptr<string> totalRowNum{};
  shared_ptr<string> usedTime{};

  DescribeInitializationStatusResponseBodyDataInitializationDetails() {}

  explicit DescribeInitializationStatusResponseBodyDataInitializationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (finishRowNum) {
      res["FinishRowNum"] = boost::any(*finishRowNum);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (totalRowNum) {
      res["TotalRowNum"] = boost::any(*totalRowNum);
    }
    if (usedTime) {
      res["UsedTime"] = boost::any(*usedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FinishRowNum") != m.end() && !m["FinishRowNum"].empty()) {
      finishRowNum = make_shared<string>(boost::any_cast<string>(m["FinishRowNum"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TotalRowNum") != m.end() && !m["TotalRowNum"].empty()) {
      totalRowNum = make_shared<string>(boost::any_cast<string>(m["TotalRowNum"]));
    }
    if (m.find("UsedTime") != m.end() && !m["UsedTime"].empty()) {
      usedTime = make_shared<string>(boost::any_cast<string>(m["UsedTime"]));
    }
  }


  virtual ~DescribeInitializationStatusResponseBodyDataInitializationDetails() = default;
};
class DescribeInitializationStatusResponseBodyDataSynchronizationDetails : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};
  shared_ptr<string> tableName{};

  DescribeInitializationStatusResponseBodyDataSynchronizationDetails() {}

  explicit DescribeInitializationStatusResponseBodyDataSynchronizationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeInitializationStatusResponseBodyDataSynchronizationDetails() = default;
};
class DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> objectDefinition{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};

  DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints() {}

  explicit DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (objectDefinition) {
      res["ObjectDefinition"] = boost::any(*objectDefinition);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ObjectDefinition") != m.end() && !m["ObjectDefinition"].empty()) {
      objectDefinition = make_shared<string>(boost::any_cast<string>(m["ObjectDefinition"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints() = default;
};
class DescribeInitializationStatusResponseBodyStructureInitializationDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints>> constraints{};
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> objectDefinition{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};

  DescribeInitializationStatusResponseBodyStructureInitializationDetails() {}

  explicit DescribeInitializationStatusResponseBodyStructureInitializationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constraints) {
      vector<boost::any> temp1;
      for(auto item1:*constraints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Constraints"] = boost::any(temp1);
    }
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (objectDefinition) {
      res["ObjectDefinition"] = boost::any(*objectDefinition);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Constraints") != m.end() && !m["Constraints"].empty()) {
      if (typeid(vector<boost::any>) == m["Constraints"].type()) {
        vector<DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Constraints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constraints = make_shared<vector<DescribeInitializationStatusResponseBodyStructureInitializationDetailsConstraints>>(expect1);
      }
    }
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ObjectDefinition") != m.end() && !m["ObjectDefinition"].empty()) {
      objectDefinition = make_shared<string>(boost::any_cast<string>(m["ObjectDefinition"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeInitializationStatusResponseBodyStructureInitializationDetails() = default;
};
class DescribeInitializationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInitializationStatusResponseBodyDataInitializationDetails>> dataInitializationDetails{};
  shared_ptr<vector<DescribeInitializationStatusResponseBodyDataSynchronizationDetails>> dataSynchronizationDetails{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInitializationStatusResponseBodyStructureInitializationDetails>> structureInitializationDetails{};
  shared_ptr<string> success{};

  DescribeInitializationStatusResponseBody() {}

  explicit DescribeInitializationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitializationDetails) {
      vector<boost::any> temp1;
      for(auto item1:*dataInitializationDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataInitializationDetails"] = boost::any(temp1);
    }
    if (dataSynchronizationDetails) {
      vector<boost::any> temp1;
      for(auto item1:*dataSynchronizationDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSynchronizationDetails"] = boost::any(temp1);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structureInitializationDetails) {
      vector<boost::any> temp1;
      for(auto item1:*structureInitializationDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StructureInitializationDetails"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitializationDetails") != m.end() && !m["DataInitializationDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["DataInitializationDetails"].type()) {
        vector<DescribeInitializationStatusResponseBodyDataInitializationDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataInitializationDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInitializationStatusResponseBodyDataInitializationDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataInitializationDetails = make_shared<vector<DescribeInitializationStatusResponseBodyDataInitializationDetails>>(expect1);
      }
    }
    if (m.find("DataSynchronizationDetails") != m.end() && !m["DataSynchronizationDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSynchronizationDetails"].type()) {
        vector<DescribeInitializationStatusResponseBodyDataSynchronizationDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSynchronizationDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInitializationStatusResponseBodyDataSynchronizationDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSynchronizationDetails = make_shared<vector<DescribeInitializationStatusResponseBodyDataSynchronizationDetails>>(expect1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructureInitializationDetails") != m.end() && !m["StructureInitializationDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["StructureInitializationDetails"].type()) {
        vector<DescribeInitializationStatusResponseBodyStructureInitializationDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StructureInitializationDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInitializationStatusResponseBodyStructureInitializationDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        structureInitializationDetails = make_shared<vector<DescribeInitializationStatusResponseBodyStructureInitializationDetails>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeInitializationStatusResponseBody() = default;
};
class DescribeInitializationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInitializationStatusResponseBody> body{};

  DescribeInitializationStatusResponse() {}

  explicit DescribeInitializationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInitializationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInitializationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInitializationStatusResponse() = default;
};
class DescribeJobMonitorRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};

  DescribeJobMonitorRuleRequest() {}

  explicit DescribeJobMonitorRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeJobMonitorRuleRequest() = default;
};
class DescribeJobMonitorRuleResponseBodyMonitorRules : public Darabonba::Model {
public:
  shared_ptr<long> delayRuleTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<long> noticeValue{};
  shared_ptr<long> period{};
  shared_ptr<string> phone{};
  shared_ptr<string> state{};
  shared_ptr<long> times{};
  shared_ptr<string> type{};

  DescribeJobMonitorRuleResponseBodyMonitorRules() {}

  explicit DescribeJobMonitorRuleResponseBodyMonitorRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayRuleTime) {
      res["DelayRuleTime"] = boost::any(*delayRuleTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (noticeValue) {
      res["NoticeValue"] = boost::any(*noticeValue);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayRuleTime") != m.end() && !m["DelayRuleTime"].empty()) {
      delayRuleTime = make_shared<long>(boost::any_cast<long>(m["DelayRuleTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("NoticeValue") != m.end() && !m["NoticeValue"].empty()) {
      noticeValue = make_shared<long>(boost::any_cast<long>(m["NoticeValue"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeJobMonitorRuleResponseBodyMonitorRules() = default;
};
class DescribeJobMonitorRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<DescribeJobMonitorRuleResponseBodyMonitorRules>> monitorRules{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<string>> topics{};

  DescribeJobMonitorRuleResponseBody() {}

  explicit DescribeJobMonitorRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (monitorRules) {
      vector<boost::any> temp1;
      for(auto item1:*monitorRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (topics) {
      res["Topics"] = boost::any(*topics);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MonitorRules") != m.end() && !m["MonitorRules"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorRules"].type()) {
        vector<DescribeJobMonitorRuleResponseBodyMonitorRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeJobMonitorRuleResponseBodyMonitorRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorRules = make_shared<vector<DescribeJobMonitorRuleResponseBodyMonitorRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topics = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeJobMonitorRuleResponseBody() = default;
};
class DescribeJobMonitorRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeJobMonitorRuleResponseBody> body{};

  DescribeJobMonitorRuleResponse() {}

  explicit DescribeJobMonitorRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeJobMonitorRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeJobMonitorRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeJobMonitorRuleResponse() = default;
};
class DescribeMetricListRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> env{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> ownerID{};
  shared_ptr<string> param{};
  shared_ptr<long> period{};
  shared_ptr<long> startTime{};

  DescribeMetricListRequest() {}

  explicit DescribeMetricListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricListRequest() = default;
};
class DescribeMetricListResponseBodyDataPoints : public Darabonba::Model {
public:
  shared_ptr<double> statistics{};
  shared_ptr<long> timestamp{};

  DescribeMetricListResponseBodyDataPoints() {}

  explicit DescribeMetricListResponseBodyDataPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<double>(boost::any_cast<double>(m["Statistics"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeMetricListResponseBodyDataPoints() = default;
};
class DescribeMetricListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeMetricListResponseBodyDataPoints>> dataPoints{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricType{};
  shared_ptr<string> param{};
  shared_ptr<long> period{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMetricListResponseBody() {}

  explicit DescribeMetricListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataPoints) {
      vector<boost::any> temp1;
      for(auto item1:*dataPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataPoints"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataPoints") != m.end() && !m["DataPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["DataPoints"].type()) {
        vector<DescribeMetricListResponseBodyDataPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricListResponseBodyDataPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataPoints = make_shared<vector<DescribeMetricListResponseBodyDataPoints>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMetricListResponseBody() = default;
};
class DescribeMetricListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricListResponseBody> body{};

  DescribeMetricListResponse() {}

  explicit DescribeMetricListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricListResponse() = default;
};
class DescribeMigrationJobAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  DescribeMigrationJobAlertRequest() {}

  explicit DescribeMigrationJobAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMigrationJobAlertRequest() = default;
};
class DescribeMigrationJobAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> migrationJobName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeMigrationJobAlertResponseBody() {}

  explicit DescribeMigrationJobAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (migrationJobName) {
      res["MigrationJobName"] = boost::any(*migrationJobName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("MigrationJobName") != m.end() && !m["MigrationJobName"].empty()) {
      migrationJobName = make_shared<string>(boost::any_cast<string>(m["MigrationJobName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeMigrationJobAlertResponseBody() = default;
};
class DescribeMigrationJobAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationJobAlertResponseBody> body{};

  DescribeMigrationJobAlertResponse() {}

  explicit DescribeMigrationJobAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationJobAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationJobAlertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationJobAlertResponse() = default;
};
class DescribeMigrationJobDetailRequestMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeMigrationJobDetailRequestMigrationMode() {}

  explicit DescribeMigrationJobDetailRequestMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeMigrationJobDetailRequestMigrationMode() = default;
};
class DescribeMigrationJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobDetailRequestMigrationMode> migrationMode{};
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeMigrationJobDetailRequest() {}

  explicit DescribeMigrationJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeMigrationJobDetailRequestMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeMigrationJobDetailRequestMigrationMode>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMigrationJobDetailRequest() = default;
};
class DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> finishRowNum{};
  shared_ptr<string> migrationTime{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};
  shared_ptr<string> tableName{};
  shared_ptr<string> totalRowNum{};

  DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail() {}

  explicit DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (finishRowNum) {
      res["FinishRowNum"] = boost::any(*finishRowNum);
    }
    if (migrationTime) {
      res["MigrationTime"] = boost::any(*migrationTime);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (totalRowNum) {
      res["TotalRowNum"] = boost::any(*totalRowNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FinishRowNum") != m.end() && !m["FinishRowNum"].empty()) {
      finishRowNum = make_shared<string>(boost::any_cast<string>(m["FinishRowNum"]));
    }
    if (m.find("MigrationTime") != m.end() && !m["MigrationTime"].empty()) {
      migrationTime = make_shared<string>(boost::any_cast<string>(m["MigrationTime"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TotalRowNum") != m.end() && !m["TotalRowNum"].empty()) {
      totalRowNum = make_shared<string>(boost::any_cast<string>(m["TotalRowNum"]));
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail() = default;
};
class DescribeMigrationJobDetailResponseBodyDataInitializationDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail>> dataInitializationDetail{};

  DescribeMigrationJobDetailResponseBodyDataInitializationDetailList() {}

  explicit DescribeMigrationJobDetailResponseBodyDataInitializationDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitializationDetail) {
      vector<boost::any> temp1;
      for(auto item1:*dataInitializationDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataInitializationDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitializationDetail") != m.end() && !m["DataInitializationDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DataInitializationDetail"].type()) {
        vector<DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataInitializationDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataInitializationDetail = make_shared<vector<DescribeMigrationJobDetailResponseBodyDataInitializationDetailListDataInitializationDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyDataInitializationDetailList() = default;
};
class DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};
  shared_ptr<string> tableName{};

  DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail() {}

  explicit DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail() = default;
};
class DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail>> dataSynchronizationDetail{};

  DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList() {}

  explicit DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSynchronizationDetail) {
      vector<boost::any> temp1;
      for(auto item1:*dataSynchronizationDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSynchronizationDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSynchronizationDetail") != m.end() && !m["DataSynchronizationDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSynchronizationDetail"].type()) {
        vector<DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSynchronizationDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSynchronizationDetail = make_shared<vector<DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailListDataSynchronizationDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList() = default;
};
class DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail : public Darabonba::Model {
public:
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> objectDefinition{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};

  DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail() {}

  explicit DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (objectDefinition) {
      res["ObjectDefinition"] = boost::any(*objectDefinition);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ObjectDefinition") != m.end() && !m["ObjectDefinition"].empty()) {
      objectDefinition = make_shared<string>(boost::any_cast<string>(m["ObjectDefinition"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail() = default;
};
class DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail>> structureInitializationDetail{};

  DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList() {}

  explicit DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (structureInitializationDetail) {
      vector<boost::any> temp1;
      for(auto item1:*structureInitializationDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StructureInitializationDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StructureInitializationDetail") != m.end() && !m["StructureInitializationDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["StructureInitializationDetail"].type()) {
        vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StructureInitializationDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        structureInitializationDetail = make_shared<vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintListStructureInitializationDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList() = default;
};
class DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList> constraintList{};
  shared_ptr<string> destinationOwnerDBName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> objectDefinition{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> sourceOwnerDBName{};
  shared_ptr<string> status{};

  DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail() {}

  explicit DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constraintList) {
      res["ConstraintList"] = constraintList ? boost::any(constraintList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destinationOwnerDBName) {
      res["DestinationOwnerDBName"] = boost::any(*destinationOwnerDBName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (objectDefinition) {
      res["ObjectDefinition"] = boost::any(*objectDefinition);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (sourceOwnerDBName) {
      res["SourceOwnerDBName"] = boost::any(*sourceOwnerDBName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstraintList") != m.end() && !m["ConstraintList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstraintList"].type()) {
        DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstraintList"]));
        constraintList = make_shared<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetailConstraintList>(model1);
      }
    }
    if (m.find("DestinationOwnerDBName") != m.end() && !m["DestinationOwnerDBName"].empty()) {
      destinationOwnerDBName = make_shared<string>(boost::any_cast<string>(m["DestinationOwnerDBName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ObjectDefinition") != m.end() && !m["ObjectDefinition"].empty()) {
      objectDefinition = make_shared<string>(boost::any_cast<string>(m["ObjectDefinition"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("SourceOwnerDBName") != m.end() && !m["SourceOwnerDBName"].empty()) {
      sourceOwnerDBName = make_shared<string>(boost::any_cast<string>(m["SourceOwnerDBName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail() = default;
};
class DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail>> structureInitializationDetail{};

  DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList() {}

  explicit DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (structureInitializationDetail) {
      vector<boost::any> temp1;
      for(auto item1:*structureInitializationDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StructureInitializationDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StructureInitializationDetail") != m.end() && !m["StructureInitializationDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["StructureInitializationDetail"].type()) {
        vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StructureInitializationDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        structureInitializationDetail = make_shared<vector<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailListStructureInitializationDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList() = default;
};
class DescribeMigrationJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobDetailResponseBodyDataInitializationDetailList> dataInitializationDetailList{};
  shared_ptr<DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList> dataSynchronizationDetailList{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList> structureInitializationDetailList{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeMigrationJobDetailResponseBody() {}

  explicit DescribeMigrationJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitializationDetailList) {
      res["DataInitializationDetailList"] = dataInitializationDetailList ? boost::any(dataInitializationDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationDetailList) {
      res["DataSynchronizationDetailList"] = dataSynchronizationDetailList ? boost::any(dataSynchronizationDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (structureInitializationDetailList) {
      res["StructureInitializationDetailList"] = structureInitializationDetailList ? boost::any(structureInitializationDetailList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitializationDetailList") != m.end() && !m["DataInitializationDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationDetailList"].type()) {
        DescribeMigrationJobDetailResponseBodyDataInitializationDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationDetailList"]));
        dataInitializationDetailList = make_shared<DescribeMigrationJobDetailResponseBodyDataInitializationDetailList>(model1);
      }
    }
    if (m.find("DataSynchronizationDetailList") != m.end() && !m["DataSynchronizationDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationDetailList"].type()) {
        DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationDetailList"]));
        dataSynchronizationDetailList = make_shared<DescribeMigrationJobDetailResponseBodyDataSynchronizationDetailList>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StructureInitializationDetailList") != m.end() && !m["StructureInitializationDetailList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationDetailList"].type()) {
        DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationDetailList"]));
        structureInitializationDetailList = make_shared<DescribeMigrationJobDetailResponseBodyStructureInitializationDetailList>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeMigrationJobDetailResponseBody() = default;
};
class DescribeMigrationJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationJobDetailResponseBody> body{};

  DescribeMigrationJobDetailResponse() {}

  explicit DescribeMigrationJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationJobDetailResponse() = default;
};
class DescribeMigrationJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  DescribeMigrationJobStatusRequest() {}

  explicit DescribeMigrationJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMigrationJobStatusRequest() = default;
};
class DescribeMigrationJobStatusResponseBodyDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeMigrationJobStatusResponseBodyDataInitializationStatus() {}

  explicit DescribeMigrationJobStatusResponseBodyDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyDataInitializationStatus() = default;
};
class DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> delay{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus() {}

  explicit DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus() = default;
};
class DescribeMigrationJobStatusResponseBodyDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};
  shared_ptr<string> oracleSID{};

  DescribeMigrationJobStatusResponseBodyDestinationEndpoint() {}

  explicit DescribeMigrationJobStatusResponseBodyDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (oracleSID) {
      res["oracleSID"] = boost::any(*oracleSID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("oracleSID") != m.end() && !m["oracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["oracleSID"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyDestinationEndpoint() = default;
};
class DescribeMigrationJobStatusResponseBodyMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeMigrationJobStatusResponseBodyMigrationMode() {}

  explicit DescribeMigrationJobStatusResponseBodyMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["dataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["dataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["structureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataInitialization") != m.end() && !m["dataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["dataInitialization"]));
    }
    if (m.find("dataSynchronization") != m.end() && !m["dataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["dataSynchronization"]));
    }
    if (m.find("structureInitialization") != m.end() && !m["structureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["structureInitialization"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyMigrationMode() = default;
};
class DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> itemName{};
  shared_ptr<string> repairMethod{};

  DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem() {}

  explicit DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem() = default;
};
class DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem>> checkItem{};

  DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail() {}

  explicit DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItem) {
      vector<boost::any> temp1;
      for(auto item1:*checkItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckItem"].type()) {
        vector<DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkItem = make_shared<vector<DescribeMigrationJobStatusResponseBodyPrecheckStatusDetailCheckItem>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail() = default;
};
class DescribeMigrationJobStatusResponseBodyPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail> detail{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeMigrationJobStatusResponseBodyPrecheckStatus() {}

  explicit DescribeMigrationJobStatusResponseBodyPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<DescribeMigrationJobStatusResponseBodyPrecheckStatusDetail>(model1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyPrecheckStatus() = default;
};
class DescribeMigrationJobStatusResponseBodySourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};
  shared_ptr<string> oracleSID{};

  DescribeMigrationJobStatusResponseBodySourceEndpoint() {}

  explicit DescribeMigrationJobStatusResponseBodySourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (oracleSID) {
      res["oracleSID"] = boost::any(*oracleSID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("oracleSID") != m.end() && !m["oracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["oracleSID"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodySourceEndpoint() = default;
};
class DescribeMigrationJobStatusResponseBodyStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeMigrationJobStatusResponseBodyStructureInitializationStatus() {}

  explicit DescribeMigrationJobStatusResponseBodyStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBodyStructureInitializationStatus() = default;
};
class DescribeMigrationJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobStatusResponseBodyDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<DescribeMigrationJobStatusResponseBodyDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> migrationJobClass{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> migrationJobName{};
  shared_ptr<string> migrationJobStatus{};
  shared_ptr<DescribeMigrationJobStatusResponseBodyMigrationMode> migrationMode{};
  shared_ptr<string> migrationObject{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeMigrationJobStatusResponseBodyPrecheckStatus> precheckStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMigrationJobStatusResponseBodySourceEndpoint> sourceEndpoint{};
  shared_ptr<DescribeMigrationJobStatusResponseBodyStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> success{};
  shared_ptr<string> taskId{};

  DescribeMigrationJobStatusResponseBody() {}

  explicit DescribeMigrationJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (migrationJobClass) {
      res["MigrationJobClass"] = boost::any(*migrationJobClass);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (migrationJobName) {
      res["MigrationJobName"] = boost::any(*migrationJobName);
    }
    if (migrationJobStatus) {
      res["MigrationJobStatus"] = boost::any(*migrationJobStatus);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (migrationObject) {
      res["MigrationObject"] = boost::any(*migrationObject);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeMigrationJobStatusResponseBodyDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeMigrationJobStatusResponseBodyDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeMigrationJobStatusResponseBodyDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeMigrationJobStatusResponseBodyDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeMigrationJobStatusResponseBodyDestinationEndpoint>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("MigrationJobClass") != m.end() && !m["MigrationJobClass"].empty()) {
      migrationJobClass = make_shared<string>(boost::any_cast<string>(m["MigrationJobClass"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("MigrationJobName") != m.end() && !m["MigrationJobName"].empty()) {
      migrationJobName = make_shared<string>(boost::any_cast<string>(m["MigrationJobName"]));
    }
    if (m.find("MigrationJobStatus") != m.end() && !m["MigrationJobStatus"].empty()) {
      migrationJobStatus = make_shared<string>(boost::any_cast<string>(m["MigrationJobStatus"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeMigrationJobStatusResponseBodyMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeMigrationJobStatusResponseBodyMigrationMode>(model1);
      }
    }
    if (m.find("MigrationObject") != m.end() && !m["MigrationObject"].empty()) {
      migrationObject = make_shared<string>(boost::any_cast<string>(m["MigrationObject"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeMigrationJobStatusResponseBodyPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeMigrationJobStatusResponseBodyPrecheckStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeMigrationJobStatusResponseBodySourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeMigrationJobStatusResponseBodySourceEndpoint>(model1);
      }
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeMigrationJobStatusResponseBodyStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeMigrationJobStatusResponseBodyStructureInitializationStatus>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeMigrationJobStatusResponseBody() = default;
};
class DescribeMigrationJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationJobStatusResponseBody> body{};

  DescribeMigrationJobStatusResponse() {}

  explicit DescribeMigrationJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationJobStatusResponse() = default;
};
class DescribeMigrationJobsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMigrationJobsRequestTag() {}

  explicit DescribeMigrationJobsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMigrationJobsRequestTag() = default;
};
class DescribeMigrationJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> migrationJobName{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<DescribeMigrationJobsRequestTag>> tag{};

  DescribeMigrationJobsRequest() {}

  explicit DescribeMigrationJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (migrationJobName) {
      res["MigrationJobName"] = boost::any(*migrationJobName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("MigrationJobName") != m.end() && !m["MigrationJobName"].empty()) {
      migrationJobName = make_shared<string>(boost::any_cast<string>(m["MigrationJobName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMigrationJobsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMigrationJobsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobsRequest() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization : public Darabonba::Model {
public:
  shared_ptr<string> delay{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode : public Darabonba::Model {
public:
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<bool> structureInitialization{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> table{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Table"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Table"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      table = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList> tableList{};
  shared_ptr<string> wholeDatabase{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableList) {
      res["TableList"] = tableList ? boost::any(tableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wholeDatabase) {
      res["WholeDatabase"] = boost::any(*wholeDatabase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableList"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableList"]));
        tableList = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObjectTableList>(model1);
      }
    }
    if (m.find("WholeDatabase") != m.end() && !m["WholeDatabase"].empty()) {
      wholeDatabase = make_shared<string>(boost::any_cast<string>(m["WholeDatabase"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject>> synchronousObject{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (synchronousObject) {
      vector<boost::any> temp1;
      for(auto item1:*synchronousObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronousObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SynchronousObject") != m.end() && !m["SynchronousObject"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronousObject"].type()) {
        vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronousObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronousObject = make_shared<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObjectSynchronousObject>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck : public Darabonba::Model {
public:
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> oracleSID{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (oracleSID) {
      res["OracleSID"] = boost::any(*oracleSID);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OracleSID") != m.end() && !m["OracleSID"].empty()) {
      oracleSID = make_shared<string>(boost::any_cast<string>(m["OracleSID"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag>> tag{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob : public Darabonba::Model {
public:
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization> dataInitialization{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization> dataSynchronization{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> instanceCreateTime{};
  shared_ptr<string> jobCreateTime{};
  shared_ptr<string> migrationJobClass{};
  shared_ptr<string> migrationJobID{};
  shared_ptr<string> migrationJobName{};
  shared_ptr<string> migrationJobStatus{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode> migrationMode{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject> migrationObject{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck> precheck{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint> sourceEndpoint{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization> structureInitialization{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags> tags{};

  DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitialization) {
      res["DataInitialization"] = dataInitialization ? boost::any(dataInitialization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = dataSynchronization ? boost::any(dataSynchronization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceCreateTime) {
      res["InstanceCreateTime"] = boost::any(*instanceCreateTime);
    }
    if (jobCreateTime) {
      res["JobCreateTime"] = boost::any(*jobCreateTime);
    }
    if (migrationJobClass) {
      res["MigrationJobClass"] = boost::any(*migrationJobClass);
    }
    if (migrationJobID) {
      res["MigrationJobID"] = boost::any(*migrationJobID);
    }
    if (migrationJobName) {
      res["MigrationJobName"] = boost::any(*migrationJobName);
    }
    if (migrationJobStatus) {
      res["MigrationJobStatus"] = boost::any(*migrationJobStatus);
    }
    if (migrationMode) {
      res["MigrationMode"] = migrationMode ? boost::any(migrationMode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (migrationObject) {
      res["MigrationObject"] = migrationObject ? boost::any(migrationObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (precheck) {
      res["Precheck"] = precheck ? boost::any(precheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (structureInitialization) {
      res["StructureInitialization"] = structureInitialization ? boost::any(structureInitialization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitialization"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitialization"]));
        dataInitialization = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataInitialization>(model1);
      }
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronization"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronization"]));
        dataSynchronization = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDataSynchronization>(model1);
      }
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobDestinationEndpoint>(model1);
      }
    }
    if (m.find("InstanceCreateTime") != m.end() && !m["InstanceCreateTime"].empty()) {
      instanceCreateTime = make_shared<string>(boost::any_cast<string>(m["InstanceCreateTime"]));
    }
    if (m.find("JobCreateTime") != m.end() && !m["JobCreateTime"].empty()) {
      jobCreateTime = make_shared<string>(boost::any_cast<string>(m["JobCreateTime"]));
    }
    if (m.find("MigrationJobClass") != m.end() && !m["MigrationJobClass"].empty()) {
      migrationJobClass = make_shared<string>(boost::any_cast<string>(m["MigrationJobClass"]));
    }
    if (m.find("MigrationJobID") != m.end() && !m["MigrationJobID"].empty()) {
      migrationJobID = make_shared<string>(boost::any_cast<string>(m["MigrationJobID"]));
    }
    if (m.find("MigrationJobName") != m.end() && !m["MigrationJobName"].empty()) {
      migrationJobName = make_shared<string>(boost::any_cast<string>(m["MigrationJobName"]));
    }
    if (m.find("MigrationJobStatus") != m.end() && !m["MigrationJobStatus"].empty()) {
      migrationJobStatus = make_shared<string>(boost::any_cast<string>(m["MigrationJobStatus"]));
    }
    if (m.find("MigrationMode") != m.end() && !m["MigrationMode"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationMode"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationMode"]));
        migrationMode = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationMode>(model1);
      }
    }
    if (m.find("MigrationObject") != m.end() && !m["MigrationObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationObject"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationObject"]));
        migrationObject = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobMigrationObject>(model1);
      }
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Precheck") != m.end() && !m["Precheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["Precheck"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Precheck"]));
        precheck = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobPrecheck>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobSourceEndpoint>(model1);
      }
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitialization"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitialization"]));
        structureInitialization = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobStructureInitialization>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJobTags>(model1);
      }
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob() = default;
};
class DescribeMigrationJobsResponseBodyMigrationJobs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob>> migrationJob{};

  DescribeMigrationJobsResponseBodyMigrationJobs() {}

  explicit DescribeMigrationJobsResponseBodyMigrationJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (migrationJob) {
      vector<boost::any> temp1;
      for(auto item1:*migrationJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MigrationJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MigrationJob") != m.end() && !m["MigrationJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MigrationJob"].type()) {
        vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MigrationJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        migrationJob = make_shared<vector<DescribeMigrationJobsResponseBodyMigrationJobsMigrationJob>>(expect1);
      }
    }
  }


  virtual ~DescribeMigrationJobsResponseBodyMigrationJobs() = default;
};
class DescribeMigrationJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<DescribeMigrationJobsResponseBodyMigrationJobs> migrationJobs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeMigrationJobsResponseBody() {}

  explicit DescribeMigrationJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (migrationJobs) {
      res["MigrationJobs"] = migrationJobs ? boost::any(migrationJobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("MigrationJobs") != m.end() && !m["MigrationJobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationJobs"].type()) {
        DescribeMigrationJobsResponseBodyMigrationJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationJobs"]));
        migrationJobs = make_shared<DescribeMigrationJobsResponseBodyMigrationJobs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeMigrationJobsResponseBody() = default;
};
class DescribeMigrationJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMigrationJobsResponseBody> body{};

  DescribeMigrationJobsResponse() {}

  explicit DescribeMigrationJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMigrationJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMigrationJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMigrationJobsResponse() = default;
};
class DescribePreCheckStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> jobCode{};
  shared_ptr<string> name{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> structPhase{};
  shared_ptr<string> structType{};

  DescribePreCheckStatusRequest() {}

  explicit DescribePreCheckStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (structPhase) {
      res["StructPhase"] = boost::any(*structPhase);
    }
    if (structType) {
      res["StructType"] = boost::any(*structType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StructPhase") != m.end() && !m["StructPhase"].empty()) {
      structPhase = make_shared<string>(boost::any_cast<string>(m["StructPhase"]));
    }
    if (m.find("StructType") != m.end() && !m["StructType"].empty()) {
      structType = make_shared<string>(boost::any_cast<string>(m["StructType"]));
    }
  }


  virtual ~DescribePreCheckStatusRequest() = default;
};
class DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs : public Darabonba::Model {
public:
  shared_ptr<string> errData{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> errType{};
  shared_ptr<string> logLevel{};

  DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs() {}

  explicit DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errData) {
      res["ErrData"] = boost::any(*errData);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errType) {
      res["ErrType"] = boost::any(*errType);
    }
    if (logLevel) {
      res["LogLevel"] = boost::any(*logLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrData") != m.end() && !m["ErrData"].empty()) {
      errData = make_shared<string>(boost::any_cast<string>(m["ErrData"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrType") != m.end() && !m["ErrType"].empty()) {
      errType = make_shared<string>(boost::any_cast<string>(m["ErrType"]));
    }
    if (m.find("LogLevel") != m.end() && !m["LogLevel"].empty()) {
      logLevel = make_shared<string>(boost::any_cast<string>(m["LogLevel"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs() = default;
};
class DescribePreCheckStatusResponseBodyAnalysisJobProgress : public Darabonba::Model {
public:
  shared_ptr<string> bootTime{};
  shared_ptr<bool> canSkip{};
  shared_ptr<string> current{};
  shared_ptr<string> ddlSql{};
  shared_ptr<long> delaySeconds{};
  shared_ptr<string> destSchema{};
  shared_ptr<long> diffRow{};
  shared_ptr<string> errDetail{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<string> ignoreFlag{};
  shared_ptr<string> item{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs>> logs{};
  shared_ptr<string> names{};
  shared_ptr<long> orderNum{};
  shared_ptr<string> parentObj{};
  shared_ptr<string> repairMethod{};
  shared_ptr<bool> skip{};
  shared_ptr<string> sourceSchema{};
  shared_ptr<string> state{};
  shared_ptr<string> sub{};
  shared_ptr<string> targetNames{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodyAnalysisJobProgress() {}

  explicit DescribePreCheckStatusResponseBodyAnalysisJobProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (canSkip) {
      res["CanSkip"] = boost::any(*canSkip);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (ddlSql) {
      res["DdlSql"] = boost::any(*ddlSql);
    }
    if (delaySeconds) {
      res["DelaySeconds"] = boost::any(*delaySeconds);
    }
    if (destSchema) {
      res["DestSchema"] = boost::any(*destSchema);
    }
    if (diffRow) {
      res["DiffRow"] = boost::any(*diffRow);
    }
    if (errDetail) {
      res["ErrDetail"] = boost::any(*errDetail);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ignoreFlag) {
      res["IgnoreFlag"] = boost::any(*ignoreFlag);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (orderNum) {
      res["OrderNum"] = boost::any(*orderNum);
    }
    if (parentObj) {
      res["ParentObj"] = boost::any(*parentObj);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    if (targetNames) {
      res["TargetNames"] = boost::any(*targetNames);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("CanSkip") != m.end() && !m["CanSkip"].empty()) {
      canSkip = make_shared<bool>(boost::any_cast<bool>(m["CanSkip"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("DdlSql") != m.end() && !m["DdlSql"].empty()) {
      ddlSql = make_shared<string>(boost::any_cast<string>(m["DdlSql"]));
    }
    if (m.find("DelaySeconds") != m.end() && !m["DelaySeconds"].empty()) {
      delaySeconds = make_shared<long>(boost::any_cast<long>(m["DelaySeconds"]));
    }
    if (m.find("DestSchema") != m.end() && !m["DestSchema"].empty()) {
      destSchema = make_shared<string>(boost::any_cast<string>(m["DestSchema"]));
    }
    if (m.find("DiffRow") != m.end() && !m["DiffRow"].empty()) {
      diffRow = make_shared<long>(boost::any_cast<long>(m["DiffRow"]));
    }
    if (m.find("ErrDetail") != m.end() && !m["ErrDetail"].empty()) {
      errDetail = make_shared<string>(boost::any_cast<string>(m["ErrDetail"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IgnoreFlag") != m.end() && !m["IgnoreFlag"].empty()) {
      ignoreFlag = make_shared<string>(boost::any_cast<string>(m["IgnoreFlag"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePreCheckStatusResponseBodyAnalysisJobProgressLogs>>(expect1);
      }
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      names = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("OrderNum") != m.end() && !m["OrderNum"].empty()) {
      orderNum = make_shared<long>(boost::any_cast<long>(m["OrderNum"]));
    }
    if (m.find("ParentObj") != m.end() && !m["ParentObj"].empty()) {
      parentObj = make_shared<string>(boost::any_cast<string>(m["ParentObj"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<string>(boost::any_cast<string>(m["Sub"]));
    }
    if (m.find("TargetNames") != m.end() && !m["TargetNames"].empty()) {
      targetNames = make_shared<string>(boost::any_cast<string>(m["TargetNames"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyAnalysisJobProgress() = default;
};
class DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs : public Darabonba::Model {
public:
  shared_ptr<string> errData{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> errType{};
  shared_ptr<string> logLevel{};

  DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs() {}

  explicit DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errData) {
      res["ErrData"] = boost::any(*errData);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errType) {
      res["ErrType"] = boost::any(*errType);
    }
    if (logLevel) {
      res["LogLevel"] = boost::any(*logLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrData") != m.end() && !m["ErrData"].empty()) {
      errData = make_shared<string>(boost::any_cast<string>(m["ErrData"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrType") != m.end() && !m["ErrType"].empty()) {
      errType = make_shared<string>(boost::any_cast<string>(m["ErrType"]));
    }
    if (m.find("LogLevel") != m.end() && !m["LogLevel"].empty()) {
      logLevel = make_shared<string>(boost::any_cast<string>(m["LogLevel"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs() = default;
};
class DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress : public Darabonba::Model {
public:
  shared_ptr<string> bootTime{};
  shared_ptr<bool> canSkip{};
  shared_ptr<string> current{};
  shared_ptr<string> ddlSql{};
  shared_ptr<long> delaySeconds{};
  shared_ptr<string> destSchema{};
  shared_ptr<long> diffRow{};
  shared_ptr<string> errDetail{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<string> ignoreFlag{};
  shared_ptr<string> item{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs>> logs{};
  shared_ptr<string> names{};
  shared_ptr<long> orderNum{};
  shared_ptr<string> parentObj{};
  shared_ptr<string> repairMethod{};
  shared_ptr<bool> skip{};
  shared_ptr<string> sourceSchema{};
  shared_ptr<string> state{};
  shared_ptr<string> sub{};
  shared_ptr<string> targetNames{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress() {}

  explicit DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (canSkip) {
      res["CanSkip"] = boost::any(*canSkip);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (ddlSql) {
      res["DdlSql"] = boost::any(*ddlSql);
    }
    if (delaySeconds) {
      res["DelaySeconds"] = boost::any(*delaySeconds);
    }
    if (destSchema) {
      res["DestSchema"] = boost::any(*destSchema);
    }
    if (diffRow) {
      res["DiffRow"] = boost::any(*diffRow);
    }
    if (errDetail) {
      res["ErrDetail"] = boost::any(*errDetail);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ignoreFlag) {
      res["IgnoreFlag"] = boost::any(*ignoreFlag);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (orderNum) {
      res["OrderNum"] = boost::any(*orderNum);
    }
    if (parentObj) {
      res["ParentObj"] = boost::any(*parentObj);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    if (targetNames) {
      res["TargetNames"] = boost::any(*targetNames);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("CanSkip") != m.end() && !m["CanSkip"].empty()) {
      canSkip = make_shared<bool>(boost::any_cast<bool>(m["CanSkip"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("DdlSql") != m.end() && !m["DdlSql"].empty()) {
      ddlSql = make_shared<string>(boost::any_cast<string>(m["DdlSql"]));
    }
    if (m.find("DelaySeconds") != m.end() && !m["DelaySeconds"].empty()) {
      delaySeconds = make_shared<long>(boost::any_cast<long>(m["DelaySeconds"]));
    }
    if (m.find("DestSchema") != m.end() && !m["DestSchema"].empty()) {
      destSchema = make_shared<string>(boost::any_cast<string>(m["DestSchema"]));
    }
    if (m.find("DiffRow") != m.end() && !m["DiffRow"].empty()) {
      diffRow = make_shared<long>(boost::any_cast<long>(m["DiffRow"]));
    }
    if (m.find("ErrDetail") != m.end() && !m["ErrDetail"].empty()) {
      errDetail = make_shared<string>(boost::any_cast<string>(m["ErrDetail"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IgnoreFlag") != m.end() && !m["IgnoreFlag"].empty()) {
      ignoreFlag = make_shared<string>(boost::any_cast<string>(m["IgnoreFlag"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgressLogs>>(expect1);
      }
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      names = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("OrderNum") != m.end() && !m["OrderNum"].empty()) {
      orderNum = make_shared<long>(boost::any_cast<long>(m["OrderNum"]));
    }
    if (m.find("ParentObj") != m.end() && !m["ParentObj"].empty()) {
      parentObj = make_shared<string>(boost::any_cast<string>(m["ParentObj"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<string>(boost::any_cast<string>(m["Sub"]));
    }
    if (m.find("TargetNames") != m.end() && !m["TargetNames"].empty()) {
      targetNames = make_shared<string>(boost::any_cast<string>(m["TargetNames"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress() = default;
};
class DescribePreCheckStatusResponseBodyFullNetCheckJobStatus : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> destRegion{};
  shared_ptr<string> destRegionCidr{};
  shared_ptr<string> destinationEndpointType{};
  shared_ptr<long> errorItem{};
  shared_ptr<string> hostRegion{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress>> jobProgress{};
  shared_ptr<string> sourceEndpointType{};
  shared_ptr<string> srcRegion{};
  shared_ptr<string> srcRegionCidr{};
  shared_ptr<string> state{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodyFullNetCheckJobStatus() {}

  explicit DescribePreCheckStatusResponseBodyFullNetCheckJobStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (destRegion) {
      res["DestRegion"] = boost::any(*destRegion);
    }
    if (destRegionCidr) {
      res["DestRegionCidr"] = boost::any(*destRegionCidr);
    }
    if (destinationEndpointType) {
      res["DestinationEndpointType"] = boost::any(*destinationEndpointType);
    }
    if (errorItem) {
      res["ErrorItem"] = boost::any(*errorItem);
    }
    if (hostRegion) {
      res["HostRegion"] = boost::any(*hostRegion);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobProgress) {
      vector<boost::any> temp1;
      for(auto item1:*jobProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobProgress"] = boost::any(temp1);
    }
    if (sourceEndpointType) {
      res["SourceEndpointType"] = boost::any(*sourceEndpointType);
    }
    if (srcRegion) {
      res["SrcRegion"] = boost::any(*srcRegion);
    }
    if (srcRegionCidr) {
      res["SrcRegionCidr"] = boost::any(*srcRegionCidr);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DestRegion") != m.end() && !m["DestRegion"].empty()) {
      destRegion = make_shared<string>(boost::any_cast<string>(m["DestRegion"]));
    }
    if (m.find("DestRegionCidr") != m.end() && !m["DestRegionCidr"].empty()) {
      destRegionCidr = make_shared<string>(boost::any_cast<string>(m["DestRegionCidr"]));
    }
    if (m.find("DestinationEndpointType") != m.end() && !m["DestinationEndpointType"].empty()) {
      destinationEndpointType = make_shared<string>(boost::any_cast<string>(m["DestinationEndpointType"]));
    }
    if (m.find("ErrorItem") != m.end() && !m["ErrorItem"].empty()) {
      errorItem = make_shared<long>(boost::any_cast<long>(m["ErrorItem"]));
    }
    if (m.find("HostRegion") != m.end() && !m["HostRegion"].empty()) {
      hostRegion = make_shared<string>(boost::any_cast<string>(m["HostRegion"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobProgress") != m.end() && !m["JobProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["JobProgress"].type()) {
        vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobProgress = make_shared<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatusJobProgress>>(expect1);
      }
    }
    if (m.find("SourceEndpointType") != m.end() && !m["SourceEndpointType"].empty()) {
      sourceEndpointType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointType"]));
    }
    if (m.find("SrcRegion") != m.end() && !m["SrcRegion"].empty()) {
      srcRegion = make_shared<string>(boost::any_cast<string>(m["SrcRegion"]));
    }
    if (m.find("SrcRegionCidr") != m.end() && !m["SrcRegionCidr"].empty()) {
      srcRegionCidr = make_shared<string>(boost::any_cast<string>(m["SrcRegionCidr"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyFullNetCheckJobStatus() = default;
};
class DescribePreCheckStatusResponseBodyJobProgressLogs : public Darabonba::Model {
public:
  shared_ptr<string> errData{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> errType{};
  shared_ptr<string> logLevel{};

  DescribePreCheckStatusResponseBodyJobProgressLogs() {}

  explicit DescribePreCheckStatusResponseBodyJobProgressLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errData) {
      res["ErrData"] = boost::any(*errData);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errType) {
      res["ErrType"] = boost::any(*errType);
    }
    if (logLevel) {
      res["LogLevel"] = boost::any(*logLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrData") != m.end() && !m["ErrData"].empty()) {
      errData = make_shared<string>(boost::any_cast<string>(m["ErrData"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrType") != m.end() && !m["ErrType"].empty()) {
      errType = make_shared<string>(boost::any_cast<string>(m["ErrType"]));
    }
    if (m.find("LogLevel") != m.end() && !m["LogLevel"].empty()) {
      logLevel = make_shared<string>(boost::any_cast<string>(m["LogLevel"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyJobProgressLogs() = default;
};
class DescribePreCheckStatusResponseBodyJobProgress : public Darabonba::Model {
public:
  shared_ptr<string> bootTime{};
  shared_ptr<bool> canSkip{};
  shared_ptr<string> current{};
  shared_ptr<string> ddlSql{};
  shared_ptr<long> delaySeconds{};
  shared_ptr<string> destSchema{};
  shared_ptr<long> diffRow{};
  shared_ptr<string> errDetail{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<string> ignoreFlag{};
  shared_ptr<string> item{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyJobProgressLogs>> logs{};
  shared_ptr<string> names{};
  shared_ptr<long> orderNum{};
  shared_ptr<string> parentObj{};
  shared_ptr<string> repairMethod{};
  shared_ptr<bool> skip{};
  shared_ptr<string> sourceSchema{};
  shared_ptr<string> state{};
  shared_ptr<string> sub{};
  shared_ptr<string> targetNames{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodyJobProgress() {}

  explicit DescribePreCheckStatusResponseBodyJobProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (canSkip) {
      res["CanSkip"] = boost::any(*canSkip);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (ddlSql) {
      res["DdlSql"] = boost::any(*ddlSql);
    }
    if (delaySeconds) {
      res["DelaySeconds"] = boost::any(*delaySeconds);
    }
    if (destSchema) {
      res["DestSchema"] = boost::any(*destSchema);
    }
    if (diffRow) {
      res["DiffRow"] = boost::any(*diffRow);
    }
    if (errDetail) {
      res["ErrDetail"] = boost::any(*errDetail);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ignoreFlag) {
      res["IgnoreFlag"] = boost::any(*ignoreFlag);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (orderNum) {
      res["OrderNum"] = boost::any(*orderNum);
    }
    if (parentObj) {
      res["ParentObj"] = boost::any(*parentObj);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    if (targetNames) {
      res["TargetNames"] = boost::any(*targetNames);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("CanSkip") != m.end() && !m["CanSkip"].empty()) {
      canSkip = make_shared<bool>(boost::any_cast<bool>(m["CanSkip"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("DdlSql") != m.end() && !m["DdlSql"].empty()) {
      ddlSql = make_shared<string>(boost::any_cast<string>(m["DdlSql"]));
    }
    if (m.find("DelaySeconds") != m.end() && !m["DelaySeconds"].empty()) {
      delaySeconds = make_shared<long>(boost::any_cast<long>(m["DelaySeconds"]));
    }
    if (m.find("DestSchema") != m.end() && !m["DestSchema"].empty()) {
      destSchema = make_shared<string>(boost::any_cast<string>(m["DestSchema"]));
    }
    if (m.find("DiffRow") != m.end() && !m["DiffRow"].empty()) {
      diffRow = make_shared<long>(boost::any_cast<long>(m["DiffRow"]));
    }
    if (m.find("ErrDetail") != m.end() && !m["ErrDetail"].empty()) {
      errDetail = make_shared<string>(boost::any_cast<string>(m["ErrDetail"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IgnoreFlag") != m.end() && !m["IgnoreFlag"].empty()) {
      ignoreFlag = make_shared<string>(boost::any_cast<string>(m["IgnoreFlag"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePreCheckStatusResponseBodyJobProgressLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyJobProgressLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePreCheckStatusResponseBodyJobProgressLogs>>(expect1);
      }
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      names = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("OrderNum") != m.end() && !m["OrderNum"].empty()) {
      orderNum = make_shared<long>(boost::any_cast<long>(m["OrderNum"]));
    }
    if (m.find("ParentObj") != m.end() && !m["ParentObj"].empty()) {
      parentObj = make_shared<string>(boost::any_cast<string>(m["ParentObj"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<string>(boost::any_cast<string>(m["Sub"]));
    }
    if (m.find("TargetNames") != m.end() && !m["TargetNames"].empty()) {
      targetNames = make_shared<string>(boost::any_cast<string>(m["TargetNames"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyJobProgress() = default;
};
class DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis : public Darabonba::Model {
public:
  shared_ptr<string> cnDocUrl{};
  shared_ptr<string> code{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> internationalDocUrl{};
  shared_ptr<string> result{};

  DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis() {}

  explicit DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnDocUrl) {
      res["CnDocUrl"] = boost::any(*cnDocUrl);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (internationalDocUrl) {
      res["InternationalDocUrl"] = boost::any(*internationalDocUrl);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnDocUrl") != m.end() && !m["CnDocUrl"].empty()) {
      cnDocUrl = make_shared<string>(boost::any_cast<string>(m["CnDocUrl"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("InternationalDocUrl") != m.end() && !m["InternationalDocUrl"].empty()) {
      internationalDocUrl = make_shared<string>(boost::any_cast<string>(m["InternationalDocUrl"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis() = default;
};
class DescribePreCheckStatusResponseBodyNetworkDiagnosisResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis>> diagnosis{};
  shared_ptr<string> modelVersion{};

  DescribePreCheckStatusResponseBodyNetworkDiagnosisResult() {}

  explicit DescribePreCheckStatusResponseBodyNetworkDiagnosisResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnosis) {
      vector<boost::any> temp1;
      for(auto item1:*diagnosis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Diagnosis"] = boost::any(temp1);
    }
    if (modelVersion) {
      res["ModelVersion"] = boost::any(*modelVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Diagnosis") != m.end() && !m["Diagnosis"].empty()) {
      if (typeid(vector<boost::any>) == m["Diagnosis"].type()) {
        vector<DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Diagnosis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnosis = make_shared<vector<DescribePreCheckStatusResponseBodyNetworkDiagnosisResultDiagnosis>>(expect1);
      }
    }
    if (m.find("ModelVersion") != m.end() && !m["ModelVersion"].empty()) {
      modelVersion = make_shared<string>(boost::any_cast<string>(m["ModelVersion"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodyNetworkDiagnosisResult() = default;
};
class DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs : public Darabonba::Model {
public:
  shared_ptr<string> errData{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> errType{};
  shared_ptr<string> logLevel{};

  DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs() {}

  explicit DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errData) {
      res["ErrData"] = boost::any(*errData);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errType) {
      res["ErrType"] = boost::any(*errType);
    }
    if (logLevel) {
      res["LogLevel"] = boost::any(*logLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrData") != m.end() && !m["ErrData"].empty()) {
      errData = make_shared<string>(boost::any_cast<string>(m["ErrData"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrType") != m.end() && !m["ErrType"].empty()) {
      errType = make_shared<string>(boost::any_cast<string>(m["ErrType"]));
    }
    if (m.find("LogLevel") != m.end() && !m["LogLevel"].empty()) {
      logLevel = make_shared<string>(boost::any_cast<string>(m["LogLevel"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs() = default;
};
class DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress : public Darabonba::Model {
public:
  shared_ptr<string> bootTime{};
  shared_ptr<bool> canSkip{};
  shared_ptr<string> current{};
  shared_ptr<string> ddlSql{};
  shared_ptr<long> delaySeconds{};
  shared_ptr<string> destSchema{};
  shared_ptr<long> diffRow{};
  shared_ptr<string> errDetail{};
  shared_ptr<string> errMsg{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<string> ignoreFlag{};
  shared_ptr<string> item{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs>> logs{};
  shared_ptr<string> names{};
  shared_ptr<long> orderNum{};
  shared_ptr<string> parentObj{};
  shared_ptr<string> repairMethod{};
  shared_ptr<bool> skip{};
  shared_ptr<string> sourceSchema{};
  shared_ptr<string> state{};
  shared_ptr<string> sub{};
  shared_ptr<string> targetNames{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress() {}

  explicit DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bootTime) {
      res["BootTime"] = boost::any(*bootTime);
    }
    if (canSkip) {
      res["CanSkip"] = boost::any(*canSkip);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (ddlSql) {
      res["DdlSql"] = boost::any(*ddlSql);
    }
    if (delaySeconds) {
      res["DelaySeconds"] = boost::any(*delaySeconds);
    }
    if (destSchema) {
      res["DestSchema"] = boost::any(*destSchema);
    }
    if (diffRow) {
      res["DiffRow"] = boost::any(*diffRow);
    }
    if (errDetail) {
      res["ErrDetail"] = boost::any(*errDetail);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ignoreFlag) {
      res["IgnoreFlag"] = boost::any(*ignoreFlag);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (names) {
      res["Names"] = boost::any(*names);
    }
    if (orderNum) {
      res["OrderNum"] = boost::any(*orderNum);
    }
    if (parentObj) {
      res["ParentObj"] = boost::any(*parentObj);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (sub) {
      res["Sub"] = boost::any(*sub);
    }
    if (targetNames) {
      res["TargetNames"] = boost::any(*targetNames);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BootTime") != m.end() && !m["BootTime"].empty()) {
      bootTime = make_shared<string>(boost::any_cast<string>(m["BootTime"]));
    }
    if (m.find("CanSkip") != m.end() && !m["CanSkip"].empty()) {
      canSkip = make_shared<bool>(boost::any_cast<bool>(m["CanSkip"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("DdlSql") != m.end() && !m["DdlSql"].empty()) {
      ddlSql = make_shared<string>(boost::any_cast<string>(m["DdlSql"]));
    }
    if (m.find("DelaySeconds") != m.end() && !m["DelaySeconds"].empty()) {
      delaySeconds = make_shared<long>(boost::any_cast<long>(m["DelaySeconds"]));
    }
    if (m.find("DestSchema") != m.end() && !m["DestSchema"].empty()) {
      destSchema = make_shared<string>(boost::any_cast<string>(m["DestSchema"]));
    }
    if (m.find("DiffRow") != m.end() && !m["DiffRow"].empty()) {
      diffRow = make_shared<long>(boost::any_cast<long>(m["DiffRow"]));
    }
    if (m.find("ErrDetail") != m.end() && !m["ErrDetail"].empty()) {
      errDetail = make_shared<string>(boost::any_cast<string>(m["ErrDetail"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IgnoreFlag") != m.end() && !m["IgnoreFlag"].empty()) {
      ignoreFlag = make_shared<string>(boost::any_cast<string>(m["IgnoreFlag"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgressLogs>>(expect1);
      }
    }
    if (m.find("Names") != m.end() && !m["Names"].empty()) {
      names = make_shared<string>(boost::any_cast<string>(m["Names"]));
    }
    if (m.find("OrderNum") != m.end() && !m["OrderNum"].empty()) {
      orderNum = make_shared<long>(boost::any_cast<long>(m["OrderNum"]));
    }
    if (m.find("ParentObj") != m.end() && !m["ParentObj"].empty()) {
      parentObj = make_shared<string>(boost::any_cast<string>(m["ParentObj"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Sub") != m.end() && !m["Sub"].empty()) {
      sub = make_shared<string>(boost::any_cast<string>(m["Sub"]));
    }
    if (m.find("TargetNames") != m.end() && !m["TargetNames"].empty()) {
      targetNames = make_shared<string>(boost::any_cast<string>(m["TargetNames"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress() = default;
};
class DescribePreCheckStatusResponseBodySubDistributedJobStatus : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> errorItem{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress>> jobProgress{};
  shared_ptr<string> state{};
  shared_ptr<long> total{};

  DescribePreCheckStatusResponseBodySubDistributedJobStatus() {}

  explicit DescribePreCheckStatusResponseBodySubDistributedJobStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorItem) {
      res["ErrorItem"] = boost::any(*errorItem);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobProgress) {
      vector<boost::any> temp1;
      for(auto item1:*jobProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobProgress"] = boost::any(temp1);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorItem") != m.end() && !m["ErrorItem"].empty()) {
      errorItem = make_shared<long>(boost::any_cast<long>(m["ErrorItem"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobProgress") != m.end() && !m["JobProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["JobProgress"].type()) {
        vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobProgress = make_shared<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatusJobProgress>>(expect1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBodySubDistributedJobStatus() = default;
};
class DescribePreCheckStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePreCheckStatusResponseBodyAnalysisJobProgress>> analysisJobProgress{};
  shared_ptr<string> code{};
  shared_ptr<long> errorAnalysisItem{};
  shared_ptr<long> errorItem{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatus>> fullNetCheckJobStatus{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodyJobProgress>> jobProgress{};
  shared_ptr<DescribePreCheckStatusResponseBodyNetworkDiagnosisResult> networkDiagnosisResult{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatus>> subDistributedJobStatus{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};
  shared_ptr<long> totalRecordCount{};

  DescribePreCheckStatusResponseBody() {}

  explicit DescribePreCheckStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisJobProgress) {
      vector<boost::any> temp1;
      for(auto item1:*analysisJobProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnalysisJobProgress"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorAnalysisItem) {
      res["ErrorAnalysisItem"] = boost::any(*errorAnalysisItem);
    }
    if (errorItem) {
      res["ErrorItem"] = boost::any(*errorItem);
    }
    if (fullNetCheckJobStatus) {
      vector<boost::any> temp1;
      for(auto item1:*fullNetCheckJobStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FullNetCheckJobStatus"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (jobProgress) {
      vector<boost::any> temp1;
      for(auto item1:*jobProgress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobProgress"] = boost::any(temp1);
    }
    if (networkDiagnosisResult) {
      res["NetworkDiagnosisResult"] = networkDiagnosisResult ? boost::any(networkDiagnosisResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (subDistributedJobStatus) {
      vector<boost::any> temp1;
      for(auto item1:*subDistributedJobStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubDistributedJobStatus"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisJobProgress") != m.end() && !m["AnalysisJobProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["AnalysisJobProgress"].type()) {
        vector<DescribePreCheckStatusResponseBodyAnalysisJobProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnalysisJobProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyAnalysisJobProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        analysisJobProgress = make_shared<vector<DescribePreCheckStatusResponseBodyAnalysisJobProgress>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorAnalysisItem") != m.end() && !m["ErrorAnalysisItem"].empty()) {
      errorAnalysisItem = make_shared<long>(boost::any_cast<long>(m["ErrorAnalysisItem"]));
    }
    if (m.find("ErrorItem") != m.end() && !m["ErrorItem"].empty()) {
      errorItem = make_shared<long>(boost::any_cast<long>(m["ErrorItem"]));
    }
    if (m.find("FullNetCheckJobStatus") != m.end() && !m["FullNetCheckJobStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["FullNetCheckJobStatus"].type()) {
        vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FullNetCheckJobStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyFullNetCheckJobStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fullNetCheckJobStatus = make_shared<vector<DescribePreCheckStatusResponseBodyFullNetCheckJobStatus>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("JobProgress") != m.end() && !m["JobProgress"].empty()) {
      if (typeid(vector<boost::any>) == m["JobProgress"].type()) {
        vector<DescribePreCheckStatusResponseBodyJobProgress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobProgress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodyJobProgress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobProgress = make_shared<vector<DescribePreCheckStatusResponseBodyJobProgress>>(expect1);
      }
    }
    if (m.find("NetworkDiagnosisResult") != m.end() && !m["NetworkDiagnosisResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkDiagnosisResult"].type()) {
        DescribePreCheckStatusResponseBodyNetworkDiagnosisResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkDiagnosisResult"]));
        networkDiagnosisResult = make_shared<DescribePreCheckStatusResponseBodyNetworkDiagnosisResult>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SubDistributedJobStatus") != m.end() && !m["SubDistributedJobStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["SubDistributedJobStatus"].type()) {
        vector<DescribePreCheckStatusResponseBodySubDistributedJobStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubDistributedJobStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePreCheckStatusResponseBodySubDistributedJobStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subDistributedJobStatus = make_shared<vector<DescribePreCheckStatusResponseBodySubDistributedJobStatus>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribePreCheckStatusResponseBody() = default;
};
class DescribePreCheckStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePreCheckStatusResponseBody> body{};

  DescribePreCheckStatusResponse() {}

  explicit DescribePreCheckStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePreCheckStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePreCheckStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePreCheckStatusResponse() = default;
};
class DescribeSubscriptionInstanceAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  DescribeSubscriptionInstanceAlertRequest() {}

  explicit DescribeSubscriptionInstanceAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceAlertRequest() = default;
};
class DescribeSubscriptionInstanceAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subscriptionInstanceID{};
  shared_ptr<string> subscriptionInstanceName{};
  shared_ptr<string> success{};

  DescribeSubscriptionInstanceAlertResponseBody() {}

  explicit DescribeSubscriptionInstanceAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscriptionInstanceID) {
      res["SubscriptionInstanceID"] = boost::any(*subscriptionInstanceID);
    }
    if (subscriptionInstanceName) {
      res["SubscriptionInstanceName"] = boost::any(*subscriptionInstanceName);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscriptionInstanceID") != m.end() && !m["SubscriptionInstanceID"].empty()) {
      subscriptionInstanceID = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceID"]));
    }
    if (m.find("SubscriptionInstanceName") != m.end() && !m["SubscriptionInstanceName"].empty()) {
      subscriptionInstanceName = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceName"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceAlertResponseBody() = default;
};
class DescribeSubscriptionInstanceAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubscriptionInstanceAlertResponseBody> body{};

  DescribeSubscriptionInstanceAlertResponse() {}

  explicit DescribeSubscriptionInstanceAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubscriptionInstanceAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubscriptionInstanceAlertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstanceAlertResponse() = default;
};
class DescribeSubscriptionInstanceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  DescribeSubscriptionInstanceStatusRequest() {}

  explicit DescribeSubscriptionInstanceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusRequest() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};

  DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> DDL{};
  shared_ptr<bool> DML{};

  DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDL) {
      res["DDL"] = boost::any(*DDL);
    }
    if (DML) {
      res["DML"] = boost::any(*DML);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDL") != m.end() && !m["DDL"].empty()) {
      DDL = make_shared<bool>(boost::any_cast<bool>(m["DDL"]));
    }
    if (m.find("DML") != m.end() && !m["DML"].empty()) {
      DML = make_shared<bool>(boost::any_cast<bool>(m["DML"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> VPCHost{};

  DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (VPCHost) {
      res["VPCHost"] = boost::any(*VPCHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VPCHost") != m.end() && !m["VPCHost"].empty()) {
      VPCHost = make_shared<string>(boost::any_cast<string>(m["VPCHost"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> table{};

  DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Table"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Table"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      table = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList> tableList{};
  shared_ptr<string> wholeDatabase{};

  DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableList) {
      res["TableList"] = tableList ? boost::any(tableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wholeDatabase) {
      res["WholeDatabase"] = boost::any(*wholeDatabase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableList"].type()) {
        DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableList"]));
        tableList = make_shared<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObjectTableList>(model1);
      }
    }
    if (m.find("WholeDatabase") != m.end() && !m["WholeDatabase"].empty()) {
      wholeDatabase = make_shared<string>(boost::any_cast<string>(m["WholeDatabase"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject() = default;
};
class DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject>> synchronousObject{};

  DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject() {}

  explicit DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (synchronousObject) {
      vector<boost::any> temp1;
      for(auto item1:*synchronousObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronousObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SynchronousObject") != m.end() && !m["SynchronousObject"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronousObject"].type()) {
        vector<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronousObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronousObject = make_shared<vector<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObjectSynchronousObject>>(expect1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject() = default;
};
class DescribeSubscriptionInstanceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> payType{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost> subscriptionHost{};
  shared_ptr<string> subscriptionInstanceID{};
  shared_ptr<string> subscriptionInstanceName{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject> subscriptionObject{};
  shared_ptr<string> success{};
  shared_ptr<string> taskId{};

  DescribeSubscriptionInstanceStatusResponseBody() {}

  explicit DescribeSubscriptionInstanceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionInstanceID) {
      res["SubscriptionInstanceID"] = boost::any(*subscriptionInstanceID);
    }
    if (subscriptionInstanceName) {
      res["SubscriptionInstanceName"] = boost::any(*subscriptionInstanceName);
    }
    if (subscriptionObject) {
      res["SubscriptionObject"] = subscriptionObject ? boost::any(subscriptionObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeSubscriptionInstanceStatusResponseBodySourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeSubscriptionInstanceStatusResponseBodySubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeSubscriptionInstanceStatusResponseBodySubscriptionHost>(model1);
      }
    }
    if (m.find("SubscriptionInstanceID") != m.end() && !m["SubscriptionInstanceID"].empty()) {
      subscriptionInstanceID = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceID"]));
    }
    if (m.find("SubscriptionInstanceName") != m.end() && !m["SubscriptionInstanceName"].empty()) {
      subscriptionInstanceName = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceName"]));
    }
    if (m.find("SubscriptionObject") != m.end() && !m["SubscriptionObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionObject"].type()) {
        DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionObject"]));
        subscriptionObject = make_shared<DescribeSubscriptionInstanceStatusResponseBodySubscriptionObject>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponseBody() = default;
};
class DescribeSubscriptionInstanceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubscriptionInstanceStatusResponseBody> body{};

  DescribeSubscriptionInstanceStatusResponse() {}

  explicit DescribeSubscriptionInstanceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubscriptionInstanceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubscriptionInstanceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstanceStatusResponse() = default;
};
class DescribeSubscriptionInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSubscriptionInstancesRequestTag() {}

  explicit DescribeSubscriptionInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesRequestTag() = default;
};
class DescribeSubscriptionInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceName{};
  shared_ptr<vector<DescribeSubscriptionInstancesRequestTag>> tag{};

  DescribeSubscriptionInstancesRequest() {}

  explicit DescribeSubscriptionInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceName) {
      res["SubscriptionInstanceName"] = boost::any(*subscriptionInstanceName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceName") != m.end() && !m["SubscriptionInstanceName"].empty()) {
      subscriptionInstanceName = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSubscriptionInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSubscriptionInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesRequest() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> instanceID{};
  shared_ptr<string> instanceType{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceID) {
      res["InstanceID"] = boost::any(*instanceID);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceID") != m.end() && !m["InstanceID"].empty()) {
      instanceID = make_shared<string>(boost::any_cast<string>(m["InstanceID"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType : public Darabonba::Model {
public:
  shared_ptr<bool> DDL{};
  shared_ptr<bool> DML{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDL) {
      res["DDL"] = boost::any(*DDL);
    }
    if (DML) {
      res["DML"] = boost::any(*DML);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDL") != m.end() && !m["DDL"].empty()) {
      DDL = make_shared<bool>(boost::any_cast<bool>(m["DDL"]));
    }
    if (m.find("DML") != m.end() && !m["DML"].empty()) {
      DML = make_shared<bool>(boost::any_cast<bool>(m["DML"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost : public Darabonba::Model {
public:
  shared_ptr<string> privateHost{};
  shared_ptr<string> publicHost{};
  shared_ptr<string> VPCHost{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateHost) {
      res["PrivateHost"] = boost::any(*privateHost);
    }
    if (publicHost) {
      res["PublicHost"] = boost::any(*publicHost);
    }
    if (VPCHost) {
      res["VPCHost"] = boost::any(*VPCHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateHost") != m.end() && !m["PrivateHost"].empty()) {
      privateHost = make_shared<string>(boost::any_cast<string>(m["PrivateHost"]));
    }
    if (m.find("PublicHost") != m.end() && !m["PublicHost"].empty()) {
      publicHost = make_shared<string>(boost::any_cast<string>(m["PublicHost"]));
    }
    if (m.find("VPCHost") != m.end() && !m["VPCHost"].empty()) {
      VPCHost = make_shared<string>(boost::any_cast<string>(m["VPCHost"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> table{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Table"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Table"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      table = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList> tableList{};
  shared_ptr<string> wholeDatabase{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableList) {
      res["TableList"] = tableList ? boost::any(tableList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wholeDatabase) {
      res["WholeDatabase"] = boost::any(*wholeDatabase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableList"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableList"]));
        tableList = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObjectTableList>(model1);
      }
    }
    if (m.find("WholeDatabase") != m.end() && !m["WholeDatabase"].empty()) {
      wholeDatabase = make_shared<string>(boost::any_cast<string>(m["WholeDatabase"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject>> synchronousObject{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (synchronousObject) {
      vector<boost::any> temp1;
      for(auto item1:*synchronousObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronousObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SynchronousObject") != m.end() && !m["SynchronousObject"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronousObject"].type()) {
        vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronousObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronousObject = make_shared<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObjectSynchronousObject>>(expect1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag>> tag{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance : public Darabonba::Model {
public:
  shared_ptr<string> beginTimestamp{};
  shared_ptr<string> consumptionCheckpoint{};
  shared_ptr<string> consumptionClient{};
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceCreateTime{};
  shared_ptr<string> jobCreateTime{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<string> subscribeTopic{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType> subscriptionDataType{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost> subscriptionHost{};
  shared_ptr<string> subscriptionInstanceID{};
  shared_ptr<string> subscriptionInstanceName{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject> subscriptionObject{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags> tags{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (consumptionCheckpoint) {
      res["ConsumptionCheckpoint"] = boost::any(*consumptionCheckpoint);
    }
    if (consumptionClient) {
      res["ConsumptionClient"] = boost::any(*consumptionClient);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceCreateTime) {
      res["InstanceCreateTime"] = boost::any(*instanceCreateTime);
    }
    if (jobCreateTime) {
      res["JobCreateTime"] = boost::any(*jobCreateTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subscribeTopic) {
      res["SubscribeTopic"] = boost::any(*subscribeTopic);
    }
    if (subscriptionDataType) {
      res["SubscriptionDataType"] = subscriptionDataType ? boost::any(subscriptionDataType->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionHost) {
      res["SubscriptionHost"] = subscriptionHost ? boost::any(subscriptionHost->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subscriptionInstanceID) {
      res["SubscriptionInstanceID"] = boost::any(*subscriptionInstanceID);
    }
    if (subscriptionInstanceName) {
      res["SubscriptionInstanceName"] = boost::any(*subscriptionInstanceName);
    }
    if (subscriptionObject) {
      res["SubscriptionObject"] = subscriptionObject ? boost::any(subscriptionObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<string>(boost::any_cast<string>(m["BeginTimestamp"]));
    }
    if (m.find("ConsumptionCheckpoint") != m.end() && !m["ConsumptionCheckpoint"].empty()) {
      consumptionCheckpoint = make_shared<string>(boost::any_cast<string>(m["ConsumptionCheckpoint"]));
    }
    if (m.find("ConsumptionClient") != m.end() && !m["ConsumptionClient"].empty()) {
      consumptionClient = make_shared<string>(boost::any_cast<string>(m["ConsumptionClient"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceCreateTime") != m.end() && !m["InstanceCreateTime"].empty()) {
      instanceCreateTime = make_shared<string>(boost::any_cast<string>(m["InstanceCreateTime"]));
    }
    if (m.find("JobCreateTime") != m.end() && !m["JobCreateTime"].empty()) {
      jobCreateTime = make_shared<string>(boost::any_cast<string>(m["JobCreateTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubscribeTopic") != m.end() && !m["SubscribeTopic"].empty()) {
      subscribeTopic = make_shared<string>(boost::any_cast<string>(m["SubscribeTopic"]));
    }
    if (m.find("SubscriptionDataType") != m.end() && !m["SubscriptionDataType"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionDataType"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionDataType"]));
        subscriptionDataType = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionDataType>(model1);
      }
    }
    if (m.find("SubscriptionHost") != m.end() && !m["SubscriptionHost"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionHost"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionHost"]));
        subscriptionHost = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionHost>(model1);
      }
    }
    if (m.find("SubscriptionInstanceID") != m.end() && !m["SubscriptionInstanceID"].empty()) {
      subscriptionInstanceID = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceID"]));
    }
    if (m.find("SubscriptionInstanceName") != m.end() && !m["SubscriptionInstanceName"].empty()) {
      subscriptionInstanceName = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceName"]));
    }
    if (m.find("SubscriptionObject") != m.end() && !m["SubscriptionObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionObject"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionObject"]));
        subscriptionObject = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceSubscriptionObject>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstanceTags>(model1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance() = default;
};
class DescribeSubscriptionInstancesResponseBodySubscriptionInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance>> subscriptionInstance{};

  DescribeSubscriptionInstancesResponseBodySubscriptionInstances() {}

  explicit DescribeSubscriptionInstancesResponseBodySubscriptionInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionInstance) {
      vector<boost::any> temp1;
      for(auto item1:*subscriptionInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubscriptionInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubscriptionInstance") != m.end() && !m["SubscriptionInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["SubscriptionInstance"].type()) {
        vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubscriptionInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscriptionInstance = make_shared<vector<DescribeSubscriptionInstancesResponseBodySubscriptionInstancesSubscriptionInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBodySubscriptionInstances() = default;
};
class DescribeSubscriptionInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSubscriptionInstancesResponseBodySubscriptionInstances> subscriptionInstances{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  DescribeSubscriptionInstancesResponseBody() {}

  explicit DescribeSubscriptionInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscriptionInstances) {
      res["SubscriptionInstances"] = subscriptionInstances ? boost::any(subscriptionInstances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscriptionInstances") != m.end() && !m["SubscriptionInstances"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubscriptionInstances"].type()) {
        DescribeSubscriptionInstancesResponseBodySubscriptionInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubscriptionInstances"]));
        subscriptionInstances = make_shared<DescribeSubscriptionInstancesResponseBodySubscriptionInstances>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeSubscriptionInstancesResponseBody() = default;
};
class DescribeSubscriptionInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubscriptionInstancesResponseBody> body{};

  DescribeSubscriptionInstancesResponse() {}

  explicit DescribeSubscriptionInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubscriptionInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubscriptionInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubscriptionInstancesResponse() = default;
};
class DescribeSubscriptionMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sid{};
  shared_ptr<map<string, boost::any>> subMigrationJobIds{};
  shared_ptr<map<string, boost::any>> topics{};

  DescribeSubscriptionMetaRequest() {}

  explicit DescribeSubscriptionMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (subMigrationJobIds) {
      res["SubMigrationJobIds"] = boost::any(*subMigrationJobIds);
    }
    if (topics) {
      res["Topics"] = boost::any(*topics);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SubMigrationJobIds") != m.end() && !m["SubMigrationJobIds"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubMigrationJobIds"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subMigrationJobIds = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Topics"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      topics = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeSubscriptionMetaRequest() = default;
};
class DescribeSubscriptionMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sid{};
  shared_ptr<string> subMigrationJobIdsShrink{};
  shared_ptr<string> topicsShrink{};

  DescribeSubscriptionMetaShrinkRequest() {}

  explicit DescribeSubscriptionMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (subMigrationJobIdsShrink) {
      res["SubMigrationJobIds"] = boost::any(*subMigrationJobIdsShrink);
    }
    if (topicsShrink) {
      res["Topics"] = boost::any(*topicsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("SubMigrationJobIds") != m.end() && !m["SubMigrationJobIds"].empty()) {
      subMigrationJobIdsShrink = make_shared<string>(boost::any_cast<string>(m["SubMigrationJobIds"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      topicsShrink = make_shared<string>(boost::any_cast<string>(m["Topics"]));
    }
  }


  virtual ~DescribeSubscriptionMetaShrinkRequest() = default;
};
class DescribeSubscriptionMetaResponseBodySubscriptionMetaList : public Darabonba::Model {
public:
  shared_ptr<long> checkpoint{};
  shared_ptr<string> DBList{};
  shared_ptr<string> DProxyUrl{};
  shared_ptr<string> sid{};
  shared_ptr<string> topic{};

  DescribeSubscriptionMetaResponseBodySubscriptionMetaList() {}

  explicit DescribeSubscriptionMetaResponseBodySubscriptionMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (DBList) {
      res["DBList"] = boost::any(*DBList);
    }
    if (DProxyUrl) {
      res["DProxyUrl"] = boost::any(*DProxyUrl);
    }
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<long>(boost::any_cast<long>(m["Checkpoint"]));
    }
    if (m.find("DBList") != m.end() && !m["DBList"].empty()) {
      DBList = make_shared<string>(boost::any_cast<string>(m["DBList"]));
    }
    if (m.find("DProxyUrl") != m.end() && !m["DProxyUrl"].empty()) {
      DProxyUrl = make_shared<string>(boost::any_cast<string>(m["DProxyUrl"]));
    }
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~DescribeSubscriptionMetaResponseBodySubscriptionMetaList() = default;
};
class DescribeSubscriptionMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSubscriptionMetaResponseBodySubscriptionMetaList>> subscriptionMetaList{};
  shared_ptr<string> success{};

  DescribeSubscriptionMetaResponseBody() {}

  explicit DescribeSubscriptionMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscriptionMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*subscriptionMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubscriptionMetaList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubscriptionMetaList") != m.end() && !m["SubscriptionMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubscriptionMetaList"].type()) {
        vector<DescribeSubscriptionMetaResponseBodySubscriptionMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubscriptionMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSubscriptionMetaResponseBodySubscriptionMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscriptionMetaList = make_shared<vector<DescribeSubscriptionMetaResponseBodySubscriptionMetaList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSubscriptionMetaResponseBody() = default;
};
class DescribeSubscriptionMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubscriptionMetaResponseBody> body{};

  DescribeSubscriptionMetaResponse() {}

  explicit DescribeSubscriptionMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubscriptionMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubscriptionMetaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubscriptionMetaResponse() = default;
};
class DescribeSynchronizationJobAlertRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  DescribeSynchronizationJobAlertRequest() {}

  explicit DescribeSynchronizationJobAlertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DescribeSynchronizationJobAlertRequest() = default;
};
class DescribeSynchronizationJobAlertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> delayAlertPhone{};
  shared_ptr<string> delayAlertStatus{};
  shared_ptr<string> delayOverSeconds{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorAlertPhone{};
  shared_ptr<string> errorAlertStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> synchronizationJobName{};

  DescribeSynchronizationJobAlertResponseBody() {}

  explicit DescribeSynchronizationJobAlertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delayAlertPhone) {
      res["DelayAlertPhone"] = boost::any(*delayAlertPhone);
    }
    if (delayAlertStatus) {
      res["DelayAlertStatus"] = boost::any(*delayAlertStatus);
    }
    if (delayOverSeconds) {
      res["DelayOverSeconds"] = boost::any(*delayOverSeconds);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorAlertPhone) {
      res["ErrorAlertPhone"] = boost::any(*errorAlertPhone);
    }
    if (errorAlertStatus) {
      res["ErrorAlertStatus"] = boost::any(*errorAlertStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationJobName) {
      res["SynchronizationJobName"] = boost::any(*synchronizationJobName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DelayAlertPhone") != m.end() && !m["DelayAlertPhone"].empty()) {
      delayAlertPhone = make_shared<string>(boost::any_cast<string>(m["DelayAlertPhone"]));
    }
    if (m.find("DelayAlertStatus") != m.end() && !m["DelayAlertStatus"].empty()) {
      delayAlertStatus = make_shared<string>(boost::any_cast<string>(m["DelayAlertStatus"]));
    }
    if (m.find("DelayOverSeconds") != m.end() && !m["DelayOverSeconds"].empty()) {
      delayOverSeconds = make_shared<string>(boost::any_cast<string>(m["DelayOverSeconds"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorAlertPhone") != m.end() && !m["ErrorAlertPhone"].empty()) {
      errorAlertPhone = make_shared<string>(boost::any_cast<string>(m["ErrorAlertPhone"]));
    }
    if (m.find("ErrorAlertStatus") != m.end() && !m["ErrorAlertStatus"].empty()) {
      errorAlertStatus = make_shared<string>(boost::any_cast<string>(m["ErrorAlertStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationJobName") != m.end() && !m["SynchronizationJobName"].empty()) {
      synchronizationJobName = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobName"]));
    }
  }


  virtual ~DescribeSynchronizationJobAlertResponseBody() = default;
};
class DescribeSynchronizationJobAlertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationJobAlertResponseBody> body{};

  DescribeSynchronizationJobAlertResponse() {}

  explicit DescribeSynchronizationJobAlertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationJobAlertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationJobAlertResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobAlertResponse() = default;
};
class DescribeSynchronizationJobReplicatorCompareRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  DescribeSynchronizationJobReplicatorCompareRequest() {}

  explicit DescribeSynchronizationJobReplicatorCompareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DescribeSynchronizationJobReplicatorCompareRequest() = default;
};
class DescribeSynchronizationJobReplicatorCompareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<bool> synchronizationReplicatorCompareEnable{};

  DescribeSynchronizationJobReplicatorCompareResponseBody() {}

  explicit DescribeSynchronizationJobReplicatorCompareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationReplicatorCompareEnable) {
      res["SynchronizationReplicatorCompareEnable"] = boost::any(*synchronizationReplicatorCompareEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SynchronizationReplicatorCompareEnable") != m.end() && !m["SynchronizationReplicatorCompareEnable"].empty()) {
      synchronizationReplicatorCompareEnable = make_shared<bool>(boost::any_cast<bool>(m["SynchronizationReplicatorCompareEnable"]));
    }
  }


  virtual ~DescribeSynchronizationJobReplicatorCompareResponseBody() = default;
};
class DescribeSynchronizationJobReplicatorCompareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationJobReplicatorCompareResponseBody> body{};

  DescribeSynchronizationJobReplicatorCompareResponse() {}

  explicit DescribeSynchronizationJobReplicatorCompareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationJobReplicatorCompareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationJobReplicatorCompareResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobReplicatorCompareResponse() = default;
};
class DescribeSynchronizationJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  DescribeSynchronizationJobStatusRequest() {}

  explicit DescribeSynchronizationJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusRequest() = default;
};
class DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus() {}

  explicit DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus() = default;
};
class DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> delay{};
  shared_ptr<long> delayMillis{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus() {}

  explicit DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (delayMillis) {
      res["DelayMillis"] = boost::any(*delayMillis);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("DelayMillis") != m.end() && !m["DelayMillis"].empty()) {
      delayMillis = make_shared<long>(boost::any_cast<long>(m["DelayMillis"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus() = default;
};
class DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint() {}

  explicit DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint() = default;
};
class DescribeSynchronizationJobStatusResponseBodyPerformance : public Darabonba::Model {
public:
  shared_ptr<string> FLOW{};
  shared_ptr<string> RPS{};

  DescribeSynchronizationJobStatusResponseBodyPerformance() {}

  explicit DescribeSynchronizationJobStatusResponseBodyPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FLOW) {
      res["FLOW"] = boost::any(*FLOW);
    }
    if (RPS) {
      res["RPS"] = boost::any(*RPS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FLOW") != m.end() && !m["FLOW"].empty()) {
      FLOW = make_shared<string>(boost::any_cast<string>(m["FLOW"]));
    }
    if (m.find("RPS") != m.end() && !m["RPS"].empty()) {
      RPS = make_shared<string>(boost::any_cast<string>(m["RPS"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyPerformance() = default;
};
class DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> itemName{};
  shared_ptr<string> repairMethod{};

  DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail() {}

  explicit DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail() = default;
};
class DescribeSynchronizationJobStatusResponseBodyPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail>> detail{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobStatusResponseBodyPrecheckStatus() {}

  explicit DescribeSynchronizationJobStatusResponseBodyPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeSynchronizationJobStatusResponseBodyPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyPrecheckStatus() = default;
};
class DescribeSynchronizationJobStatusResponseBodySourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeSynchronizationJobStatusResponseBodySourceEndpoint() {}

  explicit DescribeSynchronizationJobStatusResponseBodySourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodySourceEndpoint() = default;
};
class DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus() {}

  explicit DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus() = default;
};
class DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes() {}

  explicit DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes() = default;
};
class DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes() {}

  explicit DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes() = default;
};
class DescribeSynchronizationJobStatusResponseBodySynchronizationObjects : public Darabonba::Model {
public:
  shared_ptr<string> newSchemaName{};
  shared_ptr<string> schemaName{};
  shared_ptr<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes>> tableExcludes{};
  shared_ptr<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes>> tableIncludes{};

  DescribeSynchronizationJobStatusResponseBodySynchronizationObjects() {}

  explicit DescribeSynchronizationJobStatusResponseBodySynchronizationObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newSchemaName) {
      res["NewSchemaName"] = boost::any(*newSchemaName);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableExcludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableExcludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableExcludes"] = boost::any(temp1);
    }
    if (tableIncludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableIncludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableIncludes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewSchemaName") != m.end() && !m["NewSchemaName"].empty()) {
      newSchemaName = make_shared<string>(boost::any_cast<string>(m["NewSchemaName"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableExcludes") != m.end() && !m["TableExcludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableExcludes"].type()) {
        vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableExcludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableExcludes = make_shared<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableExcludes>>(expect1);
      }
    }
    if (m.find("TableIncludes") != m.end() && !m["TableIncludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableIncludes"].type()) {
        vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableIncludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableIncludes = make_shared<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjectsTableIncludes>>(expect1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBodySynchronizationObjects() = default;
};
class DescribeSynchronizationJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> dataInitialization{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> delay{};
  shared_ptr<long> delayMillis{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyPerformance> performance{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyPrecheckStatus> precheckStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodySourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<string> structureInitialization{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> success{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobClass{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> synchronizationJobName{};
  shared_ptr<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjects>> synchronizationObjects{};
  shared_ptr<string> taskId{};

  DescribeSynchronizationJobStatusResponseBody() {}

  explicit DescribeSynchronizationJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (delayMillis) {
      res["DelayMillis"] = boost::any(*delayMillis);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobClass) {
      res["SynchronizationJobClass"] = boost::any(*synchronizationJobClass);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationJobName) {
      res["SynchronizationJobName"] = boost::any(*synchronizationJobName);
    }
    if (synchronizationObjects) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationObjects"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<string>(boost::any_cast<string>(m["DataInitialization"]));
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeSynchronizationJobStatusResponseBodyDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeSynchronizationJobStatusResponseBodyDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("DelayMillis") != m.end() && !m["DelayMillis"].empty()) {
      delayMillis = make_shared<long>(boost::any_cast<long>(m["DelayMillis"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeSynchronizationJobStatusResponseBodyDestinationEndpoint>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeSynchronizationJobStatusResponseBodyPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeSynchronizationJobStatusResponseBodyPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeSynchronizationJobStatusResponseBodyPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeSynchronizationJobStatusResponseBodyPrecheckStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeSynchronizationJobStatusResponseBodySourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeSynchronizationJobStatusResponseBodySourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<string>(boost::any_cast<string>(m["StructureInitialization"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeSynchronizationJobStatusResponseBodyStructureInitializationStatus>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobClass") != m.end() && !m["SynchronizationJobClass"].empty()) {
      synchronizationJobClass = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobClass"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationJobName") != m.end() && !m["SynchronizationJobName"].empty()) {
      synchronizationJobName = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobName"]));
    }
    if (m.find("SynchronizationObjects") != m.end() && !m["SynchronizationObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationObjects"].type()) {
        vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusResponseBodySynchronizationObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationObjects = make_shared<vector<DescribeSynchronizationJobStatusResponseBodySynchronizationObjects>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponseBody() = default;
};
class DescribeSynchronizationJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationJobStatusResponseBody> body{};

  DescribeSynchronizationJobStatusResponse() {}

  explicit DescribeSynchronizationJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobStatusResponse() = default;
};
class DescribeSynchronizationJobStatusListRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationJobIdListJsonStr{};

  DescribeSynchronizationJobStatusListRequest() {}

  explicit DescribeSynchronizationJobStatusListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationJobIdListJsonStr) {
      res["SynchronizationJobIdListJsonStr"] = boost::any(*synchronizationJobIdListJsonStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationJobIdListJsonStr") != m.end() && !m["SynchronizationJobIdListJsonStr"].empty()) {
      synchronizationJobIdListJsonStr = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobIdListJsonStr"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusListRequest() = default;
};
class DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<string> status{};
  shared_ptr<string> synchronizationDirection{};

  DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList() {}

  explicit DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList() = default;
};
class DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList>> synchronizationDirectionInfoList{};
  shared_ptr<string> synchronizationJobId{};

  DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList() {}

  explicit DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (synchronizationDirectionInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationDirectionInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationDirectionInfoList"] = boost::any(temp1);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SynchronizationDirectionInfoList") != m.end() && !m["SynchronizationDirectionInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationDirectionInfoList"].type()) {
        vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationDirectionInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationDirectionInfoList = make_shared<vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusListSynchronizationDirectionInfoList>>(expect1);
      }
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList() = default;
};
class DescribeSynchronizationJobStatusListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList>> synchronizationJobListStatusList{};
  shared_ptr<long> totalRecordCount{};

  DescribeSynchronizationJobStatusListResponseBody() {}

  explicit DescribeSynchronizationJobStatusListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (synchronizationJobListStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationJobListStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationJobListStatusList"] = boost::any(temp1);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SynchronizationJobListStatusList") != m.end() && !m["SynchronizationJobListStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationJobListStatusList"].type()) {
        vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationJobListStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationJobListStatusList = make_shared<vector<DescribeSynchronizationJobStatusListResponseBodySynchronizationJobListStatusList>>(expect1);
      }
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeSynchronizationJobStatusListResponseBody() = default;
};
class DescribeSynchronizationJobStatusListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationJobStatusListResponseBody> body{};

  DescribeSynchronizationJobStatusListResponse() {}

  explicit DescribeSynchronizationJobStatusListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationJobStatusListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationJobStatusListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobStatusListResponse() = default;
};
class DescribeSynchronizationJobsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSynchronizationJobsRequestTag() {}

  explicit DescribeSynchronizationJobsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSynchronizationJobsRequestTag() = default;
};
class DescribeSynchronizationJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationJobName{};
  shared_ptr<vector<DescribeSynchronizationJobsRequestTag>> tag{};

  DescribeSynchronizationJobsRequest() {}

  explicit DescribeSynchronizationJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationJobName) {
      res["SynchronizationJobName"] = boost::any(*synchronizationJobName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationJobName") != m.end() && !m["SynchronizationJobName"].empty()) {
      synchronizationJobName = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeSynchronizationJobsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeSynchronizationJobsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobsRequest() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> delay{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance : public Darabonba::Model {
public:
  shared_ptr<string> FLOW{};
  shared_ptr<string> RPS{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FLOW) {
      res["FLOW"] = boost::any(*FLOW);
    }
    if (RPS) {
      res["RPS"] = boost::any(*RPS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FLOW") != m.end() && !m["FLOW"].empty()) {
      FLOW = make_shared<string>(boost::any_cast<string>(m["FLOW"]));
    }
    if (m.find("RPS") != m.end() && !m["RPS"].empty()) {
      RPS = make_shared<string>(boost::any_cast<string>(m["RPS"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> itemName{};
  shared_ptr<string> repairMethod{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail>> detail{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> engineName{};
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> userName{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (engineName) {
      res["EngineName"] = boost::any(*engineName);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EngineName") != m.end() && !m["EngineName"].empty()) {
      engineName = make_shared<string>(boost::any_cast<string>(m["EngineName"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects : public Darabonba::Model {
public:
  shared_ptr<string> newSchemaName{};
  shared_ptr<string> schemaName{};
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes>> tableExcludes{};
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes>> tableIncludes{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newSchemaName) {
      res["NewSchemaName"] = boost::any(*newSchemaName);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    if (tableExcludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableExcludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableExcludes"] = boost::any(temp1);
    }
    if (tableIncludes) {
      vector<boost::any> temp1;
      for(auto item1:*tableIncludes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableIncludes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewSchemaName") != m.end() && !m["NewSchemaName"].empty()) {
      newSchemaName = make_shared<string>(boost::any_cast<string>(m["NewSchemaName"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
    if (m.find("TableExcludes") != m.end() && !m["TableExcludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableExcludes"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableExcludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableExcludes = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableExcludes>>(expect1);
      }
    }
    if (m.find("TableIncludes") != m.end() && !m["TableIncludes"].empty()) {
      if (typeid(vector<boost::any>) == m["TableIncludes"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableIncludes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableIncludes = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjectsTableIncludes>>(expect1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags() = default;
};
class DescribeSynchronizationJobsResponseBodySynchronizationInstances : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> dataInitialization{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> delay{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint> destinationEndpoint{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceCreateTime{};
  shared_ptr<string> jobCreateTime{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance> performance{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus> precheckStatus{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> status{};
  shared_ptr<string> structureInitialization{};
  shared_ptr<DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobClass{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> synchronizationJobName{};
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects>> synchronizationObjects{};
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags>> tags{};

  DescribeSynchronizationJobsResponseBodySynchronizationInstances() {}

  explicit DescribeSynchronizationJobsResponseBodySynchronizationInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (destinationEndpoint) {
      res["DestinationEndpoint"] = destinationEndpoint ? boost::any(destinationEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceCreateTime) {
      res["InstanceCreateTime"] = boost::any(*instanceCreateTime);
    }
    if (jobCreateTime) {
      res["JobCreateTime"] = boost::any(*jobCreateTime);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (performance) {
      res["Performance"] = performance ? boost::any(performance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobClass) {
      res["SynchronizationJobClass"] = boost::any(*synchronizationJobClass);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationJobName) {
      res["SynchronizationJobName"] = boost::any(*synchronizationJobName);
    }
    if (synchronizationObjects) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationObjects"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<string>(boost::any_cast<string>(m["DataInitialization"]));
    }
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("DestinationEndpoint") != m.end() && !m["DestinationEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationEndpoint"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationEndpoint"]));
        destinationEndpoint = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesDestinationEndpoint>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceCreateTime") != m.end() && !m["InstanceCreateTime"].empty()) {
      instanceCreateTime = make_shared<string>(boost::any_cast<string>(m["InstanceCreateTime"]));
    }
    if (m.find("JobCreateTime") != m.end() && !m["JobCreateTime"].empty()) {
      jobCreateTime = make_shared<string>(boost::any_cast<string>(m["JobCreateTime"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Performance") != m.end() && !m["Performance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Performance"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Performance"]));
        performance = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPerformance>(model1);
      }
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesPrecheckStatus>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSourceEndpoint>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<string>(boost::any_cast<string>(m["StructureInitialization"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeSynchronizationJobsResponseBodySynchronizationInstancesStructureInitializationStatus>(model1);
      }
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobClass") != m.end() && !m["SynchronizationJobClass"].empty()) {
      synchronizationJobClass = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobClass"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationJobName") != m.end() && !m["SynchronizationJobName"].empty()) {
      synchronizationJobName = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobName"]));
    }
    if (m.find("SynchronizationObjects") != m.end() && !m["SynchronizationObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationObjects"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationObjects = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesSynchronizationObjects>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstancesTags>>(expect1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBodySynchronizationInstances() = default;
};
class DescribeSynchronizationJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstances>> synchronizationInstances{};
  shared_ptr<long> totalRecordCount{};

  DescribeSynchronizationJobsResponseBody() {}

  explicit DescribeSynchronizationJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (synchronizationInstances) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationInstances"] = boost::any(temp1);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SynchronizationInstances") != m.end() && !m["SynchronizationInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationInstances"].type()) {
        vector<DescribeSynchronizationJobsResponseBodySynchronizationInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationJobsResponseBodySynchronizationInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationInstances = make_shared<vector<DescribeSynchronizationJobsResponseBodySynchronizationInstances>>(expect1);
      }
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~DescribeSynchronizationJobsResponseBody() = default;
};
class DescribeSynchronizationJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationJobsResponseBody> body{};

  DescribeSynchronizationJobsResponse() {}

  explicit DescribeSynchronizationJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationJobsResponse() = default;
};
class DescribeSynchronizationObjectModifyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeSynchronizationObjectModifyStatusRequest() {}

  explicit DescribeSynchronizationObjectModifyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusRequest() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus : public Darabonba::Model {
public:
  shared_ptr<string> delay{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail : public Darabonba::Model {
public:
  shared_ptr<string> checkStatus{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> itemName{};
  shared_ptr<string> repairMethod{};

  DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStatus) {
      res["CheckStatus"] = boost::any(*checkStatus);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (repairMethod) {
      res["RepairMethod"] = boost::any(*repairMethod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckStatus") != m.end() && !m["CheckStatus"].empty()) {
      checkStatus = make_shared<string>(boost::any_cast<string>(m["CheckStatus"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("RepairMethod") != m.end() && !m["RepairMethod"].empty()) {
      repairMethod = make_shared<string>(boost::any_cast<string>(m["RepairMethod"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail>> detail{};
  shared_ptr<string> percent{};
  shared_ptr<string> status{};

  DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatusDetail>>(expect1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> percent{};
  shared_ptr<string> progress{};
  shared_ptr<string> status{};

  DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus() = default;
};
class DescribeSynchronizationObjectModifyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus> dataInitializationStatus{};
  shared_ptr<DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus> dataSynchronizationStatus{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> errorMessage{};
  shared_ptr<DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus> precheckStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus> structureInitializationStatus{};
  shared_ptr<string> success{};

  DescribeSynchronizationObjectModifyStatusResponseBody() {}

  explicit DescribeSynchronizationObjectModifyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInitializationStatus) {
      res["DataInitializationStatus"] = dataInitializationStatus ? boost::any(dataInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSynchronizationStatus) {
      res["DataSynchronizationStatus"] = dataSynchronizationStatus ? boost::any(dataSynchronizationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (precheckStatus) {
      res["PrecheckStatus"] = precheckStatus ? boost::any(precheckStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureInitializationStatus) {
      res["StructureInitializationStatus"] = structureInitializationStatus ? boost::any(structureInitializationStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInitializationStatus") != m.end() && !m["DataInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataInitializationStatus"].type()) {
        DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataInitializationStatus"]));
        dataInitializationStatus = make_shared<DescribeSynchronizationObjectModifyStatusResponseBodyDataInitializationStatus>(model1);
      }
    }
    if (m.find("DataSynchronizationStatus") != m.end() && !m["DataSynchronizationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSynchronizationStatus"].type()) {
        DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSynchronizationStatus"]));
        dataSynchronizationStatus = make_shared<DescribeSynchronizationObjectModifyStatusResponseBodyDataSynchronizationStatus>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("PrecheckStatus") != m.end() && !m["PrecheckStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrecheckStatus"].type()) {
        DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrecheckStatus"]));
        precheckStatus = make_shared<DescribeSynchronizationObjectModifyStatusResponseBodyPrecheckStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureInitializationStatus") != m.end() && !m["StructureInitializationStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructureInitializationStatus"].type()) {
        DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructureInitializationStatus"]));
        structureInitializationStatus = make_shared<DescribeSynchronizationObjectModifyStatusResponseBodyStructureInitializationStatus>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponseBody() = default;
};
class DescribeSynchronizationObjectModifyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSynchronizationObjectModifyStatusResponseBody> body{};

  DescribeSynchronizationObjectModifyStatusResponse() {}

  explicit DescribeSynchronizationObjectModifyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSynchronizationObjectModifyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSynchronizationObjectModifyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSynchronizationObjectModifyStatusResponse() = default;
};
class DescribeTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  DescribeTagKeysRequest() {}

  explicit DescribeTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagKeysRequest() = default;
};
class DescribeTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> tagKeys{};
  shared_ptr<long> totalCount{};

  DescribeTagKeysResponseBody() {}

  explicit DescribeTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTagKeysResponseBody() = default;
};
class DescribeTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagKeysResponseBody> body{};

  DescribeTagKeysResponse() {}

  explicit DescribeTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagKeysResponse() = default;
};
class DescribeTagValuesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> key{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  DescribeTagValuesRequest() {}

  explicit DescribeTagValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~DescribeTagValuesRequest() = default;
};
class DescribeTagValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> tagValues{};
  shared_ptr<long> totalCount{};

  DescribeTagValuesResponseBody() {}

  explicit DescribeTagValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagValues) {
      res["TagValues"] = boost::any(*tagValues);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValues = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTagValuesResponseBody() = default;
};
class DescribeTagValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagValuesResponseBody> body{};

  DescribeTagValuesResponse() {}

  explicit DescribeTagValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagValuesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagValuesResponse() = default;
};
class InitDtsRdsInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> endpointCenId{};
  shared_ptr<string> endpointInstanceId{};
  shared_ptr<string> endpointInstanceType{};
  shared_ptr<string> endpointRegion{};
  shared_ptr<string> regionId{};

  InitDtsRdsInstanceRequest() {}

  explicit InitDtsRdsInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (endpointCenId) {
      res["EndpointCenId"] = boost::any(*endpointCenId);
    }
    if (endpointInstanceId) {
      res["EndpointInstanceId"] = boost::any(*endpointInstanceId);
    }
    if (endpointInstanceType) {
      res["EndpointInstanceType"] = boost::any(*endpointInstanceType);
    }
    if (endpointRegion) {
      res["EndpointRegion"] = boost::any(*endpointRegion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("EndpointCenId") != m.end() && !m["EndpointCenId"].empty()) {
      endpointCenId = make_shared<string>(boost::any_cast<string>(m["EndpointCenId"]));
    }
    if (m.find("EndpointInstanceId") != m.end() && !m["EndpointInstanceId"].empty()) {
      endpointInstanceId = make_shared<string>(boost::any_cast<string>(m["EndpointInstanceId"]));
    }
    if (m.find("EndpointInstanceType") != m.end() && !m["EndpointInstanceType"].empty()) {
      endpointInstanceType = make_shared<string>(boost::any_cast<string>(m["EndpointInstanceType"]));
    }
    if (m.find("EndpointRegion") != m.end() && !m["EndpointRegion"].empty()) {
      endpointRegion = make_shared<string>(boost::any_cast<string>(m["EndpointRegion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InitDtsRdsInstanceRequest() = default;
};
class InitDtsRdsInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> adminAccount{};
  shared_ptr<string> adminPassword{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  InitDtsRdsInstanceResponseBody() {}

  explicit InitDtsRdsInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminAccount) {
      res["AdminAccount"] = boost::any(*adminAccount);
    }
    if (adminPassword) {
      res["AdminPassword"] = boost::any(*adminPassword);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminAccount") != m.end() && !m["AdminAccount"].empty()) {
      adminAccount = make_shared<string>(boost::any_cast<string>(m["AdminAccount"]));
    }
    if (m.find("AdminPassword") != m.end() && !m["AdminPassword"].empty()) {
      adminPassword = make_shared<string>(boost::any_cast<string>(m["AdminPassword"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~InitDtsRdsInstanceResponseBody() = default;
};
class InitDtsRdsInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitDtsRdsInstanceResponseBody> body{};

  InitDtsRdsInstanceResponse() {}

  explicit InitDtsRdsInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitDtsRdsInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitDtsRdsInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~InitDtsRdsInstanceResponse() = default;
};
class ListDedicatedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> orderColumn{};
  shared_ptr<string> orderDirection{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> params{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};

  ListDedicatedClusterRequest() {}

  explicit ListDedicatedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderColumn) {
      res["OrderColumn"] = boost::any(*orderColumn);
    }
    if (orderDirection) {
      res["OrderDirection"] = boost::any(*orderDirection);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderColumn") != m.end() && !m["OrderColumn"].empty()) {
      orderColumn = make_shared<string>(boost::any_cast<string>(m["OrderColumn"]));
    }
    if (m.find("OrderDirection") != m.end() && !m["OrderDirection"].empty()) {
      orderDirection = make_shared<string>(boost::any_cast<string>(m["OrderDirection"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDedicatedClusterRequest() = default;
};
class ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus : public Darabonba::Model {
public:
  shared_ptr<long> cpuUtilization{};
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dedicatedClusterName{};
  shared_ptr<long> diskUtilization{};
  shared_ptr<string> dtsInstanceID{};
  shared_ptr<long> du{};
  shared_ptr<long> duUtilization{};
  shared_ptr<long> gmtCreated{};
  shared_ptr<long> memUtilization{};
  shared_ptr<long> nodeCount{};
  shared_ptr<long> oversoldDu{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<long> totalCpuCore{};
  shared_ptr<long> totalDiskGBSize{};
  shared_ptr<long> totalMemGBSize{};
  shared_ptr<long> usedCpuCore{};
  shared_ptr<long> usedDiskGBSize{};
  shared_ptr<long> usedDu{};
  shared_ptr<long> usedMemGBSize{};

  ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus() {}

  explicit ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuUtilization) {
      res["CpuUtilization"] = boost::any(*cpuUtilization);
    }
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dedicatedClusterName) {
      res["DedicatedClusterName"] = boost::any(*dedicatedClusterName);
    }
    if (diskUtilization) {
      res["DiskUtilization"] = boost::any(*diskUtilization);
    }
    if (dtsInstanceID) {
      res["DtsInstanceID"] = boost::any(*dtsInstanceID);
    }
    if (du) {
      res["Du"] = boost::any(*du);
    }
    if (duUtilization) {
      res["DuUtilization"] = boost::any(*duUtilization);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (memUtilization) {
      res["MemUtilization"] = boost::any(*memUtilization);
    }
    if (nodeCount) {
      res["NodeCount"] = boost::any(*nodeCount);
    }
    if (oversoldDu) {
      res["OversoldDu"] = boost::any(*oversoldDu);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (totalCpuCore) {
      res["TotalCpuCore"] = boost::any(*totalCpuCore);
    }
    if (totalDiskGBSize) {
      res["TotalDiskGBSize"] = boost::any(*totalDiskGBSize);
    }
    if (totalMemGBSize) {
      res["TotalMemGBSize"] = boost::any(*totalMemGBSize);
    }
    if (usedCpuCore) {
      res["UsedCpuCore"] = boost::any(*usedCpuCore);
    }
    if (usedDiskGBSize) {
      res["UsedDiskGBSize"] = boost::any(*usedDiskGBSize);
    }
    if (usedDu) {
      res["UsedDu"] = boost::any(*usedDu);
    }
    if (usedMemGBSize) {
      res["UsedMemGBSize"] = boost::any(*usedMemGBSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuUtilization") != m.end() && !m["CpuUtilization"].empty()) {
      cpuUtilization = make_shared<long>(boost::any_cast<long>(m["CpuUtilization"]));
    }
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DedicatedClusterName") != m.end() && !m["DedicatedClusterName"].empty()) {
      dedicatedClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterName"]));
    }
    if (m.find("DiskUtilization") != m.end() && !m["DiskUtilization"].empty()) {
      diskUtilization = make_shared<long>(boost::any_cast<long>(m["DiskUtilization"]));
    }
    if (m.find("DtsInstanceID") != m.end() && !m["DtsInstanceID"].empty()) {
      dtsInstanceID = make_shared<string>(boost::any_cast<string>(m["DtsInstanceID"]));
    }
    if (m.find("Du") != m.end() && !m["Du"].empty()) {
      du = make_shared<long>(boost::any_cast<long>(m["Du"]));
    }
    if (m.find("DuUtilization") != m.end() && !m["DuUtilization"].empty()) {
      duUtilization = make_shared<long>(boost::any_cast<long>(m["DuUtilization"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<long>(boost::any_cast<long>(m["GmtCreated"]));
    }
    if (m.find("MemUtilization") != m.end() && !m["MemUtilization"].empty()) {
      memUtilization = make_shared<long>(boost::any_cast<long>(m["MemUtilization"]));
    }
    if (m.find("NodeCount") != m.end() && !m["NodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["NodeCount"]));
    }
    if (m.find("OversoldDu") != m.end() && !m["OversoldDu"].empty()) {
      oversoldDu = make_shared<long>(boost::any_cast<long>(m["OversoldDu"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TotalCpuCore") != m.end() && !m["TotalCpuCore"].empty()) {
      totalCpuCore = make_shared<long>(boost::any_cast<long>(m["TotalCpuCore"]));
    }
    if (m.find("TotalDiskGBSize") != m.end() && !m["TotalDiskGBSize"].empty()) {
      totalDiskGBSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskGBSize"]));
    }
    if (m.find("TotalMemGBSize") != m.end() && !m["TotalMemGBSize"].empty()) {
      totalMemGBSize = make_shared<long>(boost::any_cast<long>(m["TotalMemGBSize"]));
    }
    if (m.find("UsedCpuCore") != m.end() && !m["UsedCpuCore"].empty()) {
      usedCpuCore = make_shared<long>(boost::any_cast<long>(m["UsedCpuCore"]));
    }
    if (m.find("UsedDiskGBSize") != m.end() && !m["UsedDiskGBSize"].empty()) {
      usedDiskGBSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskGBSize"]));
    }
    if (m.find("UsedDu") != m.end() && !m["UsedDu"].empty()) {
      usedDu = make_shared<long>(boost::any_cast<long>(m["UsedDu"]));
    }
    if (m.find("UsedMemGBSize") != m.end() && !m["UsedMemGBSize"].empty()) {
      usedMemGBSize = make_shared<long>(boost::any_cast<long>(m["UsedMemGBSize"]));
    }
  }


  virtual ~ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus() = default;
};
class ListDedicatedClusterResponseBodyDedicatedClusterStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus>> dedicatedClusterStatus{};

  ListDedicatedClusterResponseBodyDedicatedClusterStatusList() {}

  explicit ListDedicatedClusterResponseBodyDedicatedClusterStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterStatus) {
      vector<boost::any> temp1;
      for(auto item1:*dedicatedClusterStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DedicatedClusterStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterStatus") != m.end() && !m["DedicatedClusterStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DedicatedClusterStatus"].type()) {
        vector<ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DedicatedClusterStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dedicatedClusterStatus = make_shared<vector<ListDedicatedClusterResponseBodyDedicatedClusterStatusListDedicatedClusterStatus>>(expect1);
      }
    }
  }


  virtual ~ListDedicatedClusterResponseBodyDedicatedClusterStatusList() = default;
};
class ListDedicatedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDedicatedClusterResponseBodyDedicatedClusterStatusList> dedicatedClusterStatusList{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageRecordCount{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> totalRecordCount{};

  ListDedicatedClusterResponseBody() {}

  explicit ListDedicatedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterStatusList) {
      res["DedicatedClusterStatusList"] = dedicatedClusterStatusList ? boost::any(dedicatedClusterStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageRecordCount) {
      res["PageRecordCount"] = boost::any(*pageRecordCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalRecordCount) {
      res["TotalRecordCount"] = boost::any(*totalRecordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterStatusList") != m.end() && !m["DedicatedClusterStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DedicatedClusterStatusList"].type()) {
        ListDedicatedClusterResponseBodyDedicatedClusterStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DedicatedClusterStatusList"]));
        dedicatedClusterStatusList = make_shared<ListDedicatedClusterResponseBodyDedicatedClusterStatusList>(model1);
      }
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageRecordCount") != m.end() && !m["PageRecordCount"].empty()) {
      pageRecordCount = make_shared<long>(boost::any_cast<long>(m["PageRecordCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalRecordCount") != m.end() && !m["TotalRecordCount"].empty()) {
      totalRecordCount = make_shared<long>(boost::any_cast<long>(m["TotalRecordCount"]));
    }
  }


  virtual ~ListDedicatedClusterResponseBody() = default;
};
class ListDedicatedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDedicatedClusterResponseBody> body{};

  ListDedicatedClusterResponse() {}

  explicit ListDedicatedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDedicatedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDedicatedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ListDedicatedClusterResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyConsumerChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> consumerGroupId{};
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupPassword{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};

  ModifyConsumerChannelRequest() {}

  explicit ModifyConsumerChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerGroupId) {
      res["ConsumerGroupId"] = boost::any(*consumerGroupId);
    }
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupPassword) {
      res["ConsumerGroupPassword"] = boost::any(*consumerGroupPassword);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerGroupId") != m.end() && !m["ConsumerGroupId"].empty()) {
      consumerGroupId = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupId"]));
    }
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupPassword") != m.end() && !m["ConsumerGroupPassword"].empty()) {
      consumerGroupPassword = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupPassword"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyConsumerChannelRequest() = default;
};
class ModifyConsumerChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyConsumerChannelResponseBody() {}

  explicit ModifyConsumerChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyConsumerChannelResponseBody() = default;
};
class ModifyConsumerChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyConsumerChannelResponseBody> body{};

  ModifyConsumerChannelResponse() {}

  explicit ModifyConsumerChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyConsumerChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyConsumerChannelResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyConsumerChannelResponse() = default;
};
class ModifyConsumerGroupPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> consumerGroupID{};
  shared_ptr<string> consumerGroupName{};
  shared_ptr<string> consumerGroupPassword{};
  shared_ptr<string> consumerGroupUserName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};
  shared_ptr<string> consumerGroupNewPassword{};

  ModifyConsumerGroupPasswordRequest() {}

  explicit ModifyConsumerGroupPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (consumerGroupID) {
      res["ConsumerGroupID"] = boost::any(*consumerGroupID);
    }
    if (consumerGroupName) {
      res["ConsumerGroupName"] = boost::any(*consumerGroupName);
    }
    if (consumerGroupPassword) {
      res["ConsumerGroupPassword"] = boost::any(*consumerGroupPassword);
    }
    if (consumerGroupUserName) {
      res["ConsumerGroupUserName"] = boost::any(*consumerGroupUserName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    if (consumerGroupNewPassword) {
      res["consumerGroupNewPassword"] = boost::any(*consumerGroupNewPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ConsumerGroupID") != m.end() && !m["ConsumerGroupID"].empty()) {
      consumerGroupID = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupID"]));
    }
    if (m.find("ConsumerGroupName") != m.end() && !m["ConsumerGroupName"].empty()) {
      consumerGroupName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupName"]));
    }
    if (m.find("ConsumerGroupPassword") != m.end() && !m["ConsumerGroupPassword"].empty()) {
      consumerGroupPassword = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupPassword"]));
    }
    if (m.find("ConsumerGroupUserName") != m.end() && !m["ConsumerGroupUserName"].empty()) {
      consumerGroupUserName = make_shared<string>(boost::any_cast<string>(m["ConsumerGroupUserName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
    if (m.find("consumerGroupNewPassword") != m.end() && !m["consumerGroupNewPassword"].empty()) {
      consumerGroupNewPassword = make_shared<string>(boost::any_cast<string>(m["consumerGroupNewPassword"]));
    }
  }


  virtual ~ModifyConsumerGroupPasswordRequest() = default;
};
class ModifyConsumerGroupPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyConsumerGroupPasswordResponseBody() {}

  explicit ModifyConsumerGroupPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyConsumerGroupPasswordResponseBody() = default;
};
class ModifyConsumerGroupPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyConsumerGroupPasswordResponseBody> body{};

  ModifyConsumerGroupPasswordResponse() {}

  explicit ModifyConsumerGroupPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyConsumerGroupPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyConsumerGroupPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyConsumerGroupPasswordResponse() = default;
};
class ModifyConsumptionTimestampRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> consumptionTimestamp{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  ModifyConsumptionTimestampRequest() {}

  explicit ModifyConsumptionTimestampRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (consumptionTimestamp) {
      res["ConsumptionTimestamp"] = boost::any(*consumptionTimestamp);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ConsumptionTimestamp") != m.end() && !m["ConsumptionTimestamp"].empty()) {
      consumptionTimestamp = make_shared<string>(boost::any_cast<string>(m["ConsumptionTimestamp"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~ModifyConsumptionTimestampRequest() = default;
};
class ModifyConsumptionTimestampResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyConsumptionTimestampResponseBody() {}

  explicit ModifyConsumptionTimestampResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyConsumptionTimestampResponseBody() = default;
};
class ModifyConsumptionTimestampResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyConsumptionTimestampResponseBody> body{};

  ModifyConsumptionTimestampResponse() {}

  explicit ModifyConsumptionTimestampResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyConsumptionTimestampResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyConsumptionTimestampResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyConsumptionTimestampResponse() = default;
};
class ModifyDedicatedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dedicatedClusterName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> oversoldRatio{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  ModifyDedicatedClusterRequest() {}

  explicit ModifyDedicatedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dedicatedClusterName) {
      res["DedicatedClusterName"] = boost::any(*dedicatedClusterName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (oversoldRatio) {
      res["OversoldRatio"] = boost::any(*oversoldRatio);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DedicatedClusterName") != m.end() && !m["DedicatedClusterName"].empty()) {
      dedicatedClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OversoldRatio") != m.end() && !m["OversoldRatio"].empty()) {
      oversoldRatio = make_shared<long>(boost::any_cast<long>(m["OversoldRatio"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDedicatedClusterRequest() = default;
};
class ModifyDedicatedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyDedicatedClusterResponseBody() {}

  explicit ModifyDedicatedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyDedicatedClusterResponseBody() = default;
};
class ModifyDedicatedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDedicatedClusterResponseBody> body{};

  ModifyDedicatedClusterResponse() {}

  explicit ModifyDedicatedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDedicatedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDedicatedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDedicatedClusterResponse() = default;
};
class ModifyDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<map<string, boost::any>> dbList{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> etlOperatorColumnReference{};
  shared_ptr<string> fileOssUrl{};
  shared_ptr<string> filterTableName{};
  shared_ptr<string> modifyTypeEnum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserved{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};

  ModifyDtsJobRequest() {}

  explicit ModifyDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (etlOperatorColumnReference) {
      res["EtlOperatorColumnReference"] = boost::any(*etlOperatorColumnReference);
    }
    if (fileOssUrl) {
      res["FileOssUrl"] = boost::any(*fileOssUrl);
    }
    if (filterTableName) {
      res["FilterTableName"] = boost::any(*filterTableName);
    }
    if (modifyTypeEnum) {
      res["ModifyTypeEnum"] = boost::any(*modifyTypeEnum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DbList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dbList = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EtlOperatorColumnReference") != m.end() && !m["EtlOperatorColumnReference"].empty()) {
      etlOperatorColumnReference = make_shared<string>(boost::any_cast<string>(m["EtlOperatorColumnReference"]));
    }
    if (m.find("FileOssUrl") != m.end() && !m["FileOssUrl"].empty()) {
      fileOssUrl = make_shared<string>(boost::any_cast<string>(m["FileOssUrl"]));
    }
    if (m.find("FilterTableName") != m.end() && !m["FilterTableName"].empty()) {
      filterTableName = make_shared<string>(boost::any_cast<string>(m["FilterTableName"]));
    }
    if (m.find("ModifyTypeEnum") != m.end() && !m["ModifyTypeEnum"].empty()) {
      modifyTypeEnum = make_shared<string>(boost::any_cast<string>(m["ModifyTypeEnum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ModifyDtsJobRequest() = default;
};
class ModifyDtsJobAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<map<string, boost::any>> dbList{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> etlOperatorColumnReference{};
  shared_ptr<Darabonba::Stream> fileOssUrlObject{};
  shared_ptr<string> filterTableName{};
  shared_ptr<string> modifyTypeEnum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserved{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};

  ModifyDtsJobAdvanceRequest() {}

  explicit ModifyDtsJobAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (etlOperatorColumnReference) {
      res["EtlOperatorColumnReference"] = boost::any(*etlOperatorColumnReference);
    }
    if (fileOssUrlObject) {
      res["FileOssUrl"] = boost::any(*fileOssUrlObject);
    }
    if (filterTableName) {
      res["FilterTableName"] = boost::any(*filterTableName);
    }
    if (modifyTypeEnum) {
      res["ModifyTypeEnum"] = boost::any(*modifyTypeEnum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DbList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dbList = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EtlOperatorColumnReference") != m.end() && !m["EtlOperatorColumnReference"].empty()) {
      etlOperatorColumnReference = make_shared<string>(boost::any_cast<string>(m["EtlOperatorColumnReference"]));
    }
    if (m.find("FileOssUrl") != m.end() && !m["FileOssUrl"].empty()) {
      fileOssUrlObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["FileOssUrl"]));
    }
    if (m.find("FilterTableName") != m.end() && !m["FilterTableName"].empty()) {
      filterTableName = make_shared<string>(boost::any_cast<string>(m["FilterTableName"]));
    }
    if (m.find("ModifyTypeEnum") != m.end() && !m["ModifyTypeEnum"].empty()) {
      modifyTypeEnum = make_shared<string>(boost::any_cast<string>(m["ModifyTypeEnum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ModifyDtsJobAdvanceRequest() = default;
};
class ModifyDtsJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dataInitialization{};
  shared_ptr<bool> dataSynchronization{};
  shared_ptr<string> dbListShrink{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> etlOperatorColumnReference{};
  shared_ptr<string> fileOssUrl{};
  shared_ptr<string> filterTableName{};
  shared_ptr<string> modifyTypeEnum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> reserved{};
  shared_ptr<bool> structureInitialization{};
  shared_ptr<string> synchronizationDirection{};

  ModifyDtsJobShrinkRequest() {}

  explicit ModifyDtsJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dataInitialization) {
      res["DataInitialization"] = boost::any(*dataInitialization);
    }
    if (dataSynchronization) {
      res["DataSynchronization"] = boost::any(*dataSynchronization);
    }
    if (dbListShrink) {
      res["DbList"] = boost::any(*dbListShrink);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (etlOperatorColumnReference) {
      res["EtlOperatorColumnReference"] = boost::any(*etlOperatorColumnReference);
    }
    if (fileOssUrl) {
      res["FileOssUrl"] = boost::any(*fileOssUrl);
    }
    if (filterTableName) {
      res["FilterTableName"] = boost::any(*filterTableName);
    }
    if (modifyTypeEnum) {
      res["ModifyTypeEnum"] = boost::any(*modifyTypeEnum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (structureInitialization) {
      res["StructureInitialization"] = boost::any(*structureInitialization);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DataInitialization") != m.end() && !m["DataInitialization"].empty()) {
      dataInitialization = make_shared<bool>(boost::any_cast<bool>(m["DataInitialization"]));
    }
    if (m.find("DataSynchronization") != m.end() && !m["DataSynchronization"].empty()) {
      dataSynchronization = make_shared<bool>(boost::any_cast<bool>(m["DataSynchronization"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      dbListShrink = make_shared<string>(boost::any_cast<string>(m["DbList"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EtlOperatorColumnReference") != m.end() && !m["EtlOperatorColumnReference"].empty()) {
      etlOperatorColumnReference = make_shared<string>(boost::any_cast<string>(m["EtlOperatorColumnReference"]));
    }
    if (m.find("FileOssUrl") != m.end() && !m["FileOssUrl"].empty()) {
      fileOssUrl = make_shared<string>(boost::any_cast<string>(m["FileOssUrl"]));
    }
    if (m.find("FilterTableName") != m.end() && !m["FilterTableName"].empty()) {
      filterTableName = make_shared<string>(boost::any_cast<string>(m["FilterTableName"]));
    }
    if (m.find("ModifyTypeEnum") != m.end() && !m["ModifyTypeEnum"].empty()) {
      modifyTypeEnum = make_shared<string>(boost::any_cast<string>(m["ModifyTypeEnum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<string>(boost::any_cast<string>(m["Reserved"]));
    }
    if (m.find("StructureInitialization") != m.end() && !m["StructureInitialization"].empty()) {
      structureInitialization = make_shared<bool>(boost::any_cast<bool>(m["StructureInitialization"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ModifyDtsJobShrinkRequest() = default;
};
class ModifyDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> errCode{};
  shared_ptr<bool> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<bool> success{};

  ModifyDtsJobResponseBody() {}

  explicit ModifyDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<bool>(boost::any_cast<bool>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobResponseBody() = default;
};
class ModifyDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobResponseBody> body{};

  ModifyDtsJobResponse() {}

  explicit ModifyDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobResponse() = default;
};
class ModifyDtsJobConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> parameters{};
  shared_ptr<string> regionId{};

  ModifyDtsJobConfigRequest() {}

  explicit ModifyDtsJobConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDtsJobConfigRequest() = default;
};
class ModifyDtsJobConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDtsJobConfigResponseBody() {}

  explicit ModifyDtsJobConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDtsJobConfigResponseBody() = default;
};
class ModifyDtsJobConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobConfigResponseBody> body{};

  ModifyDtsJobConfigResponse() {}

  explicit ModifyDtsJobConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobConfigResponse() = default;
};
class ModifyDtsJobDedicatedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dtsJobIds{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  ModifyDtsJobDedicatedClusterRequest() {}

  explicit ModifyDtsJobDedicatedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dtsJobIds) {
      res["DtsJobIds"] = boost::any(*dtsJobIds);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DtsJobIds") != m.end() && !m["DtsJobIds"].empty()) {
      dtsJobIds = make_shared<string>(boost::any_cast<string>(m["DtsJobIds"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDtsJobDedicatedClusterRequest() = default;
};
class ModifyDtsJobDedicatedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDtsJobDedicatedClusterResponseBody() {}

  explicit ModifyDtsJobDedicatedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobDedicatedClusterResponseBody() = default;
};
class ModifyDtsJobDedicatedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobDedicatedClusterResponseBody> body{};

  ModifyDtsJobDedicatedClusterResponse() {}

  explicit ModifyDtsJobDedicatedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobDedicatedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobDedicatedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobDedicatedClusterResponse() = default;
};
class ModifyDtsJobDuLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<long> duLimit{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  ModifyDtsJobDuLimitRequest() {}

  explicit ModifyDtsJobDuLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (duLimit) {
      res["DuLimit"] = boost::any(*duLimit);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DuLimit") != m.end() && !m["DuLimit"].empty()) {
      duLimit = make_shared<long>(boost::any_cast<long>(m["DuLimit"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDtsJobDuLimitRequest() = default;
};
class ModifyDtsJobDuLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDtsJobDuLimitResponseBody() {}

  explicit ModifyDtsJobDuLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobDuLimitResponseBody() = default;
};
class ModifyDtsJobDuLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobDuLimitResponseBody> body{};

  ModifyDtsJobDuLimitResponse() {}

  explicit ModifyDtsJobDuLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobDuLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobDuLimitResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobDuLimitResponse() = default;
};
class ModifyDtsJobEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> database{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointInstanceId{};
  shared_ptr<string> endpointInstanceType{};
  shared_ptr<string> endpointIp{};
  shared_ptr<string> endpointPort{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> shardPassword{};
  shared_ptr<string> shardUsername{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> username{};

  ModifyDtsJobEndpointRequest() {}

  explicit ModifyDtsJobEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointInstanceId) {
      res["EndpointInstanceId"] = boost::any(*endpointInstanceId);
    }
    if (endpointInstanceType) {
      res["EndpointInstanceType"] = boost::any(*endpointInstanceType);
    }
    if (endpointIp) {
      res["EndpointIp"] = boost::any(*endpointIp);
    }
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (shardPassword) {
      res["ShardPassword"] = boost::any(*shardPassword);
    }
    if (shardUsername) {
      res["ShardUsername"] = boost::any(*shardUsername);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointInstanceId") != m.end() && !m["EndpointInstanceId"].empty()) {
      endpointInstanceId = make_shared<string>(boost::any_cast<string>(m["EndpointInstanceId"]));
    }
    if (m.find("EndpointInstanceType") != m.end() && !m["EndpointInstanceType"].empty()) {
      endpointInstanceType = make_shared<string>(boost::any_cast<string>(m["EndpointInstanceType"]));
    }
    if (m.find("EndpointIp") != m.end() && !m["EndpointIp"].empty()) {
      endpointIp = make_shared<string>(boost::any_cast<string>(m["EndpointIp"]));
    }
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<string>(boost::any_cast<string>(m["EndpointPort"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("ShardPassword") != m.end() && !m["ShardPassword"].empty()) {
      shardPassword = make_shared<string>(boost::any_cast<string>(m["ShardPassword"]));
    }
    if (m.find("ShardUsername") != m.end() && !m["ShardUsername"].empty()) {
      shardUsername = make_shared<string>(boost::any_cast<string>(m["ShardUsername"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ModifyDtsJobEndpointRequest() = default;
};
class ModifyDtsJobEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDtsJobEndpointResponseBody() {}

  explicit ModifyDtsJobEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobEndpointResponseBody() = default;
};
class ModifyDtsJobEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobEndpointResponseBody> body{};

  ModifyDtsJobEndpointResponse() {}

  explicit ModifyDtsJobEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobEndpointResponse() = default;
};
class ModifyDtsJobNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dtsJobName{};
  shared_ptr<string> regionId{};

  ModifyDtsJobNameRequest() {}

  explicit ModifyDtsJobNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dtsJobName) {
      res["DtsJobName"] = boost::any(*dtsJobName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DtsJobName") != m.end() && !m["DtsJobName"].empty()) {
      dtsJobName = make_shared<string>(boost::any_cast<string>(m["DtsJobName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDtsJobNameRequest() = default;
};
class ModifyDtsJobNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDtsJobNameResponseBody() {}

  explicit ModifyDtsJobNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobNameResponseBody() = default;
};
class ModifyDtsJobNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobNameResponseBody> body{};

  ModifyDtsJobNameResponse() {}

  explicit ModifyDtsJobNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobNameResponse() = default;
};
class ModifyDtsJobPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> password{};
  shared_ptr<string> regionId{};
  shared_ptr<string> userName{};

  ModifyDtsJobPasswordRequest() {}

  explicit ModifyDtsJobPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ModifyDtsJobPasswordRequest() = default;
};
class ModifyDtsJobPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDtsJobPasswordResponseBody() {}

  explicit ModifyDtsJobPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDtsJobPasswordResponseBody() = default;
};
class ModifyDtsJobPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDtsJobPasswordResponseBody> body{};

  ModifyDtsJobPasswordResponse() {}

  explicit ModifyDtsJobPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDtsJobPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDtsJobPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDtsJobPasswordResponse() = default;
};
class ModifyDynamicConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configList{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<bool> enableLimit{};
  shared_ptr<string> jobCode{};
  shared_ptr<string> regionId{};

  ModifyDynamicConfigRequest() {}

  explicit ModifyDynamicConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configList) {
      res["ConfigList"] = boost::any(*configList);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (enableLimit) {
      res["EnableLimit"] = boost::any(*enableLimit);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      configList = make_shared<string>(boost::any_cast<string>(m["ConfigList"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("EnableLimit") != m.end() && !m["EnableLimit"].empty()) {
      enableLimit = make_shared<bool>(boost::any_cast<bool>(m["EnableLimit"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDynamicConfigRequest() = default;
};
class ModifyDynamicConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyDynamicConfigResponseBody() {}

  explicit ModifyDynamicConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyDynamicConfigResponseBody() = default;
};
class ModifyDynamicConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDynamicConfigResponseBody> body{};

  ModifyDynamicConfigResponse() {}

  explicit ModifyDynamicConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDynamicConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDynamicConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDynamicConfigResponse() = default;
};
class ModifySubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbList{};
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> subscriptionDataTypeDDL{};
  shared_ptr<bool> subscriptionDataTypeDML{};

  ModifySubscriptionRequest() {}

  explicit ModifySubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbList) {
      res["DbList"] = boost::any(*dbList);
    }
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionDataTypeDDL) {
      res["SubscriptionDataTypeDDL"] = boost::any(*subscriptionDataTypeDDL);
    }
    if (subscriptionDataTypeDML) {
      res["SubscriptionDataTypeDML"] = boost::any(*subscriptionDataTypeDML);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      dbList = make_shared<string>(boost::any_cast<string>(m["DbList"]));
    }
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionDataTypeDDL") != m.end() && !m["SubscriptionDataTypeDDL"].empty()) {
      subscriptionDataTypeDDL = make_shared<bool>(boost::any_cast<bool>(m["SubscriptionDataTypeDDL"]));
    }
    if (m.find("SubscriptionDataTypeDML") != m.end() && !m["SubscriptionDataTypeDML"].empty()) {
      subscriptionDataTypeDML = make_shared<bool>(boost::any_cast<bool>(m["SubscriptionDataTypeDML"]));
    }
  }


  virtual ~ModifySubscriptionRequest() = default;
};
class ModifySubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifySubscriptionResponseBody() {}

  explicit ModifySubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifySubscriptionResponseBody() = default;
};
class ModifySubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySubscriptionResponseBody> body{};

  ModifySubscriptionResponse() {}

  explicit ModifySubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySubscriptionResponse() = default;
};
class ModifySubscriptionObjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};
  shared_ptr<string> subscriptionObject{};

  ModifySubscriptionObjectRequest() {}

  explicit ModifySubscriptionObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    if (subscriptionObject) {
      res["SubscriptionObject"] = boost::any(*subscriptionObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
    if (m.find("SubscriptionObject") != m.end() && !m["SubscriptionObject"].empty()) {
      subscriptionObject = make_shared<string>(boost::any_cast<string>(m["SubscriptionObject"]));
    }
  }


  virtual ~ModifySubscriptionObjectRequest() = default;
};
class ModifySubscriptionObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifySubscriptionObjectResponseBody() {}

  explicit ModifySubscriptionObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifySubscriptionObjectResponseBody() = default;
};
class ModifySubscriptionObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySubscriptionObjectResponseBody> body{};

  ModifySubscriptionObjectResponse() {}

  explicit ModifySubscriptionObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySubscriptionObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySubscriptionObjectResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySubscriptionObjectResponse() = default;
};
class ModifySynchronizationObjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> synchronizationObjects{};

  ModifySynchronizationObjectRequest() {}

  explicit ModifySynchronizationObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (synchronizationObjects) {
      res["SynchronizationObjects"] = boost::any(*synchronizationObjects);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("SynchronizationObjects") != m.end() && !m["SynchronizationObjects"].empty()) {
      synchronizationObjects = make_shared<string>(boost::any_cast<string>(m["SynchronizationObjects"]));
    }
  }


  virtual ~ModifySynchronizationObjectRequest() = default;
};
class ModifySynchronizationObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> taskId{};

  ModifySynchronizationObjectResponseBody() {}

  explicit ModifySynchronizationObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ModifySynchronizationObjectResponseBody() = default;
};
class ModifySynchronizationObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySynchronizationObjectResponseBody> body{};

  ModifySynchronizationObjectResponse() {}

  explicit ModifySynchronizationObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySynchronizationObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySynchronizationObjectResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySynchronizationObjectResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> buyCount{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyCount) {
      res["BuyCount"] = boost::any(*buyCount);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyCount") != m.end() && !m["BuyCount"].empty()) {
      buyCount = make_shared<string>(boost::any_cast<string>(m["BuyCount"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> code{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> endTime{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class ResetDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  ResetDtsJobRequest() {}

  explicit ResetDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~ResetDtsJobRequest() = default;
};
class ResetDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResetDtsJobResponseBody() {}

  explicit ResetDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetDtsJobResponseBody() = default;
};
class ResetDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetDtsJobResponseBody> body{};

  ResetDtsJobResponse() {}

  explicit ResetDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~ResetDtsJobResponse() = default;
};
class ResetSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  ResetSynchronizationJobRequest() {}

  explicit ResetSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~ResetSynchronizationJobRequest() = default;
};
class ResetSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ResetSynchronizationJobResponseBody() {}

  explicit ResetSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ResetSynchronizationJobResponseBody() = default;
};
class ResetSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetSynchronizationJobResponseBody> body{};

  ResetSynchronizationJobResponse() {}

  explicit ResetSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~ResetSynchronizationJobResponse() = default;
};
class ReverseTwoWayDirectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<bool> ignoreErrorSubJob{};
  shared_ptr<string> regionId{};

  ReverseTwoWayDirectionRequest() {}

  explicit ReverseTwoWayDirectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (ignoreErrorSubJob) {
      res["IgnoreErrorSubJob"] = boost::any(*ignoreErrorSubJob);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("IgnoreErrorSubJob") != m.end() && !m["IgnoreErrorSubJob"].empty()) {
      ignoreErrorSubJob = make_shared<bool>(boost::any_cast<bool>(m["IgnoreErrorSubJob"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ReverseTwoWayDirectionRequest() = default;
};
class ReverseTwoWayDirectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ReverseTwoWayDirectionResponseBody() {}

  explicit ReverseTwoWayDirectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ReverseTwoWayDirectionResponseBody() = default;
};
class ReverseTwoWayDirectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReverseTwoWayDirectionResponseBody> body{};

  ReverseTwoWayDirectionResponse() {}

  explicit ReverseTwoWayDirectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReverseTwoWayDirectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReverseTwoWayDirectionResponseBody>(model1);
      }
    }
  }


  virtual ~ReverseTwoWayDirectionResponse() = default;
};
class ShieldPrecheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> precheckItems{};
  shared_ptr<string> regionId{};

  ShieldPrecheckRequest() {}

  explicit ShieldPrecheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (precheckItems) {
      res["PrecheckItems"] = boost::any(*precheckItems);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("PrecheckItems") != m.end() && !m["PrecheckItems"].empty()) {
      precheckItems = make_shared<string>(boost::any_cast<string>(m["PrecheckItems"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ShieldPrecheckRequest() = default;
};
class ShieldPrecheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ShieldPrecheckResponseBody() {}

  explicit ShieldPrecheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ShieldPrecheckResponseBody() = default;
};
class ShieldPrecheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ShieldPrecheckResponseBody> body{};

  ShieldPrecheckResponse() {}

  explicit ShieldPrecheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ShieldPrecheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ShieldPrecheckResponseBody>(model1);
      }
    }
  }


  virtual ~ShieldPrecheckResponse() = default;
};
class SkipPreCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> skip{};
  shared_ptr<string> skipPreCheckItems{};
  shared_ptr<string> skipPreCheckNames{};

  SkipPreCheckRequest() {}

  explicit SkipPreCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (skipPreCheckItems) {
      res["SkipPreCheckItems"] = boost::any(*skipPreCheckItems);
    }
    if (skipPreCheckNames) {
      res["SkipPreCheckNames"] = boost::any(*skipPreCheckNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<bool>(boost::any_cast<bool>(m["Skip"]));
    }
    if (m.find("SkipPreCheckItems") != m.end() && !m["SkipPreCheckItems"].empty()) {
      skipPreCheckItems = make_shared<string>(boost::any_cast<string>(m["SkipPreCheckItems"]));
    }
    if (m.find("SkipPreCheckNames") != m.end() && !m["SkipPreCheckNames"].empty()) {
      skipPreCheckNames = make_shared<string>(boost::any_cast<string>(m["SkipPreCheckNames"]));
    }
  }


  virtual ~SkipPreCheckRequest() = default;
};
class SkipPreCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scheduleJobId{};
  shared_ptr<string> skipItems{};
  shared_ptr<string> skipNames{};
  shared_ptr<bool> success{};

  SkipPreCheckResponseBody() {}

  explicit SkipPreCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleJobId) {
      res["ScheduleJobId"] = boost::any(*scheduleJobId);
    }
    if (skipItems) {
      res["SkipItems"] = boost::any(*skipItems);
    }
    if (skipNames) {
      res["SkipNames"] = boost::any(*skipNames);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleJobId") != m.end() && !m["ScheduleJobId"].empty()) {
      scheduleJobId = make_shared<string>(boost::any_cast<string>(m["ScheduleJobId"]));
    }
    if (m.find("SkipItems") != m.end() && !m["SkipItems"].empty()) {
      skipItems = make_shared<string>(boost::any_cast<string>(m["SkipItems"]));
    }
    if (m.find("SkipNames") != m.end() && !m["SkipNames"].empty()) {
      skipNames = make_shared<string>(boost::any_cast<string>(m["SkipNames"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SkipPreCheckResponseBody() = default;
};
class SkipPreCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SkipPreCheckResponseBody> body{};

  SkipPreCheckResponse() {}

  explicit SkipPreCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SkipPreCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SkipPreCheckResponseBody>(model1);
      }
    }
  }


  virtual ~SkipPreCheckResponse() = default;
};
class StartDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  StartDtsJobRequest() {}

  explicit StartDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~StartDtsJobRequest() = default;
};
class StartDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartDtsJobResponseBody() {}

  explicit StartDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartDtsJobResponseBody() = default;
};
class StartDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDtsJobResponseBody> body{};

  StartDtsJobResponse() {}

  explicit StartDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartDtsJobResponse() = default;
};
class StartDtsJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobIds{};
  shared_ptr<string> regionId{};

  StartDtsJobsRequest() {}

  explicit StartDtsJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobIds) {
      res["DtsJobIds"] = boost::any(*dtsJobIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobIds") != m.end() && !m["DtsJobIds"].empty()) {
      dtsJobIds = make_shared<string>(boost::any_cast<string>(m["DtsJobIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartDtsJobsRequest() = default;
};
class StartDtsJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartDtsJobsResponseBody() {}

  explicit StartDtsJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartDtsJobsResponseBody() = default;
};
class StartDtsJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDtsJobsResponseBody> body{};

  StartDtsJobsResponse() {}

  explicit StartDtsJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDtsJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDtsJobsResponseBody>(model1);
      }
    }
  }


  virtual ~StartDtsJobsResponse() = default;
};
class StartMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  StartMigrationJobRequest() {}

  explicit StartMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StartMigrationJobRequest() = default;
};
class StartMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StartMigrationJobResponseBody() {}

  explicit StartMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StartMigrationJobResponseBody() = default;
};
class StartMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartMigrationJobResponseBody> body{};

  StartMigrationJobResponse() {}

  explicit StartMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartMigrationJobResponse() = default;
};
class StartReverseWriterRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkPoint{};
  shared_ptr<string> dtsJobId{};

  StartReverseWriterRequest() {}

  explicit StartReverseWriterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkPoint) {
      res["CheckPoint"] = boost::any(*checkPoint);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckPoint") != m.end() && !m["CheckPoint"].empty()) {
      checkPoint = make_shared<string>(boost::any_cast<string>(m["CheckPoint"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
  }


  virtual ~StartReverseWriterRequest() = default;
};
class StartReverseWriterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StartReverseWriterResponseBody() {}

  explicit StartReverseWriterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StartReverseWriterResponseBody() = default;
};
class StartReverseWriterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartReverseWriterResponseBody> body{};

  StartReverseWriterResponse() {}

  explicit StartReverseWriterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartReverseWriterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartReverseWriterResponseBody>(model1);
      }
    }
  }


  virtual ~StartReverseWriterResponse() = default;
};
class StartSubscriptionInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subscriptionInstanceId{};

  StartSubscriptionInstanceRequest() {}

  explicit StartSubscriptionInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subscriptionInstanceId) {
      res["SubscriptionInstanceId"] = boost::any(*subscriptionInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubscriptionInstanceId") != m.end() && !m["SubscriptionInstanceId"].empty()) {
      subscriptionInstanceId = make_shared<string>(boost::any_cast<string>(m["SubscriptionInstanceId"]));
    }
  }


  virtual ~StartSubscriptionInstanceRequest() = default;
};
class StartSubscriptionInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> taskId{};

  StartSubscriptionInstanceResponseBody() {}

  explicit StartSubscriptionInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StartSubscriptionInstanceResponseBody() = default;
};
class StartSubscriptionInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartSubscriptionInstanceResponseBody> body{};

  StartSubscriptionInstanceResponse() {}

  explicit StartSubscriptionInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartSubscriptionInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartSubscriptionInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartSubscriptionInstanceResponse() = default;
};
class StartSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  StartSynchronizationJobRequest() {}

  explicit StartSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~StartSynchronizationJobRequest() = default;
};
class StartSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StartSynchronizationJobResponseBody() {}

  explicit StartSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StartSynchronizationJobResponseBody() = default;
};
class StartSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartSynchronizationJobResponseBody> body{};

  StartSynchronizationJobResponse() {}

  explicit StartSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartSynchronizationJobResponse() = default;
};
class StopDedicatedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> dedicatedClusterId{};
  shared_ptr<string> dedicatedClusterName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  StopDedicatedClusterRequest() {}

  explicit StopDedicatedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dedicatedClusterId) {
      res["DedicatedClusterId"] = boost::any(*dedicatedClusterId);
    }
    if (dedicatedClusterName) {
      res["DedicatedClusterName"] = boost::any(*dedicatedClusterName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DedicatedClusterId") != m.end() && !m["DedicatedClusterId"].empty()) {
      dedicatedClusterId = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterId"]));
    }
    if (m.find("DedicatedClusterName") != m.end() && !m["DedicatedClusterName"].empty()) {
      dedicatedClusterName = make_shared<string>(boost::any_cast<string>(m["DedicatedClusterName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopDedicatedClusterRequest() = default;
};
class StopDedicatedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StopDedicatedClusterResponseBody() {}

  explicit StopDedicatedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StopDedicatedClusterResponseBody() = default;
};
class StopDedicatedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDedicatedClusterResponseBody> body{};

  StopDedicatedClusterResponse() {}

  explicit StopDedicatedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDedicatedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDedicatedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~StopDedicatedClusterResponse() = default;
};
class StopDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  StopDtsJobRequest() {}

  explicit StopDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~StopDtsJobRequest() = default;
};
class StopDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopDtsJobResponseBody() {}

  explicit StopDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopDtsJobResponseBody() = default;
};
class StopDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDtsJobResponseBody> body{};

  StopDtsJobResponse() {}

  explicit StopDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopDtsJobResponse() = default;
};
class StopDtsJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobIds{};
  shared_ptr<string> regionId{};

  StopDtsJobsRequest() {}

  explicit StopDtsJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobIds) {
      res["DtsJobIds"] = boost::any(*dtsJobIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobIds") != m.end() && !m["DtsJobIds"].empty()) {
      dtsJobIds = make_shared<string>(boost::any_cast<string>(m["DtsJobIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopDtsJobsRequest() = default;
};
class StopDtsJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopDtsJobsResponseBody() {}

  explicit StopDtsJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopDtsJobsResponseBody() = default;
};
class StopDtsJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDtsJobsResponseBody> body{};

  StopDtsJobsResponse() {}

  explicit StopDtsJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDtsJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDtsJobsResponseBody>(model1);
      }
    }
  }


  virtual ~StopDtsJobsResponse() = default;
};
class StopMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  StopMigrationJobRequest() {}

  explicit StopMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~StopMigrationJobRequest() = default;
};
class StopMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  StopMigrationJobResponseBody() {}

  explicit StopMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~StopMigrationJobResponseBody() = default;
};
class StopMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopMigrationJobResponseBody> body{};

  StopMigrationJobResponse() {}

  explicit StopMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~StopMigrationJobResponse() = default;
};
class SummaryJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> jobCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> structType{};
  shared_ptr<string> synchronizationDirection{};

  SummaryJobDetailRequest() {}

  explicit SummaryJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (jobCode) {
      res["JobCode"] = boost::any(*jobCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (structType) {
      res["StructType"] = boost::any(*structType);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("JobCode") != m.end() && !m["JobCode"].empty()) {
      jobCode = make_shared<string>(boost::any_cast<string>(m["JobCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StructType") != m.end() && !m["StructType"].empty()) {
      structType = make_shared<string>(boost::any_cast<string>(m["StructType"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~SummaryJobDetailRequest() = default;
};
class SummaryJobDetailResponseBodyProgressSummaryDetails : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<long> state{};
  shared_ptr<long> totalCount{};

  SummaryJobDetailResponseBodyProgressSummaryDetails() {}

  explicit SummaryJobDetailResponseBodyProgressSummaryDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SummaryJobDetailResponseBodyProgressSummaryDetails() = default;
};
class SummaryJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> jobId{};
  shared_ptr<vector<SummaryJobDetailResponseBodyProgressSummaryDetails>> progressSummaryDetails{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SummaryJobDetailResponseBody() {}

  explicit SummaryJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (progressSummaryDetails) {
      vector<boost::any> temp1;
      for(auto item1:*progressSummaryDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgressSummaryDetails"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ProgressSummaryDetails") != m.end() && !m["ProgressSummaryDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgressSummaryDetails"].type()) {
        vector<SummaryJobDetailResponseBodyProgressSummaryDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgressSummaryDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SummaryJobDetailResponseBodyProgressSummaryDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        progressSummaryDetails = make_shared<vector<SummaryJobDetailResponseBodyProgressSummaryDetails>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SummaryJobDetailResponseBody() = default;
};
class SummaryJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SummaryJobDetailResponseBody> body{};

  SummaryJobDetailResponse() {}

  explicit SummaryJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SummaryJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SummaryJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~SummaryJobDetailResponse() = default;
};
class SuspendDtsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  SuspendDtsJobRequest() {}

  explicit SuspendDtsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~SuspendDtsJobRequest() = default;
};
class SuspendDtsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendDtsJobResponseBody() {}

  explicit SuspendDtsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendDtsJobResponseBody() = default;
};
class SuspendDtsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendDtsJobResponseBody> body{};

  SuspendDtsJobResponse() {}

  explicit SuspendDtsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendDtsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendDtsJobResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendDtsJobResponse() = default;
};
class SuspendDtsJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobIds{};
  shared_ptr<string> regionId{};

  SuspendDtsJobsRequest() {}

  explicit SuspendDtsJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobIds) {
      res["DtsJobIds"] = boost::any(*dtsJobIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobIds") != m.end() && !m["DtsJobIds"].empty()) {
      dtsJobIds = make_shared<string>(boost::any_cast<string>(m["DtsJobIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SuspendDtsJobsRequest() = default;
};
class SuspendDtsJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SuspendDtsJobsResponseBody() {}

  explicit SuspendDtsJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendDtsJobsResponseBody() = default;
};
class SuspendDtsJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendDtsJobsResponseBody> body{};

  SuspendDtsJobsResponse() {}

  explicit SuspendDtsJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendDtsJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendDtsJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendDtsJobsResponse() = default;
};
class SuspendMigrationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> migrationJobId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};

  SuspendMigrationJobRequest() {}

  explicit SuspendMigrationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (migrationJobId) {
      res["MigrationJobId"] = boost::any(*migrationJobId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MigrationJobId") != m.end() && !m["MigrationJobId"].empty()) {
      migrationJobId = make_shared<string>(boost::any_cast<string>(m["MigrationJobId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SuspendMigrationJobRequest() = default;
};
class SuspendMigrationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SuspendMigrationJobResponseBody() {}

  explicit SuspendMigrationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SuspendMigrationJobResponseBody() = default;
};
class SuspendMigrationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendMigrationJobResponseBody> body{};

  SuspendMigrationJobResponse() {}

  explicit SuspendMigrationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendMigrationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendMigrationJobResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendMigrationJobResponse() = default;
};
class SuspendSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  SuspendSynchronizationJobRequest() {}

  explicit SuspendSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~SuspendSynchronizationJobRequest() = default;
};
class SuspendSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SuspendSynchronizationJobResponseBody() {}

  explicit SuspendSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SuspendSynchronizationJobResponseBody() = default;
};
class SuspendSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendSynchronizationJobResponseBody> body{};

  SuspendSynchronizationJobResponse() {}

  explicit SuspendSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendSynchronizationJobResponse() = default;
};
class SwitchPhysicalDtsJobToCloudRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsInstanceId{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};

  SwitchPhysicalDtsJobToCloudRequest() {}

  explicit SwitchPhysicalDtsJobToCloudRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsInstanceId) {
      res["DtsInstanceId"] = boost::any(*dtsInstanceId);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsInstanceId") != m.end() && !m["DtsInstanceId"].empty()) {
      dtsInstanceId = make_shared<string>(boost::any_cast<string>(m["DtsInstanceId"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
  }


  virtual ~SwitchPhysicalDtsJobToCloudRequest() = default;
};
class SwitchPhysicalDtsJobToCloudResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SwitchPhysicalDtsJobToCloudResponseBody() {}

  explicit SwitchPhysicalDtsJobToCloudResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SwitchPhysicalDtsJobToCloudResponseBody() = default;
};
class SwitchPhysicalDtsJobToCloudResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchPhysicalDtsJobToCloudResponseBody> body{};

  SwitchPhysicalDtsJobToCloudResponse() {}

  explicit SwitchPhysicalDtsJobToCloudResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchPhysicalDtsJobToCloudResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchPhysicalDtsJobToCloudResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchPhysicalDtsJobToCloudResponse() = default;
};
class SwitchSynchronizationEndpointRequestEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> IP{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> port{};
  shared_ptr<string> type{};

  SwitchSynchronizationEndpointRequestEndpoint() {}

  explicit SwitchSynchronizationEndpointRequestEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SwitchSynchronizationEndpointRequestEndpoint() = default;
};
class SwitchSynchronizationEndpointRequestSourceEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> ownerID{};
  shared_ptr<string> role{};

  SwitchSynchronizationEndpointRequestSourceEndpoint() {}

  explicit SwitchSynchronizationEndpointRequestSourceEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerID) {
      res["OwnerID"] = boost::any(*ownerID);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerID") != m.end() && !m["OwnerID"].empty()) {
      ownerID = make_shared<string>(boost::any_cast<string>(m["OwnerID"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~SwitchSynchronizationEndpointRequestSourceEndpoint() = default;
};
class SwitchSynchronizationEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<SwitchSynchronizationEndpointRequestEndpoint> endpoint{};
  shared_ptr<SwitchSynchronizationEndpointRequestSourceEndpoint> sourceEndpoint{};
  shared_ptr<string> accountId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> synchronizationDirection{};
  shared_ptr<string> synchronizationJobId{};

  SwitchSynchronizationEndpointRequest() {}

  explicit SwitchSynchronizationEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = endpoint ? boost::any(endpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpoint) {
      res["SourceEndpoint"] = sourceEndpoint ? boost::any(sourceEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (synchronizationDirection) {
      res["SynchronizationDirection"] = boost::any(*synchronizationDirection);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Endpoint"].type()) {
        SwitchSynchronizationEndpointRequestEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Endpoint"]));
        endpoint = make_shared<SwitchSynchronizationEndpointRequestEndpoint>(model1);
      }
    }
    if (m.find("SourceEndpoint") != m.end() && !m["SourceEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceEndpoint"].type()) {
        SwitchSynchronizationEndpointRequestSourceEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceEndpoint"]));
        sourceEndpoint = make_shared<SwitchSynchronizationEndpointRequestSourceEndpoint>(model1);
      }
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SynchronizationDirection") != m.end() && !m["SynchronizationDirection"].empty()) {
      synchronizationDirection = make_shared<string>(boost::any_cast<string>(m["SynchronizationDirection"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~SwitchSynchronizationEndpointRequest() = default;
};
class SwitchSynchronizationEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<string> taskId{};

  SwitchSynchronizationEndpointResponseBody() {}

  explicit SwitchSynchronizationEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SwitchSynchronizationEndpointResponseBody() = default;
};
class SwitchSynchronizationEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchSynchronizationEndpointResponseBody> body{};

  SwitchSynchronizationEndpointResponse() {}

  explicit SwitchSynchronizationEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchSynchronizationEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchSynchronizationEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchSynchronizationEndpointResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TransferInstanceClassRequest : public Darabonba::Model {
public:
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  TransferInstanceClassRequest() {}

  explicit TransferInstanceClassRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~TransferInstanceClassRequest() = default;
};
class TransferInstanceClassResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> code{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> endTime{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TransferInstanceClassResponseBody() {}

  explicit TransferInstanceClassResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TransferInstanceClassResponseBody() = default;
};
class TransferInstanceClassResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferInstanceClassResponseBody> body{};

  TransferInstanceClassResponse() {}

  explicit TransferInstanceClassResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferInstanceClassResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferInstanceClassResponseBody>(model1);
      }
    }
  }


  virtual ~TransferInstanceClassResponse() = default;
};
class TransferPayTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> buyCount{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};

  TransferPayTypeRequest() {}

  explicit TransferPayTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyCount) {
      res["BuyCount"] = boost::any(*buyCount);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyCount") != m.end() && !m["BuyCount"].empty()) {
      buyCount = make_shared<string>(boost::any_cast<string>(m["BuyCount"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~TransferPayTypeRequest() = default;
};
class TransferPayTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> code{};
  shared_ptr<string> dtsJobId{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> endTime{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TransferPayTypeResponseBody() {}

  explicit TransferPayTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dtsJobId) {
      res["DtsJobId"] = boost::any(*dtsJobId);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DtsJobId") != m.end() && !m["DtsJobId"].empty()) {
      dtsJobId = make_shared<string>(boost::any_cast<string>(m["DtsJobId"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TransferPayTypeResponseBody() = default;
};
class TransferPayTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferPayTypeResponseBody> body{};

  TransferPayTypeResponse() {}

  explicit TransferPayTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferPayTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferPayTypeResponseBody>(model1);
      }
    }
  }


  virtual ~TransferPayTypeResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpgradeTwoWayRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  UpgradeTwoWayRequest() {}

  explicit UpgradeTwoWayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpgradeTwoWayRequest() = default;
};
class UpgradeTwoWayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpgradeTwoWayResponseBody() {}

  explicit UpgradeTwoWayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeTwoWayResponseBody() = default;
};
class UpgradeTwoWayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeTwoWayResponseBody> body{};

  UpgradeTwoWayResponse() {}

  explicit UpgradeTwoWayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeTwoWayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeTwoWayResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeTwoWayResponse() = default;
};
class WhiteIpListRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationRegion{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  WhiteIpListRequest() {}

  explicit WhiteIpListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationRegion) {
      res["DestinationRegion"] = boost::any(*destinationRegion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationRegion") != m.end() && !m["DestinationRegion"].empty()) {
      destinationRegion = make_shared<string>(boost::any_cast<string>(m["DestinationRegion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~WhiteIpListRequest() = default;
};
class WhiteIpListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> ipList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  WhiteIpListResponseBody() {}

  explicit WhiteIpListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~WhiteIpListResponseBody() = default;
};
class WhiteIpListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<WhiteIpListResponseBody> body{};

  WhiteIpListResponse() {}

  explicit WhiteIpListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        WhiteIpListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<WhiteIpListResponseBody>(model1);
      }
    }
  }


  virtual ~WhiteIpListResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ConfigureDtsJobResponse configureDtsJobWithOptions(shared_ptr<ConfigureDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureDtsJobResponse configureDtsJob(shared_ptr<ConfigureDtsJobRequest> request);
  ConfigureDtsJobResponse configureDtsJobAdvance(shared_ptr<ConfigureDtsJobAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureMigrationJobResponse configureMigrationJobWithOptions(shared_ptr<ConfigureMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureMigrationJobResponse configureMigrationJob(shared_ptr<ConfigureMigrationJobRequest> request);
  ConfigureMigrationJobAlertResponse configureMigrationJobAlertWithOptions(shared_ptr<ConfigureMigrationJobAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureMigrationJobAlertResponse configureMigrationJobAlert(shared_ptr<ConfigureMigrationJobAlertRequest> request);
  ConfigureSubscriptionResponse configureSubscriptionWithOptions(shared_ptr<ConfigureSubscriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSubscriptionResponse configureSubscription(shared_ptr<ConfigureSubscriptionRequest> request);
  ConfigureSubscriptionInstanceResponse configureSubscriptionInstanceWithOptions(shared_ptr<ConfigureSubscriptionInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSubscriptionInstanceResponse configureSubscriptionInstance(shared_ptr<ConfigureSubscriptionInstanceRequest> request);
  ConfigureSubscriptionInstanceAlertResponse configureSubscriptionInstanceAlertWithOptions(shared_ptr<ConfigureSubscriptionInstanceAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSubscriptionInstanceAlertResponse configureSubscriptionInstanceAlert(shared_ptr<ConfigureSubscriptionInstanceAlertRequest> request);
  ConfigureSynchronizationJobResponse configureSynchronizationJobWithOptions(shared_ptr<ConfigureSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSynchronizationJobResponse configureSynchronizationJob(shared_ptr<ConfigureSynchronizationJobRequest> request);
  ConfigureSynchronizationJobAlertResponse configureSynchronizationJobAlertWithOptions(shared_ptr<ConfigureSynchronizationJobAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSynchronizationJobAlertResponse configureSynchronizationJobAlert(shared_ptr<ConfigureSynchronizationJobAlertRequest> request);
  ConfigureSynchronizationJobReplicatorCompareResponse configureSynchronizationJobReplicatorCompareWithOptions(shared_ptr<ConfigureSynchronizationJobReplicatorCompareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigureSynchronizationJobReplicatorCompareResponse configureSynchronizationJobReplicatorCompare(shared_ptr<ConfigureSynchronizationJobReplicatorCompareRequest> request);
  CountJobByConditionResponse countJobByConditionWithOptions(shared_ptr<CountJobByConditionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountJobByConditionResponse countJobByCondition(shared_ptr<CountJobByConditionRequest> request);
  CreateConsumerChannelResponse createConsumerChannelWithOptions(shared_ptr<CreateConsumerChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerChannelResponse createConsumerChannel(shared_ptr<CreateConsumerChannelRequest> request);
  CreateConsumerGroupResponse createConsumerGroupWithOptions(shared_ptr<CreateConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsumerGroupResponse createConsumerGroup(shared_ptr<CreateConsumerGroupRequest> request);
  CreateDedicatedClusterMonitorRuleResponse createDedicatedClusterMonitorRuleWithOptions(shared_ptr<CreateDedicatedClusterMonitorRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDedicatedClusterMonitorRuleResponse createDedicatedClusterMonitorRule(shared_ptr<CreateDedicatedClusterMonitorRuleRequest> request);
  CreateDtsInstanceResponse createDtsInstanceWithOptions(shared_ptr<CreateDtsInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDtsInstanceResponse createDtsInstance(shared_ptr<CreateDtsInstanceRequest> request);
  CreateJobMonitorRuleResponse createJobMonitorRuleWithOptions(shared_ptr<CreateJobMonitorRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobMonitorRuleResponse createJobMonitorRule(shared_ptr<CreateJobMonitorRuleRequest> request);
  CreateMigrationJobResponse createMigrationJobWithOptions(shared_ptr<CreateMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMigrationJobResponse createMigrationJob(shared_ptr<CreateMigrationJobRequest> request);
  CreateReverseDtsJobResponse createReverseDtsJobWithOptions(shared_ptr<CreateReverseDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateReverseDtsJobResponse createReverseDtsJob(shared_ptr<CreateReverseDtsJobRequest> request);
  CreateSubscriptionInstanceResponse createSubscriptionInstanceWithOptions(shared_ptr<CreateSubscriptionInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscriptionInstanceResponse createSubscriptionInstance(shared_ptr<CreateSubscriptionInstanceRequest> request);
  CreateSynchronizationJobResponse createSynchronizationJobWithOptions(shared_ptr<CreateSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSynchronizationJobResponse createSynchronizationJob(shared_ptr<CreateSynchronizationJobRequest> request);
  DeleteConsumerChannelResponse deleteConsumerChannelWithOptions(shared_ptr<DeleteConsumerChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerChannelResponse deleteConsumerChannel(shared_ptr<DeleteConsumerChannelRequest> request);
  DeleteConsumerGroupResponse deleteConsumerGroupWithOptions(shared_ptr<DeleteConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConsumerGroupResponse deleteConsumerGroup(shared_ptr<DeleteConsumerGroupRequest> request);
  DeleteDtsJobResponse deleteDtsJobWithOptions(shared_ptr<DeleteDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDtsJobResponse deleteDtsJob(shared_ptr<DeleteDtsJobRequest> request);
  DeleteDtsJobsResponse deleteDtsJobsWithOptions(shared_ptr<DeleteDtsJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDtsJobsResponse deleteDtsJobs(shared_ptr<DeleteDtsJobsRequest> request);
  DeleteMigrationJobResponse deleteMigrationJobWithOptions(shared_ptr<DeleteMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMigrationJobResponse deleteMigrationJob(shared_ptr<DeleteMigrationJobRequest> request);
  DeleteSubscriptionInstanceResponse deleteSubscriptionInstanceWithOptions(shared_ptr<DeleteSubscriptionInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscriptionInstanceResponse deleteSubscriptionInstance(shared_ptr<DeleteSubscriptionInstanceRequest> request);
  DeleteSynchronizationJobResponse deleteSynchronizationJobWithOptions(shared_ptr<DeleteSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSynchronizationJobResponse deleteSynchronizationJob(shared_ptr<DeleteSynchronizationJobRequest> request);
  DescribeChannelAccountResponse describeChannelAccountWithOptions(shared_ptr<DescribeChannelAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelAccountResponse describeChannelAccount(shared_ptr<DescribeChannelAccountRequest> request);
  DescribeCheckJobsResponse describeCheckJobsWithOptions(shared_ptr<DescribeCheckJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckJobsResponse describeCheckJobs(shared_ptr<DescribeCheckJobsRequest> request);
  DescribeClusterOperateLogsResponse describeClusterOperateLogsWithOptions(shared_ptr<DescribeClusterOperateLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterOperateLogsResponse describeClusterOperateLogs(shared_ptr<DescribeClusterOperateLogsRequest> request);
  DescribeClusterUsedUtilizationResponse describeClusterUsedUtilizationWithOptions(shared_ptr<DescribeClusterUsedUtilizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterUsedUtilizationResponse describeClusterUsedUtilization(shared_ptr<DescribeClusterUsedUtilizationRequest> request);
  DescribeConnectionStatusResponse describeConnectionStatusWithOptions(shared_ptr<DescribeConnectionStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConnectionStatusResponse describeConnectionStatus(shared_ptr<DescribeConnectionStatusRequest> request);
  DescribeConsumerChannelResponse describeConsumerChannelWithOptions(shared_ptr<DescribeConsumerChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsumerChannelResponse describeConsumerChannel(shared_ptr<DescribeConsumerChannelRequest> request);
  DescribeConsumerGroupResponse describeConsumerGroupWithOptions(shared_ptr<DescribeConsumerGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsumerGroupResponse describeConsumerGroup(shared_ptr<DescribeConsumerGroupRequest> request);
  DescribeDTSIPResponse describeDTSIPWithOptions(shared_ptr<DescribeDTSIPRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDTSIPResponse describeDTSIP(shared_ptr<DescribeDTSIPRequest> request);
  DescribeDataCheckReportUrlResponse describeDataCheckReportUrlWithOptions(shared_ptr<DescribeDataCheckReportUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataCheckReportUrlResponse describeDataCheckReportUrl(shared_ptr<DescribeDataCheckReportUrlRequest> request);
  DescribeDataCheckTableDetailsResponse describeDataCheckTableDetailsWithOptions(shared_ptr<DescribeDataCheckTableDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataCheckTableDetailsResponse describeDataCheckTableDetails(shared_ptr<DescribeDataCheckTableDetailsRequest> request);
  DescribeDataCheckTableDiffDetailsResponse describeDataCheckTableDiffDetailsWithOptions(shared_ptr<DescribeDataCheckTableDiffDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataCheckTableDiffDetailsResponse describeDataCheckTableDiffDetails(shared_ptr<DescribeDataCheckTableDiffDetailsRequest> request);
  DescribeDedicatedClusterResponse describeDedicatedClusterWithOptions(shared_ptr<DescribeDedicatedClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedClusterResponse describeDedicatedCluster(shared_ptr<DescribeDedicatedClusterRequest> request);
  DescribeDedicatedClusterMonitorRuleResponse describeDedicatedClusterMonitorRuleWithOptions(shared_ptr<DescribeDedicatedClusterMonitorRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDedicatedClusterMonitorRuleResponse describeDedicatedClusterMonitorRule(shared_ptr<DescribeDedicatedClusterMonitorRuleRequest> request);
  DescribeDtsEtlJobVersionInfoResponse describeDtsEtlJobVersionInfoWithOptions(shared_ptr<DescribeDtsEtlJobVersionInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDtsEtlJobVersionInfoResponse describeDtsEtlJobVersionInfo(shared_ptr<DescribeDtsEtlJobVersionInfoRequest> request);
  DescribeDtsJobDetailResponse describeDtsJobDetailWithOptions(shared_ptr<DescribeDtsJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDtsJobDetailResponse describeDtsJobDetail(shared_ptr<DescribeDtsJobDetailRequest> request);
  DescribeDtsJobsResponse describeDtsJobsWithOptions(shared_ptr<DescribeDtsJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDtsJobsResponse describeDtsJobs(shared_ptr<DescribeDtsJobsRequest> request);
  DescribeDtsServiceLogResponse describeDtsServiceLogWithOptions(shared_ptr<DescribeDtsServiceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDtsServiceLogResponse describeDtsServiceLog(shared_ptr<DescribeDtsServiceLogRequest> request);
  DescribeEndpointSwitchStatusResponse describeEndpointSwitchStatusWithOptions(shared_ptr<DescribeEndpointSwitchStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEndpointSwitchStatusResponse describeEndpointSwitchStatus(shared_ptr<DescribeEndpointSwitchStatusRequest> request);
  DescribeEtlJobLogsResponse describeEtlJobLogsWithOptions(shared_ptr<DescribeEtlJobLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEtlJobLogsResponse describeEtlJobLogs(shared_ptr<DescribeEtlJobLogsRequest> request);
  DescribeInitializationStatusResponse describeInitializationStatusWithOptions(shared_ptr<DescribeInitializationStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInitializationStatusResponse describeInitializationStatus(shared_ptr<DescribeInitializationStatusRequest> request);
  DescribeJobMonitorRuleResponse describeJobMonitorRuleWithOptions(shared_ptr<DescribeJobMonitorRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeJobMonitorRuleResponse describeJobMonitorRule(shared_ptr<DescribeJobMonitorRuleRequest> request);
  DescribeMetricListResponse describeMetricListWithOptions(shared_ptr<DescribeMetricListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricListResponse describeMetricList(shared_ptr<DescribeMetricListRequest> request);
  DescribeMigrationJobAlertResponse describeMigrationJobAlertWithOptions(shared_ptr<DescribeMigrationJobAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationJobAlertResponse describeMigrationJobAlert(shared_ptr<DescribeMigrationJobAlertRequest> request);
  DescribeMigrationJobDetailResponse describeMigrationJobDetailWithOptions(shared_ptr<DescribeMigrationJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationJobDetailResponse describeMigrationJobDetail(shared_ptr<DescribeMigrationJobDetailRequest> request);
  DescribeMigrationJobStatusResponse describeMigrationJobStatusWithOptions(shared_ptr<DescribeMigrationJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationJobStatusResponse describeMigrationJobStatus(shared_ptr<DescribeMigrationJobStatusRequest> request);
  DescribeMigrationJobsResponse describeMigrationJobsWithOptions(shared_ptr<DescribeMigrationJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMigrationJobsResponse describeMigrationJobs(shared_ptr<DescribeMigrationJobsRequest> request);
  DescribePreCheckStatusResponse describePreCheckStatusWithOptions(shared_ptr<DescribePreCheckStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePreCheckStatusResponse describePreCheckStatus(shared_ptr<DescribePreCheckStatusRequest> request);
  DescribeSubscriptionInstanceAlertResponse describeSubscriptionInstanceAlertWithOptions(shared_ptr<DescribeSubscriptionInstanceAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubscriptionInstanceAlertResponse describeSubscriptionInstanceAlert(shared_ptr<DescribeSubscriptionInstanceAlertRequest> request);
  DescribeSubscriptionInstanceStatusResponse describeSubscriptionInstanceStatusWithOptions(shared_ptr<DescribeSubscriptionInstanceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubscriptionInstanceStatusResponse describeSubscriptionInstanceStatus(shared_ptr<DescribeSubscriptionInstanceStatusRequest> request);
  DescribeSubscriptionInstancesResponse describeSubscriptionInstancesWithOptions(shared_ptr<DescribeSubscriptionInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubscriptionInstancesResponse describeSubscriptionInstances(shared_ptr<DescribeSubscriptionInstancesRequest> request);
  DescribeSubscriptionMetaResponse describeSubscriptionMetaWithOptions(shared_ptr<DescribeSubscriptionMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubscriptionMetaResponse describeSubscriptionMeta(shared_ptr<DescribeSubscriptionMetaRequest> request);
  DescribeSynchronizationJobAlertResponse describeSynchronizationJobAlertWithOptions(shared_ptr<DescribeSynchronizationJobAlertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationJobAlertResponse describeSynchronizationJobAlert(shared_ptr<DescribeSynchronizationJobAlertRequest> request);
  DescribeSynchronizationJobReplicatorCompareResponse describeSynchronizationJobReplicatorCompareWithOptions(shared_ptr<DescribeSynchronizationJobReplicatorCompareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationJobReplicatorCompareResponse describeSynchronizationJobReplicatorCompare(shared_ptr<DescribeSynchronizationJobReplicatorCompareRequest> request);
  DescribeSynchronizationJobStatusResponse describeSynchronizationJobStatusWithOptions(shared_ptr<DescribeSynchronizationJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationJobStatusResponse describeSynchronizationJobStatus(shared_ptr<DescribeSynchronizationJobStatusRequest> request);
  DescribeSynchronizationJobStatusListResponse describeSynchronizationJobStatusListWithOptions(shared_ptr<DescribeSynchronizationJobStatusListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationJobStatusListResponse describeSynchronizationJobStatusList(shared_ptr<DescribeSynchronizationJobStatusListRequest> request);
  DescribeSynchronizationJobsResponse describeSynchronizationJobsWithOptions(shared_ptr<DescribeSynchronizationJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationJobsResponse describeSynchronizationJobs(shared_ptr<DescribeSynchronizationJobsRequest> request);
  DescribeSynchronizationObjectModifyStatusResponse describeSynchronizationObjectModifyStatusWithOptions(shared_ptr<DescribeSynchronizationObjectModifyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSynchronizationObjectModifyStatusResponse describeSynchronizationObjectModifyStatus(shared_ptr<DescribeSynchronizationObjectModifyStatusRequest> request);
  DescribeTagKeysResponse describeTagKeysWithOptions(shared_ptr<DescribeTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagKeysResponse describeTagKeys(shared_ptr<DescribeTagKeysRequest> request);
  DescribeTagValuesResponse describeTagValuesWithOptions(shared_ptr<DescribeTagValuesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagValuesResponse describeTagValues(shared_ptr<DescribeTagValuesRequest> request);
  InitDtsRdsInstanceResponse initDtsRdsInstanceWithOptions(shared_ptr<InitDtsRdsInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitDtsRdsInstanceResponse initDtsRdsInstance(shared_ptr<InitDtsRdsInstanceRequest> request);
  ListDedicatedClusterResponse listDedicatedClusterWithOptions(shared_ptr<ListDedicatedClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDedicatedClusterResponse listDedicatedCluster(shared_ptr<ListDedicatedClusterRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyConsumerChannelResponse modifyConsumerChannelWithOptions(shared_ptr<ModifyConsumerChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyConsumerChannelResponse modifyConsumerChannel(shared_ptr<ModifyConsumerChannelRequest> request);
  ModifyConsumerGroupPasswordResponse modifyConsumerGroupPasswordWithOptions(shared_ptr<ModifyConsumerGroupPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyConsumerGroupPasswordResponse modifyConsumerGroupPassword(shared_ptr<ModifyConsumerGroupPasswordRequest> request);
  ModifyConsumptionTimestampResponse modifyConsumptionTimestampWithOptions(shared_ptr<ModifyConsumptionTimestampRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyConsumptionTimestampResponse modifyConsumptionTimestamp(shared_ptr<ModifyConsumptionTimestampRequest> request);
  ModifyDedicatedClusterResponse modifyDedicatedClusterWithOptions(shared_ptr<ModifyDedicatedClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDedicatedClusterResponse modifyDedicatedCluster(shared_ptr<ModifyDedicatedClusterRequest> request);
  ModifyDtsJobResponse modifyDtsJobWithOptions(shared_ptr<ModifyDtsJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobResponse modifyDtsJob(shared_ptr<ModifyDtsJobRequest> request);
  ModifyDtsJobResponse modifyDtsJobAdvance(shared_ptr<ModifyDtsJobAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobConfigResponse modifyDtsJobConfigWithOptions(shared_ptr<ModifyDtsJobConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobConfigResponse modifyDtsJobConfig(shared_ptr<ModifyDtsJobConfigRequest> request);
  ModifyDtsJobDedicatedClusterResponse modifyDtsJobDedicatedClusterWithOptions(shared_ptr<ModifyDtsJobDedicatedClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobDedicatedClusterResponse modifyDtsJobDedicatedCluster(shared_ptr<ModifyDtsJobDedicatedClusterRequest> request);
  ModifyDtsJobDuLimitResponse modifyDtsJobDuLimitWithOptions(shared_ptr<ModifyDtsJobDuLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobDuLimitResponse modifyDtsJobDuLimit(shared_ptr<ModifyDtsJobDuLimitRequest> request);
  ModifyDtsJobEndpointResponse modifyDtsJobEndpointWithOptions(shared_ptr<ModifyDtsJobEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobEndpointResponse modifyDtsJobEndpoint(shared_ptr<ModifyDtsJobEndpointRequest> request);
  ModifyDtsJobNameResponse modifyDtsJobNameWithOptions(shared_ptr<ModifyDtsJobNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobNameResponse modifyDtsJobName(shared_ptr<ModifyDtsJobNameRequest> request);
  ModifyDtsJobPasswordResponse modifyDtsJobPasswordWithOptions(shared_ptr<ModifyDtsJobPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDtsJobPasswordResponse modifyDtsJobPassword(shared_ptr<ModifyDtsJobPasswordRequest> request);
  ModifyDynamicConfigResponse modifyDynamicConfigWithOptions(shared_ptr<ModifyDynamicConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDynamicConfigResponse modifyDynamicConfig(shared_ptr<ModifyDynamicConfigRequest> request);
  ModifySubscriptionResponse modifySubscriptionWithOptions(shared_ptr<ModifySubscriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySubscriptionResponse modifySubscription(shared_ptr<ModifySubscriptionRequest> request);
  ModifySubscriptionObjectResponse modifySubscriptionObjectWithOptions(shared_ptr<ModifySubscriptionObjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySubscriptionObjectResponse modifySubscriptionObject(shared_ptr<ModifySubscriptionObjectRequest> request);
  ModifySynchronizationObjectResponse modifySynchronizationObjectWithOptions(shared_ptr<ModifySynchronizationObjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySynchronizationObjectResponse modifySynchronizationObject(shared_ptr<ModifySynchronizationObjectRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<RenewInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<RenewInstanceRequest> request);
  ResetDtsJobResponse resetDtsJobWithOptions(shared_ptr<ResetDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetDtsJobResponse resetDtsJob(shared_ptr<ResetDtsJobRequest> request);
  ResetSynchronizationJobResponse resetSynchronizationJobWithOptions(shared_ptr<ResetSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetSynchronizationJobResponse resetSynchronizationJob(shared_ptr<ResetSynchronizationJobRequest> request);
  ReverseTwoWayDirectionResponse reverseTwoWayDirectionWithOptions(shared_ptr<ReverseTwoWayDirectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReverseTwoWayDirectionResponse reverseTwoWayDirection(shared_ptr<ReverseTwoWayDirectionRequest> request);
  ShieldPrecheckResponse shieldPrecheckWithOptions(shared_ptr<ShieldPrecheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ShieldPrecheckResponse shieldPrecheck(shared_ptr<ShieldPrecheckRequest> request);
  SkipPreCheckResponse skipPreCheckWithOptions(shared_ptr<SkipPreCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SkipPreCheckResponse skipPreCheck(shared_ptr<SkipPreCheckRequest> request);
  StartDtsJobResponse startDtsJobWithOptions(shared_ptr<StartDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDtsJobResponse startDtsJob(shared_ptr<StartDtsJobRequest> request);
  StartDtsJobsResponse startDtsJobsWithOptions(shared_ptr<StartDtsJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDtsJobsResponse startDtsJobs(shared_ptr<StartDtsJobsRequest> request);
  StartMigrationJobResponse startMigrationJobWithOptions(shared_ptr<StartMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMigrationJobResponse startMigrationJob(shared_ptr<StartMigrationJobRequest> request);
  StartReverseWriterResponse startReverseWriterWithOptions(shared_ptr<StartReverseWriterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartReverseWriterResponse startReverseWriter(shared_ptr<StartReverseWriterRequest> request);
  StartSubscriptionInstanceResponse startSubscriptionInstanceWithOptions(shared_ptr<StartSubscriptionInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartSubscriptionInstanceResponse startSubscriptionInstance(shared_ptr<StartSubscriptionInstanceRequest> request);
  StartSynchronizationJobResponse startSynchronizationJobWithOptions(shared_ptr<StartSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartSynchronizationJobResponse startSynchronizationJob(shared_ptr<StartSynchronizationJobRequest> request);
  StopDedicatedClusterResponse stopDedicatedClusterWithOptions(shared_ptr<StopDedicatedClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDedicatedClusterResponse stopDedicatedCluster(shared_ptr<StopDedicatedClusterRequest> request);
  StopDtsJobResponse stopDtsJobWithOptions(shared_ptr<StopDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDtsJobResponse stopDtsJob(shared_ptr<StopDtsJobRequest> request);
  StopDtsJobsResponse stopDtsJobsWithOptions(shared_ptr<StopDtsJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDtsJobsResponse stopDtsJobs(shared_ptr<StopDtsJobsRequest> request);
  StopMigrationJobResponse stopMigrationJobWithOptions(shared_ptr<StopMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopMigrationJobResponse stopMigrationJob(shared_ptr<StopMigrationJobRequest> request);
  SummaryJobDetailResponse summaryJobDetailWithOptions(shared_ptr<SummaryJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SummaryJobDetailResponse summaryJobDetail(shared_ptr<SummaryJobDetailRequest> request);
  SuspendDtsJobResponse suspendDtsJobWithOptions(shared_ptr<SuspendDtsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendDtsJobResponse suspendDtsJob(shared_ptr<SuspendDtsJobRequest> request);
  SuspendDtsJobsResponse suspendDtsJobsWithOptions(shared_ptr<SuspendDtsJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendDtsJobsResponse suspendDtsJobs(shared_ptr<SuspendDtsJobsRequest> request);
  SuspendMigrationJobResponse suspendMigrationJobWithOptions(shared_ptr<SuspendMigrationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendMigrationJobResponse suspendMigrationJob(shared_ptr<SuspendMigrationJobRequest> request);
  SuspendSynchronizationJobResponse suspendSynchronizationJobWithOptions(shared_ptr<SuspendSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendSynchronizationJobResponse suspendSynchronizationJob(shared_ptr<SuspendSynchronizationJobRequest> request);
  SwitchPhysicalDtsJobToCloudResponse switchPhysicalDtsJobToCloudWithOptions(shared_ptr<SwitchPhysicalDtsJobToCloudRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchPhysicalDtsJobToCloudResponse switchPhysicalDtsJobToCloud(shared_ptr<SwitchPhysicalDtsJobToCloudRequest> request);
  SwitchSynchronizationEndpointResponse switchSynchronizationEndpointWithOptions(shared_ptr<SwitchSynchronizationEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchSynchronizationEndpointResponse switchSynchronizationEndpoint(shared_ptr<SwitchSynchronizationEndpointRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TransferInstanceClassResponse transferInstanceClassWithOptions(shared_ptr<TransferInstanceClassRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferInstanceClassResponse transferInstanceClass(shared_ptr<TransferInstanceClassRequest> request);
  TransferPayTypeResponse transferPayTypeWithOptions(shared_ptr<TransferPayTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferPayTypeResponse transferPayType(shared_ptr<TransferPayTypeRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpgradeTwoWayResponse upgradeTwoWayWithOptions(shared_ptr<UpgradeTwoWayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeTwoWayResponse upgradeTwoWay(shared_ptr<UpgradeTwoWayRequest> request);
  WhiteIpListResponse whiteIpListWithOptions(shared_ptr<WhiteIpListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  WhiteIpListResponse whiteIpList(shared_ptr<WhiteIpListRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dts20200101

#endif
