// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_MSE20190531_H_
#define ALIBABACLOUD_MSE20190531_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Mse20190531 {
class GatewayDomain : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayName{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> mustHttps{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};

  GatewayDomain() {}

  explicit GatewayDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayName) {
      res["GatewayName"] = boost::any(*gatewayName);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayName") != m.end() && !m["GatewayName"].empty()) {
      gatewayName = make_shared<string>(boost::any_cast<string>(m["GatewayName"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<string>(boost::any_cast<string>(m["MustHttps"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~GatewayDomain() = default;
};
class GatewayOptionLogConfigDetails : public Darabonba::Model {
public:
  shared_ptr<bool> logEnabled{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};

  GatewayOptionLogConfigDetails() {}

  explicit GatewayOptionLogConfigDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnabled) {
      res["LogEnabled"] = boost::any(*logEnabled);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnabled") != m.end() && !m["LogEnabled"].empty()) {
      logEnabled = make_shared<bool>(boost::any_cast<bool>(m["LogEnabled"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GatewayOptionLogConfigDetails() = default;
};
class GatewayOptionTraceDetails : public Darabonba::Model {
public:
  shared_ptr<long> sample{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> servicePort{};
  shared_ptr<bool> traceEnabled{};
  shared_ptr<string> traceType{};

  GatewayOptionTraceDetails() {}

  explicit GatewayOptionTraceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (traceEnabled) {
      res["TraceEnabled"] = boost::any(*traceEnabled);
    }
    if (traceType) {
      res["TraceType"] = boost::any(*traceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<long>(boost::any_cast<long>(m["Sample"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<string>(boost::any_cast<string>(m["ServicePort"]));
    }
    if (m.find("TraceEnabled") != m.end() && !m["TraceEnabled"].empty()) {
      traceEnabled = make_shared<bool>(boost::any_cast<bool>(m["TraceEnabled"]));
    }
    if (m.find("TraceType") != m.end() && !m["TraceType"].empty()) {
      traceType = make_shared<string>(boost::any_cast<string>(m["TraceType"]));
    }
  }


  virtual ~GatewayOptionTraceDetails() = default;
};
class GatewayOption : public Darabonba::Model {
public:
  shared_ptr<bool> disableHttp2Alpn{};
  shared_ptr<bool> enableHardwareAcceleration{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<GatewayOptionLogConfigDetails> logConfigDetails{};
  shared_ptr<GatewayOptionTraceDetails> traceDetails{};

  GatewayOption() {}

  explicit GatewayOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableHttp2Alpn) {
      res["DisableHttp2Alpn"] = boost::any(*disableHttp2Alpn);
    }
    if (enableHardwareAcceleration) {
      res["EnableHardwareAcceleration"] = boost::any(*enableHardwareAcceleration);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (logConfigDetails) {
      res["LogConfigDetails"] = logConfigDetails ? boost::any(logConfigDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (traceDetails) {
      res["TraceDetails"] = traceDetails ? boost::any(traceDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableHttp2Alpn") != m.end() && !m["DisableHttp2Alpn"].empty()) {
      disableHttp2Alpn = make_shared<bool>(boost::any_cast<bool>(m["DisableHttp2Alpn"]));
    }
    if (m.find("EnableHardwareAcceleration") != m.end() && !m["EnableHardwareAcceleration"].empty()) {
      enableHardwareAcceleration = make_shared<bool>(boost::any_cast<bool>(m["EnableHardwareAcceleration"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("LogConfigDetails") != m.end() && !m["LogConfigDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogConfigDetails"].type()) {
        GatewayOptionLogConfigDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogConfigDetails"]));
        logConfigDetails = make_shared<GatewayOptionLogConfigDetails>(model1);
      }
    }
    if (m.find("TraceDetails") != m.end() && !m["TraceDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["TraceDetails"].type()) {
        GatewayOptionTraceDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TraceDetails"]));
        traceDetails = make_shared<GatewayOptionTraceDetails>(model1);
      }
    }
  }


  virtual ~GatewayOption() = default;
};
class TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> TTL{};

  TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie() {}

  explicit TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (TTL) {
      res["TTL"] = boost::any(*TTL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("TTL") != m.end() && !m["TTL"].empty()) {
      TTL = make_shared<string>(boost::any_cast<string>(m["TTL"]));
    }
  }


  virtual ~TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie() = default;
};
class TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig : public Darabonba::Model {
public:
  shared_ptr<string> consistentHashLBType{};
  shared_ptr<TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie> httpCookie{};
  shared_ptr<string> parameterName{};

  TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig() {}

  explicit TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentHashLBType) {
      res["ConsistentHashLBType"] = boost::any(*consistentHashLBType);
    }
    if (httpCookie) {
      res["HttpCookie"] = httpCookie ? boost::any(httpCookie->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentHashLBType") != m.end() && !m["ConsistentHashLBType"].empty()) {
      consistentHashLBType = make_shared<string>(boost::any_cast<string>(m["ConsistentHashLBType"]));
    }
    if (m.find("HttpCookie") != m.end() && !m["HttpCookie"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCookie"].type()) {
        TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCookie"]));
        httpCookie = make_shared<TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie>(model1);
      }
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig() = default;
};
class TrafficPolicyLoadBalancerSettings : public Darabonba::Model {
public:
  shared_ptr<TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig> consistentHashLBConfig{};
  shared_ptr<string> loadbalancerType{};
  shared_ptr<long> warmupDuration{};

  TrafficPolicyLoadBalancerSettings() {}

  explicit TrafficPolicyLoadBalancerSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentHashLBConfig) {
      res["ConsistentHashLBConfig"] = consistentHashLBConfig ? boost::any(consistentHashLBConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loadbalancerType) {
      res["LoadbalancerType"] = boost::any(*loadbalancerType);
    }
    if (warmupDuration) {
      res["WarmupDuration"] = boost::any(*warmupDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentHashLBConfig") != m.end() && !m["ConsistentHashLBConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsistentHashLBConfig"].type()) {
        TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsistentHashLBConfig"]));
        consistentHashLBConfig = make_shared<TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig>(model1);
      }
    }
    if (m.find("LoadbalancerType") != m.end() && !m["LoadbalancerType"].empty()) {
      loadbalancerType = make_shared<string>(boost::any_cast<string>(m["LoadbalancerType"]));
    }
    if (m.find("WarmupDuration") != m.end() && !m["WarmupDuration"].empty()) {
      warmupDuration = make_shared<long>(boost::any_cast<long>(m["WarmupDuration"]));
    }
  }


  virtual ~TrafficPolicyLoadBalancerSettings() = default;
};
class TrafficPolicyTlsSetting : public Darabonba::Model {
public:
  shared_ptr<string> caCertContent{};
  shared_ptr<string> certId{};
  shared_ptr<string> sni{};
  shared_ptr<string> tlsMode{};

  TrafficPolicyTlsSetting() {}

  explicit TrafficPolicyTlsSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCertContent) {
      res["CaCertContent"] = boost::any(*caCertContent);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (sni) {
      res["Sni"] = boost::any(*sni);
    }
    if (tlsMode) {
      res["TlsMode"] = boost::any(*tlsMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCertContent") != m.end() && !m["CaCertContent"].empty()) {
      caCertContent = make_shared<string>(boost::any_cast<string>(m["CaCertContent"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("Sni") != m.end() && !m["Sni"].empty()) {
      sni = make_shared<string>(boost::any_cast<string>(m["Sni"]));
    }
    if (m.find("TlsMode") != m.end() && !m["TlsMode"].empty()) {
      tlsMode = make_shared<string>(boost::any_cast<string>(m["TlsMode"]));
    }
  }


  virtual ~TrafficPolicyTlsSetting() = default;
};
class TrafficPolicy : public Darabonba::Model {
public:
  shared_ptr<TrafficPolicyLoadBalancerSettings> loadBalancerSettings{};
  shared_ptr<TrafficPolicyTlsSetting> tlsSetting{};

  TrafficPolicy() {}

  explicit TrafficPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSettings) {
      res["LoadBalancerSettings"] = loadBalancerSettings ? boost::any(loadBalancerSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tlsSetting) {
      res["TlsSetting"] = tlsSetting ? boost::any(tlsSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSettings") != m.end() && !m["LoadBalancerSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancerSettings"].type()) {
        TrafficPolicyLoadBalancerSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancerSettings"]));
        loadBalancerSettings = make_shared<TrafficPolicyLoadBalancerSettings>(model1);
      }
    }
    if (m.find("TlsSetting") != m.end() && !m["TlsSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["TlsSetting"].type()) {
        TrafficPolicyTlsSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TlsSetting"]));
        tlsSetting = make_shared<TrafficPolicyTlsSetting>(model1);
      }
    }
  }


  virtual ~TrafficPolicy() = default;
};
class GatewayService : public Darabonba::Model {
public:
  shared_ptr<TrafficPolicy> gatewayTrafficPolicy{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<string> metaInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> sourceType{};

  GatewayService() {}

  explicit GatewayService(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayTrafficPolicy) {
      res["GatewayTrafficPolicy"] = gatewayTrafficPolicy ? boost::any(gatewayTrafficPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (metaInfo) {
      res["MetaInfo"] = boost::any(*metaInfo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayTrafficPolicy") != m.end() && !m["GatewayTrafficPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayTrafficPolicy"].type()) {
        TrafficPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayTrafficPolicy"]));
        gatewayTrafficPolicy = make_shared<TrafficPolicy>(model1);
      }
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MetaInfo") != m.end() && !m["MetaInfo"].empty()) {
      metaInfo = make_shared<string>(boost::any_cast<string>(m["MetaInfo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~GatewayService() = default;
};
class RulesValueRulesSpringcloudRestItems : public Darabonba::Model {
public:
  shared_ptr<string> datum{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> cond{};
  shared_ptr<long> divisor{};
  shared_ptr<long> remainder{};
  shared_ptr<long> rate{};
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<boost::any> value{};

  RulesValueRulesSpringcloudRestItems() {}

  explicit RulesValueRulesSpringcloudRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["value"]));
    }
  }


  virtual ~RulesValueRulesSpringcloudRestItems() = default;
};
class RulesValueRulesSpringcloud : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<RulesValueRulesSpringcloudRestItems>> restItems{};
  shared_ptr<string> triggerPolicy{};
  shared_ptr<bool> enable{};
  shared_ptr<string> appId{};
  shared_ptr<long> priority{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<string> path{};

  RulesValueRulesSpringcloud() {}

  explicit RulesValueRulesSpringcloud(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restItems"] = boost::any(temp1);
    }
    if (triggerPolicy) {
      res["triggerPolicy"] = boost::any(*triggerPolicy);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (paths) {
      res["paths"] = boost::any(*paths);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("restItems") != m.end() && !m["restItems"].empty()) {
      if (typeid(vector<boost::any>) == m["restItems"].type()) {
        vector<RulesValueRulesSpringcloudRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RulesValueRulesSpringcloudRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<RulesValueRulesSpringcloudRestItems>>(expect1);
      }
    }
    if (m.find("triggerPolicy") != m.end() && !m["triggerPolicy"].empty()) {
      triggerPolicy = make_shared<string>(boost::any_cast<string>(m["triggerPolicy"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("paths") != m.end() && !m["paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
  }


  virtual ~RulesValueRulesSpringcloud() = default;
};
class RulesValueRulesDubboArgumentItems : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> datum{};
  shared_ptr<string> cond{};
  shared_ptr<long> divisor{};
  shared_ptr<long> remainder{};
  shared_ptr<long> rate{};
  shared_ptr<long> index{};
  shared_ptr<string> expr{};
  shared_ptr<boost::any> value{};

  RulesValueRulesDubboArgumentItems() {}

  explicit RulesValueRulesDubboArgumentItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<boost::any>(boost::any_cast<boost::any>(m["value"]));
    }
  }


  virtual ~RulesValueRulesDubboArgumentItems() = default;
};
class RulesValueRulesDubbo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> triggerPolicy{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> group{};
  shared_ptr<string> version{};
  shared_ptr<string> methodName{};
  shared_ptr<vector<string>> paramTypes{};
  shared_ptr<string> condition{};
  shared_ptr<vector<RulesValueRulesDubboArgumentItems>> argumentItems{};

  RulesValueRulesDubbo() {}

  explicit RulesValueRulesDubbo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (triggerPolicy) {
      res["triggerPolicy"] = boost::any(*triggerPolicy);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (methodName) {
      res["methodName"] = boost::any(*methodName);
    }
    if (paramTypes) {
      res["paramTypes"] = boost::any(*paramTypes);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (argumentItems) {
      vector<boost::any> temp1;
      for(auto item1:*argumentItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["argumentItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerPolicy") != m.end() && !m["triggerPolicy"].empty()) {
      triggerPolicy = make_shared<string>(boost::any_cast<string>(m["triggerPolicy"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("methodName") != m.end() && !m["methodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["methodName"]));
    }
    if (m.find("paramTypes") != m.end() && !m["paramTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paramTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paramTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paramTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("argumentItems") != m.end() && !m["argumentItems"].empty()) {
      if (typeid(vector<boost::any>) == m["argumentItems"].type()) {
        vector<RulesValueRulesDubboArgumentItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["argumentItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RulesValueRulesDubboArgumentItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        argumentItems = make_shared<vector<RulesValueRulesDubboArgumentItems>>(expect1);
      }
    }
  }


  virtual ~RulesValueRulesDubbo() = default;
};
class RulesValueRules : public Darabonba::Model {
public:
  shared_ptr<vector<RulesValueRulesSpringcloud>> springcloud{};
  shared_ptr<vector<RulesValueRulesDubbo>> dubbo{};

  RulesValueRules() {}

  explicit RulesValueRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (springcloud) {
      vector<boost::any> temp1;
      for(auto item1:*springcloud){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["springcloud"] = boost::any(temp1);
    }
    if (dubbo) {
      vector<boost::any> temp1;
      for(auto item1:*dubbo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dubbo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("springcloud") != m.end() && !m["springcloud"].empty()) {
      if (typeid(vector<boost::any>) == m["springcloud"].type()) {
        vector<RulesValueRulesSpringcloud> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["springcloud"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RulesValueRulesSpringcloud model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        springcloud = make_shared<vector<RulesValueRulesSpringcloud>>(expect1);
      }
    }
    if (m.find("dubbo") != m.end() && !m["dubbo"].empty()) {
      if (typeid(vector<boost::any>) == m["dubbo"].type()) {
        vector<RulesValueRulesDubbo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dubbo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RulesValueRulesDubbo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubbo = make_shared<vector<RulesValueRulesDubbo>>(expect1);
      }
    }
  }


  virtual ~RulesValueRules() = default;
};
class RulesValue : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> rate{};
  shared_ptr<bool> enable{};
  shared_ptr<string> tag{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceNum{};
  shared_ptr<RulesValueRules> rules{};

  RulesValue() {}

  explicit RulesValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        RulesValueRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<RulesValueRules>(model1);
      }
    }
  }


  virtual ~RulesValue() = default;
};
class DataValue : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};

  DataValue() {}

  explicit DataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DataValue() = default;
};
class AddAuthPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> authRule{};
  shared_ptr<long> authType{};
  shared_ptr<string> enable{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> protocol{};
  shared_ptr<string> region{};
  shared_ptr<string> source{};

  AddAuthPolicyRequest() {}

  explicit AddAuthPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authRule) {
      res["AuthRule"] = boost::any(*authRule);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthRule") != m.end() && !m["AuthRule"].empty()) {
      authRule = make_shared<string>(boost::any_cast<string>(m["AuthRule"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<long>(boost::any_cast<long>(m["AuthType"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~AddAuthPolicyRequest() = default;
};
class AddAuthPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddAuthPolicyResponseBody() {}

  explicit AddAuthPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAuthPolicyResponseBody() = default;
};
class AddAuthPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAuthPolicyResponseBody> body{};

  AddAuthPolicyResponse() {}

  explicit AddAuthPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAuthPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAuthPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~AddAuthPolicyResponse() = default;
};
class AddAuthResourceRequestAuthResourceHeaderList : public Darabonba::Model {
public:
  shared_ptr<string> headerKey{};
  shared_ptr<string> headerMethod{};
  shared_ptr<string> headerValue{};

  AddAuthResourceRequestAuthResourceHeaderList() {}

  explicit AddAuthResourceRequestAuthResourceHeaderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerKey) {
      res["HeaderKey"] = boost::any(*headerKey);
    }
    if (headerMethod) {
      res["HeaderMethod"] = boost::any(*headerMethod);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderKey") != m.end() && !m["HeaderKey"].empty()) {
      headerKey = make_shared<string>(boost::any_cast<string>(m["HeaderKey"]));
    }
    if (m.find("HeaderMethod") != m.end() && !m["HeaderMethod"].empty()) {
      headerMethod = make_shared<string>(boost::any_cast<string>(m["HeaderMethod"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~AddAuthResourceRequestAuthResourceHeaderList() = default;
};
class AddAuthResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> authId{};
  shared_ptr<vector<AddAuthResourceRequestAuthResourceHeaderList>> authResourceHeaderList{};
  shared_ptr<long> domainId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> matchType{};
  shared_ptr<string> path{};

  AddAuthResourceRequest() {}

  explicit AddAuthResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (authId) {
      res["AuthId"] = boost::any(*authId);
    }
    if (authResourceHeaderList) {
      vector<boost::any> temp1;
      for(auto item1:*authResourceHeaderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthResourceHeaderList"] = boost::any(temp1);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AuthId") != m.end() && !m["AuthId"].empty()) {
      authId = make_shared<long>(boost::any_cast<long>(m["AuthId"]));
    }
    if (m.find("AuthResourceHeaderList") != m.end() && !m["AuthResourceHeaderList"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthResourceHeaderList"].type()) {
        vector<AddAuthResourceRequestAuthResourceHeaderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthResourceHeaderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddAuthResourceRequestAuthResourceHeaderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authResourceHeaderList = make_shared<vector<AddAuthResourceRequestAuthResourceHeaderList>>(expect1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AddAuthResourceRequest() = default;
};
class AddAuthResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> authId{};
  shared_ptr<string> authResourceHeaderListShrink{};
  shared_ptr<long> domainId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> matchType{};
  shared_ptr<string> path{};

  AddAuthResourceShrinkRequest() {}

  explicit AddAuthResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (authId) {
      res["AuthId"] = boost::any(*authId);
    }
    if (authResourceHeaderListShrink) {
      res["AuthResourceHeaderList"] = boost::any(*authResourceHeaderListShrink);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (matchType) {
      res["MatchType"] = boost::any(*matchType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AuthId") != m.end() && !m["AuthId"].empty()) {
      authId = make_shared<long>(boost::any_cast<long>(m["AuthId"]));
    }
    if (m.find("AuthResourceHeaderList") != m.end() && !m["AuthResourceHeaderList"].empty()) {
      authResourceHeaderListShrink = make_shared<string>(boost::any_cast<string>(m["AuthResourceHeaderList"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("MatchType") != m.end() && !m["MatchType"].empty()) {
      matchType = make_shared<string>(boost::any_cast<string>(m["MatchType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AddAuthResourceShrinkRequest() = default;
};
class AddAuthResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddAuthResourceResponseBody() {}

  explicit AddAuthResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAuthResourceResponseBody() = default;
};
class AddAuthResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAuthResourceResponseBody> body{};

  AddAuthResourceResponse() {}

  explicit AddAuthResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAuthResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAuthResourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddAuthResourceResponse() = default;
};
class AddBlackWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> content{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<bool> isWhite{};
  shared_ptr<string> name{};
  shared_ptr<string> note{};
  shared_ptr<string> resourceIdJsonList{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  AddBlackWhiteListRequest() {}

  explicit AddBlackWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (isWhite) {
      res["IsWhite"] = boost::any(*isWhite);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (resourceIdJsonList) {
      res["ResourceIdJsonList"] = boost::any(*resourceIdJsonList);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IsWhite") != m.end() && !m["IsWhite"].empty()) {
      isWhite = make_shared<bool>(boost::any_cast<bool>(m["IsWhite"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("ResourceIdJsonList") != m.end() && !m["ResourceIdJsonList"].empty()) {
      resourceIdJsonList = make_shared<string>(boost::any_cast<string>(m["ResourceIdJsonList"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddBlackWhiteListRequest() = default;
};
class AddBlackWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddBlackWhiteListResponseBody() {}

  explicit AddBlackWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddBlackWhiteListResponseBody() = default;
};
class AddBlackWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddBlackWhiteListResponseBody> body{};

  AddBlackWhiteListResponse() {}

  explicit AddBlackWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBlackWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBlackWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~AddBlackWhiteListResponse() = default;
};
class AddGatewayRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddGatewayRequestTag() {}

  explicit AddGatewayRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddGatewayRequestTag() = default;
};
class AddGatewayRequestZoneInfo : public Darabonba::Model {
public:
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  AddGatewayRequestZoneInfo() {}

  explicit AddGatewayRequestZoneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~AddGatewayRequestZoneInfo() = default;
};
class AddGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> enableHardwareAcceleration{};
  shared_ptr<bool> enableSls{};
  shared_ptr<bool> enableXtrace{};
  shared_ptr<bool> enterpriseSecurityGroup{};
  shared_ptr<string> internetSlbSpec{};
  shared_ptr<string> mserVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> nlbNetworkType{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> slbSpec{};
  shared_ptr<string> spec{};
  shared_ptr<vector<AddGatewayRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchId2{};
  shared_ptr<string> vpc{};
  shared_ptr<string> xtraceRatio{};
  shared_ptr<vector<AddGatewayRequestZoneInfo>> zoneInfo{};

  AddGatewayRequest() {}

  explicit AddGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (enableHardwareAcceleration) {
      res["EnableHardwareAcceleration"] = boost::any(*enableHardwareAcceleration);
    }
    if (enableSls) {
      res["EnableSls"] = boost::any(*enableSls);
    }
    if (enableXtrace) {
      res["EnableXtrace"] = boost::any(*enableXtrace);
    }
    if (enterpriseSecurityGroup) {
      res["EnterpriseSecurityGroup"] = boost::any(*enterpriseSecurityGroup);
    }
    if (internetSlbSpec) {
      res["InternetSlbSpec"] = boost::any(*internetSlbSpec);
    }
    if (mserVersion) {
      res["MserVersion"] = boost::any(*mserVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nlbNetworkType) {
      res["NlbNetworkType"] = boost::any(*nlbNetworkType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (slbSpec) {
      res["SlbSpec"] = boost::any(*slbSpec);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchId2) {
      res["VSwitchId2"] = boost::any(*vSwitchId2);
    }
    if (vpc) {
      res["Vpc"] = boost::any(*vpc);
    }
    if (xtraceRatio) {
      res["XtraceRatio"] = boost::any(*xtraceRatio);
    }
    if (zoneInfo) {
      vector<boost::any> temp1;
      for(auto item1:*zoneInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("EnableHardwareAcceleration") != m.end() && !m["EnableHardwareAcceleration"].empty()) {
      enableHardwareAcceleration = make_shared<bool>(boost::any_cast<bool>(m["EnableHardwareAcceleration"]));
    }
    if (m.find("EnableSls") != m.end() && !m["EnableSls"].empty()) {
      enableSls = make_shared<bool>(boost::any_cast<bool>(m["EnableSls"]));
    }
    if (m.find("EnableXtrace") != m.end() && !m["EnableXtrace"].empty()) {
      enableXtrace = make_shared<bool>(boost::any_cast<bool>(m["EnableXtrace"]));
    }
    if (m.find("EnterpriseSecurityGroup") != m.end() && !m["EnterpriseSecurityGroup"].empty()) {
      enterpriseSecurityGroup = make_shared<bool>(boost::any_cast<bool>(m["EnterpriseSecurityGroup"]));
    }
    if (m.find("InternetSlbSpec") != m.end() && !m["InternetSlbSpec"].empty()) {
      internetSlbSpec = make_shared<string>(boost::any_cast<string>(m["InternetSlbSpec"]));
    }
    if (m.find("MserVersion") != m.end() && !m["MserVersion"].empty()) {
      mserVersion = make_shared<string>(boost::any_cast<string>(m["MserVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NlbNetworkType") != m.end() && !m["NlbNetworkType"].empty()) {
      nlbNetworkType = make_shared<string>(boost::any_cast<string>(m["NlbNetworkType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SlbSpec") != m.end() && !m["SlbSpec"].empty()) {
      slbSpec = make_shared<string>(boost::any_cast<string>(m["SlbSpec"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddGatewayRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddGatewayRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchId2") != m.end() && !m["VSwitchId2"].empty()) {
      vSwitchId2 = make_shared<string>(boost::any_cast<string>(m["VSwitchId2"]));
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      vpc = make_shared<string>(boost::any_cast<string>(m["Vpc"]));
    }
    if (m.find("XtraceRatio") != m.end() && !m["XtraceRatio"].empty()) {
      xtraceRatio = make_shared<string>(boost::any_cast<string>(m["XtraceRatio"]));
    }
    if (m.find("ZoneInfo") != m.end() && !m["ZoneInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneInfo"].type()) {
        vector<AddGatewayRequestZoneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRequestZoneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneInfo = make_shared<vector<AddGatewayRequestZoneInfo>>(expect1);
      }
    }
  }


  virtual ~AddGatewayRequest() = default;
};
class AddGatewayShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddGatewayShrinkRequestTag() {}

  explicit AddGatewayShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddGatewayShrinkRequestTag() = default;
};
class AddGatewayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> enableHardwareAcceleration{};
  shared_ptr<bool> enableSls{};
  shared_ptr<bool> enableXtrace{};
  shared_ptr<bool> enterpriseSecurityGroup{};
  shared_ptr<string> internetSlbSpec{};
  shared_ptr<string> mserVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> nlbNetworkType{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> slbSpec{};
  shared_ptr<string> spec{};
  shared_ptr<vector<AddGatewayShrinkRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vSwitchId2{};
  shared_ptr<string> vpc{};
  shared_ptr<string> xtraceRatio{};
  shared_ptr<string> zoneInfoShrink{};

  AddGatewayShrinkRequest() {}

  explicit AddGatewayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (enableHardwareAcceleration) {
      res["EnableHardwareAcceleration"] = boost::any(*enableHardwareAcceleration);
    }
    if (enableSls) {
      res["EnableSls"] = boost::any(*enableSls);
    }
    if (enableXtrace) {
      res["EnableXtrace"] = boost::any(*enableXtrace);
    }
    if (enterpriseSecurityGroup) {
      res["EnterpriseSecurityGroup"] = boost::any(*enterpriseSecurityGroup);
    }
    if (internetSlbSpec) {
      res["InternetSlbSpec"] = boost::any(*internetSlbSpec);
    }
    if (mserVersion) {
      res["MserVersion"] = boost::any(*mserVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nlbNetworkType) {
      res["NlbNetworkType"] = boost::any(*nlbNetworkType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (slbSpec) {
      res["SlbSpec"] = boost::any(*slbSpec);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vSwitchId2) {
      res["VSwitchId2"] = boost::any(*vSwitchId2);
    }
    if (vpc) {
      res["Vpc"] = boost::any(*vpc);
    }
    if (xtraceRatio) {
      res["XtraceRatio"] = boost::any(*xtraceRatio);
    }
    if (zoneInfoShrink) {
      res["ZoneInfo"] = boost::any(*zoneInfoShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("EnableHardwareAcceleration") != m.end() && !m["EnableHardwareAcceleration"].empty()) {
      enableHardwareAcceleration = make_shared<bool>(boost::any_cast<bool>(m["EnableHardwareAcceleration"]));
    }
    if (m.find("EnableSls") != m.end() && !m["EnableSls"].empty()) {
      enableSls = make_shared<bool>(boost::any_cast<bool>(m["EnableSls"]));
    }
    if (m.find("EnableXtrace") != m.end() && !m["EnableXtrace"].empty()) {
      enableXtrace = make_shared<bool>(boost::any_cast<bool>(m["EnableXtrace"]));
    }
    if (m.find("EnterpriseSecurityGroup") != m.end() && !m["EnterpriseSecurityGroup"].empty()) {
      enterpriseSecurityGroup = make_shared<bool>(boost::any_cast<bool>(m["EnterpriseSecurityGroup"]));
    }
    if (m.find("InternetSlbSpec") != m.end() && !m["InternetSlbSpec"].empty()) {
      internetSlbSpec = make_shared<string>(boost::any_cast<string>(m["InternetSlbSpec"]));
    }
    if (m.find("MserVersion") != m.end() && !m["MserVersion"].empty()) {
      mserVersion = make_shared<string>(boost::any_cast<string>(m["MserVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NlbNetworkType") != m.end() && !m["NlbNetworkType"].empty()) {
      nlbNetworkType = make_shared<string>(boost::any_cast<string>(m["NlbNetworkType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SlbSpec") != m.end() && !m["SlbSpec"].empty()) {
      slbSpec = make_shared<string>(boost::any_cast<string>(m["SlbSpec"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddGatewayShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddGatewayShrinkRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VSwitchId2") != m.end() && !m["VSwitchId2"].empty()) {
      vSwitchId2 = make_shared<string>(boost::any_cast<string>(m["VSwitchId2"]));
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      vpc = make_shared<string>(boost::any_cast<string>(m["Vpc"]));
    }
    if (m.find("XtraceRatio") != m.end() && !m["XtraceRatio"].empty()) {
      xtraceRatio = make_shared<string>(boost::any_cast<string>(m["XtraceRatio"]));
    }
    if (m.find("ZoneInfo") != m.end() && !m["ZoneInfo"].empty()) {
      zoneInfoShrink = make_shared<string>(boost::any_cast<string>(m["ZoneInfo"]));
    }
  }


  virtual ~AddGatewayShrinkRequest() = default;
};
class AddGatewayResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gatewayUniqueId{};

  AddGatewayResponseBodyData() {}

  explicit AddGatewayResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~AddGatewayResponseBodyData() = default;
};
class AddGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddGatewayResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewayResponseBody() {}

  explicit AddGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddGatewayResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddGatewayResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewayResponseBody() = default;
};
class AddGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewayResponseBody> body{};

  AddGatewayResponse() {}

  explicit AddGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewayResponse() = default;
};
class AddGatewayAuthConsumerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> description{};
  shared_ptr<string> encodeType{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> jwks{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyValue{};
  shared_ptr<string> name{};
  shared_ptr<string> tokenName{};
  shared_ptr<bool> tokenPass{};
  shared_ptr<string> tokenPosition{};
  shared_ptr<string> tokenPrefix{};
  shared_ptr<string> type{};

  AddGatewayAuthConsumerRequest() {}

  explicit AddGatewayAuthConsumerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encodeType) {
      res["EncodeType"] = boost::any(*encodeType);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (jwks) {
      res["Jwks"] = boost::any(*jwks);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyValue) {
      res["KeyValue"] = boost::any(*keyValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tokenName) {
      res["TokenName"] = boost::any(*tokenName);
    }
    if (tokenPass) {
      res["TokenPass"] = boost::any(*tokenPass);
    }
    if (tokenPosition) {
      res["TokenPosition"] = boost::any(*tokenPosition);
    }
    if (tokenPrefix) {
      res["TokenPrefix"] = boost::any(*tokenPrefix);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EncodeType") != m.end() && !m["EncodeType"].empty()) {
      encodeType = make_shared<string>(boost::any_cast<string>(m["EncodeType"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Jwks") != m.end() && !m["Jwks"].empty()) {
      jwks = make_shared<string>(boost::any_cast<string>(m["Jwks"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyValue") != m.end() && !m["KeyValue"].empty()) {
      keyValue = make_shared<string>(boost::any_cast<string>(m["KeyValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TokenName") != m.end() && !m["TokenName"].empty()) {
      tokenName = make_shared<string>(boost::any_cast<string>(m["TokenName"]));
    }
    if (m.find("TokenPass") != m.end() && !m["TokenPass"].empty()) {
      tokenPass = make_shared<bool>(boost::any_cast<bool>(m["TokenPass"]));
    }
    if (m.find("TokenPosition") != m.end() && !m["TokenPosition"].empty()) {
      tokenPosition = make_shared<string>(boost::any_cast<string>(m["TokenPosition"]));
    }
    if (m.find("TokenPrefix") != m.end() && !m["TokenPrefix"].empty()) {
      tokenPrefix = make_shared<string>(boost::any_cast<string>(m["TokenPrefix"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddGatewayAuthConsumerRequest() = default;
};
class AddGatewayAuthConsumerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewayAuthConsumerResponseBody() {}

  explicit AddGatewayAuthConsumerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewayAuthConsumerResponseBody() = default;
};
class AddGatewayAuthConsumerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewayAuthConsumerResponseBody> body{};

  AddGatewayAuthConsumerResponse() {}

  explicit AddGatewayAuthConsumerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewayAuthConsumerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewayAuthConsumerResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewayAuthConsumerResponse() = default;
};
class AddGatewayDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> http2{};
  shared_ptr<bool> mustHttps{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> tlsMax{};
  shared_ptr<string> tlsMin{};

  AddGatewayDomainRequest() {}

  explicit AddGatewayDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tlsMax) {
      res["TlsMax"] = boost::any(*tlsMax);
    }
    if (tlsMin) {
      res["TlsMin"] = boost::any(*tlsMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<bool>(boost::any_cast<bool>(m["MustHttps"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TlsMax") != m.end() && !m["TlsMax"].empty()) {
      tlsMax = make_shared<string>(boost::any_cast<string>(m["TlsMax"]));
    }
    if (m.find("TlsMin") != m.end() && !m["TlsMin"].empty()) {
      tlsMin = make_shared<string>(boost::any_cast<string>(m["TlsMin"]));
    }
  }


  virtual ~AddGatewayDomainRequest() = default;
};
class AddGatewayDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewayDomainResponseBody() {}

  explicit AddGatewayDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewayDomainResponseBody() = default;
};
class AddGatewayDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewayDomainResponseBody> body{};

  AddGatewayDomainResponse() {}

  explicit AddGatewayDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewayDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewayDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewayDomainResponse() = default;
};
class AddGatewayRouteRequestDirectResponseJSON : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> code{};

  AddGatewayRouteRequestDirectResponseJSON() {}

  explicit AddGatewayRouteRequestDirectResponseJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~AddGatewayRouteRequestDirectResponseJSON() = default;
};
class AddGatewayRouteRequestFallbackServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  AddGatewayRouteRequestFallbackServices() {}

  explicit AddGatewayRouteRequestFallbackServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AddGatewayRouteRequestFallbackServices() = default;
};
class AddGatewayRouteRequestPredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  AddGatewayRouteRequestPredicatesHeaderPredicates() {}

  explicit AddGatewayRouteRequestPredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddGatewayRouteRequestPredicatesHeaderPredicates() = default;
};
class AddGatewayRouteRequestPredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  AddGatewayRouteRequestPredicatesPathPredicates() {}

  explicit AddGatewayRouteRequestPredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddGatewayRouteRequestPredicatesPathPredicates() = default;
};
class AddGatewayRouteRequestPredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  AddGatewayRouteRequestPredicatesQueryPredicates() {}

  explicit AddGatewayRouteRequestPredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddGatewayRouteRequestPredicatesQueryPredicates() = default;
};
class AddGatewayRouteRequestPredicates : public Darabonba::Model {
public:
  shared_ptr<vector<AddGatewayRouteRequestPredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<AddGatewayRouteRequestPredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<AddGatewayRouteRequestPredicatesQueryPredicates>> queryPredicates{};

  AddGatewayRouteRequestPredicates() {}

  explicit AddGatewayRouteRequestPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<AddGatewayRouteRequestPredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestPredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<AddGatewayRouteRequestPredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        AddGatewayRouteRequestPredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<AddGatewayRouteRequestPredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<AddGatewayRouteRequestPredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestPredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<AddGatewayRouteRequestPredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~AddGatewayRouteRequestPredicates() = default;
};
class AddGatewayRouteRequestRedirectJSON : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> host{};
  shared_ptr<string> path{};

  AddGatewayRouteRequestRedirectJSON() {}

  explicit AddGatewayRouteRequestRedirectJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~AddGatewayRouteRequestRedirectJSON() = default;
};
class AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList : public Darabonba::Model {
public:
  shared_ptr<string> extractKey{};
  shared_ptr<string> extractKeySpec{};
  shared_ptr<string> mappingType{};

  AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList() {}

  explicit AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractKey) {
      res["ExtractKey"] = boost::any(*extractKey);
    }
    if (extractKeySpec) {
      res["ExtractKeySpec"] = boost::any(*extractKeySpec);
    }
    if (mappingType) {
      res["MappingType"] = boost::any(*mappingType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractKey") != m.end() && !m["ExtractKey"].empty()) {
      extractKey = make_shared<string>(boost::any_cast<string>(m["ExtractKey"]));
    }
    if (m.find("ExtractKeySpec") != m.end() && !m["ExtractKeySpec"].empty()) {
      extractKeySpec = make_shared<string>(boost::any_cast<string>(m["ExtractKeySpec"]));
    }
    if (m.find("MappingType") != m.end() && !m["MappingType"].empty()) {
      mappingType = make_shared<string>(boost::any_cast<string>(m["MappingType"]));
    }
  }


  virtual ~AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList() = default;
};
class AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList : public Darabonba::Model {
public:
  shared_ptr<string> dubboMothedName{};
  shared_ptr<string> httpMothed{};
  shared_ptr<string> mothedpath{};
  shared_ptr<vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList>> paramMapsList{};
  shared_ptr<string> passThroughAllHeaders{};
  shared_ptr<vector<string>> passThroughList{};

  AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList() {}

  explicit AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboMothedName) {
      res["DubboMothedName"] = boost::any(*dubboMothedName);
    }
    if (httpMothed) {
      res["HttpMothed"] = boost::any(*httpMothed);
    }
    if (mothedpath) {
      res["Mothedpath"] = boost::any(*mothedpath);
    }
    if (paramMapsList) {
      vector<boost::any> temp1;
      for(auto item1:*paramMapsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamMapsList"] = boost::any(temp1);
    }
    if (passThroughAllHeaders) {
      res["PassThroughAllHeaders"] = boost::any(*passThroughAllHeaders);
    }
    if (passThroughList) {
      res["PassThroughList"] = boost::any(*passThroughList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboMothedName") != m.end() && !m["DubboMothedName"].empty()) {
      dubboMothedName = make_shared<string>(boost::any_cast<string>(m["DubboMothedName"]));
    }
    if (m.find("HttpMothed") != m.end() && !m["HttpMothed"].empty()) {
      httpMothed = make_shared<string>(boost::any_cast<string>(m["HttpMothed"]));
    }
    if (m.find("Mothedpath") != m.end() && !m["Mothedpath"].empty()) {
      mothedpath = make_shared<string>(boost::any_cast<string>(m["Mothedpath"]));
    }
    if (m.find("ParamMapsList") != m.end() && !m["ParamMapsList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamMapsList"].type()) {
        vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamMapsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramMapsList = make_shared<vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList>>(expect1);
      }
    }
    if (m.find("PassThroughAllHeaders") != m.end() && !m["PassThroughAllHeaders"].empty()) {
      passThroughAllHeaders = make_shared<string>(boost::any_cast<string>(m["PassThroughAllHeaders"]));
    }
    if (m.find("PassThroughList") != m.end() && !m["PassThroughList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PassThroughList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PassThroughList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passThroughList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList() = default;
};
class AddGatewayRouteRequestServicesHttpDubboTranscoder : public Darabonba::Model {
public:
  shared_ptr<string> dubboServiceGroup{};
  shared_ptr<string> dubboServiceName{};
  shared_ptr<string> dubboServiceVersion{};
  shared_ptr<vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList>> mothedMapList{};

  AddGatewayRouteRequestServicesHttpDubboTranscoder() {}

  explicit AddGatewayRouteRequestServicesHttpDubboTranscoder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboServiceGroup) {
      res["DubboServiceGroup"] = boost::any(*dubboServiceGroup);
    }
    if (dubboServiceName) {
      res["DubboServiceName"] = boost::any(*dubboServiceName);
    }
    if (dubboServiceVersion) {
      res["DubboServiceVersion"] = boost::any(*dubboServiceVersion);
    }
    if (mothedMapList) {
      vector<boost::any> temp1;
      for(auto item1:*mothedMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MothedMapList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboServiceGroup") != m.end() && !m["DubboServiceGroup"].empty()) {
      dubboServiceGroup = make_shared<string>(boost::any_cast<string>(m["DubboServiceGroup"]));
    }
    if (m.find("DubboServiceName") != m.end() && !m["DubboServiceName"].empty()) {
      dubboServiceName = make_shared<string>(boost::any_cast<string>(m["DubboServiceName"]));
    }
    if (m.find("DubboServiceVersion") != m.end() && !m["DubboServiceVersion"].empty()) {
      dubboServiceVersion = make_shared<string>(boost::any_cast<string>(m["DubboServiceVersion"]));
    }
    if (m.find("MothedMapList") != m.end() && !m["MothedMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["MothedMapList"].type()) {
        vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MothedMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mothedMapList = make_shared<vector<AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList>>(expect1);
      }
    }
  }


  virtual ~AddGatewayRouteRequestServicesHttpDubboTranscoder() = default;
};
class AddGatewayRouteRequestServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<AddGatewayRouteRequestServicesHttpDubboTranscoder> httpDubboTranscoder{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  AddGatewayRouteRequestServices() {}

  explicit AddGatewayRouteRequestServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpDubboTranscoder) {
      res["HttpDubboTranscoder"] = httpDubboTranscoder ? boost::any(httpDubboTranscoder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpDubboTranscoder") != m.end() && !m["HttpDubboTranscoder"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpDubboTranscoder"].type()) {
        AddGatewayRouteRequestServicesHttpDubboTranscoder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpDubboTranscoder"]));
        httpDubboTranscoder = make_shared<AddGatewayRouteRequestServicesHttpDubboTranscoder>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AddGatewayRouteRequestServices() = default;
};
class AddGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> destinationType{};
  shared_ptr<AddGatewayRouteRequestDirectResponseJSON> directResponseJSON{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainIdListJSON{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<vector<AddGatewayRouteRequestFallbackServices>> fallbackServices{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};
  shared_ptr<string> policies{};
  shared_ptr<AddGatewayRouteRequestPredicates> predicates{};
  shared_ptr<AddGatewayRouteRequestRedirectJSON> redirectJSON{};
  shared_ptr<long> routeOrder{};
  shared_ptr<string> routeType{};
  shared_ptr<vector<AddGatewayRouteRequestServices>> services{};

  AddGatewayRouteRequest() {}

  explicit AddGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponseJSON) {
      res["DirectResponseJSON"] = directResponseJSON ? boost::any(directResponseJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdListJSON) {
      res["DomainIdListJSON"] = boost::any(*domainIdListJSON);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServices) {
      vector<boost::any> temp1;
      for(auto item1:*fallbackServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FallbackServices"] = boost::any(temp1);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policies) {
      res["Policies"] = boost::any(*policies);
    }
    if (predicates) {
      res["Predicates"] = predicates ? boost::any(predicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectJSON) {
      res["RedirectJSON"] = redirectJSON ? boost::any(redirectJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (routeType) {
      res["RouteType"] = boost::any(*routeType);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponseJSON") != m.end() && !m["DirectResponseJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["DirectResponseJSON"].type()) {
        AddGatewayRouteRequestDirectResponseJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DirectResponseJSON"]));
        directResponseJSON = make_shared<AddGatewayRouteRequestDirectResponseJSON>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdListJSON") != m.end() && !m["DomainIdListJSON"].empty()) {
      domainIdListJSON = make_shared<string>(boost::any_cast<string>(m["DomainIdListJSON"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      if (typeid(vector<boost::any>) == m["FallbackServices"].type()) {
        vector<AddGatewayRouteRequestFallbackServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FallbackServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestFallbackServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fallbackServices = make_shared<vector<AddGatewayRouteRequestFallbackServices>>(expect1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      policies = make_shared<string>(boost::any_cast<string>(m["Policies"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Predicates"].type()) {
        AddGatewayRouteRequestPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Predicates"]));
        predicates = make_shared<AddGatewayRouteRequestPredicates>(model1);
      }
    }
    if (m.find("RedirectJSON") != m.end() && !m["RedirectJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["RedirectJSON"].type()) {
        AddGatewayRouteRequestRedirectJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RedirectJSON"]));
        redirectJSON = make_shared<AddGatewayRouteRequestRedirectJSON>(model1);
      }
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("RouteType") != m.end() && !m["RouteType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["RouteType"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<AddGatewayRouteRequestServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewayRouteRequestServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<AddGatewayRouteRequestServices>>(expect1);
      }
    }
  }


  virtual ~AddGatewayRouteRequest() = default;
};
class AddGatewayRouteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> destinationType{};
  shared_ptr<string> directResponseJSONShrink{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainIdListJSON{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<string> fallbackServicesShrink{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};
  shared_ptr<string> policies{};
  shared_ptr<string> predicatesShrink{};
  shared_ptr<string> redirectJSONShrink{};
  shared_ptr<long> routeOrder{};
  shared_ptr<string> routeType{};
  shared_ptr<string> servicesShrink{};

  AddGatewayRouteShrinkRequest() {}

  explicit AddGatewayRouteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponseJSONShrink) {
      res["DirectResponseJSON"] = boost::any(*directResponseJSONShrink);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdListJSON) {
      res["DomainIdListJSON"] = boost::any(*domainIdListJSON);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServicesShrink) {
      res["FallbackServices"] = boost::any(*fallbackServicesShrink);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policies) {
      res["Policies"] = boost::any(*policies);
    }
    if (predicatesShrink) {
      res["Predicates"] = boost::any(*predicatesShrink);
    }
    if (redirectJSONShrink) {
      res["RedirectJSON"] = boost::any(*redirectJSONShrink);
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (routeType) {
      res["RouteType"] = boost::any(*routeType);
    }
    if (servicesShrink) {
      res["Services"] = boost::any(*servicesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponseJSON") != m.end() && !m["DirectResponseJSON"].empty()) {
      directResponseJSONShrink = make_shared<string>(boost::any_cast<string>(m["DirectResponseJSON"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdListJSON") != m.end() && !m["DomainIdListJSON"].empty()) {
      domainIdListJSON = make_shared<string>(boost::any_cast<string>(m["DomainIdListJSON"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      fallbackServicesShrink = make_shared<string>(boost::any_cast<string>(m["FallbackServices"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      policies = make_shared<string>(boost::any_cast<string>(m["Policies"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicatesShrink = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("RedirectJSON") != m.end() && !m["RedirectJSON"].empty()) {
      redirectJSONShrink = make_shared<string>(boost::any_cast<string>(m["RedirectJSON"]));
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("RouteType") != m.end() && !m["RouteType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["RouteType"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      servicesShrink = make_shared<string>(boost::any_cast<string>(m["Services"]));
    }
  }


  virtual ~AddGatewayRouteShrinkRequest() = default;
};
class AddGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewayRouteResponseBody() {}

  explicit AddGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewayRouteResponseBody() = default;
};
class AddGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewayRouteResponseBody> body{};

  AddGatewayRouteResponse() {}

  explicit AddGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewayRouteResponse() = default;
};
class AddGatewayServiceVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceVersion{};

  AddGatewayServiceVersionRequest() {}

  explicit AddGatewayServiceVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~AddGatewayServiceVersionRequest() = default;
};
class AddGatewayServiceVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewayServiceVersionResponseBody() {}

  explicit AddGatewayServiceVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewayServiceVersionResponseBody() = default;
};
class AddGatewayServiceVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewayServiceVersionResponseBody> body{};

  AddGatewayServiceVersionResponse() {}

  explicit AddGatewayServiceVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewayServiceVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewayServiceVersionResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewayServiceVersionResponse() = default;
};
class AddGatewaySlbRequestVServiceList : public Darabonba::Model {
public:
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> VServerGroupName{};

  AddGatewaySlbRequestVServiceList() {}

  explicit AddGatewaySlbRequestVServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServerGroupName) {
      res["VServerGroupName"] = boost::any(*VServerGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServerGroupName") != m.end() && !m["VServerGroupName"].empty()) {
      VServerGroupName = make_shared<string>(boost::any_cast<string>(m["VServerGroupName"]));
    }
  }


  virtual ~AddGatewaySlbRequestVServiceList() = default;
};
class AddGatewaySlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> httpsPort{};
  shared_ptr<string> httpsVServerGroupId{};
  shared_ptr<long> serviceWeight{};
  shared_ptr<string> slbId{};
  shared_ptr<string> type{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<vector<AddGatewaySlbRequestVServiceList>> VServiceList{};

  AddGatewaySlbRequest() {}

  explicit AddGatewaySlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (httpsPort) {
      res["HttpsPort"] = boost::any(*httpsPort);
    }
    if (httpsVServerGroupId) {
      res["HttpsVServerGroupId"] = boost::any(*httpsVServerGroupId);
    }
    if (serviceWeight) {
      res["ServiceWeight"] = boost::any(*serviceWeight);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServiceList) {
      vector<boost::any> temp1;
      for(auto item1:*VServiceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServiceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("HttpsPort") != m.end() && !m["HttpsPort"].empty()) {
      httpsPort = make_shared<long>(boost::any_cast<long>(m["HttpsPort"]));
    }
    if (m.find("HttpsVServerGroupId") != m.end() && !m["HttpsVServerGroupId"].empty()) {
      httpsVServerGroupId = make_shared<string>(boost::any_cast<string>(m["HttpsVServerGroupId"]));
    }
    if (m.find("ServiceWeight") != m.end() && !m["ServiceWeight"].empty()) {
      serviceWeight = make_shared<long>(boost::any_cast<long>(m["ServiceWeight"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServiceList") != m.end() && !m["VServiceList"].empty()) {
      if (typeid(vector<boost::any>) == m["VServiceList"].type()) {
        vector<AddGatewaySlbRequestVServiceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServiceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddGatewaySlbRequestVServiceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServiceList = make_shared<vector<AddGatewaySlbRequestVServiceList>>(expect1);
      }
    }
  }


  virtual ~AddGatewaySlbRequest() = default;
};
class AddGatewaySlbShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> httpsPort{};
  shared_ptr<string> httpsVServerGroupId{};
  shared_ptr<long> serviceWeight{};
  shared_ptr<string> slbId{};
  shared_ptr<string> type{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> VServiceListShrink{};

  AddGatewaySlbShrinkRequest() {}

  explicit AddGatewaySlbShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (httpsPort) {
      res["HttpsPort"] = boost::any(*httpsPort);
    }
    if (httpsVServerGroupId) {
      res["HttpsVServerGroupId"] = boost::any(*httpsVServerGroupId);
    }
    if (serviceWeight) {
      res["ServiceWeight"] = boost::any(*serviceWeight);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServiceListShrink) {
      res["VServiceList"] = boost::any(*VServiceListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("HttpsPort") != m.end() && !m["HttpsPort"].empty()) {
      httpsPort = make_shared<long>(boost::any_cast<long>(m["HttpsPort"]));
    }
    if (m.find("HttpsVServerGroupId") != m.end() && !m["HttpsVServerGroupId"].empty()) {
      httpsVServerGroupId = make_shared<string>(boost::any_cast<string>(m["HttpsVServerGroupId"]));
    }
    if (m.find("ServiceWeight") != m.end() && !m["ServiceWeight"].empty()) {
      serviceWeight = make_shared<long>(boost::any_cast<long>(m["ServiceWeight"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServiceList") != m.end() && !m["VServiceList"].empty()) {
      VServiceListShrink = make_shared<string>(boost::any_cast<string>(m["VServiceList"]));
    }
  }


  virtual ~AddGatewaySlbShrinkRequest() = default;
};
class AddGatewaySlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddGatewaySlbResponseBody() {}

  explicit AddGatewaySlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddGatewaySlbResponseBody() = default;
};
class AddGatewaySlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddGatewaySlbResponseBody> body{};

  AddGatewaySlbResponse() {}

  explicit AddGatewaySlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddGatewaySlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddGatewaySlbResponseBody>(model1);
      }
    }
  }


  virtual ~AddGatewaySlbResponse() = default;
};
class AddMigrationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> originInstanceAddress{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<string> originInstanceNamespace{};
  shared_ptr<string> projectDesc{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> targetClusterName{};
  shared_ptr<string> targetClusterUrl{};
  shared_ptr<string> targetInstanceId{};

  AddMigrationTaskRequest() {}

  explicit AddMigrationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (originInstanceAddress) {
      res["OriginInstanceAddress"] = boost::any(*originInstanceAddress);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (originInstanceNamespace) {
      res["OriginInstanceNamespace"] = boost::any(*originInstanceNamespace);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (targetClusterName) {
      res["TargetClusterName"] = boost::any(*targetClusterName);
    }
    if (targetClusterUrl) {
      res["TargetClusterUrl"] = boost::any(*targetClusterUrl);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("OriginInstanceAddress") != m.end() && !m["OriginInstanceAddress"].empty()) {
      originInstanceAddress = make_shared<string>(boost::any_cast<string>(m["OriginInstanceAddress"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("OriginInstanceNamespace") != m.end() && !m["OriginInstanceNamespace"].empty()) {
      originInstanceNamespace = make_shared<string>(boost::any_cast<string>(m["OriginInstanceNamespace"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("TargetClusterName") != m.end() && !m["TargetClusterName"].empty()) {
      targetClusterName = make_shared<string>(boost::any_cast<string>(m["TargetClusterName"]));
    }
    if (m.find("TargetClusterUrl") != m.end() && !m["TargetClusterUrl"].empty()) {
      targetClusterUrl = make_shared<string>(boost::any_cast<string>(m["TargetClusterUrl"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~AddMigrationTaskRequest() = default;
};
class AddMigrationTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> id{};
  shared_ptr<string> originInstanceAddress{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<string> originInstanceNamespace{};
  shared_ptr<string> projectDesc{};
  shared_ptr<string> targetClusterName{};
  shared_ptr<string> targetClusterUrl{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> userId{};

  AddMigrationTaskResponseBodyData() {}

  explicit AddMigrationTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originInstanceAddress) {
      res["OriginInstanceAddress"] = boost::any(*originInstanceAddress);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (originInstanceNamespace) {
      res["OriginInstanceNamespace"] = boost::any(*originInstanceNamespace);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    if (targetClusterName) {
      res["TargetClusterName"] = boost::any(*targetClusterName);
    }
    if (targetClusterUrl) {
      res["TargetClusterUrl"] = boost::any(*targetClusterUrl);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OriginInstanceAddress") != m.end() && !m["OriginInstanceAddress"].empty()) {
      originInstanceAddress = make_shared<string>(boost::any_cast<string>(m["OriginInstanceAddress"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("OriginInstanceNamespace") != m.end() && !m["OriginInstanceNamespace"].empty()) {
      originInstanceNamespace = make_shared<string>(boost::any_cast<string>(m["OriginInstanceNamespace"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
    if (m.find("TargetClusterName") != m.end() && !m["TargetClusterName"].empty()) {
      targetClusterName = make_shared<string>(boost::any_cast<string>(m["TargetClusterName"]));
    }
    if (m.find("TargetClusterUrl") != m.end() && !m["TargetClusterUrl"].empty()) {
      targetClusterUrl = make_shared<string>(boost::any_cast<string>(m["TargetClusterUrl"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddMigrationTaskResponseBodyData() = default;
};
class AddMigrationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMigrationTaskResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddMigrationTaskResponseBody() {}

  explicit AddMigrationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddMigrationTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddMigrationTaskResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddMigrationTaskResponseBody() = default;
};
class AddMigrationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMigrationTaskResponseBody> body{};

  AddMigrationTaskResponse() {}

  explicit AddMigrationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMigrationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMigrationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~AddMigrationTaskResponse() = default;
};
class AddMockRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> consumerAppIds{};
  shared_ptr<string> dubboMockItems{};
  shared_ptr<bool> enable{};
  shared_ptr<string> extraJson{};
  shared_ptr<long> mockType{};
  shared_ptr<string> name{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> region{};
  shared_ptr<string> scMockItems{};
  shared_ptr<string> source{};

  AddMockRuleRequest() {}

  explicit AddMockRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerAppIds) {
      res["ConsumerAppIds"] = boost::any(*consumerAppIds);
    }
    if (dubboMockItems) {
      res["DubboMockItems"] = boost::any(*dubboMockItems);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (mockType) {
      res["MockType"] = boost::any(*mockType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scMockItems) {
      res["ScMockItems"] = boost::any(*scMockItems);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerAppIds") != m.end() && !m["ConsumerAppIds"].empty()) {
      consumerAppIds = make_shared<string>(boost::any_cast<string>(m["ConsumerAppIds"]));
    }
    if (m.find("DubboMockItems") != m.end() && !m["DubboMockItems"].empty()) {
      dubboMockItems = make_shared<string>(boost::any_cast<string>(m["DubboMockItems"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("MockType") != m.end() && !m["MockType"].empty()) {
      mockType = make_shared<long>(boost::any_cast<long>(m["MockType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ScMockItems") != m.end() && !m["ScMockItems"].empty()) {
      scMockItems = make_shared<string>(boost::any_cast<string>(m["ScMockItems"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~AddMockRuleRequest() = default;
};
class AddMockRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> consumerAppName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> extraJson{};
  shared_ptr<long> id{};
  shared_ptr<long> mockType{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> providerAppId{};
  shared_ptr<string> providerAppName{};
  shared_ptr<string> region{};
  shared_ptr<string> scMockItemJson{};
  shared_ptr<string> source{};

  AddMockRuleResponseBodyData() {}

  explicit AddMockRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (consumerAppName) {
      res["ConsumerAppName"] = boost::any(*consumerAppName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (extraJson) {
      res["ExtraJson"] = boost::any(*extraJson);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mockType) {
      res["MockType"] = boost::any(*mockType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (providerAppId) {
      res["ProviderAppId"] = boost::any(*providerAppId);
    }
    if (providerAppName) {
      res["ProviderAppName"] = boost::any(*providerAppName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (scMockItemJson) {
      res["ScMockItemJson"] = boost::any(*scMockItemJson);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("ConsumerAppName") != m.end() && !m["ConsumerAppName"].empty()) {
      consumerAppName = make_shared<string>(boost::any_cast<string>(m["ConsumerAppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("ExtraJson") != m.end() && !m["ExtraJson"].empty()) {
      extraJson = make_shared<string>(boost::any_cast<string>(m["ExtraJson"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MockType") != m.end() && !m["MockType"].empty()) {
      mockType = make_shared<long>(boost::any_cast<long>(m["MockType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ProviderAppId") != m.end() && !m["ProviderAppId"].empty()) {
      providerAppId = make_shared<string>(boost::any_cast<string>(m["ProviderAppId"]));
    }
    if (m.find("ProviderAppName") != m.end() && !m["ProviderAppName"].empty()) {
      providerAppName = make_shared<string>(boost::any_cast<string>(m["ProviderAppName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ScMockItemJson") != m.end() && !m["ScMockItemJson"].empty()) {
      scMockItemJson = make_shared<string>(boost::any_cast<string>(m["ScMockItemJson"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~AddMockRuleResponseBodyData() = default;
};
class AddMockRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<AddMockRuleResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddMockRuleResponseBody() {}

  explicit AddMockRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddMockRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddMockRuleResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddMockRuleResponseBody() = default;
};
class AddMockRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMockRuleResponseBody> body{};

  AddMockRuleResponse() {}

  explicit AddMockRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMockRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMockRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddMockRuleResponse() = default;
};
class AddSSLCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> domainId{};
  shared_ptr<string> gatewayUniqueId{};

  AddSSLCertRequest() {}

  explicit AddSSLCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~AddSSLCertRequest() = default;
};
class AddSSLCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddSSLCertResponseBody() {}

  explicit AddSSLCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddSSLCertResponseBody() = default;
};
class AddSSLCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSSLCertResponseBody> body{};

  AddSSLCertResponse() {}

  explicit AddSSLCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSSLCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSSLCertResponseBody>(model1);
      }
    }
  }


  virtual ~AddSSLCertResponse() = default;
};
class AddSecurityGroupRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> description{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> portRange{};
  shared_ptr<string> securityGroupId{};

  AddSecurityGroupRuleRequest() {}

  explicit AddSecurityGroupRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~AddSecurityGroupRuleRequest() = default;
};
class AddSecurityGroupRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddSecurityGroupRuleResponseBody() {}

  explicit AddSecurityGroupRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddSecurityGroupRuleResponseBody() = default;
};
class AddSecurityGroupRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSecurityGroupRuleResponseBody> body{};

  AddSecurityGroupRuleResponse() {}

  explicit AddSecurityGroupRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSecurityGroupRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSecurityGroupRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddSecurityGroupRuleResponse() = default;
};
class AddServiceSourceRequestIngressOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableIngress{};
  shared_ptr<bool> enableStatus{};
  shared_ptr<string> ingressClass{};
  shared_ptr<string> watchNamespace{};

  AddServiceSourceRequestIngressOptionsRequest() {}

  explicit AddServiceSourceRequestIngressOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIngress) {
      res["EnableIngress"] = boost::any(*enableIngress);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (ingressClass) {
      res["IngressClass"] = boost::any(*ingressClass);
    }
    if (watchNamespace) {
      res["WatchNamespace"] = boost::any(*watchNamespace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIngress") != m.end() && !m["EnableIngress"].empty()) {
      enableIngress = make_shared<bool>(boost::any_cast<bool>(m["EnableIngress"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<bool>(boost::any_cast<bool>(m["EnableStatus"]));
    }
    if (m.find("IngressClass") != m.end() && !m["IngressClass"].empty()) {
      ingressClass = make_shared<string>(boost::any_cast<string>(m["IngressClass"]));
    }
    if (m.find("WatchNamespace") != m.end() && !m["WatchNamespace"].empty()) {
      watchNamespace = make_shared<string>(boost::any_cast<string>(m["WatchNamespace"]));
    }
  }


  virtual ~AddServiceSourceRequestIngressOptionsRequest() = default;
};
class AddServiceSourceRequestToAuthorizeSecurityGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> portRange{};
  shared_ptr<string> securityGroupId{};

  AddServiceSourceRequestToAuthorizeSecurityGroups() {}

  explicit AddServiceSourceRequestToAuthorizeSecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~AddServiceSourceRequestToAuthorizeSecurityGroups() = default;
};
class AddServiceSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<vector<string>> groupList{};
  shared_ptr<AddServiceSourceRequestIngressOptionsRequest> ingressOptionsRequest{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> pathList{};
  shared_ptr<string> source{};
  shared_ptr<vector<AddServiceSourceRequestToAuthorizeSecurityGroups>> toAuthorizeSecurityGroups{};
  shared_ptr<string> type{};

  AddServiceSourceRequest() {}

  explicit AddServiceSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (groupList) {
      res["GroupList"] = boost::any(*groupList);
    }
    if (ingressOptionsRequest) {
      res["IngressOptionsRequest"] = ingressOptionsRequest ? boost::any(ingressOptionsRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pathList) {
      res["PathList"] = boost::any(*pathList);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (toAuthorizeSecurityGroups) {
      vector<boost::any> temp1;
      for(auto item1:*toAuthorizeSecurityGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ToAuthorizeSecurityGroups"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IngressOptionsRequest") != m.end() && !m["IngressOptionsRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressOptionsRequest"].type()) {
        AddServiceSourceRequestIngressOptionsRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressOptionsRequest"]));
        ingressOptionsRequest = make_shared<AddServiceSourceRequestIngressOptionsRequest>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PathList") != m.end() && !m["PathList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PathList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PathList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pathList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("ToAuthorizeSecurityGroups") != m.end() && !m["ToAuthorizeSecurityGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["ToAuthorizeSecurityGroups"].type()) {
        vector<AddServiceSourceRequestToAuthorizeSecurityGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ToAuthorizeSecurityGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddServiceSourceRequestToAuthorizeSecurityGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        toAuthorizeSecurityGroups = make_shared<vector<AddServiceSourceRequestToAuthorizeSecurityGroups>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddServiceSourceRequest() = default;
};
class AddServiceSourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> groupListShrink{};
  shared_ptr<string> ingressOptionsRequestShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> pathListShrink{};
  shared_ptr<string> source{};
  shared_ptr<string> toAuthorizeSecurityGroupsShrink{};
  shared_ptr<string> type{};

  AddServiceSourceShrinkRequest() {}

  explicit AddServiceSourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (groupListShrink) {
      res["GroupList"] = boost::any(*groupListShrink);
    }
    if (ingressOptionsRequestShrink) {
      res["IngressOptionsRequest"] = boost::any(*ingressOptionsRequestShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pathListShrink) {
      res["PathList"] = boost::any(*pathListShrink);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (toAuthorizeSecurityGroupsShrink) {
      res["ToAuthorizeSecurityGroups"] = boost::any(*toAuthorizeSecurityGroupsShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      groupListShrink = make_shared<string>(boost::any_cast<string>(m["GroupList"]));
    }
    if (m.find("IngressOptionsRequest") != m.end() && !m["IngressOptionsRequest"].empty()) {
      ingressOptionsRequestShrink = make_shared<string>(boost::any_cast<string>(m["IngressOptionsRequest"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PathList") != m.end() && !m["PathList"].empty()) {
      pathListShrink = make_shared<string>(boost::any_cast<string>(m["PathList"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("ToAuthorizeSecurityGroups") != m.end() && !m["ToAuthorizeSecurityGroups"].empty()) {
      toAuthorizeSecurityGroupsShrink = make_shared<string>(boost::any_cast<string>(m["ToAuthorizeSecurityGroups"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddServiceSourceShrinkRequest() = default;
};
class AddServiceSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddServiceSourceResponseBody() {}

  explicit AddServiceSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddServiceSourceResponseBody() = default;
};
class AddServiceSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddServiceSourceResponseBody> body{};

  AddServiceSourceResponse() {}

  explicit AddServiceSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddServiceSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddServiceSourceResponseBody>(model1);
      }
    }
  }


  virtual ~AddServiceSourceResponse() = default;
};
class ApplyGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> routeId{};

  ApplyGatewayRouteRequest() {}

  explicit ApplyGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
  }


  virtual ~ApplyGatewayRouteRequest() = default;
};
class ApplyGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ApplyGatewayRouteResponseBody() {}

  explicit ApplyGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyGatewayRouteResponseBody() = default;
};
class ApplyGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyGatewayRouteResponseBody> body{};

  ApplyGatewayRouteResponse() {}

  explicit ApplyGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyGatewayRouteResponse() = default;
};
class ApplyTagPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> region{};
  shared_ptr<map<string, RulesValue>> rules{};

  ApplyTagPoliciesRequest() {}

  explicit ApplyTagPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (rules) {
      map<string, boost::any> temp1;
      for(auto item1:*rules){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        map<string, RulesValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            RulesValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        rules = make_shared<map<string, RulesValue>>(expect1);
      }
    }
  }


  virtual ~ApplyTagPoliciesRequest() = default;
};
class ApplyTagPoliciesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> region{};
  shared_ptr<string> rulesShrink{};

  ApplyTagPoliciesShrinkRequest() {}

  explicit ApplyTagPoliciesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (rulesShrink) {
      res["Rules"] = boost::any(*rulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rulesShrink = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ApplyTagPoliciesShrinkRequest() = default;
};
class ApplyTagPoliciesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> carryData{};
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> name{};
  shared_ptr<long> rate{};
  shared_ptr<bool> remove{};
  shared_ptr<string> rules{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};

  ApplyTagPoliciesResponseBodyData() {}

  explicit ApplyTagPoliciesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (carryData) {
      res["CarryData"] = boost::any(*carryData);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CarryData") != m.end() && !m["CarryData"].empty()) {
      carryData = make_shared<bool>(boost::any_cast<bool>(m["CarryData"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<bool>(boost::any_cast<bool>(m["Remove"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ApplyTagPoliciesResponseBodyData() = default;
};
class ApplyTagPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ApplyTagPoliciesResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ApplyTagPoliciesResponseBody() {}

  explicit ApplyTagPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ApplyTagPoliciesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyTagPoliciesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ApplyTagPoliciesResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyTagPoliciesResponseBody() = default;
};
class ApplyTagPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyTagPoliciesResponseBody> body{};

  ApplyTagPoliciesResponse() {}

  explicit ApplyTagPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyTagPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyTagPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyTagPoliciesResponse() = default;
};
class CloneNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ids{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> originNamespaceId{};
  shared_ptr<string> policy{};
  shared_ptr<string> targetNamespaceId{};

  CloneNacosConfigRequest() {}

  explicit CloneNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (originNamespaceId) {
      res["OriginNamespaceId"] = boost::any(*originNamespaceId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (targetNamespaceId) {
      res["TargetNamespaceId"] = boost::any(*targetNamespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OriginNamespaceId") != m.end() && !m["OriginNamespaceId"].empty()) {
      originNamespaceId = make_shared<string>(boost::any_cast<string>(m["OriginNamespaceId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("TargetNamespaceId") != m.end() && !m["TargetNamespaceId"].empty()) {
      targetNamespaceId = make_shared<string>(boost::any_cast<string>(m["TargetNamespaceId"]));
    }
  }


  virtual ~CloneNacosConfigRequest() = default;
};
class CloneNacosConfigResponseBodyDataFailData : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};

  CloneNacosConfigResponseBodyDataFailData() {}

  explicit CloneNacosConfigResponseBodyDataFailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~CloneNacosConfigResponseBodyDataFailData() = default;
};
class CloneNacosConfigResponseBodyDataSkipData : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};

  CloneNacosConfigResponseBodyDataSkipData() {}

  explicit CloneNacosConfigResponseBodyDataSkipData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~CloneNacosConfigResponseBodyDataSkipData() = default;
};
class CloneNacosConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<CloneNacosConfigResponseBodyDataFailData>> failData{};
  shared_ptr<long> skipCount{};
  shared_ptr<vector<CloneNacosConfigResponseBodyDataSkipData>> skipData{};
  shared_ptr<long> succCount{};

  CloneNacosConfigResponseBodyData() {}

  explicit CloneNacosConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failData) {
      vector<boost::any> temp1;
      for(auto item1:*failData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailData"] = boost::any(temp1);
    }
    if (skipCount) {
      res["SkipCount"] = boost::any(*skipCount);
    }
    if (skipData) {
      vector<boost::any> temp1;
      for(auto item1:*skipData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkipData"] = boost::any(temp1);
    }
    if (succCount) {
      res["SuccCount"] = boost::any(*succCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailData") != m.end() && !m["FailData"].empty()) {
      if (typeid(vector<boost::any>) == m["FailData"].type()) {
        vector<CloneNacosConfigResponseBodyDataFailData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CloneNacosConfigResponseBodyDataFailData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failData = make_shared<vector<CloneNacosConfigResponseBodyDataFailData>>(expect1);
      }
    }
    if (m.find("SkipCount") != m.end() && !m["SkipCount"].empty()) {
      skipCount = make_shared<long>(boost::any_cast<long>(m["SkipCount"]));
    }
    if (m.find("SkipData") != m.end() && !m["SkipData"].empty()) {
      if (typeid(vector<boost::any>) == m["SkipData"].type()) {
        vector<CloneNacosConfigResponseBodyDataSkipData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkipData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CloneNacosConfigResponseBodyDataSkipData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skipData = make_shared<vector<CloneNacosConfigResponseBodyDataSkipData>>(expect1);
      }
    }
    if (m.find("SuccCount") != m.end() && !m["SuccCount"].empty()) {
      succCount = make_shared<long>(boost::any_cast<long>(m["SuccCount"]));
    }
  }


  virtual ~CloneNacosConfigResponseBodyData() = default;
};
class CloneNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CloneNacosConfigResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CloneNacosConfigResponseBody() {}

  explicit CloneNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CloneNacosConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CloneNacosConfigResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CloneNacosConfigResponseBody() = default;
};
class CloneNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloneNacosConfigResponseBody> body{};

  CloneNacosConfigResponse() {}

  explicit CloneNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloneNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloneNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CloneNacosConfigResponse() = default;
};
class CreateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> language{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};
  shared_ptr<string> sentinelEnable{};
  shared_ptr<string> source{};
  shared_ptr<string> switchEnable{};

  CreateApplicationRequest() {}

  explicit CreateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sentinelEnable) {
      res["SentinelEnable"] = boost::any(*sentinelEnable);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (switchEnable) {
      res["SwitchEnable"] = boost::any(*switchEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SentinelEnable") != m.end() && !m["SentinelEnable"].empty()) {
      sentinelEnable = make_shared<string>(boost::any_cast<string>(m["SentinelEnable"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SwitchEnable") != m.end() && !m["SwitchEnable"].empty()) {
      switchEnable = make_shared<string>(boost::any_cast<string>(m["SwitchEnable"]));
    }
  }


  virtual ~CreateApplicationRequest() = default;
};
class CreateApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> language{};
  shared_ptr<string> licenseKey{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};

  CreateApplicationResponseBodyData() {}

  explicit CreateApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (licenseKey) {
      res["LicenseKey"] = boost::any(*licenseKey);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LicenseKey") != m.end() && !m["LicenseKey"].empty()) {
      licenseKey = make_shared<string>(boost::any_cast<string>(m["LicenseKey"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateApplicationResponseBodyData() = default;
};
class CreateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateApplicationResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateApplicationResponseBody() {}

  explicit CreateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateApplicationResponseBody() = default;
};
class CreateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationResponseBody> body{};

  CreateApplicationResponse() {}

  explicit CreateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationResponse() = default;
};
class CreateCircuitBreakerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<long> halfOpenBaseAmountPerStep{};
  shared_ptr<long> halfOpenRecoveryStepNum{};
  shared_ptr<long> maxAllowedRtMs{};
  shared_ptr<long> minRequestAmount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<long> retryTimeoutMs{};
  shared_ptr<long> statIntervalMs{};
  shared_ptr<long> strategy{};
  shared_ptr<double> threshold{};

  CreateCircuitBreakerRuleRequest() {}

  explicit CreateCircuitBreakerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (halfOpenBaseAmountPerStep) {
      res["HalfOpenBaseAmountPerStep"] = boost::any(*halfOpenBaseAmountPerStep);
    }
    if (halfOpenRecoveryStepNum) {
      res["HalfOpenRecoveryStepNum"] = boost::any(*halfOpenRecoveryStepNum);
    }
    if (maxAllowedRtMs) {
      res["MaxAllowedRtMs"] = boost::any(*maxAllowedRtMs);
    }
    if (minRequestAmount) {
      res["MinRequestAmount"] = boost::any(*minRequestAmount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (retryTimeoutMs) {
      res["RetryTimeoutMs"] = boost::any(*retryTimeoutMs);
    }
    if (statIntervalMs) {
      res["StatIntervalMs"] = boost::any(*statIntervalMs);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("HalfOpenBaseAmountPerStep") != m.end() && !m["HalfOpenBaseAmountPerStep"].empty()) {
      halfOpenBaseAmountPerStep = make_shared<long>(boost::any_cast<long>(m["HalfOpenBaseAmountPerStep"]));
    }
    if (m.find("HalfOpenRecoveryStepNum") != m.end() && !m["HalfOpenRecoveryStepNum"].empty()) {
      halfOpenRecoveryStepNum = make_shared<long>(boost::any_cast<long>(m["HalfOpenRecoveryStepNum"]));
    }
    if (m.find("MaxAllowedRtMs") != m.end() && !m["MaxAllowedRtMs"].empty()) {
      maxAllowedRtMs = make_shared<long>(boost::any_cast<long>(m["MaxAllowedRtMs"]));
    }
    if (m.find("MinRequestAmount") != m.end() && !m["MinRequestAmount"].empty()) {
      minRequestAmount = make_shared<long>(boost::any_cast<long>(m["MinRequestAmount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RetryTimeoutMs") != m.end() && !m["RetryTimeoutMs"].empty()) {
      retryTimeoutMs = make_shared<long>(boost::any_cast<long>(m["RetryTimeoutMs"]));
    }
    if (m.find("StatIntervalMs") != m.end() && !m["StatIntervalMs"].empty()) {
      statIntervalMs = make_shared<long>(boost::any_cast<long>(m["StatIntervalMs"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~CreateCircuitBreakerRuleRequest() = default;
};
class CreateCircuitBreakerRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<long> halfOpenBaseAmountPerStep{};
  shared_ptr<long> halfOpenRecoveryStepNum{};
  shared_ptr<long> id{};
  shared_ptr<long> maxAllowedRtMs{};
  shared_ptr<long> minRequestAmount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<long> retryTimeoutMs{};
  shared_ptr<long> statIntervalMs{};
  shared_ptr<long> strategy{};
  shared_ptr<double> threshold{};

  CreateCircuitBreakerRuleResponseBodyData() {}

  explicit CreateCircuitBreakerRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (halfOpenBaseAmountPerStep) {
      res["HalfOpenBaseAmountPerStep"] = boost::any(*halfOpenBaseAmountPerStep);
    }
    if (halfOpenRecoveryStepNum) {
      res["HalfOpenRecoveryStepNum"] = boost::any(*halfOpenRecoveryStepNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxAllowedRtMs) {
      res["MaxAllowedRtMs"] = boost::any(*maxAllowedRtMs);
    }
    if (minRequestAmount) {
      res["MinRequestAmount"] = boost::any(*minRequestAmount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (retryTimeoutMs) {
      res["RetryTimeoutMs"] = boost::any(*retryTimeoutMs);
    }
    if (statIntervalMs) {
      res["StatIntervalMs"] = boost::any(*statIntervalMs);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("HalfOpenBaseAmountPerStep") != m.end() && !m["HalfOpenBaseAmountPerStep"].empty()) {
      halfOpenBaseAmountPerStep = make_shared<long>(boost::any_cast<long>(m["HalfOpenBaseAmountPerStep"]));
    }
    if (m.find("HalfOpenRecoveryStepNum") != m.end() && !m["HalfOpenRecoveryStepNum"].empty()) {
      halfOpenRecoveryStepNum = make_shared<long>(boost::any_cast<long>(m["HalfOpenRecoveryStepNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxAllowedRtMs") != m.end() && !m["MaxAllowedRtMs"].empty()) {
      maxAllowedRtMs = make_shared<long>(boost::any_cast<long>(m["MaxAllowedRtMs"]));
    }
    if (m.find("MinRequestAmount") != m.end() && !m["MinRequestAmount"].empty()) {
      minRequestAmount = make_shared<long>(boost::any_cast<long>(m["MinRequestAmount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RetryTimeoutMs") != m.end() && !m["RetryTimeoutMs"].empty()) {
      retryTimeoutMs = make_shared<long>(boost::any_cast<long>(m["RetryTimeoutMs"]));
    }
    if (m.find("StatIntervalMs") != m.end() && !m["StatIntervalMs"].empty()) {
      statIntervalMs = make_shared<long>(boost::any_cast<long>(m["StatIntervalMs"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~CreateCircuitBreakerRuleResponseBodyData() = default;
};
class CreateCircuitBreakerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateCircuitBreakerRuleResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCircuitBreakerRuleResponseBody() {}

  explicit CreateCircuitBreakerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateCircuitBreakerRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateCircuitBreakerRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCircuitBreakerRuleResponseBody() = default;
};
class CreateCircuitBreakerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCircuitBreakerRuleResponseBody> body{};

  CreateCircuitBreakerRuleResponse() {}

  explicit CreateCircuitBreakerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCircuitBreakerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCircuitBreakerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCircuitBreakerRuleResponse() = default;
};
class CreateClusterRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateClusterRequestTag() {}

  explicit CreateClusterRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateClusterRequestTag() = default;
};
class CreateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterSpecification{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> eipEnabled{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> netType{};
  shared_ptr<string> privateSlbSpecification{};
  shared_ptr<string> pubNetworkFlow{};
  shared_ptr<string> pubSlbSpecification{};
  shared_ptr<string> region{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<vector<CreateClusterRequestTag>> tag{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  CreateClusterRequest() {}

  explicit CreateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterSpecification) {
      res["ClusterSpecification"] = boost::any(*clusterSpecification);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["ClusterVersion"] = boost::any(*clusterVersion);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (eipEnabled) {
      res["EipEnabled"] = boost::any(*eipEnabled);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (privateSlbSpecification) {
      res["PrivateSlbSpecification"] = boost::any(*privateSlbSpecification);
    }
    if (pubNetworkFlow) {
      res["PubNetworkFlow"] = boost::any(*pubNetworkFlow);
    }
    if (pubSlbSpecification) {
      res["PubSlbSpecification"] = boost::any(*pubSlbSpecification);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterSpecification") != m.end() && !m["ClusterSpecification"].empty()) {
      clusterSpecification = make_shared<string>(boost::any_cast<string>(m["ClusterSpecification"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ClusterVersion") != m.end() && !m["ClusterVersion"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["ClusterVersion"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EipEnabled") != m.end() && !m["EipEnabled"].empty()) {
      eipEnabled = make_shared<bool>(boost::any_cast<bool>(m["EipEnabled"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("PrivateSlbSpecification") != m.end() && !m["PrivateSlbSpecification"].empty()) {
      privateSlbSpecification = make_shared<string>(boost::any_cast<string>(m["PrivateSlbSpecification"]));
    }
    if (m.find("PubNetworkFlow") != m.end() && !m["PubNetworkFlow"].empty()) {
      pubNetworkFlow = make_shared<string>(boost::any_cast<string>(m["PubNetworkFlow"]));
    }
    if (m.find("PubSlbSpecification") != m.end() && !m["PubSlbSpecification"].empty()) {
      pubSlbSpecification = make_shared<string>(boost::any_cast<string>(m["PubSlbSpecification"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateClusterRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateClusterRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateClusterRequestTag>>(expect1);
      }
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateClusterRequest() = default;
};
class CreateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateClusterResponseBody() {}

  explicit CreateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateClusterResponseBody() = default;
};
class CreateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateClusterResponseBody> body{};

  CreateClusterResponse() {}

  explicit CreateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateClusterResponse() = default;
};
class CreateEngineNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> desc{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceCount{};

  CreateEngineNamespaceRequest() {}

  explicit CreateEngineNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (serviceCount) {
      res["ServiceCount"] = boost::any(*serviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServiceCount") != m.end() && !m["ServiceCount"].empty()) {
      serviceCount = make_shared<long>(boost::any_cast<long>(m["ServiceCount"]));
    }
  }


  virtual ~CreateEngineNamespaceRequest() = default;
};
class CreateEngineNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceDesc{};
  shared_ptr<string> namespaceShowName{};
  shared_ptr<long> quota{};
  shared_ptr<long> serviceCount{};
  shared_ptr<long> type{};

  CreateEngineNamespaceResponseBodyData() {}

  explicit CreateEngineNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configCount) {
      res["ConfigCount"] = boost::any(*configCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceDesc) {
      res["NamespaceDesc"] = boost::any(*namespaceDesc);
    }
    if (namespaceShowName) {
      res["NamespaceShowName"] = boost::any(*namespaceShowName);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (serviceCount) {
      res["ServiceCount"] = boost::any(*serviceCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigCount") != m.end() && !m["ConfigCount"].empty()) {
      configCount = make_shared<long>(boost::any_cast<long>(m["ConfigCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceDesc") != m.end() && !m["NamespaceDesc"].empty()) {
      namespaceDesc = make_shared<string>(boost::any_cast<string>(m["NamespaceDesc"]));
    }
    if (m.find("NamespaceShowName") != m.end() && !m["NamespaceShowName"].empty()) {
      namespaceShowName = make_shared<string>(boost::any_cast<string>(m["NamespaceShowName"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("ServiceCount") != m.end() && !m["ServiceCount"].empty()) {
      serviceCount = make_shared<long>(boost::any_cast<long>(m["ServiceCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateEngineNamespaceResponseBodyData() = default;
};
class CreateEngineNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<CreateEngineNamespaceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateEngineNamespaceResponseBody() {}

  explicit CreateEngineNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateEngineNamespaceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateEngineNamespaceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEngineNamespaceResponseBody() = default;
};
class CreateEngineNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEngineNamespaceResponseBody> body{};

  CreateEngineNamespaceResponse() {}

  explicit CreateEngineNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEngineNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEngineNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEngineNamespaceResponse() = default;
};
class CreateFlowRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> controlBehavior{};
  shared_ptr<bool> enable{};
  shared_ptr<long> maxQueueingTimeMs{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<long> threshold{};

  CreateFlowRuleRequest() {}

  explicit CreateFlowRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlBehavior) {
      res["ControlBehavior"] = boost::any(*controlBehavior);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (maxQueueingTimeMs) {
      res["MaxQueueingTimeMs"] = boost::any(*maxQueueingTimeMs);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlBehavior") != m.end() && !m["ControlBehavior"].empty()) {
      controlBehavior = make_shared<long>(boost::any_cast<long>(m["ControlBehavior"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("MaxQueueingTimeMs") != m.end() && !m["MaxQueueingTimeMs"].empty()) {
      maxQueueingTimeMs = make_shared<long>(boost::any_cast<long>(m["MaxQueueingTimeMs"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~CreateFlowRuleRequest() = default;
};
class CreateFlowRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> controlBehavior{};
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<long> maxQueueingTimeMs{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<double> threshold{};

  CreateFlowRuleResponseBodyData() {}

  explicit CreateFlowRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlBehavior) {
      res["ControlBehavior"] = boost::any(*controlBehavior);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxQueueingTimeMs) {
      res["MaxQueueingTimeMs"] = boost::any(*maxQueueingTimeMs);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlBehavior") != m.end() && !m["ControlBehavior"].empty()) {
      controlBehavior = make_shared<long>(boost::any_cast<long>(m["ControlBehavior"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxQueueingTimeMs") != m.end() && !m["MaxQueueingTimeMs"].empty()) {
      maxQueueingTimeMs = make_shared<long>(boost::any_cast<long>(m["MaxQueueingTimeMs"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~CreateFlowRuleResponseBodyData() = default;
};
class CreateFlowRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateFlowRuleResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateFlowRuleResponseBody() {}

  explicit CreateFlowRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateFlowRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateFlowRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFlowRuleResponseBody() = default;
};
class CreateFlowRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFlowRuleResponseBody> body{};

  CreateFlowRuleResponse() {}

  explicit CreateFlowRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowRuleResponse() = default;
};
class CreateMseServiceApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> language{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> region{};
  shared_ptr<string> sentinelEnable{};
  shared_ptr<string> source{};
  shared_ptr<string> switchEnable{};

  CreateMseServiceApplicationRequest() {}

  explicit CreateMseServiceApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sentinelEnable) {
      res["SentinelEnable"] = boost::any(*sentinelEnable);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (switchEnable) {
      res["SwitchEnable"] = boost::any(*switchEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SentinelEnable") != m.end() && !m["SentinelEnable"].empty()) {
      sentinelEnable = make_shared<string>(boost::any_cast<string>(m["SentinelEnable"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SwitchEnable") != m.end() && !m["SwitchEnable"].empty()) {
      switchEnable = make_shared<string>(boost::any_cast<string>(m["SwitchEnable"]));
    }
  }


  virtual ~CreateMseServiceApplicationRequest() = default;
};
class CreateMseServiceApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> language{};
  shared_ptr<string> licenseKey{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> version{};

  CreateMseServiceApplicationResponseBodyData() {}

  explicit CreateMseServiceApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (licenseKey) {
      res["LicenseKey"] = boost::any(*licenseKey);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LicenseKey") != m.end() && !m["LicenseKey"].empty()) {
      licenseKey = make_shared<string>(boost::any_cast<string>(m["LicenseKey"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateMseServiceApplicationResponseBodyData() = default;
};
class CreateMseServiceApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMseServiceApplicationResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateMseServiceApplicationResponseBody() {}

  explicit CreateMseServiceApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateMseServiceApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateMseServiceApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateMseServiceApplicationResponseBody() = default;
};
class CreateMseServiceApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMseServiceApplicationResponseBody> body{};

  CreateMseServiceApplicationResponse() {}

  explicit CreateMseServiceApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMseServiceApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMseServiceApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMseServiceApplicationResponse() = default;
};
class CreateNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> betaIps{};
  shared_ptr<string> content{};
  shared_ptr<string> dataId{};
  shared_ptr<string> desc{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  CreateNacosConfigRequest() {}

  explicit CreateNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (betaIps) {
      res["BetaIps"] = boost::any(*betaIps);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BetaIps") != m.end() && !m["BetaIps"].empty()) {
      betaIps = make_shared<string>(boost::any_cast<string>(m["BetaIps"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateNacosConfigRequest() = default;
};
class CreateNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNacosConfigResponseBody() {}

  explicit CreateNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNacosConfigResponseBody() = default;
};
class CreateNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNacosConfigResponseBody> body{};

  CreateNacosConfigResponse() {}

  explicit CreateNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNacosConfigResponse() = default;
};
class CreateNacosInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterName{};
  shared_ptr<bool> enabled{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> metadata{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> port{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> weight{};

  CreateNacosInstanceRequest() {}

  explicit CreateNacosInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~CreateNacosInstanceRequest() = default;
};
class CreateNacosInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNacosInstanceResponseBody() {}

  explicit CreateNacosInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNacosInstanceResponseBody() = default;
};
class CreateNacosInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNacosInstanceResponseBody> body{};

  CreateNacosInstanceResponse() {}

  explicit CreateNacosInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNacosInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNacosInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNacosInstanceResponse() = default;
};
class CreateNacosServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> protectThreshold{};
  shared_ptr<string> serviceName{};

  CreateNacosServiceRequest() {}

  explicit CreateNacosServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (protectThreshold) {
      res["ProtectThreshold"] = boost::any(*protectThreshold);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ProtectThreshold") != m.end() && !m["ProtectThreshold"].empty()) {
      protectThreshold = make_shared<string>(boost::any_cast<string>(m["ProtectThreshold"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~CreateNacosServiceRequest() = default;
};
class CreateNacosServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateNacosServiceResponseBody() {}

  explicit CreateNacosServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNacosServiceResponseBody() = default;
};
class CreateNacosServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNacosServiceResponseBody> body{};

  CreateNacosServiceResponse() {}

  explicit CreateNacosServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNacosServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNacosServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNacosServiceResponse() = default;
};
class CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems() {}

  explicit CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["Cond"] = boost::any(*cond);
    }
    if (datum) {
      res["Datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["Divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameList) {
      res["NameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["Remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cond") != m.end() && !m["Cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["Cond"]));
    }
    if (m.find("Datum") != m.end() && !m["Datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["Datum"]));
    }
    if (m.find("Divisor") != m.end() && !m["Divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["Divisor"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("Remainder") != m.end() && !m["Remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["Remainder"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems() = default;
};
class CreateOrUpdateSwimmingLaneRequestEntryRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> priority{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems>> restItems{};

  CreateOrUpdateSwimmingLaneRequestEntryRules() {}

  explicit CreateOrUpdateSwimmingLaneRequestEntryRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RestItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RestItems") != m.end() && !m["RestItems"].empty()) {
      if (typeid(vector<boost::any>) == m["RestItems"].type()) {
        vector<CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RestItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestEntryRules() = default;
};
class CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions() {}

  explicit CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["Cond"] = boost::any(*cond);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cond") != m.end() && !m["Cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["Cond"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions() = default;
};
class CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson : public Darabonba::Model {
public:
  shared_ptr<vector<CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions>> conditions{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<vector<long>> routeIdList{};

  CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson() {}

  explicit CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeIdList) {
      res["RouteIdList"] = boost::any(*routeIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions>>(expect1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteIdList") != m.end() && !m["RouteIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RouteIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RouteIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      routeIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson() = default;
};
class CreateOrUpdateSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRule{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneRequestEntryRules>> entryRules{};
  shared_ptr<CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson> gatewaySwimmingLaneRouteJson{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tag{};

  CreateOrUpdateSwimmingLaneRequest() {}

  explicit CreateOrUpdateSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (entryRules) {
      vector<boost::any> temp1;
      for(auto item1:*entryRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntryRules"] = boost::any(temp1);
    }
    if (gatewaySwimmingLaneRouteJson) {
      res["GatewaySwimmingLaneRouteJson"] = gatewaySwimmingLaneRouteJson ? boost::any(gatewaySwimmingLaneRouteJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EntryRules"].type()) {
        vector<CreateOrUpdateSwimmingLaneRequestEntryRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntryRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneRequestEntryRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entryRules = make_shared<vector<CreateOrUpdateSwimmingLaneRequestEntryRules>>(expect1);
      }
    }
    if (m.find("GatewaySwimmingLaneRouteJson") != m.end() && !m["GatewaySwimmingLaneRouteJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewaySwimmingLaneRouteJson"].type()) {
        CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewaySwimmingLaneRouteJson"]));
        gatewaySwimmingLaneRouteJson = make_shared<CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneRequest() = default;
};
class CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems() {}

  explicit CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["Cond"] = boost::any(*cond);
    }
    if (datum) {
      res["Datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["Divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameList) {
      res["NameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["Remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cond") != m.end() && !m["Cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["Cond"]));
    }
    if (m.find("Datum") != m.end() && !m["Datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["Datum"]));
    }
    if (m.find("Divisor") != m.end() && !m["Divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["Divisor"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("Remainder") != m.end() && !m["Remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["Remainder"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems() = default;
};
class CreateOrUpdateSwimmingLaneShrinkRequestEntryRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> priority{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems>> restItems{};

  CreateOrUpdateSwimmingLaneShrinkRequestEntryRules() {}

  explicit CreateOrUpdateSwimmingLaneShrinkRequestEntryRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RestItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RestItems") != m.end() && !m["RestItems"].empty()) {
      if (typeid(vector<boost::any>) == m["RestItems"].type()) {
        vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RestItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneShrinkRequestEntryRules() = default;
};
class CreateOrUpdateSwimmingLaneShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRule{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRules>> entryRules{};
  shared_ptr<string> gatewaySwimmingLaneRouteJsonShrink{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tag{};

  CreateOrUpdateSwimmingLaneShrinkRequest() {}

  explicit CreateOrUpdateSwimmingLaneShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["EnableRules"] = boost::any(*enableRules);
    }
    if (entryRule) {
      res["EntryRule"] = boost::any(*entryRule);
    }
    if (entryRules) {
      vector<boost::any> temp1;
      for(auto item1:*entryRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntryRules"] = boost::any(temp1);
    }
    if (gatewaySwimmingLaneRouteJsonShrink) {
      res["GatewaySwimmingLaneRouteJson"] = boost::any(*gatewaySwimmingLaneRouteJsonShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EnableRules") != m.end() && !m["EnableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["EnableRules"]));
    }
    if (m.find("EntryRule") != m.end() && !m["EntryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["EntryRule"]));
    }
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EntryRules"].type()) {
        vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntryRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneShrinkRequestEntryRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entryRules = make_shared<vector<CreateOrUpdateSwimmingLaneShrinkRequestEntryRules>>(expect1);
      }
    }
    if (m.find("GatewaySwimmingLaneRouteJson") != m.end() && !m["GatewaySwimmingLaneRouteJson"].empty()) {
      gatewaySwimmingLaneRouteJsonShrink = make_shared<string>(boost::any_cast<string>(m["GatewaySwimmingLaneRouteJson"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneShrinkRequest() = default;
};
class CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems() {}

  explicit CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems() = default;
};
class CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> path{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems>> restItems{};

  CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules() {}

  explicit CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (paths) {
      res["paths"] = boost::any(*paths);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("paths") != m.end() && !m["paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("restItems") != m.end() && !m["restItems"].empty()) {
      if (typeid(vector<boost::any>) == m["restItems"].type()) {
        vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems>>(expect1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules() = default;
};
class CreateOrUpdateSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRule{};
  shared_ptr<vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules>> entryRules{};
  shared_ptr<string> gatewaySwimmingLaneRouteJson{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};

  CreateOrUpdateSwimmingLaneResponseBodyData() {}

  explicit CreateOrUpdateSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["enableRules"] = boost::any(*enableRules);
    }
    if (entryRule) {
      res["entryRule"] = boost::any(*entryRule);
    }
    if (entryRules) {
      vector<boost::any> temp1;
      for(auto item1:*entryRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entryRules"] = boost::any(temp1);
    }
    if (gatewaySwimmingLaneRouteJson) {
      res["gatewaySwimmingLaneRouteJson"] = boost::any(*gatewaySwimmingLaneRouteJson);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tag) {
      res["tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("enableRules") != m.end() && !m["enableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["enableRules"]));
    }
    if (m.find("entryRule") != m.end() && !m["entryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["entryRule"]));
    }
    if (m.find("entryRules") != m.end() && !m["entryRules"].empty()) {
      if (typeid(vector<boost::any>) == m["entryRules"].type()) {
        vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entryRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entryRules = make_shared<vector<CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules>>(expect1);
      }
    }
    if (m.find("gatewaySwimmingLaneRouteJson") != m.end() && !m["gatewaySwimmingLaneRouteJson"].empty()) {
      gatewaySwimmingLaneRouteJson = make_shared<string>(boost::any_cast<string>(m["gatewaySwimmingLaneRouteJson"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["tag"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBodyData() = default;
};
class CreateOrUpdateSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<CreateOrUpdateSwimmingLaneResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOrUpdateSwimmingLaneResponseBody() {}

  explicit CreateOrUpdateSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOrUpdateSwimmingLaneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOrUpdateSwimmingLaneResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponseBody() = default;
};
class CreateOrUpdateSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSwimmingLaneResponseBody> body{};

  CreateOrUpdateSwimmingLaneResponse() {}

  explicit CreateOrUpdateSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneResponse() = default;
};
class CreateOrUpdateSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appIds{};
  shared_ptr<bool> dbGrayEnable{};
  shared_ptr<string> entryApp{};
  shared_ptr<long> id{};
  shared_ptr<string> messageQueueFilterSide{};
  shared_ptr<bool> messageQueueGrayEnable{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> recordCanaryDetail{};
  shared_ptr<string> region{};
  shared_ptr<long> status{};

  CreateOrUpdateSwimmingLaneGroupRequest() {}

  explicit CreateOrUpdateSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (dbGrayEnable) {
      res["DbGrayEnable"] = boost::any(*dbGrayEnable);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (messageQueueFilterSide) {
      res["MessageQueueFilterSide"] = boost::any(*messageQueueFilterSide);
    }
    if (messageQueueGrayEnable) {
      res["MessageQueueGrayEnable"] = boost::any(*messageQueueGrayEnable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (recordCanaryDetail) {
      res["RecordCanaryDetail"] = boost::any(*recordCanaryDetail);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("DbGrayEnable") != m.end() && !m["DbGrayEnable"].empty()) {
      dbGrayEnable = make_shared<bool>(boost::any_cast<bool>(m["DbGrayEnable"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MessageQueueFilterSide") != m.end() && !m["MessageQueueFilterSide"].empty()) {
      messageQueueFilterSide = make_shared<string>(boost::any_cast<string>(m["MessageQueueFilterSide"]));
    }
    if (m.find("MessageQueueGrayEnable") != m.end() && !m["MessageQueueGrayEnable"].empty()) {
      messageQueueGrayEnable = make_shared<bool>(boost::any_cast<bool>(m["MessageQueueGrayEnable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RecordCanaryDetail") != m.end() && !m["RecordCanaryDetail"].empty()) {
      recordCanaryDetail = make_shared<bool>(boost::any_cast<bool>(m["RecordCanaryDetail"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupRequest() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> dbGrayEnable{};
  shared_ptr<string> entryApp{};
  shared_ptr<long> id{};
  shared_ptr<string> messageQueueFilterSide{};
  shared_ptr<bool> messageQueueGrayEnable{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> recordCanaryDetail{};
  shared_ptr<string> region{};
  shared_ptr<string> userId{};

  CreateOrUpdateSwimmingLaneGroupResponseBodyData() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (dbGrayEnable) {
      res["DbGrayEnable"] = boost::any(*dbGrayEnable);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (messageQueueFilterSide) {
      res["MessageQueueFilterSide"] = boost::any(*messageQueueFilterSide);
    }
    if (messageQueueGrayEnable) {
      res["MessageQueueGrayEnable"] = boost::any(*messageQueueGrayEnable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (recordCanaryDetail) {
      res["RecordCanaryDetail"] = boost::any(*recordCanaryDetail);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("DbGrayEnable") != m.end() && !m["DbGrayEnable"].empty()) {
      dbGrayEnable = make_shared<string>(boost::any_cast<string>(m["DbGrayEnable"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MessageQueueFilterSide") != m.end() && !m["MessageQueueFilterSide"].empty()) {
      messageQueueFilterSide = make_shared<string>(boost::any_cast<string>(m["MessageQueueFilterSide"]));
    }
    if (m.find("MessageQueueGrayEnable") != m.end() && !m["MessageQueueGrayEnable"].empty()) {
      messageQueueGrayEnable = make_shared<bool>(boost::any_cast<bool>(m["MessageQueueGrayEnable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RecordCanaryDetail") != m.end() && !m["RecordCanaryDetail"].empty()) {
      recordCanaryDetail = make_shared<bool>(boost::any_cast<bool>(m["RecordCanaryDetail"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponseBodyData() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOrUpdateSwimmingLaneGroupResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateOrUpdateSwimmingLaneGroupResponseBody() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOrUpdateSwimmingLaneGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOrUpdateSwimmingLaneGroupResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponseBody() = default;
};
class CreateOrUpdateSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateSwimmingLaneGroupResponseBody> body{};

  CreateOrUpdateSwimmingLaneGroupResponse() {}

  explicit CreateOrUpdateSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateSwimmingLaneGroupResponse() = default;
};
class CreateZnodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> data{};
  shared_ptr<string> path{};

  CreateZnodeRequest() {}

  explicit CreateZnodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateZnodeRequest() = default;
};
class CreateZnodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<bool> dir{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  CreateZnodeResponseBodyData() {}

  explicit CreateZnodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<bool>(boost::any_cast<bool>(m["Dir"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~CreateZnodeResponseBodyData() = default;
};
class CreateZnodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateZnodeResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateZnodeResponseBody() {}

  explicit CreateZnodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateZnodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateZnodeResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateZnodeResponseBody() = default;
};
class CreateZnodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateZnodeResponseBody> body{};

  CreateZnodeResponse() {}

  explicit CreateZnodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateZnodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateZnodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateZnodeResponse() = default;
};
class DeleteAuthResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  DeleteAuthResourceRequest() {}

  explicit DeleteAuthResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteAuthResourceRequest() = default;
};
class DeleteAuthResourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> authId{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<bool> isWhite{};
  shared_ptr<string> path{};

  DeleteAuthResourceResponseBodyData() {}

  explicit DeleteAuthResourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authId) {
      res["AuthId"] = boost::any(*authId);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isWhite) {
      res["IsWhite"] = boost::any(*isWhite);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthId") != m.end() && !m["AuthId"].empty()) {
      authId = make_shared<long>(boost::any_cast<long>(m["AuthId"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsWhite") != m.end() && !m["IsWhite"].empty()) {
      isWhite = make_shared<bool>(boost::any_cast<bool>(m["IsWhite"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DeleteAuthResourceResponseBodyData() = default;
};
class DeleteAuthResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteAuthResourceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAuthResourceResponseBody() {}

  explicit DeleteAuthResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteAuthResourceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteAuthResourceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAuthResourceResponseBody() = default;
};
class DeleteAuthResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAuthResourceResponseBody> body{};

  DeleteAuthResourceResponse() {}

  explicit DeleteAuthResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAuthResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAuthResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAuthResourceResponse() = default;
};
class DeleteCircuitBreakerRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> namespace_{};

  DeleteCircuitBreakerRulesRequest() {}

  explicit DeleteCircuitBreakerRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteCircuitBreakerRulesRequest() = default;
};
class DeleteCircuitBreakerRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> namespace_{};

  DeleteCircuitBreakerRulesShrinkRequest() {}

  explicit DeleteCircuitBreakerRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteCircuitBreakerRulesShrinkRequest() = default;
};
class DeleteCircuitBreakerRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<long>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCircuitBreakerRulesResponseBody() {}

  explicit DeleteCircuitBreakerRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCircuitBreakerRulesResponseBody() = default;
};
class DeleteCircuitBreakerRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCircuitBreakerRulesResponseBody> body{};

  DeleteCircuitBreakerRulesResponse() {}

  explicit DeleteCircuitBreakerRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCircuitBreakerRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCircuitBreakerRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCircuitBreakerRulesResponse() = default;
};
class DeleteClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};

  DeleteClusterRequest() {}

  explicit DeleteClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteClusterRequest() = default;
};
class DeleteClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteClusterResponseBody() {}

  explicit DeleteClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteClusterResponseBody() = default;
};
class DeleteClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClusterResponseBody> body{};

  DeleteClusterResponse() {}

  explicit DeleteClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClusterResponse() = default;
};
class DeleteEngineNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};

  DeleteEngineNamespaceRequest() {}

  explicit DeleteEngineNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteEngineNamespaceRequest() = default;
};
class DeleteEngineNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEngineNamespaceResponseBody() {}

  explicit DeleteEngineNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEngineNamespaceResponseBody() = default;
};
class DeleteEngineNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEngineNamespaceResponseBody> body{};

  DeleteEngineNamespaceResponse() {}

  explicit DeleteEngineNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEngineNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEngineNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEngineNamespaceResponse() = default;
};
class DeleteFlowRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<vector<long>> ids{};
  shared_ptr<string> namespace_{};

  DeleteFlowRulesRequest() {}

  explicit DeleteFlowRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteFlowRulesRequest() = default;
};
class DeleteFlowRulesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> idsShrink{};
  shared_ptr<string> namespace_{};

  DeleteFlowRulesShrinkRequest() {}

  explicit DeleteFlowRulesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (idsShrink) {
      res["Ids"] = boost::any(*idsShrink);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      idsShrink = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteFlowRulesShrinkRequest() = default;
};
class DeleteFlowRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<long>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFlowRulesResponseBody() {}

  explicit DeleteFlowRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFlowRulesResponseBody() = default;
};
class DeleteFlowRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFlowRulesResponseBody> body{};

  DeleteFlowRulesResponse() {}

  explicit DeleteFlowRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowRulesResponse() = default;
};
class DeleteGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> deleteSlb{};
  shared_ptr<string> gatewayUniqueId{};

  DeleteGatewayRequest() {}

  explicit DeleteGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (deleteSlb) {
      res["DeleteSlb"] = boost::any(*deleteSlb);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DeleteSlb") != m.end() && !m["DeleteSlb"].empty()) {
      deleteSlb = make_shared<bool>(boost::any_cast<bool>(m["DeleteSlb"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~DeleteGatewayRequest() = default;
};
class DeleteGatewayResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> securityGroup{};
  shared_ptr<string> spec{};
  shared_ptr<long> status{};
  shared_ptr<string> vpc{};
  shared_ptr<string> vswitch{};

  DeleteGatewayResponseBodyData() {}

  explicit DeleteGatewayResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (securityGroup) {
      res["SecurityGroup"] = boost::any(*securityGroup);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vpc) {
      res["Vpc"] = boost::any(*vpc);
    }
    if (vswitch) {
      res["Vswitch"] = boost::any(*vswitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      securityGroup = make_shared<string>(boost::any_cast<string>(m["SecurityGroup"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      vpc = make_shared<string>(boost::any_cast<string>(m["Vpc"]));
    }
    if (m.find("Vswitch") != m.end() && !m["Vswitch"].empty()) {
      vswitch = make_shared<string>(boost::any_cast<string>(m["Vswitch"]));
    }
  }


  virtual ~DeleteGatewayResponseBodyData() = default;
};
class DeleteGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteGatewayResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayResponseBody() {}

  explicit DeleteGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteGatewayResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteGatewayResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayResponseBody() = default;
};
class DeleteGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayResponseBody> body{};

  DeleteGatewayResponse() {}

  explicit DeleteGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayResponse() = default;
};
class DeleteGatewayAuthConsumerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  DeleteGatewayAuthConsumerRequest() {}

  explicit DeleteGatewayAuthConsumerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteGatewayAuthConsumerRequest() = default;
};
class DeleteGatewayAuthConsumerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayAuthConsumerResponseBody() {}

  explicit DeleteGatewayAuthConsumerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayAuthConsumerResponseBody() = default;
};
class DeleteGatewayAuthConsumerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayAuthConsumerResponseBody> body{};

  DeleteGatewayAuthConsumerResponse() {}

  explicit DeleteGatewayAuthConsumerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayAuthConsumerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayAuthConsumerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayAuthConsumerResponse() = default;
};
class DeleteGatewayAuthConsumerResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> idList{};

  DeleteGatewayAuthConsumerResourceRequest() {}

  explicit DeleteGatewayAuthConsumerResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (idList) {
      res["IdList"] = boost::any(*idList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IdList") != m.end() && !m["IdList"].empty()) {
      idList = make_shared<string>(boost::any_cast<string>(m["IdList"]));
    }
  }


  virtual ~DeleteGatewayAuthConsumerResourceRequest() = default;
};
class DeleteGatewayAuthConsumerResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayAuthConsumerResourceResponseBody() {}

  explicit DeleteGatewayAuthConsumerResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayAuthConsumerResourceResponseBody() = default;
};
class DeleteGatewayAuthConsumerResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayAuthConsumerResourceResponseBody> body{};

  DeleteGatewayAuthConsumerResourceResponse() {}

  explicit DeleteGatewayAuthConsumerResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayAuthConsumerResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayAuthConsumerResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayAuthConsumerResourceResponse() = default;
};
class DeleteGatewayDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> id{};

  DeleteGatewayDomainRequest() {}

  explicit DeleteGatewayDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteGatewayDomainRequest() = default;
};
class DeleteGatewayDomainResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<bool> mustHttps{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};

  DeleteGatewayDomainResponseBodyData() {}

  explicit DeleteGatewayDomainResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<bool>(boost::any_cast<bool>(m["MustHttps"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DeleteGatewayDomainResponseBodyData() = default;
};
class DeleteGatewayDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteGatewayDomainResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayDomainResponseBody() {}

  explicit DeleteGatewayDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteGatewayDomainResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteGatewayDomainResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayDomainResponseBody() = default;
};
class DeleteGatewayDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayDomainResponseBody> body{};

  DeleteGatewayDomainResponse() {}

  explicit DeleteGatewayDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayDomainResponse() = default;
};
class DeleteGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> routeId{};

  DeleteGatewayRouteRequest() {}

  explicit DeleteGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
  }


  virtual ~DeleteGatewayRouteRequest() = default;
};
class DeleteGatewayRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> defaultServiceId{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> predicates{};
  shared_ptr<long> routeOrder{};
  shared_ptr<long> status{};

  DeleteGatewayRouteResponseBodyData() {}

  explicit DeleteGatewayRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultServiceId) {
      res["DefaultServiceId"] = boost::any(*defaultServiceId);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (predicates) {
      res["Predicates"] = boost::any(*predicates);
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultServiceId") != m.end() && !m["DefaultServiceId"].empty()) {
      defaultServiceId = make_shared<long>(boost::any_cast<long>(m["DefaultServiceId"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicates = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DeleteGatewayRouteResponseBodyData() = default;
};
class DeleteGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteGatewayRouteResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayRouteResponseBody() {}

  explicit DeleteGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteGatewayRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteGatewayRouteResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayRouteResponseBody() = default;
};
class DeleteGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayRouteResponseBody> body{};

  DeleteGatewayRouteResponse() {}

  explicit DeleteGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayRouteResponse() = default;
};
class DeleteGatewayServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> serviceId{};

  DeleteGatewayServiceRequest() {}

  explicit DeleteGatewayServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
  }


  virtual ~DeleteGatewayServiceRequest() = default;
};
class DeleteGatewayServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> metaInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> serviceNameInRegistry{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};

  DeleteGatewayServiceResponseBodyData() {}

  explicit DeleteGatewayServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (metaInfo) {
      res["MetaInfo"] = boost::any(*metaInfo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (serviceNameInRegistry) {
      res["ServiceNameInRegistry"] = boost::any(*serviceNameInRegistry);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MetaInfo") != m.end() && !m["MetaInfo"].empty()) {
      metaInfo = make_shared<string>(boost::any_cast<string>(m["MetaInfo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ServiceNameInRegistry") != m.end() && !m["ServiceNameInRegistry"].empty()) {
      serviceNameInRegistry = make_shared<string>(boost::any_cast<string>(m["ServiceNameInRegistry"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~DeleteGatewayServiceResponseBodyData() = default;
};
class DeleteGatewayServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteGatewayServiceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayServiceResponseBody() {}

  explicit DeleteGatewayServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteGatewayServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteGatewayServiceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayServiceResponseBody() = default;
};
class DeleteGatewayServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayServiceResponseBody> body{};

  DeleteGatewayServiceResponse() {}

  explicit DeleteGatewayServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayServiceResponse() = default;
};
class DeleteGatewayServiceVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceVersion{};

  DeleteGatewayServiceVersionRequest() {}

  explicit DeleteGatewayServiceVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~DeleteGatewayServiceVersionRequest() = default;
};
class DeleteGatewayServiceVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewayServiceVersionResponseBody() {}

  explicit DeleteGatewayServiceVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewayServiceVersionResponseBody() = default;
};
class DeleteGatewayServiceVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewayServiceVersionResponseBody> body{};

  DeleteGatewayServiceVersionResponse() {}

  explicit DeleteGatewayServiceVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewayServiceVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewayServiceVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewayServiceVersionResponse() = default;
};
class DeleteGatewaySlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> deleteSlb{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> id{};
  shared_ptr<string> slbId{};

  DeleteGatewaySlbRequest() {}

  explicit DeleteGatewaySlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (deleteSlb) {
      res["DeleteSlb"] = boost::any(*deleteSlb);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DeleteSlb") != m.end() && !m["DeleteSlb"].empty()) {
      deleteSlb = make_shared<bool>(boost::any_cast<bool>(m["DeleteSlb"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
  }


  virtual ~DeleteGatewaySlbRequest() = default;
};
class DeleteGatewaySlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGatewaySlbResponseBody() {}

  explicit DeleteGatewaySlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGatewaySlbResponseBody() = default;
};
class DeleteGatewaySlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGatewaySlbResponseBody> body{};

  DeleteGatewaySlbResponse() {}

  explicit DeleteGatewaySlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGatewaySlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGatewaySlbResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGatewaySlbResponse() = default;
};
class DeleteMigrationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> id{};
  shared_ptr<string> requestPars{};

  DeleteMigrationTaskRequest() {}

  explicit DeleteMigrationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~DeleteMigrationTaskRequest() = default;
};
class DeleteMigrationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMigrationTaskResponseBody() {}

  explicit DeleteMigrationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMigrationTaskResponseBody() = default;
};
class DeleteMigrationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMigrationTaskResponseBody> body{};

  DeleteMigrationTaskResponse() {}

  explicit DeleteMigrationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMigrationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMigrationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMigrationTaskResponse() = default;
};
class DeleteNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> beta{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};

  DeleteNacosConfigRequest() {}

  explicit DeleteNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (beta) {
      res["Beta"] = boost::any(*beta);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Beta") != m.end() && !m["Beta"].empty()) {
      beta = make_shared<bool>(boost::any_cast<bool>(m["Beta"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteNacosConfigRequest() = default;
};
class DeleteNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNacosConfigResponseBody() {}

  explicit DeleteNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNacosConfigResponseBody() = default;
};
class DeleteNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNacosConfigResponseBody> body{};

  DeleteNacosConfigResponse() {}

  explicit DeleteNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNacosConfigResponse() = default;
};
class DeleteNacosConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> ids{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};

  DeleteNacosConfigsRequest() {}

  explicit DeleteNacosConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~DeleteNacosConfigsRequest() = default;
};
class DeleteNacosConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNacosConfigsResponseBody() {}

  explicit DeleteNacosConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNacosConfigsResponseBody() = default;
};
class DeleteNacosConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNacosConfigsResponseBody> body{};

  DeleteNacosConfigsResponse() {}

  explicit DeleteNacosConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNacosConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNacosConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNacosConfigsResponse() = default;
};
class DeleteNacosInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterName{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> port{};
  shared_ptr<string> serviceName{};

  DeleteNacosInstanceRequest() {}

  explicit DeleteNacosInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DeleteNacosInstanceRequest() = default;
};
class DeleteNacosInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNacosInstanceResponseBody() {}

  explicit DeleteNacosInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNacosInstanceResponseBody() = default;
};
class DeleteNacosInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNacosInstanceResponseBody> body{};

  DeleteNacosInstanceResponse() {}

  explicit DeleteNacosInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNacosInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNacosInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNacosInstanceResponse() = default;
};
class DeleteNacosServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> serviceName{};

  DeleteNacosServiceRequest() {}

  explicit DeleteNacosServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DeleteNacosServiceRequest() = default;
};
class DeleteNacosServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNacosServiceResponseBody() {}

  explicit DeleteNacosServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNacosServiceResponseBody() = default;
};
class DeleteNacosServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNacosServiceResponseBody> body{};

  DeleteNacosServiceResponse() {}

  explicit DeleteNacosServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNacosServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNacosServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNacosServiceResponse() = default;
};
class DeleteNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> name{};
  shared_ptr<string> region{};

  DeleteNamespaceRequest() {}

  explicit DeleteNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DeleteNamespaceRequest() = default;
};
class DeleteNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteNamespaceResponseBody() {}

  explicit DeleteNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteNamespaceResponseBody() = default;
};
class DeleteNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNamespaceResponseBody> body{};

  DeleteNamespaceResponse() {}

  explicit DeleteNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNamespaceResponse() = default;
};
class DeleteSecurityGroupRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> cascadingDelete{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  DeleteSecurityGroupRuleRequest() {}

  explicit DeleteSecurityGroupRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (cascadingDelete) {
      res["CascadingDelete"] = boost::any(*cascadingDelete);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CascadingDelete") != m.end() && !m["CascadingDelete"].empty()) {
      cascadingDelete = make_shared<bool>(boost::any_cast<bool>(m["CascadingDelete"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteSecurityGroupRuleRequest() = default;
};
class DeleteSecurityGroupRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> securityGroupId{};

  DeleteSecurityGroupRuleResponseBodyData() {}

  explicit DeleteSecurityGroupRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~DeleteSecurityGroupRuleResponseBodyData() = default;
};
class DeleteSecurityGroupRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteSecurityGroupRuleResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSecurityGroupRuleResponseBody() {}

  explicit DeleteSecurityGroupRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteSecurityGroupRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteSecurityGroupRuleResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSecurityGroupRuleResponseBody() = default;
};
class DeleteSecurityGroupRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecurityGroupRuleResponseBody> body{};

  DeleteSecurityGroupRuleResponse() {}

  explicit DeleteSecurityGroupRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityGroupRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityGroupRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityGroupRuleResponse() = default;
};
class DeleteServiceSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> sourceId{};

  DeleteServiceSourceRequest() {}

  explicit DeleteServiceSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["SourceId"]));
    }
  }


  virtual ~DeleteServiceSourceRequest() = default;
};
class DeleteServiceSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteServiceSourceResponseBody() {}

  explicit DeleteServiceSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteServiceSourceResponseBody() = default;
};
class DeleteServiceSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceSourceResponseBody> body{};

  DeleteServiceSourceResponse() {}

  explicit DeleteServiceSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceSourceResponse() = default;
};
class DeleteSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> laneId{};
  shared_ptr<string> namespace_{};

  DeleteSwimmingLaneRequest() {}

  explicit DeleteSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteSwimmingLaneRequest() = default;
};
class DeleteSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSwimmingLaneResponseBody() {}

  explicit DeleteSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSwimmingLaneResponseBody() = default;
};
class DeleteSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSwimmingLaneResponseBody> body{};

  DeleteSwimmingLaneResponse() {}

  explicit DeleteSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneResponse() = default;
};
class DeleteSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};

  DeleteSwimmingLaneGroupRequest() {}

  explicit DeleteSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupRequest() = default;
};
class DeleteSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSwimmingLaneGroupResponseBody() {}

  explicit DeleteSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponseBody() = default;
};
class DeleteSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSwimmingLaneGroupResponseBody> body{};

  DeleteSwimmingLaneGroupResponse() {}

  explicit DeleteSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSwimmingLaneGroupResponse() = default;
};
class DeleteZnodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> path{};
  shared_ptr<string> requestPars{};

  DeleteZnodeRequest() {}

  explicit DeleteZnodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~DeleteZnodeRequest() = default;
};
class DeleteZnodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<bool> dir{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  DeleteZnodeResponseBodyData() {}

  explicit DeleteZnodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<bool>(boost::any_cast<bool>(m["Dir"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DeleteZnodeResponseBodyData() = default;
};
class DeleteZnodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteZnodeResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteZnodeResponseBody() {}

  explicit DeleteZnodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteZnodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteZnodeResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteZnodeResponseBody() = default;
};
class DeleteZnodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteZnodeResponseBody> body{};

  DeleteZnodeResponse() {}

  explicit DeleteZnodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteZnodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteZnodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteZnodeResponse() = default;
};
class ExportNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> dataIds{};
  shared_ptr<string> group{};
  shared_ptr<string> ids{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};

  ExportNacosConfigRequest() {}

  explicit ExportNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (dataIds) {
      res["DataIds"] = boost::any(*dataIds);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("DataIds") != m.end() && !m["DataIds"].empty()) {
      dataIds = make_shared<string>(boost::any_cast<string>(m["DataIds"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~ExportNacosConfigRequest() = default;
};
class ExportNacosConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  ExportNacosConfigResponseBodyData() {}

  explicit ExportNacosConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ExportNacosConfigResponseBodyData() = default;
};
class ExportNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ExportNacosConfigResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportNacosConfigResponseBody() {}

  explicit ExportNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExportNacosConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExportNacosConfigResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportNacosConfigResponseBody() = default;
};
class ExportNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportNacosConfigResponseBody> body{};

  ExportNacosConfigResponse() {}

  explicit ExportNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ExportNacosConfigResponse() = default;
};
class ExportZookeeperDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> exportType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ExportZookeeperDataRequest() {}

  explicit ExportZookeeperDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ExportZookeeperDataRequest() = default;
};
class ExportZookeeperDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> contentMap{};
  shared_ptr<long> createTime{};
  shared_ptr<string> exportType{};
  shared_ptr<string> extend{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> kubeoneTaskIds{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ExportZookeeperDataResponseBodyData() {}

  explicit ExportZookeeperDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentMap) {
      res["ContentMap"] = boost::any(*contentMap);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (kubeoneTaskIds) {
      res["KubeoneTaskIds"] = boost::any(*kubeoneTaskIds);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentMap") != m.end() && !m["ContentMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ContentMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      contentMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KubeoneTaskIds") != m.end() && !m["KubeoneTaskIds"].empty()) {
      kubeoneTaskIds = make_shared<string>(boost::any_cast<string>(m["KubeoneTaskIds"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ExportZookeeperDataResponseBodyData() = default;
};
class ExportZookeeperDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<ExportZookeeperDataResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportZookeeperDataResponseBody() {}

  explicit ExportZookeeperDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExportZookeeperDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExportZookeeperDataResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportZookeeperDataResponseBody() = default;
};
class ExportZookeeperDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportZookeeperDataResponseBody> body{};

  ExportZookeeperDataResponse() {}

  explicit ExportZookeeperDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportZookeeperDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportZookeeperDataResponseBody>(model1);
      }
    }
  }


  virtual ~ExportZookeeperDataResponse() = default;
};
class FetchLosslessRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  FetchLosslessRuleListRequest() {}

  explicit FetchLosslessRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~FetchLosslessRuleListRequest() = default;
};
class FetchLosslessRuleListResponseBodyDataResults : public Darabonba::Model {
public:
  shared_ptr<bool> aligned{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> count{};
  shared_ptr<long> delayTime{};
  shared_ptr<bool> enable{};
  shared_ptr<long> funcType{};
  shared_ptr<bool> lossLessDetail{};
  shared_ptr<bool> notice{};
  shared_ptr<bool> related{};
  shared_ptr<long> warmupTime{};

  FetchLosslessRuleListResponseBodyDataResults() {}

  explicit FetchLosslessRuleListResponseBodyDataResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aligned) {
      res["Aligned"] = boost::any(*aligned);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (funcType) {
      res["FuncType"] = boost::any(*funcType);
    }
    if (lossLessDetail) {
      res["LossLessDetail"] = boost::any(*lossLessDetail);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (warmupTime) {
      res["WarmupTime"] = boost::any(*warmupTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aligned") != m.end() && !m["Aligned"].empty()) {
      aligned = make_shared<bool>(boost::any_cast<bool>(m["Aligned"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FuncType") != m.end() && !m["FuncType"].empty()) {
      funcType = make_shared<long>(boost::any_cast<long>(m["FuncType"]));
    }
    if (m.find("LossLessDetail") != m.end() && !m["LossLessDetail"].empty()) {
      lossLessDetail = make_shared<bool>(boost::any_cast<bool>(m["LossLessDetail"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<bool>(boost::any_cast<bool>(m["Notice"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<bool>(boost::any_cast<bool>(m["Related"]));
    }
    if (m.find("WarmupTime") != m.end() && !m["WarmupTime"].empty()) {
      warmupTime = make_shared<long>(boost::any_cast<long>(m["WarmupTime"]));
    }
  }


  virtual ~FetchLosslessRuleListResponseBodyDataResults() = default;
};
class FetchLosslessRuleListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<FetchLosslessRuleListResponseBodyDataResults>> results{};
  shared_ptr<long> totalSize{};

  FetchLosslessRuleListResponseBodyData() {}

  explicit FetchLosslessRuleListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<FetchLosslessRuleListResponseBodyDataResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FetchLosslessRuleListResponseBodyDataResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<FetchLosslessRuleListResponseBodyDataResults>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~FetchLosslessRuleListResponseBodyData() = default;
};
class FetchLosslessRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<FetchLosslessRuleListResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  FetchLosslessRuleListResponseBody() {}

  explicit FetchLosslessRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        FetchLosslessRuleListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<FetchLosslessRuleListResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FetchLosslessRuleListResponseBody() = default;
};
class FetchLosslessRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FetchLosslessRuleListResponseBody> body{};

  FetchLosslessRuleListResponse() {}

  explicit FetchLosslessRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FetchLosslessRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FetchLosslessRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~FetchLosslessRuleListResponse() = default;
};
class GetAppMessageQueueRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};

  GetAppMessageQueueRouteRequest() {}

  explicit GetAppMessageQueueRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~GetAppMessageQueueRouteRequest() = default;
};
class GetAppMessageQueueRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<bool> enable{};
  shared_ptr<string> filterSide{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> tags{};

  GetAppMessageQueueRouteResponseBodyData() {}

  explicit GetAppMessageQueueRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (filterSide) {
      res["FilterSide"] = boost::any(*filterSide);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FilterSide") != m.end() && !m["FilterSide"].empty()) {
      filterSide = make_shared<string>(boost::any_cast<string>(m["FilterSide"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAppMessageQueueRouteResponseBodyData() = default;
};
class GetAppMessageQueueRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetAppMessageQueueRouteResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAppMessageQueueRouteResponseBody() {}

  explicit GetAppMessageQueueRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAppMessageQueueRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAppMessageQueueRouteResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAppMessageQueueRouteResponseBody() = default;
};
class GetAppMessageQueueRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppMessageQueueRouteResponseBody> body{};

  GetAppMessageQueueRouteResponse() {}

  explicit GetAppMessageQueueRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppMessageQueueRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppMessageQueueRouteResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppMessageQueueRouteResponse() = default;
};
class GetApplicationInstanceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> tag{};

  GetApplicationInstanceListRequest() {}

  explicit GetApplicationInstanceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~GetApplicationInstanceListRequest() = default;
};
class GetApplicationInstanceListResponseBodyDataResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tag{};

  GetApplicationInstanceListResponseBodyDataResultTags() {}

  explicit GetApplicationInstanceListResponseBodyDataResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~GetApplicationInstanceListResponseBodyDataResultTags() = default;
};
class GetApplicationInstanceListResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> port{};
  shared_ptr<vector<GetApplicationInstanceListResponseBodyDataResultTags>> tags{};

  GetApplicationInstanceListResponseBodyDataResult() {}

  explicit GetApplicationInstanceListResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetApplicationInstanceListResponseBodyDataResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationInstanceListResponseBodyDataResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetApplicationInstanceListResponseBodyDataResultTags>>(expect1);
      }
    }
  }


  virtual ~GetApplicationInstanceListResponseBodyDataResult() = default;
};
class GetApplicationInstanceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<GetApplicationInstanceListResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  GetApplicationInstanceListResponseBodyData() {}

  explicit GetApplicationInstanceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetApplicationInstanceListResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationInstanceListResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetApplicationInstanceListResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetApplicationInstanceListResponseBodyData() = default;
};
class GetApplicationInstanceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationInstanceListResponseBodyData> data{};

  GetApplicationInstanceListResponseBody() {}

  explicit GetApplicationInstanceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetApplicationInstanceListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetApplicationInstanceListResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetApplicationInstanceListResponseBody() = default;
};
class GetApplicationInstanceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationInstanceListResponseBody> body{};

  GetApplicationInstanceListResponse() {}

  explicit GetApplicationInstanceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationInstanceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationInstanceListResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationInstanceListResponse() = default;
};
class GetApplicationListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> language{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<bool> sentinelEnable{};
  shared_ptr<string> source{};
  shared_ptr<bool> switchEnable{};

  GetApplicationListRequest() {}

  explicit GetApplicationListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sentinelEnable) {
      res["SentinelEnable"] = boost::any(*sentinelEnable);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (switchEnable) {
      res["SwitchEnable"] = boost::any(*switchEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SentinelEnable") != m.end() && !m["SentinelEnable"].empty()) {
      sentinelEnable = make_shared<bool>(boost::any_cast<bool>(m["SentinelEnable"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SwitchEnable") != m.end() && !m["SwitchEnable"].empty()) {
      switchEnable = make_shared<bool>(boost::any_cast<bool>(m["SwitchEnable"]));
    }
  }


  virtual ~GetApplicationListRequest() = default;
};
class GetApplicationListResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> extraInfo{};
  shared_ptr<long> instancesNumber{};
  shared_ptr<string> language{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> userId{};

  GetApplicationListResponseBodyDataResult() {}

  explicit GetApplicationListResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (instancesNumber) {
      res["InstancesNumber"] = boost::any(*instancesNumber);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("InstancesNumber") != m.end() && !m["InstancesNumber"].empty()) {
      instancesNumber = make_shared<long>(boost::any_cast<long>(m["InstancesNumber"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetApplicationListResponseBodyDataResult() = default;
};
class GetApplicationListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<GetApplicationListResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  GetApplicationListResponseBodyData() {}

  explicit GetApplicationListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetApplicationListResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationListResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetApplicationListResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetApplicationListResponseBodyData() = default;
};
class GetApplicationListResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetApplicationListResponseBody() {}

  explicit GetApplicationListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetApplicationListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetApplicationListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetApplicationListResponseBody() = default;
};
class GetApplicationListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationListResponseBody> body{};

  GetApplicationListResponse() {}

  explicit GetApplicationListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationListResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationListResponse() = default;
};
class GetBlackWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<bool> isWhite{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> type{};

  GetBlackWhiteListRequest() {}

  explicit GetBlackWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (isWhite) {
      res["IsWhite"] = boost::any(*isWhite);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IsWhite") != m.end() && !m["IsWhite"].empty()) {
      isWhite = make_shared<bool>(boost::any_cast<bool>(m["IsWhite"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBlackWhiteListRequest() = default;
};
class GetBlackWhiteListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<bool> isWhite{};
  shared_ptr<long> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetBlackWhiteListResponseBodyData() {}

  explicit GetBlackWhiteListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isWhite) {
      res["IsWhite"] = boost::any(*isWhite);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsWhite") != m.end() && !m["IsWhite"].empty()) {
      isWhite = make_shared<bool>(boost::any_cast<bool>(m["IsWhite"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<long>(boost::any_cast<long>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBlackWhiteListResponseBodyData() = default;
};
class GetBlackWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetBlackWhiteListResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBlackWhiteListResponseBody() {}

  explicit GetBlackWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBlackWhiteListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBlackWhiteListResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBlackWhiteListResponseBody() = default;
};
class GetBlackWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBlackWhiteListResponseBody> body{};

  GetBlackWhiteListResponse() {}

  explicit GetBlackWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBlackWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBlackWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~GetBlackWhiteListResponse() = default;
};
class GetEngineNamepaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};

  GetEngineNamepaceRequest() {}

  explicit GetEngineNamepaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetEngineNamepaceRequest() = default;
};
class GetEngineNamepaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> configCount{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceDesc{};
  shared_ptr<string> namespaceShowName{};
  shared_ptr<string> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> type{};

  GetEngineNamepaceResponseBody() {}

  explicit GetEngineNamepaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configCount) {
      res["ConfigCount"] = boost::any(*configCount);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceDesc) {
      res["NamespaceDesc"] = boost::any(*namespaceDesc);
    }
    if (namespaceShowName) {
      res["NamespaceShowName"] = boost::any(*namespaceShowName);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigCount") != m.end() && !m["ConfigCount"].empty()) {
      configCount = make_shared<string>(boost::any_cast<string>(m["ConfigCount"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceDesc") != m.end() && !m["NamespaceDesc"].empty()) {
      namespaceDesc = make_shared<string>(boost::any_cast<string>(m["NamespaceDesc"]));
    }
    if (m.find("NamespaceShowName") != m.end() && !m["NamespaceShowName"].empty()) {
      namespaceShowName = make_shared<string>(boost::any_cast<string>(m["NamespaceShowName"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<string>(boost::any_cast<string>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEngineNamepaceResponseBody() = default;
};
class GetEngineNamepaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEngineNamepaceResponseBody> body{};

  GetEngineNamepaceResponse() {}

  explicit GetEngineNamepaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEngineNamepaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEngineNamepaceResponseBody>(model1);
      }
    }
  }


  virtual ~GetEngineNamepaceResponse() = default;
};
class GetGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};

  GetGatewayRequest() {}

  explicit GetGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~GetGatewayRequest() = default;
};
class GetGatewayResponseBodyDataElasticPolicyTimePolicyList : public Darabonba::Model {
public:
  shared_ptr<long> desiredReplica{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  GetGatewayResponseBodyDataElasticPolicyTimePolicyList() {}

  explicit GetGatewayResponseBodyDataElasticPolicyTimePolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredReplica) {
      res["DesiredReplica"] = boost::any(*desiredReplica);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredReplica") != m.end() && !m["DesiredReplica"].empty()) {
      desiredReplica = make_shared<long>(boost::any_cast<long>(m["DesiredReplica"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetGatewayResponseBodyDataElasticPolicyTimePolicyList() = default;
};
class GetGatewayResponseBodyDataElasticPolicy : public Darabonba::Model {
public:
  shared_ptr<string> elasticType{};
  shared_ptr<long> maxReplica{};
  shared_ptr<vector<GetGatewayResponseBodyDataElasticPolicyTimePolicyList>> timePolicyList{};

  GetGatewayResponseBodyDataElasticPolicy() {}

  explicit GetGatewayResponseBodyDataElasticPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticType) {
      res["ElasticType"] = boost::any(*elasticType);
    }
    if (maxReplica) {
      res["MaxReplica"] = boost::any(*maxReplica);
    }
    if (timePolicyList) {
      vector<boost::any> temp1;
      for(auto item1:*timePolicyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimePolicyList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElasticType") != m.end() && !m["ElasticType"].empty()) {
      elasticType = make_shared<string>(boost::any_cast<string>(m["ElasticType"]));
    }
    if (m.find("MaxReplica") != m.end() && !m["MaxReplica"].empty()) {
      maxReplica = make_shared<long>(boost::any_cast<long>(m["MaxReplica"]));
    }
    if (m.find("TimePolicyList") != m.end() && !m["TimePolicyList"].empty()) {
      if (typeid(vector<boost::any>) == m["TimePolicyList"].type()) {
        vector<GetGatewayResponseBodyDataElasticPolicyTimePolicyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimePolicyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayResponseBodyDataElasticPolicyTimePolicyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timePolicyList = make_shared<vector<GetGatewayResponseBodyDataElasticPolicyTimePolicyList>>(expect1);
      }
    }
  }


  virtual ~GetGatewayResponseBodyDataElasticPolicy() = default;
};
class GetGatewayResponseBodyDataLogConfigDetails : public Darabonba::Model {
public:
  shared_ptr<bool> logEnabled{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};

  GetGatewayResponseBodyDataLogConfigDetails() {}

  explicit GetGatewayResponseBodyDataLogConfigDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logEnabled) {
      res["LogEnabled"] = boost::any(*logEnabled);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogEnabled") != m.end() && !m["LogEnabled"].empty()) {
      logEnabled = make_shared<bool>(boost::any_cast<bool>(m["LogEnabled"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetGatewayResponseBodyDataLogConfigDetails() = default;
};
class GetGatewayResponseBodyDataXtraceDetails : public Darabonba::Model {
public:
  shared_ptr<long> sample{};
  shared_ptr<bool> traceOn{};

  GetGatewayResponseBodyDataXtraceDetails() {}

  explicit GetGatewayResponseBodyDataXtraceDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (traceOn) {
      res["TraceOn"] = boost::any(*traceOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<long>(boost::any_cast<long>(m["Sample"]));
    }
    if (m.find("TraceOn") != m.end() && !m["TraceOn"].empty()) {
      traceOn = make_shared<bool>(boost::any_cast<bool>(m["TraceOn"]));
    }
  }


  virtual ~GetGatewayResponseBodyDataXtraceDetails() = default;
};
class GetGatewayResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<bool> elastic{};
  shared_ptr<GetGatewayResponseBodyDataElasticPolicy> elasticPolicy{};
  shared_ptr<long> elasticReplica{};
  shared_ptr<string> elasticType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<GetGatewayResponseBodyDataLogConfigDetails> logConfigDetails{};
  shared_ptr<string> mseTag{};
  shared_ptr<string> name{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityGroup{};
  shared_ptr<string> spec{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<long> totalReplica{};
  shared_ptr<string> vpc{};
  shared_ptr<string> vswitch{};
  shared_ptr<string> vswitch2{};
  shared_ptr<GetGatewayResponseBodyDataXtraceDetails> xtraceDetails{};

  GetGatewayResponseBodyData() {}

  explicit GetGatewayResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (elastic) {
      res["Elastic"] = boost::any(*elastic);
    }
    if (elasticPolicy) {
      res["ElasticPolicy"] = elasticPolicy ? boost::any(elasticPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticReplica) {
      res["ElasticReplica"] = boost::any(*elasticReplica);
    }
    if (elasticType) {
      res["ElasticType"] = boost::any(*elasticType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logConfigDetails) {
      res["LogConfigDetails"] = logConfigDetails ? boost::any(logConfigDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mseTag) {
      res["MseTag"] = boost::any(*mseTag);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityGroup) {
      res["SecurityGroup"] = boost::any(*securityGroup);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (totalReplica) {
      res["TotalReplica"] = boost::any(*totalReplica);
    }
    if (vpc) {
      res["Vpc"] = boost::any(*vpc);
    }
    if (vswitch) {
      res["Vswitch"] = boost::any(*vswitch);
    }
    if (vswitch2) {
      res["Vswitch2"] = boost::any(*vswitch2);
    }
    if (xtraceDetails) {
      res["XtraceDetails"] = xtraceDetails ? boost::any(xtraceDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Elastic") != m.end() && !m["Elastic"].empty()) {
      elastic = make_shared<bool>(boost::any_cast<bool>(m["Elastic"]));
    }
    if (m.find("ElasticPolicy") != m.end() && !m["ElasticPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ElasticPolicy"].type()) {
        GetGatewayResponseBodyDataElasticPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ElasticPolicy"]));
        elasticPolicy = make_shared<GetGatewayResponseBodyDataElasticPolicy>(model1);
      }
    }
    if (m.find("ElasticReplica") != m.end() && !m["ElasticReplica"].empty()) {
      elasticReplica = make_shared<long>(boost::any_cast<long>(m["ElasticReplica"]));
    }
    if (m.find("ElasticType") != m.end() && !m["ElasticType"].empty()) {
      elasticType = make_shared<string>(boost::any_cast<string>(m["ElasticType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogConfigDetails") != m.end() && !m["LogConfigDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogConfigDetails"].type()) {
        GetGatewayResponseBodyDataLogConfigDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogConfigDetails"]));
        logConfigDetails = make_shared<GetGatewayResponseBodyDataLogConfigDetails>(model1);
      }
    }
    if (m.find("MseTag") != m.end() && !m["MseTag"].empty()) {
      mseTag = make_shared<string>(boost::any_cast<string>(m["MseTag"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      securityGroup = make_shared<string>(boost::any_cast<string>(m["SecurityGroup"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TotalReplica") != m.end() && !m["TotalReplica"].empty()) {
      totalReplica = make_shared<long>(boost::any_cast<long>(m["TotalReplica"]));
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      vpc = make_shared<string>(boost::any_cast<string>(m["Vpc"]));
    }
    if (m.find("Vswitch") != m.end() && !m["Vswitch"].empty()) {
      vswitch = make_shared<string>(boost::any_cast<string>(m["Vswitch"]));
    }
    if (m.find("Vswitch2") != m.end() && !m["Vswitch2"].empty()) {
      vswitch2 = make_shared<string>(boost::any_cast<string>(m["Vswitch2"]));
    }
    if (m.find("XtraceDetails") != m.end() && !m["XtraceDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["XtraceDetails"].type()) {
        GetGatewayResponseBodyDataXtraceDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["XtraceDetails"]));
        xtraceDetails = make_shared<GetGatewayResponseBodyDataXtraceDetails>(model1);
      }
    }
  }


  virtual ~GetGatewayResponseBodyData() = default;
};
class GetGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetGatewayResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayResponseBody() {}

  explicit GetGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayResponseBody() = default;
};
class GetGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayResponseBody> body{};

  GetGatewayResponse() {}

  explicit GetGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayResponse() = default;
};
class GetGatewayAuthConsumerDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  GetGatewayAuthConsumerDetailRequest() {}

  explicit GetGatewayAuthConsumerDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetGatewayAuthConsumerDetailRequest() = default;
};
class GetGatewayAuthConsumerDetailResponseBodyDataResourceList : public Darabonba::Model {
public:
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<bool> resourceStatus{};
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};

  GetGatewayAuthConsumerDetailResponseBodyDataResourceList() {}

  explicit GetGatewayAuthConsumerDetailResponseBodyDataResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<bool>(boost::any_cast<bool>(m["ResourceStatus"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
  }


  virtual ~GetGatewayAuthConsumerDetailResponseBodyDataResourceList() = default;
};
class GetGatewayAuthConsumerDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> consumerStatus{};
  shared_ptr<string> description{};
  shared_ptr<string> encodeType{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> jwks{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyValue{};
  shared_ptr<string> name{};
  shared_ptr<string> primaryUser{};
  shared_ptr<vector<GetGatewayAuthConsumerDetailResponseBodyDataResourceList>> resourceList{};
  shared_ptr<string> tokenName{};
  shared_ptr<bool> tokenPass{};
  shared_ptr<string> tokenPosition{};
  shared_ptr<string> tokenPrefix{};
  shared_ptr<string> type{};

  GetGatewayAuthConsumerDetailResponseBodyData() {}

  explicit GetGatewayAuthConsumerDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerStatus) {
      res["ConsumerStatus"] = boost::any(*consumerStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encodeType) {
      res["EncodeType"] = boost::any(*encodeType);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jwks) {
      res["Jwks"] = boost::any(*jwks);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyValue) {
      res["KeyValue"] = boost::any(*keyValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    if (tokenName) {
      res["TokenName"] = boost::any(*tokenName);
    }
    if (tokenPass) {
      res["TokenPass"] = boost::any(*tokenPass);
    }
    if (tokenPosition) {
      res["TokenPosition"] = boost::any(*tokenPosition);
    }
    if (tokenPrefix) {
      res["TokenPrefix"] = boost::any(*tokenPrefix);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerStatus") != m.end() && !m["ConsumerStatus"].empty()) {
      consumerStatus = make_shared<bool>(boost::any_cast<bool>(m["ConsumerStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EncodeType") != m.end() && !m["EncodeType"].empty()) {
      encodeType = make_shared<string>(boost::any_cast<string>(m["EncodeType"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Jwks") != m.end() && !m["Jwks"].empty()) {
      jwks = make_shared<string>(boost::any_cast<string>(m["Jwks"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyValue") != m.end() && !m["KeyValue"].empty()) {
      keyValue = make_shared<string>(boost::any_cast<string>(m["KeyValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<GetGatewayAuthConsumerDetailResponseBodyDataResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayAuthConsumerDetailResponseBodyDataResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<GetGatewayAuthConsumerDetailResponseBodyDataResourceList>>(expect1);
      }
    }
    if (m.find("TokenName") != m.end() && !m["TokenName"].empty()) {
      tokenName = make_shared<string>(boost::any_cast<string>(m["TokenName"]));
    }
    if (m.find("TokenPass") != m.end() && !m["TokenPass"].empty()) {
      tokenPass = make_shared<bool>(boost::any_cast<bool>(m["TokenPass"]));
    }
    if (m.find("TokenPosition") != m.end() && !m["TokenPosition"].empty()) {
      tokenPosition = make_shared<string>(boost::any_cast<string>(m["TokenPosition"]));
    }
    if (m.find("TokenPrefix") != m.end() && !m["TokenPrefix"].empty()) {
      tokenPrefix = make_shared<string>(boost::any_cast<string>(m["TokenPrefix"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetGatewayAuthConsumerDetailResponseBodyData() = default;
};
class GetGatewayAuthConsumerDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetGatewayAuthConsumerDetailResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayAuthConsumerDetailResponseBody() {}

  explicit GetGatewayAuthConsumerDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayAuthConsumerDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayAuthConsumerDetailResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayAuthConsumerDetailResponseBody() = default;
};
class GetGatewayAuthConsumerDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayAuthConsumerDetailResponseBody> body{};

  GetGatewayAuthConsumerDetailResponse() {}

  explicit GetGatewayAuthConsumerDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayAuthConsumerDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayAuthConsumerDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayAuthConsumerDetailResponse() = default;
};
class GetGatewayDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> id{};

  GetGatewayDomainDetailRequest() {}

  explicit GetGatewayDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetGatewayDomainDetailRequest() = default;
};
class GetGatewayDomainDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> afterDate{};
  shared_ptr<string> algorithm{};
  shared_ptr<long> beforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtAfter{};
  shared_ptr<string> gmtBefore{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> http2{};
  shared_ptr<long> id{};
  shared_ptr<string> issuer{};
  shared_ptr<bool> mustHttps{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> sans{};
  shared_ptr<string> tlsMax{};
  shared_ptr<string> tlsMin{};

  GetGatewayDomainDetailResponseBodyData() {}

  explicit GetGatewayDomainDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterDate) {
      res["AfterDate"] = boost::any(*afterDate);
    }
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (beforeDate) {
      res["BeforeDate"] = boost::any(*beforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtAfter) {
      res["GmtAfter"] = boost::any(*gmtAfter);
    }
    if (gmtBefore) {
      res["GmtBefore"] = boost::any(*gmtBefore);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    if (tlsMax) {
      res["TlsMax"] = boost::any(*tlsMax);
    }
    if (tlsMin) {
      res["TlsMin"] = boost::any(*tlsMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterDate") != m.end() && !m["AfterDate"].empty()) {
      afterDate = make_shared<long>(boost::any_cast<long>(m["AfterDate"]));
    }
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("BeforeDate") != m.end() && !m["BeforeDate"].empty()) {
      beforeDate = make_shared<long>(boost::any_cast<long>(m["BeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtAfter") != m.end() && !m["GmtAfter"].empty()) {
      gmtAfter = make_shared<string>(boost::any_cast<string>(m["GmtAfter"]));
    }
    if (m.find("GmtBefore") != m.end() && !m["GmtBefore"].empty()) {
      gmtBefore = make_shared<string>(boost::any_cast<string>(m["GmtBefore"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<bool>(boost::any_cast<bool>(m["MustHttps"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      sans = make_shared<string>(boost::any_cast<string>(m["Sans"]));
    }
    if (m.find("TlsMax") != m.end() && !m["TlsMax"].empty()) {
      tlsMax = make_shared<string>(boost::any_cast<string>(m["TlsMax"]));
    }
    if (m.find("TlsMin") != m.end() && !m["TlsMin"].empty()) {
      tlsMin = make_shared<string>(boost::any_cast<string>(m["TlsMin"]));
    }
  }


  virtual ~GetGatewayDomainDetailResponseBodyData() = default;
};
class GetGatewayDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetGatewayDomainDetailResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayDomainDetailResponseBody() {}

  explicit GetGatewayDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayDomainDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayDomainDetailResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayDomainDetailResponseBody() = default;
};
class GetGatewayDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayDomainDetailResponseBody> body{};

  GetGatewayDomainDetailResponse() {}

  explicit GetGatewayDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayDomainDetailResponse() = default;
};
class GetGatewayOptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};

  GetGatewayOptionRequest() {}

  explicit GetGatewayOptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~GetGatewayOptionRequest() = default;
};
class GetGatewayOptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GatewayOption> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayOptionResponseBody() {}

  explicit GetGatewayOptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GatewayOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GatewayOption>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayOptionResponseBody() = default;
};
class GetGatewayOptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayOptionResponseBody> body{};

  GetGatewayOptionResponse() {}

  explicit GetGatewayOptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayOptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayOptionResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayOptionResponse() = default;
};
class GetGatewayRouteDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> routeId{};

  GetGatewayRouteDetailRequest() {}

  explicit GetGatewayRouteDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~GetGatewayRouteDetailRequest() = default;
};
class GetGatewayRouteDetailResponseBodyDataCors : public Darabonba::Model {
public:
  shared_ptr<bool> allowCredentials{};
  shared_ptr<string> allowHeaders{};
  shared_ptr<string> allowMethods{};
  shared_ptr<string> allowOrigins{};
  shared_ptr<string> exposeHeaders{};
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  GetGatewayRouteDetailResponseBodyDataCors() {}

  explicit GetGatewayRouteDetailResponseBodyDataCors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCredentials) {
      res["AllowCredentials"] = boost::any(*allowCredentials);
    }
    if (allowHeaders) {
      res["AllowHeaders"] = boost::any(*allowHeaders);
    }
    if (allowMethods) {
      res["AllowMethods"] = boost::any(*allowMethods);
    }
    if (allowOrigins) {
      res["AllowOrigins"] = boost::any(*allowOrigins);
    }
    if (exposeHeaders) {
      res["ExposeHeaders"] = boost::any(*exposeHeaders);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCredentials") != m.end() && !m["AllowCredentials"].empty()) {
      allowCredentials = make_shared<bool>(boost::any_cast<bool>(m["AllowCredentials"]));
    }
    if (m.find("AllowHeaders") != m.end() && !m["AllowHeaders"].empty()) {
      allowHeaders = make_shared<string>(boost::any_cast<string>(m["AllowHeaders"]));
    }
    if (m.find("AllowMethods") != m.end() && !m["AllowMethods"].empty()) {
      allowMethods = make_shared<string>(boost::any_cast<string>(m["AllowMethods"]));
    }
    if (m.find("AllowOrigins") != m.end() && !m["AllowOrigins"].empty()) {
      allowOrigins = make_shared<string>(boost::any_cast<string>(m["AllowOrigins"]));
    }
    if (m.find("ExposeHeaders") != m.end() && !m["ExposeHeaders"].empty()) {
      exposeHeaders = make_shared<string>(boost::any_cast<string>(m["ExposeHeaders"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataCors() = default;
};
class GetGatewayRouteDetailResponseBodyDataDirectResponse : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> code{};

  GetGatewayRouteDetailResponseBodyDataDirectResponse() {}

  explicit GetGatewayRouteDetailResponseBodyDataDirectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataDirectResponse() = default;
};
class GetGatewayRouteDetailResponseBodyDataFallbackServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  GetGatewayRouteDetailResponseBodyDataFallbackServices() {}

  explicit GetGatewayRouteDetailResponseBodyDataFallbackServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataFallbackServices() = default;
};
class GetGatewayRouteDetailResponseBodyDataFlowMirror : public Darabonba::Model {
public:
  shared_ptr<long> percentage{};
  shared_ptr<long> port{};
  shared_ptr<string> status{};
  shared_ptr<long> targetServiceId{};
  shared_ptr<string> targetServiceName{};

  GetGatewayRouteDetailResponseBodyDataFlowMirror() {}

  explicit GetGatewayRouteDetailResponseBodyDataFlowMirror(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetServiceId) {
      res["TargetServiceId"] = boost::any(*targetServiceId);
    }
    if (targetServiceName) {
      res["TargetServiceName"] = boost::any(*targetServiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetServiceId") != m.end() && !m["TargetServiceId"].empty()) {
      targetServiceId = make_shared<long>(boost::any_cast<long>(m["TargetServiceId"]));
    }
    if (m.find("TargetServiceName") != m.end() && !m["TargetServiceName"].empty()) {
      targetServiceName = make_shared<string>(boost::any_cast<string>(m["TargetServiceName"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataFlowMirror() = default;
};
class GetGatewayRouteDetailResponseBodyDataHTTPRewrite : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> path{};
  shared_ptr<string> pathType{};
  shared_ptr<string> pattern{};
  shared_ptr<string> status{};
  shared_ptr<string> substitution{};

  GetGatewayRouteDetailResponseBodyDataHTTPRewrite() {}

  explicit GetGatewayRouteDetailResponseBodyDataHTTPRewrite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathType) {
      res["PathType"] = boost::any(*pathType);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (substitution) {
      res["Substitution"] = boost::any(*substitution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathType") != m.end() && !m["PathType"].empty()) {
      pathType = make_shared<string>(boost::any_cast<string>(m["PathType"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Substitution") != m.end() && !m["Substitution"].empty()) {
      substitution = make_shared<string>(boost::any_cast<string>(m["Substitution"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataHTTPRewrite() = default;
};
class GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems : public Darabonba::Model {
public:
  shared_ptr<string> directionType{};
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<string> value{};

  GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems() {}

  explicit GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directionType) {
      res["DirectionType"] = boost::any(*directionType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectionType") != m.end() && !m["DirectionType"].empty()) {
      directionType = make_shared<string>(boost::any_cast<string>(m["DirectionType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems() = default;
};
class GetGatewayRouteDetailResponseBodyDataHeaderOp : public Darabonba::Model {
public:
  shared_ptr<vector<GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems>> headerOpItems{};
  shared_ptr<string> status{};

  GetGatewayRouteDetailResponseBodyDataHeaderOp() {}

  explicit GetGatewayRouteDetailResponseBodyDataHeaderOp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerOpItems) {
      vector<boost::any> temp1;
      for(auto item1:*headerOpItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderOpItems"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderOpItems") != m.end() && !m["HeaderOpItems"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderOpItems"].type()) {
        vector<GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderOpItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerOpItems = make_shared<vector<GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataHeaderOp() = default;
};
class GetGatewayRouteDetailResponseBodyDataRedirect : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> host{};
  shared_ptr<string> path{};

  GetGatewayRouteDetailResponseBodyDataRedirect() {}

  explicit GetGatewayRouteDetailResponseBodyDataRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRedirect() = default;
};
class GetGatewayRouteDetailResponseBodyDataRetry : public Darabonba::Model {
public:
  shared_ptr<long> attempts{};
  shared_ptr<vector<string>> httpCodes{};
  shared_ptr<vector<string>> retryOn{};
  shared_ptr<string> status{};

  GetGatewayRouteDetailResponseBodyDataRetry() {}

  explicit GetGatewayRouteDetailResponseBodyDataRetry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attempts) {
      res["Attempts"] = boost::any(*attempts);
    }
    if (httpCodes) {
      res["HttpCodes"] = boost::any(*httpCodes);
    }
    if (retryOn) {
      res["RetryOn"] = boost::any(*retryOn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attempts") != m.end() && !m["Attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["Attempts"]));
    }
    if (m.find("HttpCodes") != m.end() && !m["HttpCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HttpCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      httpCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryOn") != m.end() && !m["RetryOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RetryOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RetryOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      retryOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRetry() = default;
};
class GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates() {}

  explicit GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates() = default;
};
class GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates() {}

  explicit GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates() = default;
};
class GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates() {}

  explicit GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates() = default;
};
class GetGatewayRouteDetailResponseBodyDataRoutePredicates : public Darabonba::Model {
public:
  shared_ptr<vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates>> queryPredicates{};

  GetGatewayRouteDetailResponseBodyDataRoutePredicates() {}

  explicit GetGatewayRouteDetailResponseBodyDataRoutePredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRoutePredicates() = default;
};
class GetGatewayRouteDetailResponseBodyDataRouteServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  GetGatewayRouteDetailResponseBodyDataRouteServices() {}

  explicit GetGatewayRouteDetailResponseBodyDataRouteServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataRouteServices() = default;
};
class GetGatewayRouteDetailResponseBodyDataTimeout : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  GetGatewayRouteDetailResponseBodyDataTimeout() {}

  explicit GetGatewayRouteDetailResponseBodyDataTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyDataTimeout() = default;
};
class GetGatewayRouteDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ahasStatus{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataCors> cors{};
  shared_ptr<long> defaultServiceId{};
  shared_ptr<string> defaultServiceName{};
  shared_ptr<string> destinationType{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataDirectResponse> directResponse{};
  shared_ptr<long> domainId{};
  shared_ptr<vector<long>> domainIdList{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<vector<GetGatewayRouteDetailResponseBodyDataFallbackServices>> fallbackServices{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataFlowMirror> flowMirror{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataHTTPRewrite> HTTPRewrite{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataHeaderOp> headerOp{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> policies{};
  shared_ptr<string> predicates{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataRedirect> redirect{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataRetry> retry{};
  shared_ptr<long> routeOrder{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataRoutePredicates> routePredicates{};
  shared_ptr<vector<GetGatewayRouteDetailResponseBodyDataRouteServices>> routeServices{};
  shared_ptr<string> services{};
  shared_ptr<long> status{};
  shared_ptr<GetGatewayRouteDetailResponseBodyDataTimeout> timeout{};

  GetGatewayRouteDetailResponseBodyData() {}

  explicit GetGatewayRouteDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ahasStatus) {
      res["AhasStatus"] = boost::any(*ahasStatus);
    }
    if (cors) {
      res["Cors"] = cors ? boost::any(cors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (defaultServiceId) {
      res["DefaultServiceId"] = boost::any(*defaultServiceId);
    }
    if (defaultServiceName) {
      res["DefaultServiceName"] = boost::any(*defaultServiceName);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponse) {
      res["DirectResponse"] = directResponse ? boost::any(directResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdList) {
      res["DomainIdList"] = boost::any(*domainIdList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServices) {
      vector<boost::any> temp1;
      for(auto item1:*fallbackServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FallbackServices"] = boost::any(temp1);
    }
    if (flowMirror) {
      res["FlowMirror"] = flowMirror ? boost::any(flowMirror->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (HTTPRewrite) {
      res["HTTPRewrite"] = HTTPRewrite ? boost::any(HTTPRewrite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (headerOp) {
      res["HeaderOp"] = headerOp ? boost::any(headerOp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policies) {
      res["Policies"] = boost::any(*policies);
    }
    if (predicates) {
      res["Predicates"] = boost::any(*predicates);
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (retry) {
      res["Retry"] = retry ? boost::any(retry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (routePredicates) {
      res["RoutePredicates"] = routePredicates ? boost::any(routePredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeServices) {
      vector<boost::any> temp1;
      for(auto item1:*routeServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteServices"] = boost::any(temp1);
    }
    if (services) {
      res["Services"] = boost::any(*services);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AhasStatus") != m.end() && !m["AhasStatus"].empty()) {
      ahasStatus = make_shared<long>(boost::any_cast<long>(m["AhasStatus"]));
    }
    if (m.find("Cors") != m.end() && !m["Cors"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cors"].type()) {
        GetGatewayRouteDetailResponseBodyDataCors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cors"]));
        cors = make_shared<GetGatewayRouteDetailResponseBodyDataCors>(model1);
      }
    }
    if (m.find("DefaultServiceId") != m.end() && !m["DefaultServiceId"].empty()) {
      defaultServiceId = make_shared<long>(boost::any_cast<long>(m["DefaultServiceId"]));
    }
    if (m.find("DefaultServiceName") != m.end() && !m["DefaultServiceName"].empty()) {
      defaultServiceName = make_shared<string>(boost::any_cast<string>(m["DefaultServiceName"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponse") != m.end() && !m["DirectResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["DirectResponse"].type()) {
        GetGatewayRouteDetailResponseBodyDataDirectResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DirectResponse"]));
        directResponse = make_shared<GetGatewayRouteDetailResponseBodyDataDirectResponse>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdList") != m.end() && !m["DomainIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DomainIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      domainIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      if (typeid(vector<boost::any>) == m["FallbackServices"].type()) {
        vector<GetGatewayRouteDetailResponseBodyDataFallbackServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FallbackServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayRouteDetailResponseBodyDataFallbackServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fallbackServices = make_shared<vector<GetGatewayRouteDetailResponseBodyDataFallbackServices>>(expect1);
      }
    }
    if (m.find("FlowMirror") != m.end() && !m["FlowMirror"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowMirror"].type()) {
        GetGatewayRouteDetailResponseBodyDataFlowMirror model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowMirror"]));
        flowMirror = make_shared<GetGatewayRouteDetailResponseBodyDataFlowMirror>(model1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HTTPRewrite") != m.end() && !m["HTTPRewrite"].empty()) {
      if (typeid(map<string, boost::any>) == m["HTTPRewrite"].type()) {
        GetGatewayRouteDetailResponseBodyDataHTTPRewrite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HTTPRewrite"]));
        HTTPRewrite = make_shared<GetGatewayRouteDetailResponseBodyDataHTTPRewrite>(model1);
      }
    }
    if (m.find("HeaderOp") != m.end() && !m["HeaderOp"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderOp"].type()) {
        GetGatewayRouteDetailResponseBodyDataHeaderOp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeaderOp"]));
        headerOp = make_shared<GetGatewayRouteDetailResponseBodyDataHeaderOp>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      policies = make_shared<string>(boost::any_cast<string>(m["Policies"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicates = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        GetGatewayRouteDetailResponseBodyDataRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<GetGatewayRouteDetailResponseBodyDataRedirect>(model1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      if (typeid(map<string, boost::any>) == m["Retry"].type()) {
        GetGatewayRouteDetailResponseBodyDataRetry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Retry"]));
        retry = make_shared<GetGatewayRouteDetailResponseBodyDataRetry>(model1);
      }
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("RoutePredicates") != m.end() && !m["RoutePredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicates"].type()) {
        GetGatewayRouteDetailResponseBodyDataRoutePredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicates"]));
        routePredicates = make_shared<GetGatewayRouteDetailResponseBodyDataRoutePredicates>(model1);
      }
    }
    if (m.find("RouteServices") != m.end() && !m["RouteServices"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteServices"].type()) {
        vector<GetGatewayRouteDetailResponseBodyDataRouteServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayRouteDetailResponseBodyDataRouteServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeServices = make_shared<vector<GetGatewayRouteDetailResponseBodyDataRouteServices>>(expect1);
      }
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      services = make_shared<string>(boost::any_cast<string>(m["Services"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        GetGatewayRouteDetailResponseBodyDataTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<GetGatewayRouteDetailResponseBodyDataTimeout>(model1);
      }
    }
  }


  virtual ~GetGatewayRouteDetailResponseBodyData() = default;
};
class GetGatewayRouteDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetGatewayRouteDetailResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayRouteDetailResponseBody() {}

  explicit GetGatewayRouteDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayRouteDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayRouteDetailResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayRouteDetailResponseBody() = default;
};
class GetGatewayRouteDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayRouteDetailResponseBody> body{};

  GetGatewayRouteDetailResponse() {}

  explicit GetGatewayRouteDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayRouteDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayRouteDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayRouteDetailResponse() = default;
};
class GetGatewayServiceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};

  GetGatewayServiceDetailRequest() {}

  explicit GetGatewayServiceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
  }


  virtual ~GetGatewayServiceDetailRequest() = default;
};
class GetGatewayServiceDetailResponseBodyDataLabelDetails : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> values{};

  GetGatewayServiceDetailResponseBodyDataLabelDetails() {}

  explicit GetGatewayServiceDetailResponseBodyDataLabelDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataLabelDetails() = default;
};
class GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList : public Darabonba::Model {
public:
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> serviceId{};
  shared_ptr<long> servicePort{};
  shared_ptr<TrafficPolicy> trafficPolicy{};

  GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList() {}

  explicit GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (trafficPolicy) {
      res["TrafficPolicy"] = trafficPolicy ? boost::any(trafficPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("TrafficPolicy") != m.end() && !m["TrafficPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPolicy"].type()) {
        TrafficPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPolicy"]));
        trafficPolicy = make_shared<TrafficPolicy>(model1);
      }
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList() = default;
};
class GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels() {}

  explicit GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels() = default;
};
class GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion : public Darabonba::Model {
public:
  shared_ptr<vector<GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels>> labels{};
  shared_ptr<string> name{};

  GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion() {}

  explicit GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion() = default;
};
class GetGatewayServiceDetailResponseBodyDataVersionDetails : public Darabonba::Model {
public:
  shared_ptr<long> endpointNum{};
  shared_ptr<string> endpointNumPercent{};
  shared_ptr<GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion> serviceVersion{};

  GetGatewayServiceDetailResponseBodyDataVersionDetails() {}

  explicit GetGatewayServiceDetailResponseBodyDataVersionDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointNum) {
      res["EndpointNum"] = boost::any(*endpointNum);
    }
    if (endpointNumPercent) {
      res["EndpointNumPercent"] = boost::any(*endpointNumPercent);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = serviceVersion ? boost::any(serviceVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointNum") != m.end() && !m["EndpointNum"].empty()) {
      endpointNum = make_shared<long>(boost::any_cast<long>(m["EndpointNum"]));
    }
    if (m.find("EndpointNumPercent") != m.end() && !m["EndpointNumPercent"].empty()) {
      endpointNumPercent = make_shared<string>(boost::any_cast<string>(m["EndpointNumPercent"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceVersion"].type()) {
        GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceVersion"]));
        serviceVersion = make_shared<GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion>(model1);
      }
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataVersionDetails() = default;
};
class GetGatewayServiceDetailResponseBodyDataVersions : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetGatewayServiceDetailResponseBodyDataVersions() {}

  explicit GetGatewayServiceDetailResponseBodyDataVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyDataVersions() = default;
};
class GetGatewayServiceDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gatewayId{};
  shared_ptr<TrafficPolicy> gatewayTrafficPolicy{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> groupName{};
  shared_ptr<string> healthCheck{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<vector<GetGatewayServiceDetailResponseBodyDataLabelDetails>> labelDetails{};
  shared_ptr<string> metaInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList>> portTrafficPolicyList{};
  shared_ptr<vector<long>> ports{};
  shared_ptr<string> serviceNameInRegistry{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<GetGatewayServiceDetailResponseBodyDataVersionDetails>> versionDetails{};
  shared_ptr<vector<GetGatewayServiceDetailResponseBodyDataVersions>> versions{};

  GetGatewayServiceDetailResponseBodyData() {}

  explicit GetGatewayServiceDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayTrafficPolicy) {
      res["GatewayTrafficPolicy"] = gatewayTrafficPolicy ? boost::any(gatewayTrafficPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (labelDetails) {
      vector<boost::any> temp1;
      for(auto item1:*labelDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LabelDetails"] = boost::any(temp1);
    }
    if (metaInfo) {
      res["MetaInfo"] = boost::any(*metaInfo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (portTrafficPolicyList) {
      vector<boost::any> temp1;
      for(auto item1:*portTrafficPolicyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortTrafficPolicyList"] = boost::any(temp1);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (serviceNameInRegistry) {
      res["ServiceNameInRegistry"] = boost::any(*serviceNameInRegistry);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (versionDetails) {
      vector<boost::any> temp1;
      for(auto item1:*versionDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VersionDetails"] = boost::any(temp1);
    }
    if (versions) {
      vector<boost::any> temp1;
      for(auto item1:*versions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Versions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayTrafficPolicy") != m.end() && !m["GatewayTrafficPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayTrafficPolicy"].type()) {
        TrafficPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayTrafficPolicy"]));
        gatewayTrafficPolicy = make_shared<TrafficPolicy>(model1);
      }
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<string>(boost::any_cast<string>(m["HealthCheck"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LabelDetails") != m.end() && !m["LabelDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["LabelDetails"].type()) {
        vector<GetGatewayServiceDetailResponseBodyDataLabelDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LabelDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayServiceDetailResponseBodyDataLabelDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labelDetails = make_shared<vector<GetGatewayServiceDetailResponseBodyDataLabelDetails>>(expect1);
      }
    }
    if (m.find("MetaInfo") != m.end() && !m["MetaInfo"].empty()) {
      metaInfo = make_shared<string>(boost::any_cast<string>(m["MetaInfo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PortTrafficPolicyList") != m.end() && !m["PortTrafficPolicyList"].empty()) {
      if (typeid(vector<boost::any>) == m["PortTrafficPolicyList"].type()) {
        vector<GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortTrafficPolicyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portTrafficPolicyList = make_shared<vector<GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList>>(expect1);
      }
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ports"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ports = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ServiceNameInRegistry") != m.end() && !m["ServiceNameInRegistry"].empty()) {
      serviceNameInRegistry = make_shared<string>(boost::any_cast<string>(m["ServiceNameInRegistry"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("VersionDetails") != m.end() && !m["VersionDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["VersionDetails"].type()) {
        vector<GetGatewayServiceDetailResponseBodyDataVersionDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VersionDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayServiceDetailResponseBodyDataVersionDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versionDetails = make_shared<vector<GetGatewayServiceDetailResponseBodyDataVersionDetails>>(expect1);
      }
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(vector<boost::any>) == m["Versions"].type()) {
        vector<GetGatewayServiceDetailResponseBodyDataVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Versions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGatewayServiceDetailResponseBodyDataVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versions = make_shared<vector<GetGatewayServiceDetailResponseBodyDataVersions>>(expect1);
      }
    }
  }


  virtual ~GetGatewayServiceDetailResponseBodyData() = default;
};
class GetGatewayServiceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetGatewayServiceDetailResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGatewayServiceDetailResponseBody() {}

  explicit GetGatewayServiceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGatewayServiceDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGatewayServiceDetailResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGatewayServiceDetailResponseBody() = default;
};
class GetGatewayServiceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGatewayServiceDetailResponseBody> body{};

  GetGatewayServiceDetailResponse() {}

  explicit GetGatewayServiceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGatewayServiceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGatewayServiceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetGatewayServiceDetailResponse() = default;
};
class GetGovernanceKubernetesClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> regionId{};

  GetGovernanceKubernetesClusterRequest() {}

  explicit GetGovernanceKubernetesClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetGovernanceKubernetesClusterRequest() = default;
};
class GetGovernanceKubernetesClusterResponseBodyDataNamespaces : public Darabonba::Model {
public:
  shared_ptr<string> mseNamespace{};
  shared_ptr<string> name{};

  GetGovernanceKubernetesClusterResponseBodyDataNamespaces() {}

  explicit GetGovernanceKubernetesClusterResponseBodyDataNamespaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mseNamespace) {
      res["MseNamespace"] = boost::any(*mseNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MseNamespace") != m.end() && !m["MseNamespace"].empty()) {
      mseNamespace = make_shared<string>(boost::any_cast<string>(m["MseNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetGovernanceKubernetesClusterResponseBodyDataNamespaces() = default;
};
class GetGovernanceKubernetesClusterResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> k8sVersion{};
  shared_ptr<string> namespaceInfos{};
  shared_ptr<vector<GetGovernanceKubernetesClusterResponseBodyDataNamespaces>> namespaces{};
  shared_ptr<string> pilotStartTime{};
  shared_ptr<string> region{};
  shared_ptr<string> updateTime{};

  GetGovernanceKubernetesClusterResponseBodyData() {}

  explicit GetGovernanceKubernetesClusterResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (k8sVersion) {
      res["K8sVersion"] = boost::any(*k8sVersion);
    }
    if (namespaceInfos) {
      res["NamespaceInfos"] = boost::any(*namespaceInfos);
    }
    if (namespaces) {
      vector<boost::any> temp1;
      for(auto item1:*namespaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Namespaces"] = boost::any(temp1);
    }
    if (pilotStartTime) {
      res["PilotStartTime"] = boost::any(*pilotStartTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("K8sVersion") != m.end() && !m["K8sVersion"].empty()) {
      k8sVersion = make_shared<string>(boost::any_cast<string>(m["K8sVersion"]));
    }
    if (m.find("NamespaceInfos") != m.end() && !m["NamespaceInfos"].empty()) {
      namespaceInfos = make_shared<string>(boost::any_cast<string>(m["NamespaceInfos"]));
    }
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      if (typeid(vector<boost::any>) == m["Namespaces"].type()) {
        vector<GetGovernanceKubernetesClusterResponseBodyDataNamespaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Namespaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetGovernanceKubernetesClusterResponseBodyDataNamespaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaces = make_shared<vector<GetGovernanceKubernetesClusterResponseBodyDataNamespaces>>(expect1);
      }
    }
    if (m.find("PilotStartTime") != m.end() && !m["PilotStartTime"].empty()) {
      pilotStartTime = make_shared<string>(boost::any_cast<string>(m["PilotStartTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetGovernanceKubernetesClusterResponseBodyData() = default;
};
class GetGovernanceKubernetesClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetGovernanceKubernetesClusterResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGovernanceKubernetesClusterResponseBody() {}

  explicit GetGovernanceKubernetesClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGovernanceKubernetesClusterResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGovernanceKubernetesClusterResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGovernanceKubernetesClusterResponseBody() = default;
};
class GetGovernanceKubernetesClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGovernanceKubernetesClusterResponseBody> body{};

  GetGovernanceKubernetesClusterResponse() {}

  explicit GetGovernanceKubernetesClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGovernanceKubernetesClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGovernanceKubernetesClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetGovernanceKubernetesClusterResponse() = default;
};
class GetImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> versionCode{};

  GetImageRequest() {}

  explicit GetImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~GetImageRequest() = default;
};
class GetImageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> currentVersionFullShowName{};
  shared_ptr<string> maxVersionChangelogUrl{};
  shared_ptr<string> maxVersionCode{};
  shared_ptr<string> maxVersionFullShowName{};

  GetImageResponseBodyData() {}

  explicit GetImageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentVersionFullShowName) {
      res["CurrentVersionFullShowName"] = boost::any(*currentVersionFullShowName);
    }
    if (maxVersionChangelogUrl) {
      res["MaxVersionChangelogUrl"] = boost::any(*maxVersionChangelogUrl);
    }
    if (maxVersionCode) {
      res["MaxVersionCode"] = boost::any(*maxVersionCode);
    }
    if (maxVersionFullShowName) {
      res["MaxVersionFullShowName"] = boost::any(*maxVersionFullShowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentVersionFullShowName") != m.end() && !m["CurrentVersionFullShowName"].empty()) {
      currentVersionFullShowName = make_shared<string>(boost::any_cast<string>(m["CurrentVersionFullShowName"]));
    }
    if (m.find("MaxVersionChangelogUrl") != m.end() && !m["MaxVersionChangelogUrl"].empty()) {
      maxVersionChangelogUrl = make_shared<string>(boost::any_cast<string>(m["MaxVersionChangelogUrl"]));
    }
    if (m.find("MaxVersionCode") != m.end() && !m["MaxVersionCode"].empty()) {
      maxVersionCode = make_shared<string>(boost::any_cast<string>(m["MaxVersionCode"]));
    }
    if (m.find("MaxVersionFullShowName") != m.end() && !m["MaxVersionFullShowName"].empty()) {
      maxVersionFullShowName = make_shared<string>(boost::any_cast<string>(m["MaxVersionFullShowName"]));
    }
  }


  virtual ~GetImageResponseBodyData() = default;
};
class GetImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetImageResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetImageResponseBody() {}

  explicit GetImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetImageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetImageResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetImageResponseBody() = default;
};
class GetImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImageResponseBody> body{};

  GetImageResponse() {}

  explicit GetImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImageResponseBody>(model1);
      }
    }
  }


  virtual ~GetImageResponse() = default;
};
class GetImportFileUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> contentType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};

  GetImportFileUrlRequest() {}

  explicit GetImportFileUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~GetImportFileUrlRequest() = default;
};
class GetImportFileUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  GetImportFileUrlResponseBodyData() {}

  explicit GetImportFileUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetImportFileUrlResponseBodyData() = default;
};
class GetImportFileUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetImportFileUrlResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetImportFileUrlResponseBody() {}

  explicit GetImportFileUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetImportFileUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetImportFileUrlResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetImportFileUrlResponseBody() = default;
};
class GetImportFileUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImportFileUrlResponseBody> body{};

  GetImportFileUrlResponse() {}

  explicit GetImportFileUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImportFileUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImportFileUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetImportFileUrlResponse() = default;
};
class GetKubernetesSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<bool> isAll{};
  shared_ptr<string> vpcId{};

  GetKubernetesSourceRequest() {}

  explicit GetKubernetesSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (isAll) {
      res["IsAll"] = boost::any(*isAll);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IsAll") != m.end() && !m["IsAll"].empty()) {
      isAll = make_shared<bool>(boost::any_cast<bool>(m["IsAll"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetKubernetesSourceRequest() = default;
};
class GetKubernetesSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> cluster{};
  shared_ptr<string> name{};

  GetKubernetesSourceResponseBodyData() {}

  explicit GetKubernetesSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetKubernetesSourceResponseBodyData() = default;
};
class GetKubernetesSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetKubernetesSourceResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetKubernetesSourceResponseBody() {}

  explicit GetKubernetesSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetKubernetesSourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetKubernetesSourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetKubernetesSourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetKubernetesSourceResponseBody() = default;
};
class GetKubernetesSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetKubernetesSourceResponseBody> body{};

  GetKubernetesSourceResponse() {}

  explicit GetKubernetesSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetKubernetesSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetKubernetesSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetKubernetesSourceResponse() = default;
};
class GetLosslessRuleByAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};

  GetLosslessRuleByAppRequest() {}

  explicit GetLosslessRuleByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetLosslessRuleByAppRequest() = default;
};
class GetLosslessRuleByAppResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> aligned{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> count{};
  shared_ptr<long> delayTime{};
  shared_ptr<bool> enable{};
  shared_ptr<long> funcType{};
  shared_ptr<bool> lossLessDetail{};
  shared_ptr<bool> notice{};
  shared_ptr<bool> related{};
  shared_ptr<long> warmupTime{};

  GetLosslessRuleByAppResponseBodyData() {}

  explicit GetLosslessRuleByAppResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aligned) {
      res["Aligned"] = boost::any(*aligned);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (funcType) {
      res["FuncType"] = boost::any(*funcType);
    }
    if (lossLessDetail) {
      res["LossLessDetail"] = boost::any(*lossLessDetail);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (warmupTime) {
      res["WarmupTime"] = boost::any(*warmupTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aligned") != m.end() && !m["Aligned"].empty()) {
      aligned = make_shared<bool>(boost::any_cast<bool>(m["Aligned"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FuncType") != m.end() && !m["FuncType"].empty()) {
      funcType = make_shared<long>(boost::any_cast<long>(m["FuncType"]));
    }
    if (m.find("LossLessDetail") != m.end() && !m["LossLessDetail"].empty()) {
      lossLessDetail = make_shared<bool>(boost::any_cast<bool>(m["LossLessDetail"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<bool>(boost::any_cast<bool>(m["Notice"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<bool>(boost::any_cast<bool>(m["Related"]));
    }
    if (m.find("WarmupTime") != m.end() && !m["WarmupTime"].empty()) {
      warmupTime = make_shared<long>(boost::any_cast<long>(m["WarmupTime"]));
    }
  }


  virtual ~GetLosslessRuleByAppResponseBodyData() = default;
};
class GetLosslessRuleByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetLosslessRuleByAppResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetLosslessRuleByAppResponseBody() {}

  explicit GetLosslessRuleByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetLosslessRuleByAppResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetLosslessRuleByAppResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetLosslessRuleByAppResponseBody() = default;
};
class GetLosslessRuleByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLosslessRuleByAppResponseBody> body{};

  GetLosslessRuleByAppResponse() {}

  explicit GetLosslessRuleByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLosslessRuleByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLosslessRuleByAppResponseBody>(model1);
      }
    }
  }


  virtual ~GetLosslessRuleByAppResponse() = default;
};
class GetMseFeatureSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  GetMseFeatureSwitchRequest() {}

  explicit GetMseFeatureSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~GetMseFeatureSwitchRequest() = default;
};
class GetMseFeatureSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> result{};
  shared_ptr<bool> success{};

  GetMseFeatureSwitchResponseBody() {}

  explicit GetMseFeatureSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Result"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      result = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMseFeatureSwitchResponseBody() = default;
};
class GetMseFeatureSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMseFeatureSwitchResponseBody> body{};

  GetMseFeatureSwitchResponse() {}

  explicit GetMseFeatureSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMseFeatureSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMseFeatureSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~GetMseFeatureSwitchResponse() = default;
};
class GetMseSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> type{};

  GetMseSourceRequest() {}

  explicit GetMseSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMseSourceRequest() = default;
};
class GetMseSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetMseSourceResponseBodyData() {}

  explicit GetMseSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMseSourceResponseBodyData() = default;
};
class GetMseSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetMseSourceResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMseSourceResponseBody() {}

  explicit GetMseSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetMseSourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMseSourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMseSourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMseSourceResponseBody() = default;
};
class GetMseSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMseSourceResponseBody> body{};

  GetMseSourceResponse() {}

  explicit GetMseSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMseSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMseSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetMseSourceResponse() = default;
};
class GetNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> beta{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};

  GetNacosConfigRequest() {}

  explicit GetNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (beta) {
      res["Beta"] = boost::any(*beta);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Beta") != m.end() && !m["Beta"].empty()) {
      beta = make_shared<bool>(boost::any_cast<bool>(m["Beta"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
  }


  virtual ~GetNacosConfigRequest() = default;
};
class GetNacosConfigResponseBodyConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> betaIps{};
  shared_ptr<string> content{};
  shared_ptr<string> dataId{};
  shared_ptr<string> desc{};
  shared_ptr<string> encryptedDataKey{};
  shared_ptr<string> group{};
  shared_ptr<string> md5{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  GetNacosConfigResponseBodyConfiguration() {}

  explicit GetNacosConfigResponseBodyConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (betaIps) {
      res["BetaIps"] = boost::any(*betaIps);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (encryptedDataKey) {
      res["EncryptedDataKey"] = boost::any(*encryptedDataKey);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BetaIps") != m.end() && !m["BetaIps"].empty()) {
      betaIps = make_shared<string>(boost::any_cast<string>(m["BetaIps"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("EncryptedDataKey") != m.end() && !m["EncryptedDataKey"].empty()) {
      encryptedDataKey = make_shared<string>(boost::any_cast<string>(m["EncryptedDataKey"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetNacosConfigResponseBodyConfiguration() = default;
};
class GetNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNacosConfigResponseBodyConfiguration> configuration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNacosConfigResponseBody() {}

  explicit GetNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = configuration ? boost::any(configuration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configuration"].type()) {
        GetNacosConfigResponseBodyConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configuration"]));
        configuration = make_shared<GetNacosConfigResponseBodyConfiguration>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNacosConfigResponseBody() = default;
};
class GetNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNacosConfigResponseBody> body{};

  GetNacosConfigResponse() {}

  explicit GetNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetNacosConfigResponse() = default;
};
class GetNacosHistoryConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> nid{};

  GetNacosHistoryConfigRequest() {}

  explicit GetNacosHistoryConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (nid) {
      res["Nid"] = boost::any(*nid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Nid") != m.end() && !m["Nid"].empty()) {
      nid = make_shared<string>(boost::any_cast<string>(m["Nid"]));
    }
  }


  virtual ~GetNacosHistoryConfigRequest() = default;
};
class GetNacosHistoryConfigResponseBodyConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> content{};
  shared_ptr<string> dataId{};
  shared_ptr<string> encryptedDataKey{};
  shared_ptr<string> group{};
  shared_ptr<string> md5{};
  shared_ptr<string> opType{};

  GetNacosHistoryConfigResponseBodyConfiguration() {}

  explicit GetNacosHistoryConfigResponseBodyConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (encryptedDataKey) {
      res["EncryptedDataKey"] = boost::any(*encryptedDataKey);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("EncryptedDataKey") != m.end() && !m["EncryptedDataKey"].empty()) {
      encryptedDataKey = make_shared<string>(boost::any_cast<string>(m["EncryptedDataKey"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
  }


  virtual ~GetNacosHistoryConfigResponseBodyConfiguration() = default;
};
class GetNacosHistoryConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNacosHistoryConfigResponseBodyConfiguration> configuration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNacosHistoryConfigResponseBody() {}

  explicit GetNacosHistoryConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = configuration ? boost::any(configuration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configuration"].type()) {
        GetNacosHistoryConfigResponseBodyConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configuration"]));
        configuration = make_shared<GetNacosHistoryConfigResponseBodyConfiguration>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNacosHistoryConfigResponseBody() = default;
};
class GetNacosHistoryConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNacosHistoryConfigResponseBody> body{};

  GetNacosHistoryConfigResponse() {}

  explicit GetNacosHistoryConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNacosHistoryConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNacosHistoryConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetNacosHistoryConfigResponse() = default;
};
class GetOverviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> period{};
  shared_ptr<string> region{};

  GetOverviewRequest() {}

  explicit GetOverviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~GetOverviewRequest() = default;
};
class GetOverviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  GetOverviewResponseBody() {}

  explicit GetOverviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~GetOverviewResponseBody() = default;
};
class GetOverviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOverviewResponseBody> body{};

  GetOverviewResponse() {}

  explicit GetOverviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOverviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOverviewResponseBody>(model1);
      }
    }
  }


  virtual ~GetOverviewResponse() = default;
};
class GetPluginConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> pluginId{};

  GetPluginConfigRequest() {}

  explicit GetPluginConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<long>(boost::any_cast<long>(m["PluginId"]));
    }
  }


  virtual ~GetPluginConfigRequest() = default;
};
class GetPluginConfigResponseBodyDataGatewayConfigList : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<long> configLevel{};
  shared_ptr<bool> enable{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> pluginId{};

  GetPluginConfigResponseBodyDataGatewayConfigList() {}

  explicit GetPluginConfigResponseBodyDataGatewayConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (configLevel) {
      res["ConfigLevel"] = boost::any(*configLevel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ConfigLevel") != m.end() && !m["ConfigLevel"].empty()) {
      configLevel = make_shared<long>(boost::any_cast<long>(m["ConfigLevel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<long>(boost::any_cast<long>(m["PluginId"]));
    }
  }


  virtual ~GetPluginConfigResponseBodyDataGatewayConfigList() = default;
};
class GetPluginConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> configCheck{};
  shared_ptr<vector<GetPluginConfigResponseBodyDataGatewayConfigList>> gatewayConfigList{};
  shared_ptr<long> id{};
  shared_ptr<string> imageName{};
  shared_ptr<long> mode{};
  shared_ptr<string> name{};
  shared_ptr<long> phase{};
  shared_ptr<string> primaryUser{};
  shared_ptr<long> priority{};
  shared_ptr<long> publishState{};
  shared_ptr<string> readme{};
  shared_ptr<string> readmeEn{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};
  shared_ptr<string> versionJson{};
  shared_ptr<long> wasmLang{};

  GetPluginConfigResponseBodyData() {}

  explicit GetPluginConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configCheck) {
      res["ConfigCheck"] = boost::any(*configCheck);
    }
    if (gatewayConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*gatewayConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GatewayConfigList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (readme) {
      res["Readme"] = boost::any(*readme);
    }
    if (readmeEn) {
      res["ReadmeEn"] = boost::any(*readmeEn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (versionJson) {
      res["VersionJson"] = boost::any(*versionJson);
    }
    if (wasmLang) {
      res["WasmLang"] = boost::any(*wasmLang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("ConfigCheck") != m.end() && !m["ConfigCheck"].empty()) {
      configCheck = make_shared<string>(boost::any_cast<string>(m["ConfigCheck"]));
    }
    if (m.find("GatewayConfigList") != m.end() && !m["GatewayConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["GatewayConfigList"].type()) {
        vector<GetPluginConfigResponseBodyDataGatewayConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GatewayConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPluginConfigResponseBodyDataGatewayConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        gatewayConfigList = make_shared<vector<GetPluginConfigResponseBodyDataGatewayConfigList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<long>(boost::any_cast<long>(m["Phase"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<long>(boost::any_cast<long>(m["PublishState"]));
    }
    if (m.find("Readme") != m.end() && !m["Readme"].empty()) {
      readme = make_shared<string>(boost::any_cast<string>(m["Readme"]));
    }
    if (m.find("ReadmeEn") != m.end() && !m["ReadmeEn"].empty()) {
      readmeEn = make_shared<string>(boost::any_cast<string>(m["ReadmeEn"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("VersionJson") != m.end() && !m["VersionJson"].empty()) {
      versionJson = make_shared<string>(boost::any_cast<string>(m["VersionJson"]));
    }
    if (m.find("WasmLang") != m.end() && !m["WasmLang"].empty()) {
      wasmLang = make_shared<long>(boost::any_cast<long>(m["WasmLang"]));
    }
  }


  virtual ~GetPluginConfigResponseBodyData() = default;
};
class GetPluginConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetPluginConfigResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPluginConfigResponseBody() {}

  explicit GetPluginConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPluginConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPluginConfigResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPluginConfigResponseBody() = default;
};
class GetPluginConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPluginConfigResponseBody> body{};

  GetPluginConfigResponse() {}

  explicit GetPluginConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPluginConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPluginConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetPluginConfigResponse() = default;
};
class GetPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> category{};
  shared_ptr<bool> enableOnly{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};

  GetPluginsRequest() {}

  explicit GetPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (enableOnly) {
      res["EnableOnly"] = boost::any(*enableOnly);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("EnableOnly") != m.end() && !m["EnableOnly"].empty()) {
      enableOnly = make_shared<bool>(boost::any_cast<bool>(m["EnableOnly"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPluginsRequest() = default;
};
class GetPluginsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> category{};
  shared_ptr<string> configCheck{};
  shared_ptr<long> id{};
  shared_ptr<string> maxVersion{};
  shared_ptr<long> mode{};
  shared_ptr<string> name{};
  shared_ptr<bool> newVersionPublishingFlag{};
  shared_ptr<long> phase{};
  shared_ptr<string> primaryUser{};
  shared_ptr<long> priority{};
  shared_ptr<long> publishState{};
  shared_ptr<string> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> version{};
  shared_ptr<string> wasmFile{};
  shared_ptr<long> wasmLang{};

  GetPluginsResponseBodyData() {}

  explicit GetPluginsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (configCheck) {
      res["ConfigCheck"] = boost::any(*configCheck);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxVersion) {
      res["MaxVersion"] = boost::any(*maxVersion);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newVersionPublishingFlag) {
      res["NewVersionPublishingFlag"] = boost::any(*newVersionPublishingFlag);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (publishState) {
      res["PublishState"] = boost::any(*publishState);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (wasmFile) {
      res["WasmFile"] = boost::any(*wasmFile);
    }
    if (wasmLang) {
      res["WasmLang"] = boost::any(*wasmLang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("ConfigCheck") != m.end() && !m["ConfigCheck"].empty()) {
      configCheck = make_shared<string>(boost::any_cast<string>(m["ConfigCheck"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxVersion") != m.end() && !m["MaxVersion"].empty()) {
      maxVersion = make_shared<string>(boost::any_cast<string>(m["MaxVersion"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewVersionPublishingFlag") != m.end() && !m["NewVersionPublishingFlag"].empty()) {
      newVersionPublishingFlag = make_shared<bool>(boost::any_cast<bool>(m["NewVersionPublishingFlag"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<long>(boost::any_cast<long>(m["Phase"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("PublishState") != m.end() && !m["PublishState"].empty()) {
      publishState = make_shared<long>(boost::any_cast<long>(m["PublishState"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("WasmFile") != m.end() && !m["WasmFile"].empty()) {
      wasmFile = make_shared<string>(boost::any_cast<string>(m["WasmFile"]));
    }
    if (m.find("WasmLang") != m.end() && !m["WasmLang"].empty()) {
      wasmLang = make_shared<long>(boost::any_cast<long>(m["WasmLang"]));
    }
  }


  virtual ~GetPluginsResponseBodyData() = default;
};
class GetPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetPluginsResponseBodyData>> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPluginsResponseBody() {}

  explicit GetPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetPluginsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPluginsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetPluginsResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPluginsResponseBody() = default;
};
class GetPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPluginsResponseBody> body{};

  GetPluginsResponse() {}

  explicit GetPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~GetPluginsResponse() = default;
};
class GetServiceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> ip{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};

  GetServiceListRequest() {}

  explicit GetServiceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~GetServiceListRequest() = default;
};
class GetServiceListResponseBodyDataMethods : public Darabonba::Model {
public:
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameterTypes{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<string>> requestMethods{};
  shared_ptr<string> returnType{};

  GetServiceListResponseBodyDataMethods() {}

  explicit GetServiceListResponseBodyDataMethods(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
  }


  virtual ~GetServiceListResponseBodyDataMethods() = default;
};
class GetServiceListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> dubboApplicationName{};
  shared_ptr<string> edasAppName{};
  shared_ptr<string> group{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<vector<GetServiceListResponseBodyDataMethods>> methods{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> springApplicationName{};
  shared_ptr<string> version{};

  GetServiceListResponseBodyData() {}

  explicit GetServiceListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboApplicationName) {
      res["DubboApplicationName"] = boost::any(*dubboApplicationName);
    }
    if (edasAppName) {
      res["EdasAppName"] = boost::any(*edasAppName);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (methods) {
      vector<boost::any> temp1;
      for(auto item1:*methods){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Methods"] = boost::any(temp1);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (springApplicationName) {
      res["SpringApplicationName"] = boost::any(*springApplicationName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboApplicationName") != m.end() && !m["DubboApplicationName"].empty()) {
      dubboApplicationName = make_shared<string>(boost::any_cast<string>(m["DubboApplicationName"]));
    }
    if (m.find("EdasAppName") != m.end() && !m["EdasAppName"].empty()) {
      edasAppName = make_shared<string>(boost::any_cast<string>(m["EdasAppName"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<GetServiceListResponseBodyDataMethods> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Methods"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListResponseBodyDataMethods model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        methods = make_shared<vector<GetServiceListResponseBodyDataMethods>>(expect1);
      }
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("SpringApplicationName") != m.end() && !m["SpringApplicationName"].empty()) {
      springApplicationName = make_shared<string>(boost::any_cast<string>(m["SpringApplicationName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetServiceListResponseBodyData() = default;
};
class GetServiceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<GetServiceListResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetServiceListResponseBody() {}

  explicit GetServiceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetServiceListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetServiceListResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceListResponseBody() = default;
};
class GetServiceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceListResponseBody> body{};

  GetServiceListResponse() {}

  explicit GetServiceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListResponse() = default;
};
class GetServiceListPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};

  GetServiceListPageRequest() {}

  explicit GetServiceListPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~GetServiceListPageRequest() = default;
};
class GetServiceListPageResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> gmtModifyTime{};
  shared_ptr<string> group{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  GetServiceListPageResponseBodyDataResult() {}

  explicit GetServiceListPageResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (gmtModifyTime) {
      res["GmtModifyTime"] = boost::any(*gmtModifyTime);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("GmtModifyTime") != m.end() && !m["GmtModifyTime"].empty()) {
      gmtModifyTime = make_shared<string>(boost::any_cast<string>(m["GmtModifyTime"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetServiceListPageResponseBodyDataResult() = default;
};
class GetServiceListPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<vector<GetServiceListPageResponseBodyDataResult>> result{};
  shared_ptr<string> totalSize{};

  GetServiceListPageResponseBodyData() {}

  explicit GetServiceListPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetServiceListPageResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListPageResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetServiceListPageResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<string>(boost::any_cast<string>(m["TotalSize"]));
    }
  }


  virtual ~GetServiceListPageResponseBodyData() = default;
};
class GetServiceListPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetServiceListPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetServiceListPageResponseBody() {}

  explicit GetServiceListPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceListPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceListPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceListPageResponseBody() = default;
};
class GetServiceListPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceListPageResponseBody> body{};

  GetServiceListPageResponse() {}

  explicit GetServiceListPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListPageResponse() = default;
};
class GetServiceListenersRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> hasIpCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> serviceName{};

  GetServiceListenersRequest() {}

  explicit GetServiceListenersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (hasIpCount) {
      res["HasIpCount"] = boost::any(*hasIpCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HasIpCount") != m.end() && !m["HasIpCount"].empty()) {
      hasIpCount = make_shared<string>(boost::any_cast<string>(m["HasIpCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~GetServiceListenersRequest() = default;
};
class GetServiceListenersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> addr{};
  shared_ptr<string> agent{};
  shared_ptr<string> app{};
  shared_ptr<string> cluster{};
  shared_ptr<string> IP{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> port{};
  shared_ptr<string> serviceName{};

  GetServiceListenersResponseBodyData() {}

  explicit GetServiceListenersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addr) {
      res["Addr"] = boost::any(*addr);
    }
    if (agent) {
      res["Agent"] = boost::any(*agent);
    }
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addr") != m.end() && !m["Addr"].empty()) {
      addr = make_shared<string>(boost::any_cast<string>(m["Addr"]));
    }
    if (m.find("Agent") != m.end() && !m["Agent"].empty()) {
      agent = make_shared<string>(boost::any_cast<string>(m["Agent"]));
    }
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~GetServiceListenersResponseBodyData() = default;
};
class GetServiceListenersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceListenersResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  GetServiceListenersResponseBody() {}

  explicit GetServiceListenersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetServiceListenersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceListenersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetServiceListenersResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetServiceListenersResponseBody() = default;
};
class GetServiceListenersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceListenersResponseBody> body{};

  GetServiceListenersResponse() {}

  explicit GetServiceListenersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceListenersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceListenersResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceListenersResponse() = default;
};
class GetServiceMethodPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> ip{};
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceGroup{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> serviceType{};
  shared_ptr<string> serviceVersion{};

  GetServiceMethodPageRequest() {}

  explicit GetServiceMethodPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceGroup) {
      res["ServiceGroup"] = boost::any(*serviceGroup);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceGroup") != m.end() && !m["ServiceGroup"].empty()) {
      serviceGroup = make_shared<string>(boost::any_cast<string>(m["ServiceGroup"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~GetServiceMethodPageRequest() = default;
};
class GetServiceMethodPageResponseBodyDataResultParameterDefinitions : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetServiceMethodPageResponseBodyDataResultParameterDefinitions() {}

  explicit GetServiceMethodPageResponseBodyDataResultParameterDefinitions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResultParameterDefinitions() = default;
};
class GetServiceMethodPageResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> methodController{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDetail{};
  shared_ptr<vector<GetServiceMethodPageResponseBodyDataResultParameterDefinitions>> parameterDefinitions{};
  shared_ptr<vector<string>> parameterDetails{};
  shared_ptr<vector<string>> parameterTypes{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<string>> requestMethods{};
  shared_ptr<string> returnDetails{};
  shared_ptr<string> returnType{};

  GetServiceMethodPageResponseBodyDataResult() {}

  explicit GetServiceMethodPageResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodController) {
      res["MethodController"] = boost::any(*methodController);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDetail) {
      res["NameDetail"] = boost::any(*nameDetail);
    }
    if (parameterDefinitions) {
      vector<boost::any> temp1;
      for(auto item1:*parameterDefinitions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParameterDefinitions"] = boost::any(temp1);
    }
    if (parameterDetails) {
      res["ParameterDetails"] = boost::any(*parameterDetails);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (requestMethods) {
      res["RequestMethods"] = boost::any(*requestMethods);
    }
    if (returnDetails) {
      res["ReturnDetails"] = boost::any(*returnDetails);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodController") != m.end() && !m["MethodController"].empty()) {
      methodController = make_shared<string>(boost::any_cast<string>(m["MethodController"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDetail") != m.end() && !m["NameDetail"].empty()) {
      nameDetail = make_shared<string>(boost::any_cast<string>(m["NameDetail"]));
    }
    if (m.find("ParameterDefinitions") != m.end() && !m["ParameterDefinitions"].empty()) {
      if (typeid(vector<boost::any>) == m["ParameterDefinitions"].type()) {
        vector<GetServiceMethodPageResponseBodyDataResultParameterDefinitions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParameterDefinitions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceMethodPageResponseBodyDataResultParameterDefinitions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameterDefinitions = make_shared<vector<GetServiceMethodPageResponseBodyDataResultParameterDefinitions>>(expect1);
      }
    }
    if (m.find("ParameterDetails") != m.end() && !m["ParameterDetails"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterDetails"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterDetails"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterDetails = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestMethods") != m.end() && !m["RequestMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RequestMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequestMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      requestMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReturnDetails") != m.end() && !m["ReturnDetails"].empty()) {
      returnDetails = make_shared<string>(boost::any_cast<string>(m["ReturnDetails"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyDataResult() = default;
};
class GetServiceMethodPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<GetServiceMethodPageResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  GetServiceMethodPageResponseBodyData() {}

  explicit GetServiceMethodPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetServiceMethodPageResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceMethodPageResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetServiceMethodPageResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBodyData() = default;
};
class GetServiceMethodPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetServiceMethodPageResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetServiceMethodPageResponseBody() {}

  explicit GetServiceMethodPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetServiceMethodPageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetServiceMethodPageResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceMethodPageResponseBody() = default;
};
class GetServiceMethodPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceMethodPageResponseBody> body{};

  GetServiceMethodPageResponse() {}

  explicit GetServiceMethodPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceMethodPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceMethodPageResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceMethodPageResponse() = default;
};
class GetTagsBySwimmingLaneGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> namespace_{};

  GetTagsBySwimmingLaneGroupIdRequest() {}

  explicit GetTagsBySwimmingLaneGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetTagsBySwimmingLaneGroupIdRequest() = default;
};
class GetTagsBySwimmingLaneGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTagsBySwimmingLaneGroupIdResponseBody() {}

  explicit GetTagsBySwimmingLaneGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTagsBySwimmingLaneGroupIdResponseBody() = default;
};
class GetTagsBySwimmingLaneGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTagsBySwimmingLaneGroupIdResponseBody> body{};

  GetTagsBySwimmingLaneGroupIdResponse() {}

  explicit GetTagsBySwimmingLaneGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTagsBySwimmingLaneGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTagsBySwimmingLaneGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTagsBySwimmingLaneGroupIdResponse() = default;
};
class GetZookeeperDataImportUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> contentType{};
  shared_ptr<string> instanceId{};

  GetZookeeperDataImportUrlRequest() {}

  explicit GetZookeeperDataImportUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetZookeeperDataImportUrlRequest() = default;
};
class GetZookeeperDataImportUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> maxSize{};
  shared_ptr<string> url{};

  GetZookeeperDataImportUrlResponseBodyData() {}

  explicit GetZookeeperDataImportUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxSize) {
      res["MaxSize"] = boost::any(*maxSize);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxSize") != m.end() && !m["MaxSize"].empty()) {
      maxSize = make_shared<string>(boost::any_cast<string>(m["MaxSize"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetZookeeperDataImportUrlResponseBodyData() = default;
};
class GetZookeeperDataImportUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GetZookeeperDataImportUrlResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetZookeeperDataImportUrlResponseBody() {}

  explicit GetZookeeperDataImportUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetZookeeperDataImportUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetZookeeperDataImportUrlResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetZookeeperDataImportUrlResponseBody() = default;
};
class GetZookeeperDataImportUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetZookeeperDataImportUrlResponseBody> body{};

  GetZookeeperDataImportUrlResponse() {}

  explicit GetZookeeperDataImportUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetZookeeperDataImportUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetZookeeperDataImportUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetZookeeperDataImportUrlResponse() = default;
};
class ImportNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> policy{};

  ImportNacosConfigRequest() {}

  explicit ImportNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~ImportNacosConfigRequest() = default;
};
class ImportNacosConfigResponseBodyDataFailData : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};

  ImportNacosConfigResponseBodyDataFailData() {}

  explicit ImportNacosConfigResponseBodyDataFailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~ImportNacosConfigResponseBodyDataFailData() = default;
};
class ImportNacosConfigResponseBodyDataSkipData : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};

  ImportNacosConfigResponseBodyDataSkipData() {}

  explicit ImportNacosConfigResponseBodyDataSkipData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
  }


  virtual ~ImportNacosConfigResponseBodyDataSkipData() = default;
};
class ImportNacosConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ImportNacosConfigResponseBodyDataFailData>> failData{};
  shared_ptr<long> skipCount{};
  shared_ptr<vector<ImportNacosConfigResponseBodyDataSkipData>> skipData{};
  shared_ptr<long> succCount{};

  ImportNacosConfigResponseBodyData() {}

  explicit ImportNacosConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failData) {
      vector<boost::any> temp1;
      for(auto item1:*failData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailData"] = boost::any(temp1);
    }
    if (skipCount) {
      res["SkipCount"] = boost::any(*skipCount);
    }
    if (skipData) {
      vector<boost::any> temp1;
      for(auto item1:*skipData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkipData"] = boost::any(temp1);
    }
    if (succCount) {
      res["SuccCount"] = boost::any(*succCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailData") != m.end() && !m["FailData"].empty()) {
      if (typeid(vector<boost::any>) == m["FailData"].type()) {
        vector<ImportNacosConfigResponseBodyDataFailData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportNacosConfigResponseBodyDataFailData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failData = make_shared<vector<ImportNacosConfigResponseBodyDataFailData>>(expect1);
      }
    }
    if (m.find("SkipCount") != m.end() && !m["SkipCount"].empty()) {
      skipCount = make_shared<long>(boost::any_cast<long>(m["SkipCount"]));
    }
    if (m.find("SkipData") != m.end() && !m["SkipData"].empty()) {
      if (typeid(vector<boost::any>) == m["SkipData"].type()) {
        vector<ImportNacosConfigResponseBodyDataSkipData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkipData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportNacosConfigResponseBodyDataSkipData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skipData = make_shared<vector<ImportNacosConfigResponseBodyDataSkipData>>(expect1);
      }
    }
    if (m.find("SuccCount") != m.end() && !m["SuccCount"].empty()) {
      succCount = make_shared<long>(boost::any_cast<long>(m["SuccCount"]));
    }
  }


  virtual ~ImportNacosConfigResponseBodyData() = default;
};
class ImportNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ImportNacosConfigResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportNacosConfigResponseBody() {}

  explicit ImportNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportNacosConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportNacosConfigResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportNacosConfigResponseBody() = default;
};
class ImportNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportNacosConfigResponseBody> body{};

  ImportNacosConfigResponse() {}

  explicit ImportNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ImportNacosConfigResponse() = default;
};
class ImportServicesRequestServiceList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> serviceProtocol{};

  ImportServicesRequestServiceList() {}

  explicit ImportServicesRequestServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
  }


  virtual ~ImportServicesRequestServiceList() = default;
};
class ImportServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> fcAlias{};
  shared_ptr<string> fcServiceName{};
  shared_ptr<string> fcVersion{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<vector<ImportServicesRequestServiceList>> serviceList{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> tlsSetting{};

  ImportServicesRequest() {}

  explicit ImportServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (fcAlias) {
      res["FcAlias"] = boost::any(*fcAlias);
    }
    if (fcServiceName) {
      res["FcServiceName"] = boost::any(*fcServiceName);
    }
    if (fcVersion) {
      res["FcVersion"] = boost::any(*fcVersion);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceList) {
      vector<boost::any> temp1;
      for(auto item1:*serviceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceList"] = boost::any(temp1);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (tlsSetting) {
      res["TlsSetting"] = boost::any(*tlsSetting);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("FcAlias") != m.end() && !m["FcAlias"].empty()) {
      fcAlias = make_shared<string>(boost::any_cast<string>(m["FcAlias"]));
    }
    if (m.find("FcServiceName") != m.end() && !m["FcServiceName"].empty()) {
      fcServiceName = make_shared<string>(boost::any_cast<string>(m["FcServiceName"]));
    }
    if (m.find("FcVersion") != m.end() && !m["FcVersion"].empty()) {
      fcVersion = make_shared<string>(boost::any_cast<string>(m["FcVersion"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceList") != m.end() && !m["ServiceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceList"].type()) {
        vector<ImportServicesRequestServiceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportServicesRequestServiceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceList = make_shared<vector<ImportServicesRequestServiceList>>(expect1);
      }
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TlsSetting") != m.end() && !m["TlsSetting"].empty()) {
      tlsSetting = make_shared<string>(boost::any_cast<string>(m["TlsSetting"]));
    }
  }


  virtual ~ImportServicesRequest() = default;
};
class ImportServicesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> fcAlias{};
  shared_ptr<string> fcServiceName{};
  shared_ptr<string> fcVersion{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> serviceListShrink{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> tlsSetting{};

  ImportServicesShrinkRequest() {}

  explicit ImportServicesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (fcAlias) {
      res["FcAlias"] = boost::any(*fcAlias);
    }
    if (fcServiceName) {
      res["FcServiceName"] = boost::any(*fcServiceName);
    }
    if (fcVersion) {
      res["FcVersion"] = boost::any(*fcVersion);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceListShrink) {
      res["ServiceList"] = boost::any(*serviceListShrink);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (tlsSetting) {
      res["TlsSetting"] = boost::any(*tlsSetting);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("FcAlias") != m.end() && !m["FcAlias"].empty()) {
      fcAlias = make_shared<string>(boost::any_cast<string>(m["FcAlias"]));
    }
    if (m.find("FcServiceName") != m.end() && !m["FcServiceName"].empty()) {
      fcServiceName = make_shared<string>(boost::any_cast<string>(m["FcServiceName"]));
    }
    if (m.find("FcVersion") != m.end() && !m["FcVersion"].empty()) {
      fcVersion = make_shared<string>(boost::any_cast<string>(m["FcVersion"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceList") != m.end() && !m["ServiceList"].empty()) {
      serviceListShrink = make_shared<string>(boost::any_cast<string>(m["ServiceList"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("TlsSetting") != m.end() && !m["TlsSetting"].empty()) {
      tlsSetting = make_shared<string>(boost::any_cast<string>(m["TlsSetting"]));
    }
  }


  virtual ~ImportServicesShrinkRequest() = default;
};
class ImportServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportServicesResponseBody() {}

  explicit ImportServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportServicesResponseBody() = default;
};
class ImportServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportServicesResponseBody> body{};

  ImportServicesResponse() {}

  explicit ImportServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ImportServicesResponse() = default;
};
class ImportZookeeperDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ImportZookeeperDataRequest() {}

  explicit ImportZookeeperDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ImportZookeeperDataRequest() = default;
};
class ImportZookeeperDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportZookeeperDataResponseBody() {}

  explicit ImportZookeeperDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportZookeeperDataResponseBody() = default;
};
class ImportZookeeperDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportZookeeperDataResponseBody> body{};

  ImportZookeeperDataResponse() {}

  explicit ImportZookeeperDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportZookeeperDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportZookeeperDataResponseBody>(model1);
      }
    }
  }


  virtual ~ImportZookeeperDataResponse() = default;
};
class ListAnsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> serviceName{};

  ListAnsInstancesRequest() {}

  explicit ListAnsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListAnsInstancesRequest() = default;
};
class ListAnsInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> datumKey{};
  shared_ptr<string> defaultKey{};
  shared_ptr<bool> enabled{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<long> failCount{};
  shared_ptr<bool> healthy{};
  shared_ptr<long> instanceHeartBeatInterval{};
  shared_ptr<long> instanceHeartBeatTimeOut{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<long> ipDeleteTimeout{};
  shared_ptr<long> lastBeat{};
  shared_ptr<bool> marked{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<long> okCount{};
  shared_ptr<long> port{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> weight{};

  ListAnsInstancesResponseBodyData() {}

  explicit ListAnsInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (datumKey) {
      res["DatumKey"] = boost::any(*datumKey);
    }
    if (defaultKey) {
      res["DefaultKey"] = boost::any(*defaultKey);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (healthy) {
      res["Healthy"] = boost::any(*healthy);
    }
    if (instanceHeartBeatInterval) {
      res["InstanceHeartBeatInterval"] = boost::any(*instanceHeartBeatInterval);
    }
    if (instanceHeartBeatTimeOut) {
      res["InstanceHeartBeatTimeOut"] = boost::any(*instanceHeartBeatTimeOut);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipDeleteTimeout) {
      res["IpDeleteTimeout"] = boost::any(*ipDeleteTimeout);
    }
    if (lastBeat) {
      res["LastBeat"] = boost::any(*lastBeat);
    }
    if (marked) {
      res["Marked"] = boost::any(*marked);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (okCount) {
      res["OkCount"] = boost::any(*okCount);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DatumKey") != m.end() && !m["DatumKey"].empty()) {
      datumKey = make_shared<string>(boost::any_cast<string>(m["DatumKey"]));
    }
    if (m.find("DefaultKey") != m.end() && !m["DefaultKey"].empty()) {
      defaultKey = make_shared<string>(boost::any_cast<string>(m["DefaultKey"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("Healthy") != m.end() && !m["Healthy"].empty()) {
      healthy = make_shared<bool>(boost::any_cast<bool>(m["Healthy"]));
    }
    if (m.find("InstanceHeartBeatInterval") != m.end() && !m["InstanceHeartBeatInterval"].empty()) {
      instanceHeartBeatInterval = make_shared<long>(boost::any_cast<long>(m["InstanceHeartBeatInterval"]));
    }
    if (m.find("InstanceHeartBeatTimeOut") != m.end() && !m["InstanceHeartBeatTimeOut"].empty()) {
      instanceHeartBeatTimeOut = make_shared<long>(boost::any_cast<long>(m["InstanceHeartBeatTimeOut"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpDeleteTimeout") != m.end() && !m["IpDeleteTimeout"].empty()) {
      ipDeleteTimeout = make_shared<long>(boost::any_cast<long>(m["IpDeleteTimeout"]));
    }
    if (m.find("LastBeat") != m.end() && !m["LastBeat"].empty()) {
      lastBeat = make_shared<long>(boost::any_cast<long>(m["LastBeat"]));
    }
    if (m.find("Marked") != m.end() && !m["Marked"].empty()) {
      marked = make_shared<bool>(boost::any_cast<bool>(m["Marked"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OkCount") != m.end() && !m["OkCount"].empty()) {
      okCount = make_shared<long>(boost::any_cast<long>(m["OkCount"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ListAnsInstancesResponseBodyData() = default;
};
class ListAnsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAnsInstancesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListAnsInstancesResponseBody() {}

  explicit ListAnsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAnsInstancesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnsInstancesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAnsInstancesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAnsInstancesResponseBody() = default;
};
class ListAnsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnsInstancesResponseBody> body{};

  ListAnsInstancesResponse() {}

  explicit ListAnsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnsInstancesResponse() = default;
};
class ListAnsServiceClustersRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serviceName{};

  ListAnsServiceClustersRequest() {}

  explicit ListAnsServiceClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListAnsServiceClustersRequest() = default;
};
class ListAnsServiceClustersResponseBodyDataAppDetail : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> checkInternal{};
  shared_ptr<string> checkPath{};
  shared_ptr<long> checkTimeout{};
  shared_ptr<string> checkType{};
  shared_ptr<long> healthyCheckTimes{};
  shared_ptr<long> port{};
  shared_ptr<long> unhealthyCheckTimes{};

  ListAnsServiceClustersResponseBodyDataAppDetail() {}

  explicit ListAnsServiceClustersResponseBodyDataAppDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (checkInternal) {
      res["CheckInternal"] = boost::any(*checkInternal);
    }
    if (checkPath) {
      res["CheckPath"] = boost::any(*checkPath);
    }
    if (checkTimeout) {
      res["CheckTimeout"] = boost::any(*checkTimeout);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (healthyCheckTimes) {
      res["HealthyCheckTimes"] = boost::any(*healthyCheckTimes);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (unhealthyCheckTimes) {
      res["UnhealthyCheckTimes"] = boost::any(*unhealthyCheckTimes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CheckInternal") != m.end() && !m["CheckInternal"].empty()) {
      checkInternal = make_shared<long>(boost::any_cast<long>(m["CheckInternal"]));
    }
    if (m.find("CheckPath") != m.end() && !m["CheckPath"].empty()) {
      checkPath = make_shared<string>(boost::any_cast<string>(m["CheckPath"]));
    }
    if (m.find("CheckTimeout") != m.end() && !m["CheckTimeout"].empty()) {
      checkTimeout = make_shared<long>(boost::any_cast<long>(m["CheckTimeout"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<string>(boost::any_cast<string>(m["CheckType"]));
    }
    if (m.find("HealthyCheckTimes") != m.end() && !m["HealthyCheckTimes"].empty()) {
      healthyCheckTimes = make_shared<long>(boost::any_cast<long>(m["HealthyCheckTimes"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UnhealthyCheckTimes") != m.end() && !m["UnhealthyCheckTimes"].empty()) {
      unhealthyCheckTimes = make_shared<long>(boost::any_cast<long>(m["UnhealthyCheckTimes"]));
    }
  }


  virtual ~ListAnsServiceClustersResponseBodyDataAppDetail() = default;
};
class ListAnsServiceClustersResponseBodyDataClusters : public Darabonba::Model {
public:
  shared_ptr<long> defaultCheckPort{};
  shared_ptr<long> defaultPort{};
  shared_ptr<string> healthCheckerType{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<string> name{};
  shared_ptr<string> serviceName{};
  shared_ptr<bool> useIPPort4Check{};

  ListAnsServiceClustersResponseBodyDataClusters() {}

  explicit ListAnsServiceClustersResponseBodyDataClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultCheckPort) {
      res["DefaultCheckPort"] = boost::any(*defaultCheckPort);
    }
    if (defaultPort) {
      res["DefaultPort"] = boost::any(*defaultPort);
    }
    if (healthCheckerType) {
      res["HealthCheckerType"] = boost::any(*healthCheckerType);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (useIPPort4Check) {
      res["UseIPPort4Check"] = boost::any(*useIPPort4Check);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultCheckPort") != m.end() && !m["DefaultCheckPort"].empty()) {
      defaultCheckPort = make_shared<long>(boost::any_cast<long>(m["DefaultCheckPort"]));
    }
    if (m.find("DefaultPort") != m.end() && !m["DefaultPort"].empty()) {
      defaultPort = make_shared<long>(boost::any_cast<long>(m["DefaultPort"]));
    }
    if (m.find("HealthCheckerType") != m.end() && !m["HealthCheckerType"].empty()) {
      healthCheckerType = make_shared<string>(boost::any_cast<string>(m["HealthCheckerType"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("UseIPPort4Check") != m.end() && !m["UseIPPort4Check"].empty()) {
      useIPPort4Check = make_shared<bool>(boost::any_cast<bool>(m["UseIPPort4Check"]));
    }
  }


  virtual ~ListAnsServiceClustersResponseBodyDataClusters() = default;
};
class ListAnsServiceClustersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListAnsServiceClustersResponseBodyDataAppDetail> appDetail{};
  shared_ptr<vector<ListAnsServiceClustersResponseBodyDataClusters>> clusters{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<string> groupName{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<string> name{};
  shared_ptr<double> protectThreshold{};
  shared_ptr<string> selectorType{};
  shared_ptr<string> source{};

  ListAnsServiceClustersResponseBodyData() {}

  explicit ListAnsServiceClustersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDetail) {
      res["AppDetail"] = appDetail ? boost::any(appDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clusters"] = boost::any(temp1);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protectThreshold) {
      res["ProtectThreshold"] = boost::any(*protectThreshold);
    }
    if (selectorType) {
      res["SelectorType"] = boost::any(*selectorType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDetail") != m.end() && !m["AppDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppDetail"].type()) {
        ListAnsServiceClustersResponseBodyDataAppDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppDetail"]));
        appDetail = make_shared<ListAnsServiceClustersResponseBodyDataAppDetail>(model1);
      }
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["Clusters"].type()) {
        vector<ListAnsServiceClustersResponseBodyDataClusters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnsServiceClustersResponseBodyDataClusters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<ListAnsServiceClustersResponseBodyDataClusters>>(expect1);
      }
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProtectThreshold") != m.end() && !m["ProtectThreshold"].empty()) {
      protectThreshold = make_shared<double>(boost::any_cast<double>(m["ProtectThreshold"]));
    }
    if (m.find("SelectorType") != m.end() && !m["SelectorType"].empty()) {
      selectorType = make_shared<string>(boost::any_cast<string>(m["SelectorType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListAnsServiceClustersResponseBodyData() = default;
};
class ListAnsServiceClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAnsServiceClustersResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAnsServiceClustersResponseBody() {}

  explicit ListAnsServiceClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAnsServiceClustersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAnsServiceClustersResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAnsServiceClustersResponseBody() = default;
};
class ListAnsServiceClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnsServiceClustersResponseBody> body{};

  ListAnsServiceClustersResponse() {}

  explicit ListAnsServiceClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnsServiceClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnsServiceClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnsServiceClustersResponse() = default;
};
class ListAnsServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> hasIpCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> serviceName{};

  ListAnsServicesRequest() {}

  explicit ListAnsServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (hasIpCount) {
      res["HasIpCount"] = boost::any(*hasIpCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HasIpCount") != m.end() && !m["HasIpCount"].empty()) {
      hasIpCount = make_shared<string>(boost::any_cast<string>(m["HasIpCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListAnsServicesRequest() = default;
};
class ListAnsServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> clusterCount{};
  shared_ptr<string> groupName{};
  shared_ptr<long> healthyInstanceCount{};
  shared_ptr<long> ipCount{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};

  ListAnsServicesResponseBodyData() {}

  explicit ListAnsServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterCount) {
      res["ClusterCount"] = boost::any(*clusterCount);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (healthyInstanceCount) {
      res["HealthyInstanceCount"] = boost::any(*healthyInstanceCount);
    }
    if (ipCount) {
      res["IpCount"] = boost::any(*ipCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterCount") != m.end() && !m["ClusterCount"].empty()) {
      clusterCount = make_shared<long>(boost::any_cast<long>(m["ClusterCount"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HealthyInstanceCount") != m.end() && !m["HealthyInstanceCount"].empty()) {
      healthyInstanceCount = make_shared<long>(boost::any_cast<long>(m["HealthyInstanceCount"]));
    }
    if (m.find("IpCount") != m.end() && !m["IpCount"].empty()) {
      ipCount = make_shared<long>(boost::any_cast<long>(m["IpCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListAnsServicesResponseBodyData() = default;
};
class ListAnsServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAnsServicesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListAnsServicesResponseBody() {}

  explicit ListAnsServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAnsServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnsServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAnsServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAnsServicesResponseBody() = default;
};
class ListAnsServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnsServicesResponseBody> body{};

  ListAnsServicesResponse() {}

  explicit ListAnsServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnsServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnsServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnsServicesResponse() = default;
};
class ListAppBySwimmingLaneGroupTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> tag{};

  ListAppBySwimmingLaneGroupTagRequest() {}

  explicit ListAppBySwimmingLaneGroupTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagRequest() = default;
};
class ListAppBySwimmingLaneGroupTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAppBySwimmingLaneGroupTagResponseBody() {}

  explicit ListAppBySwimmingLaneGroupTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagResponseBody() = default;
};
class ListAppBySwimmingLaneGroupTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppBySwimmingLaneGroupTagResponseBody> body{};

  ListAppBySwimmingLaneGroupTagResponse() {}

  explicit ListAppBySwimmingLaneGroupTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppBySwimmingLaneGroupTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppBySwimmingLaneGroupTagResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagResponse() = default;
};
class ListAppBySwimmingLaneGroupTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> tags{};

  ListAppBySwimmingLaneGroupTagsRequest() {}

  explicit ListAppBySwimmingLaneGroupTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagsRequest() = default;
};
class ListAppBySwimmingLaneGroupTagsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> tagsShrink{};

  ListAppBySwimmingLaneGroupTagsShrinkRequest() {}

  explicit ListAppBySwimmingLaneGroupTagsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagsShrinkRequest() = default;
};
class ListAppBySwimmingLaneGroupTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DataValue>>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAppBySwimmingLaneGroupTagsResponseBody() {}

  explicit ListAppBySwimmingLaneGroupTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      map<string, boost::any> temp1;
      for(auto item1:*data){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        map<string, vector<DataValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["Data"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        data = make_shared<map<string, vector<DataValue>>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagsResponseBody() = default;
};
class ListAppBySwimmingLaneGroupTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppBySwimmingLaneGroupTagsResponseBody> body{};

  ListAppBySwimmingLaneGroupTagsResponse() {}

  explicit ListAppBySwimmingLaneGroupTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppBySwimmingLaneGroupTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppBySwimmingLaneGroupTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppBySwimmingLaneGroupTagsResponse() = default;
};
class ListApplicationsWithTagRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> region{};
  shared_ptr<string> source{};

  ListApplicationsWithTagRulesRequest() {}

  explicit ListApplicationsWithTagRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesRequest() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> expr{};
  shared_ptr<long> index{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> value{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (expr) {
      res["expr"] = boost::any(*expr);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("expr") != m.end() && !m["expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["expr"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["index"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems>> argumentItems{};
  shared_ptr<string> condition{};
  shared_ptr<string> group{};
  shared_ptr<string> methodName{};
  shared_ptr<vector<string>> paramTypes{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> triggerPolicy{};
  shared_ptr<string> version{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (argumentItems) {
      vector<boost::any> temp1;
      for(auto item1:*argumentItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["argumentItems"] = boost::any(temp1);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (group) {
      res["group"] = boost::any(*group);
    }
    if (methodName) {
      res["methodName"] = boost::any(*methodName);
    }
    if (paramTypes) {
      res["paramTypes"] = boost::any(*paramTypes);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (triggerPolicy) {
      res["triggerPolicy"] = boost::any(*triggerPolicy);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("argumentItems") != m.end() && !m["argumentItems"].empty()) {
      if (typeid(vector<boost::any>) == m["argumentItems"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["argumentItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        argumentItems = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems>>(expect1);
      }
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("group") != m.end() && !m["group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["group"]));
    }
    if (m.find("methodName") != m.end() && !m["methodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["methodName"]));
    }
    if (m.find("paramTypes") != m.end() && !m["paramTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paramTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paramTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paramTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerPolicy") != m.end() && !m["triggerPolicy"].empty()) {
      triggerPolicy = make_shared<string>(boost::any_cast<string>(m["triggerPolicy"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> condition{};
  shared_ptr<bool> enable{};
  shared_ptr<string> path{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<long> priority{};
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems>> restItems{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> triggerPolicy{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["appId"] = boost::any(*appId);
    }
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (paths) {
      res["paths"] = boost::any(*paths);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restItems"] = boost::any(temp1);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (triggerPolicy) {
      res["triggerPolicy"] = boost::any(*triggerPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appId") != m.end() && !m["appId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["appId"]));
    }
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("paths") != m.end() && !m["paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("restItems") != m.end() && !m["restItems"].empty()) {
      if (typeid(vector<boost::any>) == m["restItems"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems>>(expect1);
      }
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerPolicy") != m.end() && !m["triggerPolicy"].empty()) {
      triggerPolicy = make_shared<string>(boost::any_cast<string>(m["triggerPolicy"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo>> dubbo{};
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud>> springcloud{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubbo) {
      vector<boost::any> temp1;
      for(auto item1:*dubbo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dubbo"] = boost::any(temp1);
    }
    if (springcloud) {
      vector<boost::any> temp1;
      for(auto item1:*springcloud){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["springcloud"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dubbo") != m.end() && !m["dubbo"].empty()) {
      if (typeid(vector<boost::any>) == m["dubbo"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dubbo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dubbo = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo>>(expect1);
      }
    }
    if (m.find("springcloud") != m.end() && !m["springcloud"].empty()) {
      if (typeid(vector<boost::any>) == m["springcloud"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["springcloud"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        springcloud = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud>>(expect1);
      }
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResultRouteRules : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<long> instanceNum{};
  shared_ptr<string> name{};
  shared_ptr<long> rate{};
  shared_ptr<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules> rules{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};

  ListApplicationsWithTagRulesResponseBodyDataResultRouteRules() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResultRouteRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceNum) {
      res["InstanceNum"] = boost::any(*instanceNum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceNum") != m.end() && !m["InstanceNum"].empty()) {
      instanceNum = make_shared<long>(boost::any_cast<long>(m["InstanceNum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["Rate"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResultRouteRules() = default;
};
class ListApplicationsWithTagRulesResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRules>> routeRules{};
  shared_ptr<long> routeStatus{};

  ListApplicationsWithTagRulesResponseBodyDataResult() {}

  explicit ListApplicationsWithTagRulesResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (routeRules) {
      vector<boost::any> temp1;
      for(auto item1:*routeRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteRules"] = boost::any(temp1);
    }
    if (routeStatus) {
      res["RouteStatus"] = boost::any(*routeStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RouteRules") != m.end() && !m["RouteRules"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteRules"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResultRouteRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeRules = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResultRouteRules>>(expect1);
      }
    }
    if (m.find("RouteStatus") != m.end() && !m["RouteStatus"].empty()) {
      routeStatus = make_shared<long>(boost::any_cast<long>(m["RouteStatus"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyDataResult() = default;
};
class ListApplicationsWithTagRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListApplicationsWithTagRulesResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListApplicationsWithTagRulesResponseBodyData() {}

  explicit ListApplicationsWithTagRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListApplicationsWithTagRulesResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsWithTagRulesResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListApplicationsWithTagRulesResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBodyData() = default;
};
class ListApplicationsWithTagRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApplicationsWithTagRulesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListApplicationsWithTagRulesResponseBody() {}

  explicit ListApplicationsWithTagRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListApplicationsWithTagRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListApplicationsWithTagRulesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListApplicationsWithTagRulesResponseBody() = default;
};
class ListApplicationsWithTagRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsWithTagRulesResponseBody> body{};

  ListApplicationsWithTagRulesResponse() {}

  explicit ListApplicationsWithTagRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsWithTagRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsWithTagRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsWithTagRulesResponse() = default;
};
class ListAuthPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> protocol{};
  shared_ptr<string> region{};
  shared_ptr<string> source{};

  ListAuthPolicyRequest() {}

  explicit ListAuthPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListAuthPolicyRequest() = default;
};
class ListAuthPolicyResponseBodyDataResultAuthRuleMethod : public Darabonba::Model {
public:
  shared_ptr<string> group{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameterTypes{};
  shared_ptr<string> returnType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> version{};

  ListAuthPolicyResponseBodyDataResultAuthRuleMethod() {}

  explicit ListAuthPolicyResponseBodyDataResultAuthRuleMethod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameterTypes) {
      res["ParameterTypes"] = boost::any(*parameterTypes);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParameterTypes") != m.end() && !m["ParameterTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ParameterTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParameterTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameterTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<string>(boost::any_cast<string>(m["ReturnType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListAuthPolicyResponseBodyDataResultAuthRuleMethod() = default;
};
class ListAuthPolicyResponseBodyDataResultAuthRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appIds{};
  shared_ptr<long> authType{};
  shared_ptr<bool> black{};
  shared_ptr<vector<string>> k8sNamespaces{};
  shared_ptr<ListAuthPolicyResponseBodyDataResultAuthRuleMethod> method{};
  shared_ptr<string> path{};

  ListAuthPolicyResponseBodyDataResultAuthRule() {}

  explicit ListAuthPolicyResponseBodyDataResultAuthRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (black) {
      res["Black"] = boost::any(*black);
    }
    if (k8sNamespaces) {
      res["K8sNamespaces"] = boost::any(*k8sNamespaces);
    }
    if (method) {
      res["Method"] = method ? boost::any(method->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<long>(boost::any_cast<long>(m["AuthType"]));
    }
    if (m.find("Black") != m.end() && !m["Black"].empty()) {
      black = make_shared<bool>(boost::any_cast<bool>(m["Black"]));
    }
    if (m.find("K8sNamespaces") != m.end() && !m["K8sNamespaces"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["K8sNamespaces"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["K8sNamespaces"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      k8sNamespaces = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      if (typeid(map<string, boost::any>) == m["Method"].type()) {
        ListAuthPolicyResponseBodyDataResultAuthRuleMethod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Method"]));
        method = make_shared<ListAuthPolicyResponseBodyDataResultAuthRuleMethod>(model1);
      }
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListAuthPolicyResponseBodyDataResultAuthRule() = default;
};
class ListAuthPolicyResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<vector<ListAuthPolicyResponseBodyDataResultAuthRule>> authRule{};
  shared_ptr<long> authType{};
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};

  ListAuthPolicyResponseBodyDataResult() {}

  explicit ListAuthPolicyResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (authRule) {
      vector<boost::any> temp1;
      for(auto item1:*authRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthRule"] = boost::any(temp1);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuthRule") != m.end() && !m["AuthRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthRule"].type()) {
        vector<ListAuthPolicyResponseBodyDataResultAuthRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthPolicyResponseBodyDataResultAuthRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authRule = make_shared<vector<ListAuthPolicyResponseBodyDataResultAuthRule>>(expect1);
      }
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<long>(boost::any_cast<long>(m["AuthType"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListAuthPolicyResponseBodyDataResult() = default;
};
class ListAuthPolicyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListAuthPolicyResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListAuthPolicyResponseBodyData() {}

  explicit ListAuthPolicyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAuthPolicyResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthPolicyResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAuthPolicyResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListAuthPolicyResponseBodyData() = default;
};
class ListAuthPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListAuthPolicyResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAuthPolicyResponseBody() {}

  explicit ListAuthPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAuthPolicyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAuthPolicyResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAuthPolicyResponseBody() = default;
};
class ListAuthPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAuthPolicyResponseBody> body{};

  ListAuthPolicyResponse() {}

  explicit ListAuthPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuthPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuthPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuthPolicyResponse() = default;
};
class ListCircuitBreakerRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceSearchKey{};

  ListCircuitBreakerRulesRequest() {}

  explicit ListCircuitBreakerRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceSearchKey) {
      res["ResourceSearchKey"] = boost::any(*resourceSearchKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceSearchKey") != m.end() && !m["ResourceSearchKey"].empty()) {
      resourceSearchKey = make_shared<string>(boost::any_cast<string>(m["ResourceSearchKey"]));
    }
  }


  virtual ~ListCircuitBreakerRulesRequest() = default;
};
class ListCircuitBreakerRulesResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> fallbackObject{};
  shared_ptr<long> halfOpenBaseAmountPerStep{};
  shared_ptr<long> halfOpenRecoveryStepNum{};
  shared_ptr<long> maxAllowedRtMs{};
  shared_ptr<long> minRequestAmount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<long> retryTimeoutMs{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> statIntervalMs{};
  shared_ptr<long> strategy{};
  shared_ptr<double> threshold{};

  ListCircuitBreakerRulesResponseBodyDataResult() {}

  explicit ListCircuitBreakerRulesResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (fallbackObject) {
      res["FallbackObject"] = boost::any(*fallbackObject);
    }
    if (halfOpenBaseAmountPerStep) {
      res["HalfOpenBaseAmountPerStep"] = boost::any(*halfOpenBaseAmountPerStep);
    }
    if (halfOpenRecoveryStepNum) {
      res["HalfOpenRecoveryStepNum"] = boost::any(*halfOpenRecoveryStepNum);
    }
    if (maxAllowedRtMs) {
      res["MaxAllowedRtMs"] = boost::any(*maxAllowedRtMs);
    }
    if (minRequestAmount) {
      res["MinRequestAmount"] = boost::any(*minRequestAmount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (retryTimeoutMs) {
      res["RetryTimeoutMs"] = boost::any(*retryTimeoutMs);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (statIntervalMs) {
      res["StatIntervalMs"] = boost::any(*statIntervalMs);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FallbackObject") != m.end() && !m["FallbackObject"].empty()) {
      fallbackObject = make_shared<string>(boost::any_cast<string>(m["FallbackObject"]));
    }
    if (m.find("HalfOpenBaseAmountPerStep") != m.end() && !m["HalfOpenBaseAmountPerStep"].empty()) {
      halfOpenBaseAmountPerStep = make_shared<long>(boost::any_cast<long>(m["HalfOpenBaseAmountPerStep"]));
    }
    if (m.find("HalfOpenRecoveryStepNum") != m.end() && !m["HalfOpenRecoveryStepNum"].empty()) {
      halfOpenRecoveryStepNum = make_shared<long>(boost::any_cast<long>(m["HalfOpenRecoveryStepNum"]));
    }
    if (m.find("MaxAllowedRtMs") != m.end() && !m["MaxAllowedRtMs"].empty()) {
      maxAllowedRtMs = make_shared<long>(boost::any_cast<long>(m["MaxAllowedRtMs"]));
    }
    if (m.find("MinRequestAmount") != m.end() && !m["MinRequestAmount"].empty()) {
      minRequestAmount = make_shared<long>(boost::any_cast<long>(m["MinRequestAmount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RetryTimeoutMs") != m.end() && !m["RetryTimeoutMs"].empty()) {
      retryTimeoutMs = make_shared<long>(boost::any_cast<long>(m["RetryTimeoutMs"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("StatIntervalMs") != m.end() && !m["StatIntervalMs"].empty()) {
      statIntervalMs = make_shared<long>(boost::any_cast<long>(m["StatIntervalMs"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~ListCircuitBreakerRulesResponseBodyDataResult() = default;
};
class ListCircuitBreakerRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListCircuitBreakerRulesResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListCircuitBreakerRulesResponseBodyData() {}

  explicit ListCircuitBreakerRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListCircuitBreakerRulesResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCircuitBreakerRulesResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListCircuitBreakerRulesResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListCircuitBreakerRulesResponseBodyData() = default;
};
class ListCircuitBreakerRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListCircuitBreakerRulesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCircuitBreakerRulesResponseBody() {}

  explicit ListCircuitBreakerRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCircuitBreakerRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCircuitBreakerRulesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCircuitBreakerRulesResponseBody() = default;
};
class ListCircuitBreakerRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCircuitBreakerRulesResponseBody> body{};

  ListCircuitBreakerRulesResponse() {}

  explicit ListCircuitBreakerRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCircuitBreakerRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCircuitBreakerRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCircuitBreakerRulesResponse() = default;
};
class ListClusterConnectionTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  ListClusterConnectionTypesRequest() {}

  explicit ListClusterConnectionTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~ListClusterConnectionTypesRequest() = default;
};
class ListClusterConnectionTypesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> showName{};

  ListClusterConnectionTypesResponseBodyData() {}

  explicit ListClusterConnectionTypesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~ListClusterConnectionTypesResponseBodyData() = default;
};
class ListClusterConnectionTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListClusterConnectionTypesResponseBodyData>> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListClusterConnectionTypesResponseBody() {}

  explicit ListClusterConnectionTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListClusterConnectionTypesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterConnectionTypesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListClusterConnectionTypesResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListClusterConnectionTypesResponseBody() = default;
};
class ListClusterConnectionTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterConnectionTypesResponseBody> body{};

  ListClusterConnectionTypesResponse() {}

  explicit ListClusterConnectionTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterConnectionTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterConnectionTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterConnectionTypesResponse() = default;
};
class ListClusterHealthCheckTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ListClusterHealthCheckTaskRequest() {}

  explicit ListClusterHealthCheckTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListClusterHealthCheckTaskRequest() = default;
};
class ListClusterHealthCheckTaskResponseBodyDataResultRiskList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> module{};
  shared_ptr<bool> mute{};
  shared_ptr<bool> noticeFeature{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> riskCode{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> riskName{};
  shared_ptr<string> riskType{};
  shared_ptr<string> situation{};
  shared_ptr<string> suggestion{};
  shared_ptr<long> taskId{};
  shared_ptr<long> type{};
  shared_ptr<string> values{};

  ListClusterHealthCheckTaskResponseBodyDataResultRiskList() {}

  explicit ListClusterHealthCheckTaskResponseBodyDataResultRiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (module) {
      res["Module"] = boost::any(*module);
    }
    if (mute) {
      res["Mute"] = boost::any(*mute);
    }
    if (noticeFeature) {
      res["NoticeFeature"] = boost::any(*noticeFeature);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (riskCode) {
      res["RiskCode"] = boost::any(*riskCode);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    if (situation) {
      res["Situation"] = boost::any(*situation);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Module") != m.end() && !m["Module"].empty()) {
      module = make_shared<string>(boost::any_cast<string>(m["Module"]));
    }
    if (m.find("Mute") != m.end() && !m["Mute"].empty()) {
      mute = make_shared<bool>(boost::any_cast<bool>(m["Mute"]));
    }
    if (m.find("NoticeFeature") != m.end() && !m["NoticeFeature"].empty()) {
      noticeFeature = make_shared<bool>(boost::any_cast<bool>(m["NoticeFeature"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("RiskCode") != m.end() && !m["RiskCode"].empty()) {
      riskCode = make_shared<string>(boost::any_cast<string>(m["RiskCode"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
    if (m.find("Situation") != m.end() && !m["Situation"].empty()) {
      situation = make_shared<string>(boost::any_cast<string>(m["Situation"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~ListClusterHealthCheckTaskResponseBodyDataResultRiskList() = default;
};
class ListClusterHealthCheckTaskResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> createTime{};
  shared_ptr<long> id{};
  shared_ptr<string> imageVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> replica{};
  shared_ptr<vector<ListClusterHealthCheckTaskResponseBodyDataResultRiskList>> riskList{};
  shared_ptr<long> score{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};
  shared_ptr<long> totalItem{};
  shared_ptr<long> totalRisk{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> versionCode{};

  ListClusterHealthCheckTaskResponseBodyDataResult() {}

  explicit ListClusterHealthCheckTaskResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageVersion) {
      res["ImageVersion"] = boost::any(*imageVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (riskList) {
      vector<boost::any> temp1;
      for(auto item1:*riskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskList"] = boost::any(temp1);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalItem) {
      res["TotalItem"] = boost::any(*totalItem);
    }
    if (totalRisk) {
      res["TotalRisk"] = boost::any(*totalRisk);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ImageVersion") != m.end() && !m["ImageVersion"].empty()) {
      imageVersion = make_shared<string>(boost::any_cast<string>(m["ImageVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<string>(boost::any_cast<string>(m["Replica"]));
    }
    if (m.find("RiskList") != m.end() && !m["RiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskList"].type()) {
        vector<ListClusterHealthCheckTaskResponseBodyDataResultRiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHealthCheckTaskResponseBodyDataResultRiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskList = make_shared<vector<ListClusterHealthCheckTaskResponseBodyDataResultRiskList>>(expect1);
      }
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalItem") != m.end() && !m["TotalItem"].empty()) {
      totalItem = make_shared<long>(boost::any_cast<long>(m["TotalItem"]));
    }
    if (m.find("TotalRisk") != m.end() && !m["TotalRisk"].empty()) {
      totalRisk = make_shared<long>(boost::any_cast<long>(m["TotalRisk"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~ListClusterHealthCheckTaskResponseBodyDataResult() = default;
};
class ListClusterHealthCheckTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListClusterHealthCheckTaskResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListClusterHealthCheckTaskResponseBodyData() {}

  explicit ListClusterHealthCheckTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListClusterHealthCheckTaskResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterHealthCheckTaskResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListClusterHealthCheckTaskResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListClusterHealthCheckTaskResponseBodyData() = default;
};
class ListClusterHealthCheckTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListClusterHealthCheckTaskResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListClusterHealthCheckTaskResponseBody() {}

  explicit ListClusterHealthCheckTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListClusterHealthCheckTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListClusterHealthCheckTaskResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListClusterHealthCheckTaskResponseBody() = default;
};
class ListClusterHealthCheckTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterHealthCheckTaskResponseBody> body{};

  ListClusterHealthCheckTaskResponse() {}

  explicit ListClusterHealthCheckTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterHealthCheckTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterHealthCheckTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterHealthCheckTaskResponse() = default;
};
class ListClusterTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> connectType{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> regionId{};

  ListClusterTypesRequest() {}

  explicit ListClusterTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (connectType) {
      res["ConnectType"] = boost::any(*connectType);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConnectType") != m.end() && !m["ConnectType"].empty()) {
      connectType = make_shared<string>(boost::any_cast<string>(m["ConnectType"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListClusterTypesRequest() = default;
};
class ListClusterTypesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> showName{};

  ListClusterTypesResponseBodyData() {}

  explicit ListClusterTypesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~ListClusterTypesResponseBodyData() = default;
};
class ListClusterTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListClusterTypesResponseBodyData>> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListClusterTypesResponseBody() {}

  explicit ListClusterTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListClusterTypesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterTypesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListClusterTypesResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListClusterTypesResponseBody() = default;
};
class ListClusterTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterTypesResponseBody> body{};

  ListClusterTypesResponse() {}

  explicit ListClusterTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterTypesResponse() = default;
};
class ListClusterVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> mseVersion{};

  ListClusterVersionsRequest() {}

  explicit ListClusterVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
  }


  virtual ~ListClusterVersionsRequest() = default;
};
class ListClusterVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> code{};
  shared_ptr<string> showName{};

  ListClusterVersionsResponseBodyData() {}

  explicit ListClusterVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~ListClusterVersionsResponseBodyData() = default;
};
class ListClusterVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListClusterVersionsResponseBodyData>> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListClusterVersionsResponseBody() {}

  explicit ListClusterVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListClusterVersionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterVersionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListClusterVersionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListClusterVersionsResponseBody() = default;
};
class ListClusterVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterVersionsResponseBody> body{};

  ListClusterVersionsResponse() {}

  explicit ListClusterVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterVersionsResponse() = default;
};
class ListClustersRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListClustersRequestTag() {}

  explicit ListClustersRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListClustersRequestTag() = default;
};
class ListClustersRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterAliasName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListClustersRequestTag>> tag{};

  ListClustersRequest() {}

  explicit ListClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterAliasName) {
      res["ClusterAliasName"] = boost::any(*clusterAliasName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterAliasName") != m.end() && !m["ClusterAliasName"].empty()) {
      clusterAliasName = make_shared<string>(boost::any_cast<string>(m["ClusterAliasName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListClustersRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListClustersRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListClustersRequest() = default;
};
class ListClustersResponseBodyDataMaintenancePeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ListClustersResponseBodyDataMaintenancePeriod() {}

  explicit ListClustersResponseBodyDataMaintenancePeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListClustersResponseBodyDataMaintenancePeriod() = default;
};
class ListClustersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appVersion{};
  shared_ptr<bool> canUpdate{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterAliasName{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> endDate{};
  shared_ptr<string> initStatus{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetAddress{};
  shared_ptr<string> internetDomain{};
  shared_ptr<string> intranetAddress{};
  shared_ptr<string> intranetDomain{};
  shared_ptr<ListClustersResponseBodyDataMaintenancePeriod> maintenancePeriod{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> vpcId{};

  ListClustersResponseBodyData() {}

  explicit ListClustersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (canUpdate) {
      res["CanUpdate"] = boost::any(*canUpdate);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterAliasName) {
      res["ClusterAliasName"] = boost::any(*clusterAliasName);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (initStatus) {
      res["InitStatus"] = boost::any(*initStatus);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetAddress) {
      res["InternetAddress"] = boost::any(*internetAddress);
    }
    if (internetDomain) {
      res["InternetDomain"] = boost::any(*internetDomain);
    }
    if (intranetAddress) {
      res["IntranetAddress"] = boost::any(*intranetAddress);
    }
    if (intranetDomain) {
      res["IntranetDomain"] = boost::any(*intranetDomain);
    }
    if (maintenancePeriod) {
      res["MaintenancePeriod"] = maintenancePeriod ? boost::any(maintenancePeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("CanUpdate") != m.end() && !m["CanUpdate"].empty()) {
      canUpdate = make_shared<bool>(boost::any_cast<bool>(m["CanUpdate"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterAliasName") != m.end() && !m["ClusterAliasName"].empty()) {
      clusterAliasName = make_shared<string>(boost::any_cast<string>(m["ClusterAliasName"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("InitStatus") != m.end() && !m["InitStatus"].empty()) {
      initStatus = make_shared<string>(boost::any_cast<string>(m["InitStatus"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetAddress") != m.end() && !m["InternetAddress"].empty()) {
      internetAddress = make_shared<string>(boost::any_cast<string>(m["InternetAddress"]));
    }
    if (m.find("InternetDomain") != m.end() && !m["InternetDomain"].empty()) {
      internetDomain = make_shared<string>(boost::any_cast<string>(m["InternetDomain"]));
    }
    if (m.find("IntranetAddress") != m.end() && !m["IntranetAddress"].empty()) {
      intranetAddress = make_shared<string>(boost::any_cast<string>(m["IntranetAddress"]));
    }
    if (m.find("IntranetDomain") != m.end() && !m["IntranetDomain"].empty()) {
      intranetDomain = make_shared<string>(boost::any_cast<string>(m["IntranetDomain"]));
    }
    if (m.find("MaintenancePeriod") != m.end() && !m["MaintenancePeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenancePeriod"].type()) {
        ListClustersResponseBodyDataMaintenancePeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenancePeriod"]));
        maintenancePeriod = make_shared<ListClustersResponseBodyDataMaintenancePeriod>(model1);
      }
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListClustersResponseBodyData() = default;
};
class ListClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClustersResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListClustersResponseBody() {}

  explicit ListClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListClustersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClustersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListClustersResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClustersResponseBody() = default;
};
class ListClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClustersResponseBody> body{};

  ListClustersResponse() {}

  explicit ListClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListClustersResponse() = default;
};
class ListConfigTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dataId{};
  shared_ptr<long> endTs{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestPars{};
  shared_ptr<bool> reverse{};
  shared_ptr<long> startTs{};

  ListConfigTrackRequest() {}

  explicit ListConfigTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~ListConfigTrackRequest() = default;
};
class ListConfigTrackResponseBodyTraces : public Darabonba::Model {
public:
  shared_ptr<bool> client{};
  shared_ptr<string> dataId{};
  shared_ptr<string> delay{};
  shared_ptr<string> event{};
  shared_ptr<string> group{};
  shared_ptr<string> logDate{};
  shared_ptr<string> md5{};
  shared_ptr<bool> push{};
  shared_ptr<string> requestIp{};
  shared_ptr<string> responseIp{};
  shared_ptr<string> result{};
  shared_ptr<string> ts{};
  shared_ptr<string> type{};

  ListConfigTrackResponseBodyTraces() {}

  explicit ListConfigTrackResponseBodyTraces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (client) {
      res["Client"] = boost::any(*client);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (logDate) {
      res["LogDate"] = boost::any(*logDate);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (push) {
      res["Push"] = boost::any(*push);
    }
    if (requestIp) {
      res["RequestIp"] = boost::any(*requestIp);
    }
    if (responseIp) {
      res["ResponseIp"] = boost::any(*responseIp);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (ts) {
      res["Ts"] = boost::any(*ts);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Client") != m.end() && !m["Client"].empty()) {
      client = make_shared<bool>(boost::any_cast<bool>(m["Client"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<string>(boost::any_cast<string>(m["Delay"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("LogDate") != m.end() && !m["LogDate"].empty()) {
      logDate = make_shared<string>(boost::any_cast<string>(m["LogDate"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Push") != m.end() && !m["Push"].empty()) {
      push = make_shared<bool>(boost::any_cast<bool>(m["Push"]));
    }
    if (m.find("RequestIp") != m.end() && !m["RequestIp"].empty()) {
      requestIp = make_shared<string>(boost::any_cast<string>(m["RequestIp"]));
    }
    if (m.find("ResponseIp") != m.end() && !m["ResponseIp"].empty()) {
      responseIp = make_shared<string>(boost::any_cast<string>(m["ResponseIp"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Ts") != m.end() && !m["Ts"].empty()) {
      ts = make_shared<string>(boost::any_cast<string>(m["Ts"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListConfigTrackResponseBodyTraces() = default;
};
class ListConfigTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListConfigTrackResponseBodyTraces>> traces{};

  ListConfigTrackResponseBody() {}

  explicit ListConfigTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (traces) {
      vector<boost::any> temp1;
      for(auto item1:*traces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Traces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Traces") != m.end() && !m["Traces"].empty()) {
      if (typeid(vector<boost::any>) == m["Traces"].type()) {
        vector<ListConfigTrackResponseBodyTraces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Traces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigTrackResponseBodyTraces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traces = make_shared<vector<ListConfigTrackResponseBodyTraces>>(expect1);
      }
    }
  }


  virtual ~ListConfigTrackResponseBody() = default;
};
class ListConfigTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigTrackResponseBody> body{};

  ListConfigTrackResponse() {}

  explicit ListConfigTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigTrackResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigTrackResponse() = default;
};
class ListEngineNamespacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};

  ListEngineNamespacesRequest() {}

  explicit ListEngineNamespacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListEngineNamespacesRequest() = default;
};
class ListEngineNamespacesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceDesc{};
  shared_ptr<string> namespaceShowName{};
  shared_ptr<long> quota{};
  shared_ptr<string> serviceCount{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> type{};

  ListEngineNamespacesResponseBodyData() {}

  explicit ListEngineNamespacesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configCount) {
      res["ConfigCount"] = boost::any(*configCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceDesc) {
      res["NamespaceDesc"] = boost::any(*namespaceDesc);
    }
    if (namespaceShowName) {
      res["NamespaceShowName"] = boost::any(*namespaceShowName);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (serviceCount) {
      res["ServiceCount"] = boost::any(*serviceCount);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigCount") != m.end() && !m["ConfigCount"].empty()) {
      configCount = make_shared<long>(boost::any_cast<long>(m["ConfigCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceDesc") != m.end() && !m["NamespaceDesc"].empty()) {
      namespaceDesc = make_shared<string>(boost::any_cast<string>(m["NamespaceDesc"]));
    }
    if (m.find("NamespaceShowName") != m.end() && !m["NamespaceShowName"].empty()) {
      namespaceShowName = make_shared<string>(boost::any_cast<string>(m["NamespaceShowName"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("ServiceCount") != m.end() && !m["ServiceCount"].empty()) {
      serviceCount = make_shared<string>(boost::any_cast<string>(m["ServiceCount"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListEngineNamespacesResponseBodyData() = default;
};
class ListEngineNamespacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEngineNamespacesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListEngineNamespacesResponseBody() {}

  explicit ListEngineNamespacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEngineNamespacesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEngineNamespacesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEngineNamespacesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEngineNamespacesResponseBody() = default;
};
class ListEngineNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEngineNamespacesResponseBody> body{};

  ListEngineNamespacesResponse() {}

  explicit ListEngineNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEngineNamespacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEngineNamespacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEngineNamespacesResponse() = default;
};
class ListEurekaInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> serviceName{};

  ListEurekaInstancesRequest() {}

  explicit ListEurekaInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~ListEurekaInstancesRequest() = default;
};
class ListEurekaInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> app{};
  shared_ptr<long> durationInSecs{};
  shared_ptr<string> homePageUrl{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipAddr{};
  shared_ptr<long> lastDirtyTimestamp{};
  shared_ptr<long> lastUpdatedTimestamp{};
  shared_ptr<map<string, boost::any>> metadata{};
  shared_ptr<long> port{};
  shared_ptr<long> renewalIntervalInSecs{};
  shared_ptr<long> securePort{};
  shared_ptr<string> status{};
  shared_ptr<string> vipAddress{};

  ListEurekaInstancesResponseBodyData() {}

  explicit ListEurekaInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      res["App"] = boost::any(*app);
    }
    if (durationInSecs) {
      res["DurationInSecs"] = boost::any(*durationInSecs);
    }
    if (homePageUrl) {
      res["HomePageUrl"] = boost::any(*homePageUrl);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipAddr) {
      res["IpAddr"] = boost::any(*ipAddr);
    }
    if (lastDirtyTimestamp) {
      res["LastDirtyTimestamp"] = boost::any(*lastDirtyTimestamp);
    }
    if (lastUpdatedTimestamp) {
      res["LastUpdatedTimestamp"] = boost::any(*lastUpdatedTimestamp);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (renewalIntervalInSecs) {
      res["RenewalIntervalInSecs"] = boost::any(*renewalIntervalInSecs);
    }
    if (securePort) {
      res["SecurePort"] = boost::any(*securePort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (vipAddress) {
      res["VipAddress"] = boost::any(*vipAddress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      app = make_shared<string>(boost::any_cast<string>(m["App"]));
    }
    if (m.find("DurationInSecs") != m.end() && !m["DurationInSecs"].empty()) {
      durationInSecs = make_shared<long>(boost::any_cast<long>(m["DurationInSecs"]));
    }
    if (m.find("HomePageUrl") != m.end() && !m["HomePageUrl"].empty()) {
      homePageUrl = make_shared<string>(boost::any_cast<string>(m["HomePageUrl"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpAddr") != m.end() && !m["IpAddr"].empty()) {
      ipAddr = make_shared<string>(boost::any_cast<string>(m["IpAddr"]));
    }
    if (m.find("LastDirtyTimestamp") != m.end() && !m["LastDirtyTimestamp"].empty()) {
      lastDirtyTimestamp = make_shared<long>(boost::any_cast<long>(m["LastDirtyTimestamp"]));
    }
    if (m.find("LastUpdatedTimestamp") != m.end() && !m["LastUpdatedTimestamp"].empty()) {
      lastUpdatedTimestamp = make_shared<long>(boost::any_cast<long>(m["LastUpdatedTimestamp"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Metadata"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      metadata = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RenewalIntervalInSecs") != m.end() && !m["RenewalIntervalInSecs"].empty()) {
      renewalIntervalInSecs = make_shared<long>(boost::any_cast<long>(m["RenewalIntervalInSecs"]));
    }
    if (m.find("SecurePort") != m.end() && !m["SecurePort"].empty()) {
      securePort = make_shared<long>(boost::any_cast<long>(m["SecurePort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("VipAddress") != m.end() && !m["VipAddress"].empty()) {
      vipAddress = make_shared<string>(boost::any_cast<string>(m["VipAddress"]));
    }
  }


  virtual ~ListEurekaInstancesResponseBodyData() = default;
};
class ListEurekaInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEurekaInstancesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListEurekaInstancesResponseBody() {}

  explicit ListEurekaInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEurekaInstancesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEurekaInstancesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEurekaInstancesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEurekaInstancesResponseBody() = default;
};
class ListEurekaInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEurekaInstancesResponseBody> body{};

  ListEurekaInstancesResponse() {}

  explicit ListEurekaInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEurekaInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEurekaInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEurekaInstancesResponse() = default;
};
class ListEurekaServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ListEurekaServicesRequest() {}

  explicit ListEurekaServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListEurekaServicesRequest() = default;
};
class ListEurekaServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instancesId{};
  shared_ptr<string> name{};
  shared_ptr<string> upStatus{};

  ListEurekaServicesResponseBodyData() {}

  explicit ListEurekaServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancesId) {
      res["InstancesId"] = boost::any(*instancesId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (upStatus) {
      res["UpStatus"] = boost::any(*upStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancesId") != m.end() && !m["InstancesId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstancesId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstancesId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instancesId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpStatus") != m.end() && !m["UpStatus"].empty()) {
      upStatus = make_shared<string>(boost::any_cast<string>(m["UpStatus"]));
    }
  }


  virtual ~ListEurekaServicesResponseBodyData() = default;
};
class ListEurekaServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEurekaServicesResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListEurekaServicesResponseBody() {}

  explicit ListEurekaServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListEurekaServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEurekaServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEurekaServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEurekaServicesResponseBody() = default;
};
class ListEurekaServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEurekaServicesResponseBody> body{};

  ListEurekaServicesResponse() {}

  explicit ListEurekaServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEurekaServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEurekaServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEurekaServicesResponse() = default;
};
class ListExportZookeeperDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListExportZookeeperDataRequest() {}

  explicit ListExportZookeeperDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListExportZookeeperDataRequest() = default;
};
class ListExportZookeeperDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> contentMap{};
  shared_ptr<long> createTime{};
  shared_ptr<string> exportType{};
  shared_ptr<string> extend{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> kubeoneTaskIds{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ListExportZookeeperDataResponseBodyData() {}

  explicit ListExportZookeeperDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentMap) {
      res["ContentMap"] = boost::any(*contentMap);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (kubeoneTaskIds) {
      res["KubeoneTaskIds"] = boost::any(*kubeoneTaskIds);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentMap") != m.end() && !m["ContentMap"].empty()) {
      contentMap = make_shared<string>(boost::any_cast<string>(m["ContentMap"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KubeoneTaskIds") != m.end() && !m["KubeoneTaskIds"].empty()) {
      kubeoneTaskIds = make_shared<string>(boost::any_cast<string>(m["KubeoneTaskIds"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListExportZookeeperDataResponseBodyData() = default;
};
class ListExportZookeeperDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListExportZookeeperDataResponseBodyData>> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListExportZookeeperDataResponseBody() {}

  explicit ListExportZookeeperDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListExportZookeeperDataResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListExportZookeeperDataResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListExportZookeeperDataResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListExportZookeeperDataResponseBody() = default;
};
class ListExportZookeeperDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListExportZookeeperDataResponseBody> body{};

  ListExportZookeeperDataResponse() {}

  explicit ListExportZookeeperDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListExportZookeeperDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListExportZookeeperDataResponseBody>(model1);
      }
    }
  }


  virtual ~ListExportZookeeperDataResponse() = default;
};
class ListFlowRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceSearchKey{};

  ListFlowRulesRequest() {}

  explicit ListFlowRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceSearchKey) {
      res["ResourceSearchKey"] = boost::any(*resourceSearchKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceSearchKey") != m.end() && !m["ResourceSearchKey"].empty()) {
      resourceSearchKey = make_shared<string>(boost::any_cast<string>(m["ResourceSearchKey"]));
    }
  }


  virtual ~ListFlowRulesRequest() = default;
};
class ListFlowRulesResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> controlBehavior{};
  shared_ptr<bool> enable{};
  shared_ptr<string> fallbackObject{};
  shared_ptr<long> maxQueueingTimeMs{};
  shared_ptr<long> metricType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<long> ruleId{};
  shared_ptr<double> threshold{};
  shared_ptr<map<string, boost::any>> trafficTags{};

  ListFlowRulesResponseBodyDataResult() {}

  explicit ListFlowRulesResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlBehavior) {
      res["ControlBehavior"] = boost::any(*controlBehavior);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (fallbackObject) {
      res["FallbackObject"] = boost::any(*fallbackObject);
    }
    if (maxQueueingTimeMs) {
      res["MaxQueueingTimeMs"] = boost::any(*maxQueueingTimeMs);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (trafficTags) {
      res["TrafficTags"] = boost::any(*trafficTags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlBehavior") != m.end() && !m["ControlBehavior"].empty()) {
      controlBehavior = make_shared<long>(boost::any_cast<long>(m["ControlBehavior"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FallbackObject") != m.end() && !m["FallbackObject"].empty()) {
      fallbackObject = make_shared<string>(boost::any_cast<string>(m["FallbackObject"]));
    }
    if (m.find("MaxQueueingTimeMs") != m.end() && !m["MaxQueueingTimeMs"].empty()) {
      maxQueueingTimeMs = make_shared<long>(boost::any_cast<long>(m["MaxQueueingTimeMs"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<long>(boost::any_cast<long>(m["MetricType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
    if (m.find("TrafficTags") != m.end() && !m["TrafficTags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["TrafficTags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      trafficTags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListFlowRulesResponseBodyDataResult() = default;
};
class ListFlowRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListFlowRulesResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListFlowRulesResponseBodyData() {}

  explicit ListFlowRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListFlowRulesResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFlowRulesResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListFlowRulesResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListFlowRulesResponseBodyData() = default;
};
class ListFlowRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListFlowRulesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFlowRulesResponseBody() {}

  explicit ListFlowRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFlowRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFlowRulesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFlowRulesResponseBody() = default;
};
class ListFlowRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFlowRulesResponseBody> body{};

  ListFlowRulesResponse() {}

  explicit ListFlowRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFlowRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFlowRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFlowRulesResponse() = default;
};
class ListGatewayRequestFilterParams : public Darabonba::Model {
public:
  shared_ptr<string> gatewayType{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mseTag{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> vpc{};

  ListGatewayRequestFilterParams() {}

  explicit ListGatewayRequestFilterParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mseTag) {
      res["MseTag"] = boost::any(*mseTag);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (vpc) {
      res["Vpc"] = boost::any(*vpc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MseTag") != m.end() && !m["MseTag"].empty()) {
      mseTag = make_shared<string>(boost::any_cast<string>(m["MseTag"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      vpc = make_shared<string>(boost::any_cast<string>(m["Vpc"]));
    }
  }


  virtual ~ListGatewayRequestFilterParams() = default;
};
class ListGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<ListGatewayRequestFilterParams> filterParams{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayRequest() {}

  explicit ListGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParams) {
      res["FilterParams"] = filterParams ? boost::any(filterParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterParams"].type()) {
        ListGatewayRequestFilterParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterParams"]));
        filterParams = make_shared<ListGatewayRequestFilterParams>(model1);
      }
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayRequest() = default;
};
class ListGatewayShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<string> filterParamsShrink{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayShrinkRequest() {}

  explicit ListGatewayShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParamsShrink) {
      res["FilterParams"] = boost::any(*filterParamsShrink);
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      filterParamsShrink = make_shared<string>(boost::any_cast<string>(m["FilterParams"]));
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayShrinkRequest() = default;
};
class ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList : public Darabonba::Model {
public:
  shared_ptr<long> desiredReplica{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList() {}

  explicit ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desiredReplica) {
      res["DesiredReplica"] = boost::any(*desiredReplica);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesiredReplica") != m.end() && !m["DesiredReplica"].empty()) {
      desiredReplica = make_shared<long>(boost::any_cast<long>(m["DesiredReplica"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList() = default;
};
class ListGatewayResponseBodyDataResultElasticPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> elastic{};
  shared_ptr<string> elasticType{};
  shared_ptr<long> maxReplica{};
  shared_ptr<vector<ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList>> timePolicyList{};

  ListGatewayResponseBodyDataResultElasticPolicy() {}

  explicit ListGatewayResponseBodyDataResultElasticPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elastic) {
      res["Elastic"] = boost::any(*elastic);
    }
    if (elasticType) {
      res["ElasticType"] = boost::any(*elasticType);
    }
    if (maxReplica) {
      res["MaxReplica"] = boost::any(*maxReplica);
    }
    if (timePolicyList) {
      vector<boost::any> temp1;
      for(auto item1:*timePolicyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimePolicyList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Elastic") != m.end() && !m["Elastic"].empty()) {
      elastic = make_shared<bool>(boost::any_cast<bool>(m["Elastic"]));
    }
    if (m.find("ElasticType") != m.end() && !m["ElasticType"].empty()) {
      elasticType = make_shared<string>(boost::any_cast<string>(m["ElasticType"]));
    }
    if (m.find("MaxReplica") != m.end() && !m["MaxReplica"].empty()) {
      maxReplica = make_shared<long>(boost::any_cast<long>(m["MaxReplica"]));
    }
    if (m.find("TimePolicyList") != m.end() && !m["TimePolicyList"].empty()) {
      if (typeid(vector<boost::any>) == m["TimePolicyList"].type()) {
        vector<ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimePolicyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timePolicyList = make_shared<vector<ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList>>(expect1);
      }
    }
  }


  virtual ~ListGatewayResponseBodyDataResultElasticPolicy() = default;
};
class ListGatewayResponseBodyDataResultInitConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> supportWaf{};

  ListGatewayResponseBodyDataResultInitConfig() {}

  explicit ListGatewayResponseBodyDataResultInitConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (supportWaf) {
      res["SupportWaf"] = boost::any(*supportWaf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("SupportWaf") != m.end() && !m["SupportWaf"].empty()) {
      supportWaf = make_shared<bool>(boost::any_cast<bool>(m["SupportWaf"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResultInitConfig() = default;
};
class ListGatewayResponseBodyDataResultInternetSlb : public Darabonba::Model {
public:
  shared_ptr<string> gatewaySlbMode{};
  shared_ptr<string> gatewaySlbStatus{};
  shared_ptr<string> internetNetworkFlow{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbPort{};
  shared_ptr<string> slbSpec{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> type{};

  ListGatewayResponseBodyDataResultInternetSlb() {}

  explicit ListGatewayResponseBodyDataResultInternetSlb(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewaySlbMode) {
      res["GatewaySlbMode"] = boost::any(*gatewaySlbMode);
    }
    if (gatewaySlbStatus) {
      res["GatewaySlbStatus"] = boost::any(*gatewaySlbStatus);
    }
    if (internetNetworkFlow) {
      res["InternetNetworkFlow"] = boost::any(*internetNetworkFlow);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (slbSpec) {
      res["SlbSpec"] = boost::any(*slbSpec);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewaySlbMode") != m.end() && !m["GatewaySlbMode"].empty()) {
      gatewaySlbMode = make_shared<string>(boost::any_cast<string>(m["GatewaySlbMode"]));
    }
    if (m.find("GatewaySlbStatus") != m.end() && !m["GatewaySlbStatus"].empty()) {
      gatewaySlbStatus = make_shared<string>(boost::any_cast<string>(m["GatewaySlbStatus"]));
    }
    if (m.find("InternetNetworkFlow") != m.end() && !m["InternetNetworkFlow"].empty()) {
      internetNetworkFlow = make_shared<string>(boost::any_cast<string>(m["InternetNetworkFlow"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<string>(boost::any_cast<string>(m["SlbPort"]));
    }
    if (m.find("SlbSpec") != m.end() && !m["SlbSpec"].empty()) {
      slbSpec = make_shared<string>(boost::any_cast<string>(m["SlbSpec"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResultInternetSlb() = default;
};
class ListGatewayResponseBodyDataResultMaintenancePeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeZone{};

  ListGatewayResponseBodyDataResultMaintenancePeriod() {}

  explicit ListGatewayResponseBodyDataResultMaintenancePeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResultMaintenancePeriod() = default;
};
class ListGatewayResponseBodyDataResultSlb : public Darabonba::Model {
public:
  shared_ptr<string> gatewaySlbMode{};
  shared_ptr<string> gatewaySlbStatus{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbPort{};
  shared_ptr<string> slbSpec{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> type{};

  ListGatewayResponseBodyDataResultSlb() {}

  explicit ListGatewayResponseBodyDataResultSlb(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewaySlbMode) {
      res["GatewaySlbMode"] = boost::any(*gatewaySlbMode);
    }
    if (gatewaySlbStatus) {
      res["GatewaySlbStatus"] = boost::any(*gatewaySlbStatus);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (slbSpec) {
      res["SlbSpec"] = boost::any(*slbSpec);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewaySlbMode") != m.end() && !m["GatewaySlbMode"].empty()) {
      gatewaySlbMode = make_shared<string>(boost::any_cast<string>(m["GatewaySlbMode"]));
    }
    if (m.find("GatewaySlbStatus") != m.end() && !m["GatewaySlbStatus"].empty()) {
      gatewaySlbStatus = make_shared<string>(boost::any_cast<string>(m["GatewaySlbStatus"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<string>(boost::any_cast<string>(m["SlbPort"]));
    }
    if (m.find("SlbSpec") != m.end() && !m["SlbSpec"].empty()) {
      slbSpec = make_shared<string>(boost::any_cast<string>(m["SlbSpec"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResultSlb() = default;
};
class ListGatewayResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<bool> ahasOn{};
  shared_ptr<string> appVersion{};
  shared_ptr<bool> armsOn{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> currentVersion{};
  shared_ptr<bool> elastic{};
  shared_ptr<string> elasticInstanceId{};
  shared_ptr<ListGatewayResponseBodyDataResultElasticPolicy> elasticPolicy{};
  shared_ptr<long> elasticReplica{};
  shared_ptr<string> elasticType{};
  shared_ptr<string> endDate{};
  shared_ptr<string> gatewayType{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gatewayVersion{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<ListGatewayResponseBodyDataResultInitConfig> initConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<ListGatewayResponseBodyDataResultInternetSlb>> internetSlb{};
  shared_ptr<string> latestVersion{};
  shared_ptr<ListGatewayResponseBodyDataResultMaintenancePeriod> maintenancePeriod{};
  shared_ptr<string> mseTag{};
  shared_ptr<string> mseVersion{};
  shared_ptr<bool> mustUpgrade{};
  shared_ptr<string> name{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> rollBack{};
  shared_ptr<vector<ListGatewayResponseBodyDataResultSlb>> slb{};
  shared_ptr<string> spec{};
  shared_ptr<long> status{};
  shared_ptr<string> statusDesc{};
  shared_ptr<bool> supportWasm{};
  shared_ptr<string> tag{};
  shared_ptr<long> totalReplica{};
  shared_ptr<bool> upgrade{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitch2{};

  ListGatewayResponseBodyDataResult() {}

  explicit ListGatewayResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ahasOn) {
      res["AhasOn"] = boost::any(*ahasOn);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (armsOn) {
      res["ArmsOn"] = boost::any(*armsOn);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (elastic) {
      res["Elastic"] = boost::any(*elastic);
    }
    if (elasticInstanceId) {
      res["ElasticInstanceId"] = boost::any(*elasticInstanceId);
    }
    if (elasticPolicy) {
      res["ElasticPolicy"] = elasticPolicy ? boost::any(elasticPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticReplica) {
      res["ElasticReplica"] = boost::any(*elasticReplica);
    }
    if (elasticType) {
      res["ElasticType"] = boost::any(*elasticType);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (gatewayType) {
      res["GatewayType"] = boost::any(*gatewayType);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gatewayVersion) {
      res["GatewayVersion"] = boost::any(*gatewayVersion);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initConfig) {
      res["InitConfig"] = initConfig ? boost::any(initConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetSlb) {
      vector<boost::any> temp1;
      for(auto item1:*internetSlb){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InternetSlb"] = boost::any(temp1);
    }
    if (latestVersion) {
      res["LatestVersion"] = boost::any(*latestVersion);
    }
    if (maintenancePeriod) {
      res["MaintenancePeriod"] = maintenancePeriod ? boost::any(maintenancePeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mseTag) {
      res["MseTag"] = boost::any(*mseTag);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (mustUpgrade) {
      res["MustUpgrade"] = boost::any(*mustUpgrade);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (rollBack) {
      res["RollBack"] = boost::any(*rollBack);
    }
    if (slb) {
      vector<boost::any> temp1;
      for(auto item1:*slb){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Slb"] = boost::any(temp1);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (supportWasm) {
      res["SupportWasm"] = boost::any(*supportWasm);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (totalReplica) {
      res["TotalReplica"] = boost::any(*totalReplica);
    }
    if (upgrade) {
      res["Upgrade"] = boost::any(*upgrade);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitch2) {
      res["Vswitch2"] = boost::any(*vswitch2);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AhasOn") != m.end() && !m["AhasOn"].empty()) {
      ahasOn = make_shared<bool>(boost::any_cast<bool>(m["AhasOn"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("ArmsOn") != m.end() && !m["ArmsOn"].empty()) {
      armsOn = make_shared<bool>(boost::any_cast<bool>(m["ArmsOn"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["CurrentVersion"]));
    }
    if (m.find("Elastic") != m.end() && !m["Elastic"].empty()) {
      elastic = make_shared<bool>(boost::any_cast<bool>(m["Elastic"]));
    }
    if (m.find("ElasticInstanceId") != m.end() && !m["ElasticInstanceId"].empty()) {
      elasticInstanceId = make_shared<string>(boost::any_cast<string>(m["ElasticInstanceId"]));
    }
    if (m.find("ElasticPolicy") != m.end() && !m["ElasticPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ElasticPolicy"].type()) {
        ListGatewayResponseBodyDataResultElasticPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ElasticPolicy"]));
        elasticPolicy = make_shared<ListGatewayResponseBodyDataResultElasticPolicy>(model1);
      }
    }
    if (m.find("ElasticReplica") != m.end() && !m["ElasticReplica"].empty()) {
      elasticReplica = make_shared<long>(boost::any_cast<long>(m["ElasticReplica"]));
    }
    if (m.find("ElasticType") != m.end() && !m["ElasticType"].empty()) {
      elasticType = make_shared<string>(boost::any_cast<string>(m["ElasticType"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("GatewayType") != m.end() && !m["GatewayType"].empty()) {
      gatewayType = make_shared<string>(boost::any_cast<string>(m["GatewayType"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GatewayVersion") != m.end() && !m["GatewayVersion"].empty()) {
      gatewayVersion = make_shared<string>(boost::any_cast<string>(m["GatewayVersion"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InitConfig") != m.end() && !m["InitConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InitConfig"].type()) {
        ListGatewayResponseBodyDataResultInitConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InitConfig"]));
        initConfig = make_shared<ListGatewayResponseBodyDataResultInitConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetSlb") != m.end() && !m["InternetSlb"].empty()) {
      if (typeid(vector<boost::any>) == m["InternetSlb"].type()) {
        vector<ListGatewayResponseBodyDataResultInternetSlb> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InternetSlb"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayResponseBodyDataResultInternetSlb model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        internetSlb = make_shared<vector<ListGatewayResponseBodyDataResultInternetSlb>>(expect1);
      }
    }
    if (m.find("LatestVersion") != m.end() && !m["LatestVersion"].empty()) {
      latestVersion = make_shared<string>(boost::any_cast<string>(m["LatestVersion"]));
    }
    if (m.find("MaintenancePeriod") != m.end() && !m["MaintenancePeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenancePeriod"].type()) {
        ListGatewayResponseBodyDataResultMaintenancePeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenancePeriod"]));
        maintenancePeriod = make_shared<ListGatewayResponseBodyDataResultMaintenancePeriod>(model1);
      }
    }
    if (m.find("MseTag") != m.end() && !m["MseTag"].empty()) {
      mseTag = make_shared<string>(boost::any_cast<string>(m["MseTag"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("MustUpgrade") != m.end() && !m["MustUpgrade"].empty()) {
      mustUpgrade = make_shared<bool>(boost::any_cast<bool>(m["MustUpgrade"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("RollBack") != m.end() && !m["RollBack"].empty()) {
      rollBack = make_shared<bool>(boost::any_cast<bool>(m["RollBack"]));
    }
    if (m.find("Slb") != m.end() && !m["Slb"].empty()) {
      if (typeid(vector<boost::any>) == m["Slb"].type()) {
        vector<ListGatewayResponseBodyDataResultSlb> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Slb"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayResponseBodyDataResultSlb model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slb = make_shared<vector<ListGatewayResponseBodyDataResultSlb>>(expect1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("SupportWasm") != m.end() && !m["SupportWasm"].empty()) {
      supportWasm = make_shared<bool>(boost::any_cast<bool>(m["SupportWasm"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TotalReplica") != m.end() && !m["TotalReplica"].empty()) {
      totalReplica = make_shared<long>(boost::any_cast<long>(m["TotalReplica"]));
    }
    if (m.find("Upgrade") != m.end() && !m["Upgrade"].empty()) {
      upgrade = make_shared<bool>(boost::any_cast<bool>(m["Upgrade"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("Vswitch2") != m.end() && !m["Vswitch2"].empty()) {
      vswitch2 = make_shared<string>(boost::any_cast<string>(m["Vswitch2"]));
    }
  }


  virtual ~ListGatewayResponseBodyDataResult() = default;
};
class ListGatewayResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGatewayResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGatewayResponseBodyData() {}

  explicit ListGatewayResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGatewayResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGatewayResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGatewayResponseBodyData() = default;
};
class ListGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListGatewayResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayResponseBody() {}

  explicit ListGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGatewayResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGatewayResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayResponseBody() = default;
};
class ListGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayResponseBody> body{};

  ListGatewayResponse() {}

  explicit ListGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayResponse() = default;
};
class ListGatewayAuthConsumerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> consumerStatus{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};
  shared_ptr<string> pageNum{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> type{};

  ListGatewayAuthConsumerRequest() {}

  explicit ListGatewayAuthConsumerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerStatus) {
      res["ConsumerStatus"] = boost::any(*consumerStatus);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerStatus") != m.end() && !m["ConsumerStatus"].empty()) {
      consumerStatus = make_shared<bool>(boost::any_cast<bool>(m["ConsumerStatus"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<string>(boost::any_cast<string>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayAuthConsumerRequest() = default;
};
class ListGatewayAuthConsumerResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<bool> consumerStatus{};
  shared_ptr<string> description{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> primaryUser{};
  shared_ptr<string> type{};

  ListGatewayAuthConsumerResponseBodyDataResult() {}

  explicit ListGatewayAuthConsumerResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerStatus) {
      res["ConsumerStatus"] = boost::any(*consumerStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryUser) {
      res["PrimaryUser"] = boost::any(*primaryUser);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerStatus") != m.end() && !m["ConsumerStatus"].empty()) {
      consumerStatus = make_shared<bool>(boost::any_cast<bool>(m["ConsumerStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryUser") != m.end() && !m["PrimaryUser"].empty()) {
      primaryUser = make_shared<string>(boost::any_cast<string>(m["PrimaryUser"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResponseBodyDataResult() = default;
};
class ListGatewayAuthConsumerResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGatewayAuthConsumerResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGatewayAuthConsumerResponseBodyData() {}

  explicit ListGatewayAuthConsumerResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGatewayAuthConsumerResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayAuthConsumerResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGatewayAuthConsumerResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResponseBodyData() = default;
};
class ListGatewayAuthConsumerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListGatewayAuthConsumerResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayAuthConsumerResponseBody() {}

  explicit ListGatewayAuthConsumerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGatewayAuthConsumerResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGatewayAuthConsumerResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResponseBody() = default;
};
class ListGatewayAuthConsumerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayAuthConsumerResponseBody> body{};

  ListGatewayAuthConsumerResponse() {}

  explicit ListGatewayAuthConsumerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayAuthConsumerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayAuthConsumerResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayAuthConsumerResponse() = default;
};
class ListGatewayAuthConsumerResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> pageNum{};
  shared_ptr<string> pageSize{};
  shared_ptr<bool> resourceStatus{};
  shared_ptr<string> routeName{};

  ListGatewayAuthConsumerResourceRequest() {}

  explicit ListGatewayAuthConsumerResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<string>(boost::any_cast<string>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<bool>(boost::any_cast<bool>(m["ResourceStatus"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResourceRequest() = default;
};
class ListGatewayAuthConsumerResourceResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<bool> resourceStatus{};
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};

  ListGatewayAuthConsumerResourceResponseBodyDataResult() {}

  explicit ListGatewayAuthConsumerResourceResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<bool>(boost::any_cast<bool>(m["ResourceStatus"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResourceResponseBodyDataResult() = default;
};
class ListGatewayAuthConsumerResourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGatewayAuthConsumerResourceResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGatewayAuthConsumerResourceResponseBodyData() {}

  explicit ListGatewayAuthConsumerResourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGatewayAuthConsumerResourceResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayAuthConsumerResourceResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGatewayAuthConsumerResourceResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResourceResponseBodyData() = default;
};
class ListGatewayAuthConsumerResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListGatewayAuthConsumerResourceResponseBodyData> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayAuthConsumerResourceResponseBody() {}

  explicit ListGatewayAuthConsumerResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGatewayAuthConsumerResourceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGatewayAuthConsumerResourceResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayAuthConsumerResourceResponseBody() = default;
};
class ListGatewayAuthConsumerResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayAuthConsumerResourceResponseBody> body{};

  ListGatewayAuthConsumerResourceResponse() {}

  explicit ListGatewayAuthConsumerResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayAuthConsumerResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayAuthConsumerResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayAuthConsumerResourceResponse() = default;
};
class ListGatewayDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> type{};

  ListGatewayDomainRequest() {}

  explicit ListGatewayDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayDomainRequest() = default;
};
class ListGatewayDomainResponseBodyDataComment : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  ListGatewayDomainResponseBodyDataComment() {}

  explicit ListGatewayDomainResponseBodyDataComment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListGatewayDomainResponseBodyDataComment() = default;
};
class ListGatewayDomainResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> certBeforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<ListGatewayDomainResponseBodyDataComment> comment{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> http2{};
  shared_ptr<long> id{};
  shared_ptr<bool> mustHttps{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<long> status{};
  shared_ptr<string> tlsMax{};
  shared_ptr<string> tlsMin{};
  shared_ptr<string> type{};

  ListGatewayDomainResponseBodyData() {}

  explicit ListGatewayDomainResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certBeforeDate) {
      res["CertBeforeDate"] = boost::any(*certBeforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (comment) {
      res["Comment"] = comment ? boost::any(comment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tlsMax) {
      res["TlsMax"] = boost::any(*tlsMax);
    }
    if (tlsMin) {
      res["TlsMin"] = boost::any(*tlsMin);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertBeforeDate") != m.end() && !m["CertBeforeDate"].empty()) {
      certBeforeDate = make_shared<string>(boost::any_cast<string>(m["CertBeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Comment"].type()) {
        ListGatewayDomainResponseBodyDataComment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Comment"]));
        comment = make_shared<ListGatewayDomainResponseBodyDataComment>(model1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<bool>(boost::any_cast<bool>(m["MustHttps"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TlsMax") != m.end() && !m["TlsMax"].empty()) {
      tlsMax = make_shared<string>(boost::any_cast<string>(m["TlsMax"]));
    }
    if (m.find("TlsMin") != m.end() && !m["TlsMin"].empty()) {
      tlsMin = make_shared<string>(boost::any_cast<string>(m["TlsMin"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayDomainResponseBodyData() = default;
};
class ListGatewayDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListGatewayDomainResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayDomainResponseBody() {}

  explicit ListGatewayDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListGatewayDomainResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayDomainResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListGatewayDomainResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayDomainResponseBody() = default;
};
class ListGatewayDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayDomainResponseBody> body{};

  ListGatewayDomainResponse() {}

  explicit ListGatewayDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayDomainResponse() = default;
};
class ListGatewayRouteRequestFilterParams : public Darabonba::Model {
public:
  shared_ptr<long> defaultServiceId{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};
  shared_ptr<long> routeOrder{};
  shared_ptr<long> status{};

  ListGatewayRouteRequestFilterParams() {}

  explicit ListGatewayRouteRequestFilterParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultServiceId) {
      res["DefaultServiceId"] = boost::any(*defaultServiceId);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultServiceId") != m.end() && !m["DefaultServiceId"].empty()) {
      defaultServiceId = make_shared<long>(boost::any_cast<long>(m["DefaultServiceId"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListGatewayRouteRequestFilterParams() = default;
};
class ListGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<ListGatewayRouteRequestFilterParams> filterParams{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayRouteRequest() {}

  explicit ListGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParams) {
      res["FilterParams"] = filterParams ? boost::any(filterParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterParams"].type()) {
        ListGatewayRouteRequestFilterParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterParams"]));
        filterParams = make_shared<ListGatewayRouteRequestFilterParams>(model1);
      }
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayRouteRequest() = default;
};
class ListGatewayRouteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<string> filterParamsShrink{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayRouteShrinkRequest() {}

  explicit ListGatewayRouteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParamsShrink) {
      res["FilterParams"] = boost::any(*filterParamsShrink);
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      filterParamsShrink = make_shared<string>(boost::any_cast<string>(m["FilterParams"]));
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayRouteShrinkRequest() = default;
};
class ListGatewayRouteResponseBodyDataResultComment : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  ListGatewayRouteResponseBodyDataResultComment() {}

  explicit ListGatewayRouteResponseBodyDataResultComment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultComment() = default;
};
class ListGatewayRouteResponseBodyDataResultDirectResponse : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> code{};

  ListGatewayRouteResponseBodyDataResultDirectResponse() {}

  explicit ListGatewayRouteResponseBodyDataResultDirectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultDirectResponse() = default;
};
class ListGatewayRouteResponseBodyDataResultFallbackServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  ListGatewayRouteResponseBodyDataResultFallbackServices() {}

  explicit ListGatewayRouteResponseBodyDataResultFallbackServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultFallbackServices() = default;
};
class ListGatewayRouteResponseBodyDataResultRedirect : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> host{};
  shared_ptr<string> path{};

  ListGatewayRouteResponseBodyDataResultRedirect() {}

  explicit ListGatewayRouteResponseBodyDataResultRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRedirect() = default;
};
class ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates() {}

  explicit ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates() = default;
};
class ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates() {}

  explicit ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates() = default;
};
class ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates() {}

  explicit ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates() = default;
};
class ListGatewayRouteResponseBodyDataResultRoutePredicates : public Darabonba::Model {
public:
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates>> queryPredicates{};

  ListGatewayRouteResponseBodyDataResultRoutePredicates() {}

  explicit ListGatewayRouteResponseBodyDataResultRoutePredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRoutePredicates() = default;
};
class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList : public Darabonba::Model {
public:
  shared_ptr<string> extractKey{};
  shared_ptr<string> extractKeySpec{};
  shared_ptr<string> mappingType{};

  ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList() {}

  explicit ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractKey) {
      res["ExtractKey"] = boost::any(*extractKey);
    }
    if (extractKeySpec) {
      res["ExtractKeySpec"] = boost::any(*extractKeySpec);
    }
    if (mappingType) {
      res["MappingType"] = boost::any(*mappingType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractKey") != m.end() && !m["ExtractKey"].empty()) {
      extractKey = make_shared<string>(boost::any_cast<string>(m["ExtractKey"]));
    }
    if (m.find("ExtractKeySpec") != m.end() && !m["ExtractKeySpec"].empty()) {
      extractKeySpec = make_shared<string>(boost::any_cast<string>(m["ExtractKeySpec"]));
    }
    if (m.find("MappingType") != m.end() && !m["MappingType"].empty()) {
      mappingType = make_shared<string>(boost::any_cast<string>(m["MappingType"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList() = default;
};
class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList : public Darabonba::Model {
public:
  shared_ptr<string> dubboMothedName{};
  shared_ptr<string> httpMothed{};
  shared_ptr<string> mothedpath{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList>> paramMapsList{};
  shared_ptr<string> passThroughAllHeaders{};
  shared_ptr<vector<string>> passThroughList{};

  ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList() {}

  explicit ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboMothedName) {
      res["DubboMothedName"] = boost::any(*dubboMothedName);
    }
    if (httpMothed) {
      res["HttpMothed"] = boost::any(*httpMothed);
    }
    if (mothedpath) {
      res["Mothedpath"] = boost::any(*mothedpath);
    }
    if (paramMapsList) {
      vector<boost::any> temp1;
      for(auto item1:*paramMapsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamMapsList"] = boost::any(temp1);
    }
    if (passThroughAllHeaders) {
      res["PassThroughAllHeaders"] = boost::any(*passThroughAllHeaders);
    }
    if (passThroughList) {
      res["PassThroughList"] = boost::any(*passThroughList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboMothedName") != m.end() && !m["DubboMothedName"].empty()) {
      dubboMothedName = make_shared<string>(boost::any_cast<string>(m["DubboMothedName"]));
    }
    if (m.find("HttpMothed") != m.end() && !m["HttpMothed"].empty()) {
      httpMothed = make_shared<string>(boost::any_cast<string>(m["HttpMothed"]));
    }
    if (m.find("Mothedpath") != m.end() && !m["Mothedpath"].empty()) {
      mothedpath = make_shared<string>(boost::any_cast<string>(m["Mothedpath"]));
    }
    if (m.find("ParamMapsList") != m.end() && !m["ParamMapsList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamMapsList"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamMapsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramMapsList = make_shared<vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList>>(expect1);
      }
    }
    if (m.find("PassThroughAllHeaders") != m.end() && !m["PassThroughAllHeaders"].empty()) {
      passThroughAllHeaders = make_shared<string>(boost::any_cast<string>(m["PassThroughAllHeaders"]));
    }
    if (m.find("PassThroughList") != m.end() && !m["PassThroughList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PassThroughList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PassThroughList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passThroughList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList() = default;
};
class ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder : public Darabonba::Model {
public:
  shared_ptr<string> dubboServiceGroup{};
  shared_ptr<string> dubboServiceName{};
  shared_ptr<string> dubboServiceVersion{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList>> mothedMapList{};

  ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder() {}

  explicit ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboServiceGroup) {
      res["DubboServiceGroup"] = boost::any(*dubboServiceGroup);
    }
    if (dubboServiceName) {
      res["DubboServiceName"] = boost::any(*dubboServiceName);
    }
    if (dubboServiceVersion) {
      res["DubboServiceVersion"] = boost::any(*dubboServiceVersion);
    }
    if (mothedMapList) {
      vector<boost::any> temp1;
      for(auto item1:*mothedMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MothedMapList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboServiceGroup") != m.end() && !m["DubboServiceGroup"].empty()) {
      dubboServiceGroup = make_shared<string>(boost::any_cast<string>(m["DubboServiceGroup"]));
    }
    if (m.find("DubboServiceName") != m.end() && !m["DubboServiceName"].empty()) {
      dubboServiceName = make_shared<string>(boost::any_cast<string>(m["DubboServiceName"]));
    }
    if (m.find("DubboServiceVersion") != m.end() && !m["DubboServiceVersion"].empty()) {
      dubboServiceVersion = make_shared<string>(boost::any_cast<string>(m["DubboServiceVersion"]));
    }
    if (m.find("MothedMapList") != m.end() && !m["MothedMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["MothedMapList"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MothedMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mothedMapList = make_shared<vector<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList>>(expect1);
      }
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder() = default;
};
class ListGatewayRouteResponseBodyDataResultRouteServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder> httpDubboTranscoder{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  ListGatewayRouteResponseBodyDataResultRouteServices() {}

  explicit ListGatewayRouteResponseBodyDataResultRouteServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpDubboTranscoder) {
      res["HttpDubboTranscoder"] = httpDubboTranscoder ? boost::any(httpDubboTranscoder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpDubboTranscoder") != m.end() && !m["HttpDubboTranscoder"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpDubboTranscoder"].type()) {
        ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpDubboTranscoder"]));
        httpDubboTranscoder = make_shared<ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResultRouteServices() = default;
};
class ListGatewayRouteResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<ListGatewayRouteResponseBodyDataResultComment> comment{};
  shared_ptr<long> defaultServiceId{};
  shared_ptr<string> defaultServiceName{};
  shared_ptr<string> destinationType{};
  shared_ptr<ListGatewayRouteResponseBodyDataResultDirectResponse> directResponse{};
  shared_ptr<long> domainId{};
  shared_ptr<vector<long>> domainIdList{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultFallbackServices>> fallbackServices{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> predicates{};
  shared_ptr<ListGatewayRouteResponseBodyDataResultRedirect> redirect{};
  shared_ptr<long> routeOrder{};
  shared_ptr<ListGatewayRouteResponseBodyDataResultRoutePredicates> routePredicates{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResultRouteServices>> routeServices{};
  shared_ptr<string> services{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  ListGatewayRouteResponseBodyDataResult() {}

  explicit ListGatewayRouteResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = comment ? boost::any(comment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (defaultServiceId) {
      res["DefaultServiceId"] = boost::any(*defaultServiceId);
    }
    if (defaultServiceName) {
      res["DefaultServiceName"] = boost::any(*defaultServiceName);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponse) {
      res["DirectResponse"] = directResponse ? boost::any(directResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdList) {
      res["DomainIdList"] = boost::any(*domainIdList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServices) {
      vector<boost::any> temp1;
      for(auto item1:*fallbackServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FallbackServices"] = boost::any(temp1);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (predicates) {
      res["Predicates"] = boost::any(*predicates);
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (routePredicates) {
      res["RoutePredicates"] = routePredicates ? boost::any(routePredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeServices) {
      vector<boost::any> temp1;
      for(auto item1:*routeServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteServices"] = boost::any(temp1);
    }
    if (services) {
      res["Services"] = boost::any(*services);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Comment"].type()) {
        ListGatewayRouteResponseBodyDataResultComment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Comment"]));
        comment = make_shared<ListGatewayRouteResponseBodyDataResultComment>(model1);
      }
    }
    if (m.find("DefaultServiceId") != m.end() && !m["DefaultServiceId"].empty()) {
      defaultServiceId = make_shared<long>(boost::any_cast<long>(m["DefaultServiceId"]));
    }
    if (m.find("DefaultServiceName") != m.end() && !m["DefaultServiceName"].empty()) {
      defaultServiceName = make_shared<string>(boost::any_cast<string>(m["DefaultServiceName"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponse") != m.end() && !m["DirectResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["DirectResponse"].type()) {
        ListGatewayRouteResponseBodyDataResultDirectResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DirectResponse"]));
        directResponse = make_shared<ListGatewayRouteResponseBodyDataResultDirectResponse>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdList") != m.end() && !m["DomainIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DomainIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      domainIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<string>(boost::any_cast<string>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      if (typeid(vector<boost::any>) == m["FallbackServices"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultFallbackServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FallbackServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultFallbackServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fallbackServices = make_shared<vector<ListGatewayRouteResponseBodyDataResultFallbackServices>>(expect1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicates = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        ListGatewayRouteResponseBodyDataResultRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<ListGatewayRouteResponseBodyDataResultRedirect>(model1);
      }
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("RoutePredicates") != m.end() && !m["RoutePredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicates"].type()) {
        ListGatewayRouteResponseBodyDataResultRoutePredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicates"]));
        routePredicates = make_shared<ListGatewayRouteResponseBodyDataResultRoutePredicates>(model1);
      }
    }
    if (m.find("RouteServices") != m.end() && !m["RouteServices"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteServices"].type()) {
        vector<ListGatewayRouteResponseBodyDataResultRouteServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResultRouteServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeServices = make_shared<vector<ListGatewayRouteResponseBodyDataResultRouteServices>>(expect1);
      }
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      services = make_shared<string>(boost::any_cast<string>(m["Services"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyDataResult() = default;
};
class ListGatewayRouteResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGatewayRouteResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGatewayRouteResponseBodyData() {}

  explicit ListGatewayRouteResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGatewayRouteResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGatewayRouteResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGatewayRouteResponseBodyData() = default;
};
class ListGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListGatewayRouteResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayRouteResponseBody() {}

  explicit ListGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGatewayRouteResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGatewayRouteResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayRouteResponseBody() = default;
};
class ListGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayRouteResponseBody> body{};

  ListGatewayRouteResponse() {}

  explicit ListGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayRouteResponse() = default;
};
class ListGatewayRouteOnAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> type{};

  ListGatewayRouteOnAuthRequest() {}

  explicit ListGatewayRouteOnAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayRouteOnAuthRequest() = default;
};
class ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates() {}

  explicit ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates() = default;
};
class ListGatewayRouteOnAuthResponseBodyDataRoutePredicates : public Darabonba::Model {
public:
  shared_ptr<ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates> pathPredicates{};

  ListGatewayRouteOnAuthResponseBodyDataRoutePredicates() {}

  explicit ListGatewayRouteOnAuthResponseBodyDataRoutePredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates>(model1);
      }
    }
  }


  virtual ~ListGatewayRouteOnAuthResponseBodyDataRoutePredicates() = default;
};
class ListGatewayRouteOnAuthResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> domainId{};
  shared_ptr<vector<long>> domainIdList{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<ListGatewayRouteOnAuthResponseBodyDataRoutePredicates> routePredicates{};

  ListGatewayRouteOnAuthResponseBodyData() {}

  explicit ListGatewayRouteOnAuthResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdList) {
      res["DomainIdList"] = boost::any(*domainIdList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (routePredicates) {
      res["RoutePredicates"] = routePredicates ? boost::any(routePredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdList") != m.end() && !m["DomainIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DomainIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      domainIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RoutePredicates") != m.end() && !m["RoutePredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicates"].type()) {
        ListGatewayRouteOnAuthResponseBodyDataRoutePredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicates"]));
        routePredicates = make_shared<ListGatewayRouteOnAuthResponseBodyDataRoutePredicates>(model1);
      }
    }
  }


  virtual ~ListGatewayRouteOnAuthResponseBodyData() = default;
};
class ListGatewayRouteOnAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListGatewayRouteOnAuthResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayRouteOnAuthResponseBody() {}

  explicit ListGatewayRouteOnAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListGatewayRouteOnAuthResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayRouteOnAuthResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListGatewayRouteOnAuthResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayRouteOnAuthResponseBody() = default;
};
class ListGatewayRouteOnAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayRouteOnAuthResponseBody> body{};

  ListGatewayRouteOnAuthResponse() {}

  explicit ListGatewayRouteOnAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayRouteOnAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayRouteOnAuthResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayRouteOnAuthResponse() = default;
};
class ListGatewayServiceRequestFilterParams : public Darabonba::Model {
public:
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<string> sourceType{};

  ListGatewayServiceRequestFilterParams() {}

  explicit ListGatewayServiceRequestFilterParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ListGatewayServiceRequestFilterParams() = default;
};
class ListGatewayServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<ListGatewayServiceRequestFilterParams> filterParams{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayServiceRequest() {}

  explicit ListGatewayServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParams) {
      res["FilterParams"] = filterParams ? boost::any(filterParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterParams"].type()) {
        ListGatewayServiceRequestFilterParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterParams"]));
        filterParams = make_shared<ListGatewayServiceRequestFilterParams>(model1);
      }
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayServiceRequest() = default;
};
class ListGatewayServiceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> descSort{};
  shared_ptr<string> filterParamsShrink{};
  shared_ptr<string> orderItem{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGatewayServiceShrinkRequest() {}

  explicit ListGatewayServiceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (descSort) {
      res["DescSort"] = boost::any(*descSort);
    }
    if (filterParamsShrink) {
      res["FilterParams"] = boost::any(*filterParamsShrink);
    }
    if (orderItem) {
      res["OrderItem"] = boost::any(*orderItem);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DescSort") != m.end() && !m["DescSort"].empty()) {
      descSort = make_shared<bool>(boost::any_cast<bool>(m["DescSort"]));
    }
    if (m.find("FilterParams") != m.end() && !m["FilterParams"].empty()) {
      filterParamsShrink = make_shared<string>(boost::any_cast<string>(m["FilterParams"]));
    }
    if (m.find("OrderItem") != m.end() && !m["OrderItem"].empty()) {
      orderItem = make_shared<string>(boost::any_cast<string>(m["OrderItem"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGatewayServiceShrinkRequest() = default;
};
class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> ttl{};

  ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie() {}

  explicit ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<string>(boost::any_cast<string>(m["Ttl"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie() = default;
};
class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig : public Darabonba::Model {
public:
  shared_ptr<string> consistentHashLBType{};
  shared_ptr<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie> httpCookie{};
  shared_ptr<long> minimumRingSize{};
  shared_ptr<string> parameterName{};

  ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig() {}

  explicit ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentHashLBType) {
      res["ConsistentHashLBType"] = boost::any(*consistentHashLBType);
    }
    if (httpCookie) {
      res["HttpCookie"] = httpCookie ? boost::any(httpCookie->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (minimumRingSize) {
      res["MinimumRingSize"] = boost::any(*minimumRingSize);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentHashLBType") != m.end() && !m["ConsistentHashLBType"].empty()) {
      consistentHashLBType = make_shared<string>(boost::any_cast<string>(m["ConsistentHashLBType"]));
    }
    if (m.find("HttpCookie") != m.end() && !m["HttpCookie"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCookie"].type()) {
        ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCookie"]));
        httpCookie = make_shared<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie>(model1);
      }
    }
    if (m.find("MinimumRingSize") != m.end() && !m["MinimumRingSize"].empty()) {
      minimumRingSize = make_shared<long>(boost::any_cast<long>(m["MinimumRingSize"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig() = default;
};
class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings : public Darabonba::Model {
public:
  shared_ptr<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig> consistentHashLBConfig{};
  shared_ptr<string> loadbalancerType{};
  shared_ptr<long> warmupDuration{};

  ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings() {}

  explicit ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentHashLBConfig) {
      res["ConsistentHashLBConfig"] = consistentHashLBConfig ? boost::any(consistentHashLBConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loadbalancerType) {
      res["LoadbalancerType"] = boost::any(*loadbalancerType);
    }
    if (warmupDuration) {
      res["WarmupDuration"] = boost::any(*warmupDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentHashLBConfig") != m.end() && !m["ConsistentHashLBConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsistentHashLBConfig"].type()) {
        ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsistentHashLBConfig"]));
        consistentHashLBConfig = make_shared<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig>(model1);
      }
    }
    if (m.find("LoadbalancerType") != m.end() && !m["LoadbalancerType"].empty()) {
      loadbalancerType = make_shared<string>(boost::any_cast<string>(m["LoadbalancerType"]));
    }
    if (m.find("WarmupDuration") != m.end() && !m["WarmupDuration"].empty()) {
      warmupDuration = make_shared<long>(boost::any_cast<long>(m["WarmupDuration"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings() = default;
};
class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls : public Darabonba::Model {
public:
  shared_ptr<string> caCertContent{};
  shared_ptr<string> caCertId{};
  shared_ptr<string> certId{};
  shared_ptr<string> mode{};
  shared_ptr<string> sni{};
  shared_ptr<vector<string>> subjectAltNames{};

  ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls() {}

  explicit ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCertContent) {
      res["CaCertContent"] = boost::any(*caCertContent);
    }
    if (caCertId) {
      res["CaCertId"] = boost::any(*caCertId);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (sni) {
      res["Sni"] = boost::any(*sni);
    }
    if (subjectAltNames) {
      res["SubjectAltNames"] = boost::any(*subjectAltNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCertContent") != m.end() && !m["CaCertContent"].empty()) {
      caCertContent = make_shared<string>(boost::any_cast<string>(m["CaCertContent"]));
    }
    if (m.find("CaCertId") != m.end() && !m["CaCertId"].empty()) {
      caCertId = make_shared<string>(boost::any_cast<string>(m["CaCertId"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Sni") != m.end() && !m["Sni"].empty()) {
      sni = make_shared<string>(boost::any_cast<string>(m["Sni"]));
    }
    if (m.find("SubjectAltNames") != m.end() && !m["SubjectAltNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubjectAltNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubjectAltNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subjectAltNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls() = default;
};
class ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy : public Darabonba::Model {
public:
  shared_ptr<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings> loadBalancerSettings{};
  shared_ptr<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls> tls{};

  ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy() {}

  explicit ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loadBalancerSettings) {
      res["LoadBalancerSettings"] = loadBalancerSettings ? boost::any(loadBalancerSettings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tls) {
      res["Tls"] = tls ? boost::any(tls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoadBalancerSettings") != m.end() && !m["LoadBalancerSettings"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoadBalancerSettings"].type()) {
        ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoadBalancerSettings"]));
        loadBalancerSettings = make_shared<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings>(model1);
      }
    }
    if (m.find("Tls") != m.end() && !m["Tls"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tls"].type()) {
        ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tls"]));
        tls = make_shared<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls>(model1);
      }
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy() = default;
};
class ListGatewayServiceResponseBodyDataResultHealthCheckInfo : public Darabonba::Model {
public:
  shared_ptr<bool> check{};
  shared_ptr<vector<long>> expectedStatuses{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<string> httpHost{};
  shared_ptr<string> httpPath{};
  shared_ptr<long> interval{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeout{};
  shared_ptr<long> unhealthyThreshold{};

  ListGatewayServiceResponseBodyDataResultHealthCheckInfo() {}

  explicit ListGatewayServiceResponseBodyDataResultHealthCheckInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (expectedStatuses) {
      res["ExpectedStatuses"] = boost::any(*expectedStatuses);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (httpHost) {
      res["HttpHost"] = boost::any(*httpHost);
    }
    if (httpPath) {
      res["HttpPath"] = boost::any(*httpPath);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("ExpectedStatuses") != m.end() && !m["ExpectedStatuses"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExpectedStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpectedStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      expectedStatuses = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("HttpHost") != m.end() && !m["HttpHost"].empty()) {
      httpHost = make_shared<string>(boost::any_cast<string>(m["HttpHost"]));
    }
    if (m.find("HttpPath") != m.end() && !m["HttpPath"].empty()) {
      httpPath = make_shared<string>(boost::any_cast<string>(m["HttpPath"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultHealthCheckInfo() = default;
};
class ListGatewayServiceResponseBodyDataResultVersions : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListGatewayServiceResponseBodyDataResultVersions() {}

  explicit ListGatewayServiceResponseBodyDataResultVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResultVersions() = default;
};
class ListGatewayServiceResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<long> gatewayId{};
  shared_ptr<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy> gatewayTrafficPolicy{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> groupName{};
  shared_ptr<string> healehStatus{};
  shared_ptr<bool> healthCheck{};
  shared_ptr<ListGatewayServiceResponseBodyDataResultHealthCheckInfo> healthCheckInfo{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> metaInfo{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<long>> ports{};
  shared_ptr<string> serviceNameInRegistry{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<string>> unhealthyEndpoints{};
  shared_ptr<vector<ListGatewayServiceResponseBodyDataResultVersions>> versions{};

  ListGatewayServiceResponseBodyDataResult() {}

  explicit ListGatewayServiceResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayTrafficPolicy) {
      res["GatewayTrafficPolicy"] = gatewayTrafficPolicy ? boost::any(gatewayTrafficPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (healehStatus) {
      res["HealehStatus"] = boost::any(*healehStatus);
    }
    if (healthCheck) {
      res["HealthCheck"] = boost::any(*healthCheck);
    }
    if (healthCheckInfo) {
      res["HealthCheckInfo"] = healthCheckInfo ? boost::any(healthCheckInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (metaInfo) {
      res["MetaInfo"] = boost::any(*metaInfo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (serviceNameInRegistry) {
      res["ServiceNameInRegistry"] = boost::any(*serviceNameInRegistry);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (unhealthyEndpoints) {
      res["UnhealthyEndpoints"] = boost::any(*unhealthyEndpoints);
    }
    if (versions) {
      vector<boost::any> temp1;
      for(auto item1:*versions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Versions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayTrafficPolicy") != m.end() && !m["GatewayTrafficPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayTrafficPolicy"].type()) {
        ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayTrafficPolicy"]));
        gatewayTrafficPolicy = make_shared<ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy>(model1);
      }
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HealehStatus") != m.end() && !m["HealehStatus"].empty()) {
      healehStatus = make_shared<string>(boost::any_cast<string>(m["HealehStatus"]));
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      healthCheck = make_shared<bool>(boost::any_cast<bool>(m["HealthCheck"]));
    }
    if (m.find("HealthCheckInfo") != m.end() && !m["HealthCheckInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheckInfo"].type()) {
        ListGatewayServiceResponseBodyDataResultHealthCheckInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheckInfo"]));
        healthCheckInfo = make_shared<ListGatewayServiceResponseBodyDataResultHealthCheckInfo>(model1);
      }
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MetaInfo") != m.end() && !m["MetaInfo"].empty()) {
      metaInfo = make_shared<string>(boost::any_cast<string>(m["MetaInfo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ports"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ports = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ServiceNameInRegistry") != m.end() && !m["ServiceNameInRegistry"].empty()) {
      serviceNameInRegistry = make_shared<string>(boost::any_cast<string>(m["ServiceNameInRegistry"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<long>(boost::any_cast<long>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UnhealthyEndpoints") != m.end() && !m["UnhealthyEndpoints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnhealthyEndpoints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnhealthyEndpoints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unhealthyEndpoints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(vector<boost::any>) == m["Versions"].type()) {
        vector<ListGatewayServiceResponseBodyDataResultVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Versions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayServiceResponseBodyDataResultVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versions = make_shared<vector<ListGatewayServiceResponseBodyDataResultVersions>>(expect1);
      }
    }
  }


  virtual ~ListGatewayServiceResponseBodyDataResult() = default;
};
class ListGatewayServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListGatewayServiceResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  ListGatewayServiceResponseBodyData() {}

  explicit ListGatewayServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListGatewayServiceResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewayServiceResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListGatewayServiceResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListGatewayServiceResponseBodyData() = default;
};
class ListGatewayServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<ListGatewayServiceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewayServiceResponseBody() {}

  explicit ListGatewayServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListGatewayServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListGatewayServiceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewayServiceResponseBody() = default;
};
class ListGatewayServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewayServiceResponseBody> body{};

  ListGatewayServiceResponse() {}

  explicit ListGatewayServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewayServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewayServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewayServiceResponse() = default;
};
class ListGatewaySlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};

  ListGatewaySlbRequest() {}

  explicit ListGatewaySlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~ListGatewaySlbRequest() = default;
};
class ListGatewaySlbResponseBodyDataVServiceList : public Darabonba::Model {
public:
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<string> VServerGroupName{};

  ListGatewaySlbResponseBodyDataVServiceList() {}

  explicit ListGatewaySlbResponseBodyDataVServiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServerGroupName) {
      res["VServerGroupName"] = boost::any(*VServerGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServerGroupName") != m.end() && !m["VServerGroupName"].empty()) {
      VServerGroupName = make_shared<string>(boost::any_cast<string>(m["VServerGroupName"]));
    }
  }


  virtual ~ListGatewaySlbResponseBodyDataVServiceList() = default;
};
class ListGatewaySlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> editEnable{};
  shared_ptr<string> gatewayId{};
  shared_ptr<string> gatewaySlbMode{};
  shared_ptr<string> gatewaySlbStatus{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> httpPort{};
  shared_ptr<long> httpsPort{};
  shared_ptr<string> httpsVServerGroupId{};
  shared_ptr<string> id{};
  shared_ptr<long> serviceWeight{};
  shared_ptr<string> slbId{};
  shared_ptr<string> slbIp{};
  shared_ptr<string> slbPort{};
  shared_ptr<string> slbType{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> type{};
  shared_ptr<string> VServerGroupId{};
  shared_ptr<vector<ListGatewaySlbResponseBodyDataVServiceList>> VServiceList{};
  shared_ptr<string> vsMetaInfo{};

  ListGatewaySlbResponseBodyData() {}

  explicit ListGatewaySlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editEnable) {
      res["EditEnable"] = boost::any(*editEnable);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewaySlbMode) {
      res["GatewaySlbMode"] = boost::any(*gatewaySlbMode);
    }
    if (gatewaySlbStatus) {
      res["GatewaySlbStatus"] = boost::any(*gatewaySlbStatus);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (httpPort) {
      res["HttpPort"] = boost::any(*httpPort);
    }
    if (httpsPort) {
      res["HttpsPort"] = boost::any(*httpsPort);
    }
    if (httpsVServerGroupId) {
      res["HttpsVServerGroupId"] = boost::any(*httpsVServerGroupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (serviceWeight) {
      res["ServiceWeight"] = boost::any(*serviceWeight);
    }
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbIp) {
      res["SlbIp"] = boost::any(*slbIp);
    }
    if (slbPort) {
      res["SlbPort"] = boost::any(*slbPort);
    }
    if (slbType) {
      res["SlbType"] = boost::any(*slbType);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (VServerGroupId) {
      res["VServerGroupId"] = boost::any(*VServerGroupId);
    }
    if (VServiceList) {
      vector<boost::any> temp1;
      for(auto item1:*VServiceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VServiceList"] = boost::any(temp1);
    }
    if (vsMetaInfo) {
      res["VsMetaInfo"] = boost::any(*vsMetaInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditEnable") != m.end() && !m["EditEnable"].empty()) {
      editEnable = make_shared<bool>(boost::any_cast<bool>(m["EditEnable"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<string>(boost::any_cast<string>(m["GatewayId"]));
    }
    if (m.find("GatewaySlbMode") != m.end() && !m["GatewaySlbMode"].empty()) {
      gatewaySlbMode = make_shared<string>(boost::any_cast<string>(m["GatewaySlbMode"]));
    }
    if (m.find("GatewaySlbStatus") != m.end() && !m["GatewaySlbStatus"].empty()) {
      gatewaySlbStatus = make_shared<string>(boost::any_cast<string>(m["GatewaySlbStatus"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("HttpPort") != m.end() && !m["HttpPort"].empty()) {
      httpPort = make_shared<long>(boost::any_cast<long>(m["HttpPort"]));
    }
    if (m.find("HttpsPort") != m.end() && !m["HttpsPort"].empty()) {
      httpsPort = make_shared<long>(boost::any_cast<long>(m["HttpsPort"]));
    }
    if (m.find("HttpsVServerGroupId") != m.end() && !m["HttpsVServerGroupId"].empty()) {
      httpsVServerGroupId = make_shared<string>(boost::any_cast<string>(m["HttpsVServerGroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ServiceWeight") != m.end() && !m["ServiceWeight"].empty()) {
      serviceWeight = make_shared<long>(boost::any_cast<long>(m["ServiceWeight"]));
    }
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbIp") != m.end() && !m["SlbIp"].empty()) {
      slbIp = make_shared<string>(boost::any_cast<string>(m["SlbIp"]));
    }
    if (m.find("SlbPort") != m.end() && !m["SlbPort"].empty()) {
      slbPort = make_shared<string>(boost::any_cast<string>(m["SlbPort"]));
    }
    if (m.find("SlbType") != m.end() && !m["SlbType"].empty()) {
      slbType = make_shared<string>(boost::any_cast<string>(m["SlbType"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VServerGroupId") != m.end() && !m["VServerGroupId"].empty()) {
      VServerGroupId = make_shared<string>(boost::any_cast<string>(m["VServerGroupId"]));
    }
    if (m.find("VServiceList") != m.end() && !m["VServiceList"].empty()) {
      if (typeid(vector<boost::any>) == m["VServiceList"].type()) {
        vector<ListGatewaySlbResponseBodyDataVServiceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VServiceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewaySlbResponseBodyDataVServiceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        VServiceList = make_shared<vector<ListGatewaySlbResponseBodyDataVServiceList>>(expect1);
      }
    }
    if (m.find("VsMetaInfo") != m.end() && !m["VsMetaInfo"].empty()) {
      vsMetaInfo = make_shared<string>(boost::any_cast<string>(m["VsMetaInfo"]));
    }
  }


  virtual ~ListGatewaySlbResponseBodyData() = default;
};
class ListGatewaySlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListGatewaySlbResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListGatewaySlbResponseBody() {}

  explicit ListGatewaySlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListGatewaySlbResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGatewaySlbResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListGatewaySlbResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListGatewaySlbResponseBody() = default;
};
class ListGatewaySlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGatewaySlbResponseBody> body{};

  ListGatewaySlbResponse() {}

  explicit ListGatewaySlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGatewaySlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGatewaySlbResponseBody>(model1);
      }
    }
  }


  virtual ~ListGatewaySlbResponse() = default;
};
class ListInstanceCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ListInstanceCountRequest() {}

  explicit ListInstanceCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListInstanceCountRequest() = default;
};
class ListInstanceCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<long>> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListInstanceCountResponseBody() {}

  explicit ListInstanceCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInstanceCountResponseBody() = default;
};
class ListInstanceCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceCountResponseBody> body{};

  ListInstanceCountResponse() {}

  explicit ListInstanceCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceCountResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceCountResponse() = default;
};
class ListListenersByConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestPars{};

  ListListenersByConfigRequest() {}

  explicit ListListenersByConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListListenersByConfigRequest() = default;
};
class ListListenersByConfigResponseBodyListeners : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> md5{};
  shared_ptr<string> status{};

  ListListenersByConfigResponseBodyListeners() {}

  explicit ListListenersByConfigResponseBodyListeners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListListenersByConfigResponseBodyListeners() = default;
};
class ListListenersByConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<vector<ListListenersByConfigResponseBodyListeners>> listeners{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListListenersByConfigResponseBody() {}

  explicit ListListenersByConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (listeners) {
      vector<boost::any> temp1;
      for(auto item1:*listeners){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Listeners"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      if (typeid(vector<boost::any>) == m["Listeners"].type()) {
        vector<ListListenersByConfigResponseBodyListeners> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Listeners"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersByConfigResponseBodyListeners model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listeners = make_shared<vector<ListListenersByConfigResponseBodyListeners>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListListenersByConfigResponseBody() = default;
};
class ListListenersByConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListListenersByConfigResponseBody> body{};

  ListListenersByConfigResponse() {}

  explicit ListListenersByConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListListenersByConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListListenersByConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListListenersByConfigResponse() = default;
};
class ListListenersByIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestPars{};

  ListListenersByIpRequest() {}

  explicit ListListenersByIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListListenersByIpRequest() = default;
};
class ListListenersByIpResponseBodyListeners : public Darabonba::Model {
public:
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> md5{};

  ListListenersByIpResponseBodyListeners() {}

  explicit ListListenersByIpResponseBodyListeners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
  }


  virtual ~ListListenersByIpResponseBodyListeners() = default;
};
class ListListenersByIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<vector<ListListenersByIpResponseBodyListeners>> listeners{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListListenersByIpResponseBody() {}

  explicit ListListenersByIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (listeners) {
      vector<boost::any> temp1;
      for(auto item1:*listeners){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Listeners"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      if (typeid(vector<boost::any>) == m["Listeners"].type()) {
        vector<ListListenersByIpResponseBodyListeners> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Listeners"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersByIpResponseBodyListeners model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listeners = make_shared<vector<ListListenersByIpResponseBodyListeners>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListListenersByIpResponseBody() = default;
};
class ListListenersByIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListListenersByIpResponseBody> body{};

  ListListenersByIpResponse() {}

  explicit ListListenersByIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListListenersByIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListListenersByIpResponseBody>(model1);
      }
    }
  }


  virtual ~ListListenersByIpResponse() = default;
};
class ListMigrationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestPars{};

  ListMigrationTaskRequest() {}

  explicit ListMigrationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListMigrationTaskRequest() = default;
};
class ListMigrationTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> originInstanceAddress{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<string> originInstanceNamespace{};
  shared_ptr<string> projectDesc{};
  shared_ptr<string> targetClusterName{};
  shared_ptr<string> targetClusterUrl{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> userId{};

  ListMigrationTaskResponseBodyData() {}

  explicit ListMigrationTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originInstanceAddress) {
      res["OriginInstanceAddress"] = boost::any(*originInstanceAddress);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (originInstanceNamespace) {
      res["OriginInstanceNamespace"] = boost::any(*originInstanceNamespace);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    if (targetClusterName) {
      res["TargetClusterName"] = boost::any(*targetClusterName);
    }
    if (targetClusterUrl) {
      res["TargetClusterUrl"] = boost::any(*targetClusterUrl);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OriginInstanceAddress") != m.end() && !m["OriginInstanceAddress"].empty()) {
      originInstanceAddress = make_shared<string>(boost::any_cast<string>(m["OriginInstanceAddress"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("OriginInstanceNamespace") != m.end() && !m["OriginInstanceNamespace"].empty()) {
      originInstanceNamespace = make_shared<string>(boost::any_cast<string>(m["OriginInstanceNamespace"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
    if (m.find("TargetClusterName") != m.end() && !m["TargetClusterName"].empty()) {
      targetClusterName = make_shared<string>(boost::any_cast<string>(m["TargetClusterName"]));
    }
    if (m.find("TargetClusterUrl") != m.end() && !m["TargetClusterUrl"].empty()) {
      targetClusterUrl = make_shared<string>(boost::any_cast<string>(m["TargetClusterUrl"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListMigrationTaskResponseBodyData() = default;
};
class ListMigrationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMigrationTaskResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListMigrationTaskResponseBody() {}

  explicit ListMigrationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMigrationTaskResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMigrationTaskResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMigrationTaskResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMigrationTaskResponseBody() = default;
};
class ListMigrationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMigrationTaskResponseBody> body{};

  ListMigrationTaskResponse() {}

  explicit ListMigrationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMigrationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMigrationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListMigrationTaskResponse() = default;
};
class ListNacosConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> tags{};

  ListNacosConfigsRequest() {}

  explicit ListNacosConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListNacosConfigsRequest() = default;
};
class ListNacosConfigsResponseBodyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> id{};

  ListNacosConfigsResponseBodyConfigurations() {}

  explicit ListNacosConfigsResponseBodyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListNacosConfigsResponseBodyConfigurations() = default;
};
class ListNacosConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListNacosConfigsResponseBodyConfigurations>> configurations{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListNacosConfigsResponseBody() {}

  explicit ListNacosConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (configurations) {
      vector<boost::any> temp1;
      for(auto item1:*configurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configurations"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Configurations") != m.end() && !m["Configurations"].empty()) {
      if (typeid(vector<boost::any>) == m["Configurations"].type()) {
        vector<ListNacosConfigsResponseBodyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNacosConfigsResponseBodyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configurations = make_shared<vector<ListNacosConfigsResponseBodyConfigurations>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNacosConfigsResponseBody() = default;
};
class ListNacosConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNacosConfigsResponseBody> body{};

  ListNacosConfigsResponse() {}

  explicit ListNacosConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNacosConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNacosConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNacosConfigsResponse() = default;
};
class ListNacosHistoryConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  ListNacosHistoryConfigsRequest() {}

  explicit ListNacosHistoryConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~ListNacosHistoryConfigsRequest() = default;
};
class ListNacosHistoryConfigsResponseBodyHistoryItems : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> dataId{};
  shared_ptr<string> group{};
  shared_ptr<long> id{};
  shared_ptr<long> lastModifiedTime{};
  shared_ptr<string> opType{};

  ListNacosHistoryConfigsResponseBodyHistoryItems() {}

  explicit ListNacosHistoryConfigsResponseBodyHistoryItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<long>(boost::any_cast<long>(m["LastModifiedTime"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
  }


  virtual ~ListNacosHistoryConfigsResponseBodyHistoryItems() = default;
};
class ListNacosHistoryConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<vector<ListNacosHistoryConfigsResponseBodyHistoryItems>> historyItems{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListNacosHistoryConfigsResponseBody() {}

  explicit ListNacosHistoryConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (historyItems) {
      vector<boost::any> temp1;
      for(auto item1:*historyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HistoryItems"] = boost::any(temp1);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HistoryItems") != m.end() && !m["HistoryItems"].empty()) {
      if (typeid(vector<boost::any>) == m["HistoryItems"].type()) {
        vector<ListNacosHistoryConfigsResponseBodyHistoryItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HistoryItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNacosHistoryConfigsResponseBodyHistoryItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        historyItems = make_shared<vector<ListNacosHistoryConfigsResponseBodyHistoryItems>>(expect1);
      }
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNacosHistoryConfigsResponseBody() = default;
};
class ListNacosHistoryConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNacosHistoryConfigsResponseBody> body{};

  ListNacosHistoryConfigsResponse() {}

  explicit ListNacosHistoryConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNacosHistoryConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNacosHistoryConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNacosHistoryConfigsResponse() = default;
};
class ListNamingTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> endTs{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestPars{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> startTs{};

  ListNamingTrackRequest() {}

  explicit ListNamingTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~ListNamingTrackRequest() = default;
};
class ListNamingTrackResponseBodyTraces : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceSize{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> pushTime{};
  shared_ptr<string> pushTimeAll{};
  shared_ptr<string> pushTimeNetwork{};
  shared_ptr<string> serverName{};
  shared_ptr<string> slaTime{};

  ListNamingTrackResponseBodyTraces() {}

  explicit ListNamingTrackResponseBodyTraces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceSize) {
      res["InstanceSize"] = boost::any(*instanceSize);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pushTime) {
      res["PushTime"] = boost::any(*pushTime);
    }
    if (pushTimeAll) {
      res["PushTimeAll"] = boost::any(*pushTimeAll);
    }
    if (pushTimeNetwork) {
      res["PushTimeNetwork"] = boost::any(*pushTimeNetwork);
    }
    if (serverName) {
      res["ServerName"] = boost::any(*serverName);
    }
    if (slaTime) {
      res["SlaTime"] = boost::any(*slaTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceSize") != m.end() && !m["InstanceSize"].empty()) {
      instanceSize = make_shared<string>(boost::any_cast<string>(m["InstanceSize"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PushTime") != m.end() && !m["PushTime"].empty()) {
      pushTime = make_shared<string>(boost::any_cast<string>(m["PushTime"]));
    }
    if (m.find("PushTimeAll") != m.end() && !m["PushTimeAll"].empty()) {
      pushTimeAll = make_shared<string>(boost::any_cast<string>(m["PushTimeAll"]));
    }
    if (m.find("PushTimeNetwork") != m.end() && !m["PushTimeNetwork"].empty()) {
      pushTimeNetwork = make_shared<string>(boost::any_cast<string>(m["PushTimeNetwork"]));
    }
    if (m.find("ServerName") != m.end() && !m["ServerName"].empty()) {
      serverName = make_shared<string>(boost::any_cast<string>(m["ServerName"]));
    }
    if (m.find("SlaTime") != m.end() && !m["SlaTime"].empty()) {
      slaTime = make_shared<string>(boost::any_cast<string>(m["SlaTime"]));
    }
  }


  virtual ~ListNamingTrackResponseBodyTraces() = default;
};
class ListNamingTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListNamingTrackResponseBodyTraces>> traces{};

  ListNamingTrackResponseBody() {}

  explicit ListNamingTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (traces) {
      vector<boost::any> temp1;
      for(auto item1:*traces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Traces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Traces") != m.end() && !m["Traces"].empty()) {
      if (typeid(vector<boost::any>) == m["Traces"].type()) {
        vector<ListNamingTrackResponseBodyTraces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Traces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNamingTrackResponseBodyTraces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traces = make_shared<vector<ListNamingTrackResponseBodyTraces>>(expect1);
      }
    }
  }


  virtual ~ListNamingTrackResponseBody() = default;
};
class ListNamingTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNamingTrackResponseBody> body{};

  ListNamingTrackResponse() {}

  explicit ListNamingTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNamingTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNamingTrackResponseBody>(model1);
      }
    }
  }


  virtual ~ListNamingTrackResponse() = default;
};
class ListSSLCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};

  ListSSLCertRequest() {}

  explicit ListSSLCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~ListSSLCertRequest() = default;
};
class ListSSLCertResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> afterDate{};
  shared_ptr<string> algorithm{};
  shared_ptr<string> beforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<string> gmtAfter{};
  shared_ptr<string> gmtBefore{};
  shared_ptr<string> issuer{};
  shared_ptr<string> sans{};

  ListSSLCertResponseBodyData() {}

  explicit ListSSLCertResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterDate) {
      res["AfterDate"] = boost::any(*afterDate);
    }
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (beforeDate) {
      res["BeforeDate"] = boost::any(*beforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (gmtAfter) {
      res["GmtAfter"] = boost::any(*gmtAfter);
    }
    if (gmtBefore) {
      res["GmtBefore"] = boost::any(*gmtBefore);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterDate") != m.end() && !m["AfterDate"].empty()) {
      afterDate = make_shared<string>(boost::any_cast<string>(m["AfterDate"]));
    }
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("BeforeDate") != m.end() && !m["BeforeDate"].empty()) {
      beforeDate = make_shared<string>(boost::any_cast<string>(m["BeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("GmtAfter") != m.end() && !m["GmtAfter"].empty()) {
      gmtAfter = make_shared<string>(boost::any_cast<string>(m["GmtAfter"]));
    }
    if (m.find("GmtBefore") != m.end() && !m["GmtBefore"].empty()) {
      gmtBefore = make_shared<string>(boost::any_cast<string>(m["GmtBefore"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      sans = make_shared<string>(boost::any_cast<string>(m["Sans"]));
    }
  }


  virtual ~ListSSLCertResponseBodyData() = default;
};
class ListSSLCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListSSLCertResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSSLCertResponseBody() {}

  explicit ListSSLCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSSLCertResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSSLCertResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSSLCertResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSSLCertResponseBody() = default;
};
class ListSSLCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSSLCertResponseBody> body{};

  ListSSLCertResponse() {}

  explicit ListSSLCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSSLCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSSLCertResponseBody>(model1);
      }
    }
  }


  virtual ~ListSSLCertResponse() = default;
};
class ListSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};

  ListSecurityGroupRequest() {}

  explicit ListSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~ListSecurityGroupRequest() = default;
};
class ListSecurityGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupName{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<string> vpcId{};

  ListSecurityGroupResponseBodyData() {}

  explicit ListSecurityGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListSecurityGroupResponseBodyData() = default;
};
class ListSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListSecurityGroupResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSecurityGroupResponseBody() {}

  explicit ListSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSecurityGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSecurityGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSecurityGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSecurityGroupResponseBody() = default;
};
class ListSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSecurityGroupResponseBody> body{};

  ListSecurityGroupResponse() {}

  explicit ListSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListSecurityGroupResponse() = default;
};
class ListSecurityGroupRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};

  ListSecurityGroupRuleRequest() {}

  explicit ListSecurityGroupRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~ListSecurityGroupRuleRequest() = default;
};
class ListSecurityGroupRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> authCidrs{};
  shared_ptr<string> description{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> portRange{};
  shared_ptr<string> securityGroupId{};

  ListSecurityGroupRuleResponseBodyData() {}

  explicit ListSecurityGroupRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authCidrs) {
      res["AuthCidrs"] = boost::any(*authCidrs);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (portRange) {
      res["PortRange"] = boost::any(*portRange);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthCidrs") != m.end() && !m["AuthCidrs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthCidrs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthCidrs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authCidrs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("PortRange") != m.end() && !m["PortRange"].empty()) {
      portRange = make_shared<string>(boost::any_cast<string>(m["PortRange"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~ListSecurityGroupRuleResponseBodyData() = default;
};
class ListSecurityGroupRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListSecurityGroupRuleResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSecurityGroupRuleResponseBody() {}

  explicit ListSecurityGroupRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSecurityGroupRuleResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSecurityGroupRuleResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSecurityGroupRuleResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSecurityGroupRuleResponseBody() = default;
};
class ListSecurityGroupRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSecurityGroupRuleResponseBody> body{};

  ListSecurityGroupRuleResponse() {}

  explicit ListSecurityGroupRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSecurityGroupRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSecurityGroupRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListSecurityGroupRuleResponse() = default;
};
class ListServiceSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> source{};

  ListServiceSourceRequest() {}

  explicit ListServiceSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListServiceSourceRequest() = default;
};
class ListServiceSourceResponseBodyDataIngressOptions : public Darabonba::Model {
public:
  shared_ptr<bool> enableIngress{};
  shared_ptr<bool> enableStatus{};
  shared_ptr<string> ingressClass{};
  shared_ptr<string> watchNamespace{};

  ListServiceSourceResponseBodyDataIngressOptions() {}

  explicit ListServiceSourceResponseBodyDataIngressOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIngress) {
      res["EnableIngress"] = boost::any(*enableIngress);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (ingressClass) {
      res["IngressClass"] = boost::any(*ingressClass);
    }
    if (watchNamespace) {
      res["WatchNamespace"] = boost::any(*watchNamespace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIngress") != m.end() && !m["EnableIngress"].empty()) {
      enableIngress = make_shared<bool>(boost::any_cast<bool>(m["EnableIngress"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<bool>(boost::any_cast<bool>(m["EnableStatus"]));
    }
    if (m.find("IngressClass") != m.end() && !m["IngressClass"].empty()) {
      ingressClass = make_shared<string>(boost::any_cast<string>(m["IngressClass"]));
    }
    if (m.find("WatchNamespace") != m.end() && !m["WatchNamespace"].empty()) {
      watchNamespace = make_shared<string>(boost::any_cast<string>(m["WatchNamespace"]));
    }
  }


  virtual ~ListServiceSourceResponseBodyDataIngressOptions() = default;
};
class ListServiceSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<long> bindingWithGateway{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<string>> groupList{};
  shared_ptr<long> id{};
  shared_ptr<ListServiceSourceResponseBodyDataIngressOptions> ingressOptions{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> pathList{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceUniqueId{};
  shared_ptr<string> type{};

  ListServiceSourceResponseBodyData() {}

  explicit ListServiceSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (bindingWithGateway) {
      res["BindingWithGateway"] = boost::any(*bindingWithGateway);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupList) {
      res["GroupList"] = boost::any(*groupList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ingressOptions) {
      res["IngressOptions"] = ingressOptions ? boost::any(ingressOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pathList) {
      res["PathList"] = boost::any(*pathList);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceUniqueId) {
      res["SourceUniqueId"] = boost::any(*sourceUniqueId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("BindingWithGateway") != m.end() && !m["BindingWithGateway"].empty()) {
      bindingWithGateway = make_shared<long>(boost::any_cast<long>(m["BindingWithGateway"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GroupList") != m.end() && !m["GroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IngressOptions") != m.end() && !m["IngressOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressOptions"].type()) {
        ListServiceSourceResponseBodyDataIngressOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressOptions"]));
        ingressOptions = make_shared<ListServiceSourceResponseBodyDataIngressOptions>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PathList") != m.end() && !m["PathList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PathList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PathList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pathList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceUniqueId") != m.end() && !m["SourceUniqueId"].empty()) {
      sourceUniqueId = make_shared<string>(boost::any_cast<string>(m["SourceUniqueId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListServiceSourceResponseBodyData() = default;
};
class ListServiceSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<ListServiceSourceResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListServiceSourceResponseBody() {}

  explicit ListServiceSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListServiceSourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceSourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListServiceSourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListServiceSourceResponseBody() = default;
};
class ListServiceSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceSourceResponseBody> body{};

  ListServiceSourceResponse() {}

  explicit ListServiceSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceSourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceSourceResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListZkTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> endTs{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> requestPars{};
  shared_ptr<bool> reverse{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> startTs{};

  ListZkTrackRequest() {}

  explicit ListZkTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (reverse) {
      res["Reverse"] = boost::any(*reverse);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("Reverse") != m.end() && !m["Reverse"].empty()) {
      reverse = make_shared<bool>(boost::any_cast<bool>(m["Reverse"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~ListZkTrackRequest() = default;
};
class ListZkTrackResponseBodyTraces : public Darabonba::Model {
public:
  shared_ptr<string> acl{};
  shared_ptr<string> dataType{};
  shared_ptr<string> eventType{};
  shared_ptr<bool> finished{};
  shared_ptr<string> logDate{};
  shared_ptr<long> multiSize{};
  shared_ptr<string> opType{};
  shared_ptr<string> path{};
  shared_ptr<string> result{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> traceType{};
  shared_ptr<long> ttl{};
  shared_ptr<bool> watch{};

  ListZkTrackResponseBodyTraces() {}

  explicit ListZkTrackResponseBodyTraces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acl) {
      res["Acl"] = boost::any(*acl);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (finished) {
      res["Finished"] = boost::any(*finished);
    }
    if (logDate) {
      res["LogDate"] = boost::any(*logDate);
    }
    if (multiSize) {
      res["MultiSize"] = boost::any(*multiSize);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceType) {
      res["TraceType"] = boost::any(*traceType);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (watch) {
      res["Watch"] = boost::any(*watch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acl") != m.end() && !m["Acl"].empty()) {
      acl = make_shared<string>(boost::any_cast<string>(m["Acl"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Finished") != m.end() && !m["Finished"].empty()) {
      finished = make_shared<bool>(boost::any_cast<bool>(m["Finished"]));
    }
    if (m.find("LogDate") != m.end() && !m["LogDate"].empty()) {
      logDate = make_shared<string>(boost::any_cast<string>(m["LogDate"]));
    }
    if (m.find("MultiSize") != m.end() && !m["MultiSize"].empty()) {
      multiSize = make_shared<long>(boost::any_cast<long>(m["MultiSize"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("TraceType") != m.end() && !m["TraceType"].empty()) {
      traceType = make_shared<string>(boost::any_cast<string>(m["TraceType"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Watch") != m.end() && !m["Watch"].empty()) {
      watch = make_shared<bool>(boost::any_cast<bool>(m["Watch"]));
    }
  }


  virtual ~ListZkTrackResponseBodyTraces() = default;
};
class ListZkTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListZkTrackResponseBodyTraces>> traces{};

  ListZkTrackResponseBody() {}

  explicit ListZkTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (traces) {
      vector<boost::any> temp1;
      for(auto item1:*traces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Traces"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Traces") != m.end() && !m["Traces"].empty()) {
      if (typeid(vector<boost::any>) == m["Traces"].type()) {
        vector<ListZkTrackResponseBodyTraces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Traces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListZkTrackResponseBodyTraces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        traces = make_shared<vector<ListZkTrackResponseBodyTraces>>(expect1);
      }
    }
  }


  virtual ~ListZkTrackResponseBody() = default;
};
class ListZkTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListZkTrackResponseBody> body{};

  ListZkTrackResponse() {}

  explicit ListZkTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListZkTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListZkTrackResponseBody>(model1);
      }
    }
  }


  virtual ~ListZkTrackResponse() = default;
};
class ListZnodeChildrenRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> path{};

  ListZnodeChildrenRequest() {}

  explicit ListZnodeChildrenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListZnodeChildrenRequest() = default;
};
class ListZnodeChildrenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<bool> dir{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  ListZnodeChildrenResponseBodyData() {}

  explicit ListZnodeChildrenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<bool>(boost::any_cast<bool>(m["Dir"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ListZnodeChildrenResponseBodyData() = default;
};
class ListZnodeChildrenResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListZnodeChildrenResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListZnodeChildrenResponseBody() {}

  explicit ListZnodeChildrenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListZnodeChildrenResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListZnodeChildrenResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListZnodeChildrenResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListZnodeChildrenResponseBody() = default;
};
class ListZnodeChildrenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListZnodeChildrenResponseBody> body{};

  ListZnodeChildrenResponse() {}

  explicit ListZnodeChildrenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListZnodeChildrenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListZnodeChildrenResponseBody>(model1);
      }
    }
  }


  virtual ~ListZnodeChildrenResponse() = default;
};
class ModifyGovernanceKubernetesClusterRequestNamespaceInfos : public Darabonba::Model {
public:
  shared_ptr<string> mseNamespace{};
  shared_ptr<string> name{};

  ModifyGovernanceKubernetesClusterRequestNamespaceInfos() {}

  explicit ModifyGovernanceKubernetesClusterRequestNamespaceInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mseNamespace) {
      res["MseNamespace"] = boost::any(*mseNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MseNamespace") != m.end() && !m["MseNamespace"].empty()) {
      mseNamespace = make_shared<string>(boost::any_cast<string>(m["MseNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyGovernanceKubernetesClusterRequestNamespaceInfos() = default;
};
class ModifyGovernanceKubernetesClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<vector<ModifyGovernanceKubernetesClusterRequestNamespaceInfos>> namespaceInfos{};
  shared_ptr<string> regionId{};

  ModifyGovernanceKubernetesClusterRequest() {}

  explicit ModifyGovernanceKubernetesClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespaceInfos) {
      vector<boost::any> temp1;
      for(auto item1:*namespaceInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NamespaceInfos"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NamespaceInfos") != m.end() && !m["NamespaceInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NamespaceInfos"].type()) {
        vector<ModifyGovernanceKubernetesClusterRequestNamespaceInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NamespaceInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyGovernanceKubernetesClusterRequestNamespaceInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaceInfos = make_shared<vector<ModifyGovernanceKubernetesClusterRequestNamespaceInfos>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyGovernanceKubernetesClusterRequest() = default;
};
class ModifyGovernanceKubernetesClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespaceInfosShrink{};
  shared_ptr<string> regionId{};

  ModifyGovernanceKubernetesClusterShrinkRequest() {}

  explicit ModifyGovernanceKubernetesClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespaceInfosShrink) {
      res["NamespaceInfos"] = boost::any(*namespaceInfosShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("NamespaceInfos") != m.end() && !m["NamespaceInfos"].empty()) {
      namespaceInfosShrink = make_shared<string>(boost::any_cast<string>(m["NamespaceInfos"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyGovernanceKubernetesClusterShrinkRequest() = default;
};
class ModifyGovernanceKubernetesClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyGovernanceKubernetesClusterResponseBody() {}

  explicit ModifyGovernanceKubernetesClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyGovernanceKubernetesClusterResponseBody() = default;
};
class ModifyGovernanceKubernetesClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGovernanceKubernetesClusterResponseBody> body{};

  ModifyGovernanceKubernetesClusterResponse() {}

  explicit ModifyGovernanceKubernetesClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGovernanceKubernetesClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGovernanceKubernetesClusterResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGovernanceKubernetesClusterResponse() = default;
};
class ModifyLosslessRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> aligned{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> delayTime{};
  shared_ptr<bool> enable{};
  shared_ptr<long> funcType{};
  shared_ptr<bool> lossLessDetail{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> notice{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> related{};
  shared_ptr<long> warmupTime{};

  ModifyLosslessRuleRequest() {}

  explicit ModifyLosslessRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (aligned) {
      res["Aligned"] = boost::any(*aligned);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (delayTime) {
      res["DelayTime"] = boost::any(*delayTime);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (funcType) {
      res["FuncType"] = boost::any(*funcType);
    }
    if (lossLessDetail) {
      res["LossLessDetail"] = boost::any(*lossLessDetail);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (warmupTime) {
      res["WarmupTime"] = boost::any(*warmupTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Aligned") != m.end() && !m["Aligned"].empty()) {
      aligned = make_shared<bool>(boost::any_cast<bool>(m["Aligned"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DelayTime") != m.end() && !m["DelayTime"].empty()) {
      delayTime = make_shared<long>(boost::any_cast<long>(m["DelayTime"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FuncType") != m.end() && !m["FuncType"].empty()) {
      funcType = make_shared<long>(boost::any_cast<long>(m["FuncType"]));
    }
    if (m.find("LossLessDetail") != m.end() && !m["LossLessDetail"].empty()) {
      lossLessDetail = make_shared<bool>(boost::any_cast<bool>(m["LossLessDetail"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<bool>(boost::any_cast<bool>(m["Notice"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<bool>(boost::any_cast<bool>(m["Related"]));
    }
    if (m.find("WarmupTime") != m.end() && !m["WarmupTime"].empty()) {
      warmupTime = make_shared<long>(boost::any_cast<long>(m["WarmupTime"]));
    }
  }


  virtual ~ModifyLosslessRuleRequest() = default;
};
class ModifyLosslessRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<boost::any> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyLosslessRuleResponseBody() {}

  explicit ModifyLosslessRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyLosslessRuleResponseBody() = default;
};
class ModifyLosslessRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLosslessRuleResponseBody> body{};

  ModifyLosslessRuleResponse() {}

  explicit ModifyLosslessRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLosslessRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLosslessRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLosslessRuleResponse() = default;
};
class OfflineGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> routeId{};

  OfflineGatewayRouteRequest() {}

  explicit OfflineGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<string>(boost::any_cast<string>(m["RouteId"]));
    }
  }


  virtual ~OfflineGatewayRouteRequest() = default;
};
class OfflineGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OfflineGatewayRouteResponseBody() {}

  explicit OfflineGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OfflineGatewayRouteResponseBody() = default;
};
class OfflineGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OfflineGatewayRouteResponseBody> body{};

  OfflineGatewayRouteResponse() {}

  explicit OfflineGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OfflineGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OfflineGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~OfflineGatewayRouteResponse() = default;
};
class OrderClusterHealthCheckRiskNoticeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> mute{};
  shared_ptr<string> noticeType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> riskCode{};

  OrderClusterHealthCheckRiskNoticeRequest() {}

  explicit OrderClusterHealthCheckRiskNoticeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mute) {
      res["Mute"] = boost::any(*mute);
    }
    if (noticeType) {
      res["NoticeType"] = boost::any(*noticeType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (riskCode) {
      res["RiskCode"] = boost::any(*riskCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mute") != m.end() && !m["Mute"].empty()) {
      mute = make_shared<bool>(boost::any_cast<bool>(m["Mute"]));
    }
    if (m.find("NoticeType") != m.end() && !m["NoticeType"].empty()) {
      noticeType = make_shared<string>(boost::any_cast<string>(m["NoticeType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("RiskCode") != m.end() && !m["RiskCode"].empty()) {
      riskCode = make_shared<string>(boost::any_cast<string>(m["RiskCode"]));
    }
  }


  virtual ~OrderClusterHealthCheckRiskNoticeRequest() = default;
};
class OrderClusterHealthCheckRiskNoticeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OrderClusterHealthCheckRiskNoticeResponseBody() {}

  explicit OrderClusterHealthCheckRiskNoticeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OrderClusterHealthCheckRiskNoticeResponseBody() = default;
};
class OrderClusterHealthCheckRiskNoticeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OrderClusterHealthCheckRiskNoticeResponseBody> body{};

  OrderClusterHealthCheckRiskNoticeResponse() {}

  explicit OrderClusterHealthCheckRiskNoticeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OrderClusterHealthCheckRiskNoticeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OrderClusterHealthCheckRiskNoticeResponseBody>(model1);
      }
    }
  }


  virtual ~OrderClusterHealthCheckRiskNoticeResponse() = default;
};
class PullServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> sourceType{};

  PullServicesRequest() {}

  explicit PullServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~PullServicesRequest() = default;
};
class PullServicesResponseBodyDataServices : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};

  PullServicesResponseBodyDataServices() {}

  explicit PullServicesResponseBodyDataServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~PullServicesResponseBodyDataServices() = default;
};
class PullServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceShowName{};
  shared_ptr<vector<PullServicesResponseBodyDataServices>> services{};

  PullServicesResponseBodyData() {}

  explicit PullServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceShowName) {
      res["NamespaceShowName"] = boost::any(*namespaceShowName);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceShowName") != m.end() && !m["NamespaceShowName"].empty()) {
      namespaceShowName = make_shared<string>(boost::any_cast<string>(m["NamespaceShowName"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<PullServicesResponseBodyDataServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PullServicesResponseBodyDataServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<PullServicesResponseBodyDataServices>>(expect1);
      }
    }
  }


  virtual ~PullServicesResponseBodyData() = default;
};
class PullServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<PullServicesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PullServicesResponseBody() {}

  explicit PullServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<PullServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PullServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<PullServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PullServicesResponseBody() = default;
};
class PullServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PullServicesResponseBody> body{};

  PullServicesResponse() {}

  explicit PullServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PullServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PullServicesResponseBody>(model1);
      }
    }
  }


  virtual ~PullServicesResponse() = default;
};
class PutClusterHealthCheckTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};

  PutClusterHealthCheckTaskRequest() {}

  explicit PutClusterHealthCheckTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~PutClusterHealthCheckTaskRequest() = default;
};
class PutClusterHealthCheckTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutClusterHealthCheckTaskResponseBody() {}

  explicit PutClusterHealthCheckTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutClusterHealthCheckTaskResponseBody() = default;
};
class PutClusterHealthCheckTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutClusterHealthCheckTaskResponseBody> body{};

  PutClusterHealthCheckTaskResponse() {}

  explicit PutClusterHealthCheckTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutClusterHealthCheckTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutClusterHealthCheckTaskResponseBody>(model1);
      }
    }
  }


  virtual ~PutClusterHealthCheckTaskResponse() = default;
};
class QueryAllSwimmingLaneRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> namespace_{};

  QueryAllSwimmingLaneRequest() {}

  explicit QueryAllSwimmingLaneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~QueryAllSwimmingLaneRequest() = default;
};
class QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems() {}

  explicit QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems() = default;
};
class QueryAllSwimmingLaneResponseBodyDataEntryRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> path{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems>> restItems{};

  QueryAllSwimmingLaneResponseBodyDataEntryRules() {}

  explicit QueryAllSwimmingLaneResponseBodyDataEntryRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (paths) {
      res["paths"] = boost::any(*paths);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("paths") != m.end() && !m["paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("restItems") != m.end() && !m["restItems"].empty()) {
      if (typeid(vector<boost::any>) == m["restItems"].type()) {
        vector<QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems>>(expect1);
      }
    }
  }


  virtual ~QueryAllSwimmingLaneResponseBodyDataEntryRules() = default;
};
class QueryAllSwimmingLaneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAllSwimmingLaneResponseBodyDataEntryRules>> entryRules{};
  shared_ptr<string> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> messageQueueFilterSide{};
  shared_ptr<bool> messageQueueGrayEnable{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> recordCanaryDetail{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tag{};
  shared_ptr<string> userId{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};

  QueryAllSwimmingLaneResponseBodyData() {}

  explicit QueryAllSwimmingLaneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entryRules) {
      vector<boost::any> temp1;
      for(auto item1:*entryRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntryRules"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (messageQueueFilterSide) {
      res["MessageQueueFilterSide"] = boost::any(*messageQueueFilterSide);
    }
    if (messageQueueGrayEnable) {
      res["MessageQueueGrayEnable"] = boost::any(*messageQueueGrayEnable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (recordCanaryDetail) {
      res["RecordCanaryDetail"] = boost::any(*recordCanaryDetail);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (enableRules) {
      res["enableRules"] = boost::any(*enableRules);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntryRules") != m.end() && !m["EntryRules"].empty()) {
      if (typeid(vector<boost::any>) == m["EntryRules"].type()) {
        vector<QueryAllSwimmingLaneResponseBodyDataEntryRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntryRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllSwimmingLaneResponseBodyDataEntryRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entryRules = make_shared<vector<QueryAllSwimmingLaneResponseBodyDataEntryRules>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MessageQueueFilterSide") != m.end() && !m["MessageQueueFilterSide"].empty()) {
      messageQueueFilterSide = make_shared<string>(boost::any_cast<string>(m["MessageQueueFilterSide"]));
    }
    if (m.find("MessageQueueGrayEnable") != m.end() && !m["MessageQueueGrayEnable"].empty()) {
      messageQueueGrayEnable = make_shared<bool>(boost::any_cast<bool>(m["MessageQueueGrayEnable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RecordCanaryDetail") != m.end() && !m["RecordCanaryDetail"].empty()) {
      recordCanaryDetail = make_shared<bool>(boost::any_cast<bool>(m["RecordCanaryDetail"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("enableRules") != m.end() && !m["enableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["enableRules"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
  }


  virtual ~QueryAllSwimmingLaneResponseBodyData() = default;
};
class QueryAllSwimmingLaneResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryAllSwimmingLaneResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryAllSwimmingLaneResponseBody() {}

  explicit QueryAllSwimmingLaneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryAllSwimmingLaneResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllSwimmingLaneResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryAllSwimmingLaneResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAllSwimmingLaneResponseBody() = default;
};
class QueryAllSwimmingLaneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAllSwimmingLaneResponseBody> body{};

  QueryAllSwimmingLaneResponse() {}

  explicit QueryAllSwimmingLaneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAllSwimmingLaneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAllSwimmingLaneResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAllSwimmingLaneResponse() = default;
};
class QueryAllSwimmingLaneGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> namespace_{};

  QueryAllSwimmingLaneGroupRequest() {}

  explicit QueryAllSwimmingLaneGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~QueryAllSwimmingLaneGroupRequest() = default;
};
class QueryAllSwimmingLaneGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};
  shared_ptr<string> entryApp{};
  shared_ptr<long> id{};
  shared_ptr<string> messageQueueFilterSide{};
  shared_ptr<bool> messageQueueGrayEnable{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<bool> recordCanaryDetail{};
  shared_ptr<string> region{};
  shared_ptr<string> userId{};

  QueryAllSwimmingLaneGroupResponseBodyData() {}

  explicit QueryAllSwimmingLaneGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (entryApp) {
      res["EntryApp"] = boost::any(*entryApp);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (messageQueueFilterSide) {
      res["MessageQueueFilterSide"] = boost::any(*messageQueueFilterSide);
    }
    if (messageQueueGrayEnable) {
      res["MessageQueueGrayEnable"] = boost::any(*messageQueueGrayEnable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (recordCanaryDetail) {
      res["RecordCanaryDetail"] = boost::any(*recordCanaryDetail);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("EntryApp") != m.end() && !m["EntryApp"].empty()) {
      entryApp = make_shared<string>(boost::any_cast<string>(m["EntryApp"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MessageQueueFilterSide") != m.end() && !m["MessageQueueFilterSide"].empty()) {
      messageQueueFilterSide = make_shared<string>(boost::any_cast<string>(m["MessageQueueFilterSide"]));
    }
    if (m.find("MessageQueueGrayEnable") != m.end() && !m["MessageQueueGrayEnable"].empty()) {
      messageQueueGrayEnable = make_shared<bool>(boost::any_cast<bool>(m["MessageQueueGrayEnable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RecordCanaryDetail") != m.end() && !m["RecordCanaryDetail"].empty()) {
      recordCanaryDetail = make_shared<bool>(boost::any_cast<bool>(m["RecordCanaryDetail"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~QueryAllSwimmingLaneGroupResponseBodyData() = default;
};
class QueryAllSwimmingLaneGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<QueryAllSwimmingLaneGroupResponseBodyData>> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryAllSwimmingLaneGroupResponseBody() {}

  explicit QueryAllSwimmingLaneGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryAllSwimmingLaneGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryAllSwimmingLaneGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryAllSwimmingLaneGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAllSwimmingLaneGroupResponseBody() = default;
};
class QueryAllSwimmingLaneGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAllSwimmingLaneGroupResponseBody> body{};

  QueryAllSwimmingLaneGroupResponse() {}

  explicit QueryAllSwimmingLaneGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAllSwimmingLaneGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAllSwimmingLaneGroupResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAllSwimmingLaneGroupResponse() = default;
};
class QueryBusinessLocationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  QueryBusinessLocationsRequest() {}

  explicit QueryBusinessLocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~QueryBusinessLocationsRequest() = default;
};
class QueryBusinessLocationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> cnName{};
  shared_ptr<string> description{};
  shared_ptr<string> districtCnName{};
  shared_ptr<string> districtEnName{};
  shared_ptr<string> districtId{};
  shared_ptr<long> districtOrdering{};
  shared_ptr<string> districtShowName{};
  shared_ptr<string> enDescription{};
  shared_ptr<string> enName{};
  shared_ptr<string> name{};
  shared_ptr<long> ordering{};
  shared_ptr<string> showName{};
  shared_ptr<string> type{};

  QueryBusinessLocationsResponseBodyData() {}

  explicit QueryBusinessLocationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnName) {
      res["CnName"] = boost::any(*cnName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (districtCnName) {
      res["DistrictCnName"] = boost::any(*districtCnName);
    }
    if (districtEnName) {
      res["DistrictEnName"] = boost::any(*districtEnName);
    }
    if (districtId) {
      res["DistrictId"] = boost::any(*districtId);
    }
    if (districtOrdering) {
      res["DistrictOrdering"] = boost::any(*districtOrdering);
    }
    if (districtShowName) {
      res["DistrictShowName"] = boost::any(*districtShowName);
    }
    if (enDescription) {
      res["EnDescription"] = boost::any(*enDescription);
    }
    if (enName) {
      res["EnName"] = boost::any(*enName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ordering) {
      res["Ordering"] = boost::any(*ordering);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnName") != m.end() && !m["CnName"].empty()) {
      cnName = make_shared<string>(boost::any_cast<string>(m["CnName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DistrictCnName") != m.end() && !m["DistrictCnName"].empty()) {
      districtCnName = make_shared<string>(boost::any_cast<string>(m["DistrictCnName"]));
    }
    if (m.find("DistrictEnName") != m.end() && !m["DistrictEnName"].empty()) {
      districtEnName = make_shared<string>(boost::any_cast<string>(m["DistrictEnName"]));
    }
    if (m.find("DistrictId") != m.end() && !m["DistrictId"].empty()) {
      districtId = make_shared<string>(boost::any_cast<string>(m["DistrictId"]));
    }
    if (m.find("DistrictOrdering") != m.end() && !m["DistrictOrdering"].empty()) {
      districtOrdering = make_shared<long>(boost::any_cast<long>(m["DistrictOrdering"]));
    }
    if (m.find("DistrictShowName") != m.end() && !m["DistrictShowName"].empty()) {
      districtShowName = make_shared<string>(boost::any_cast<string>(m["DistrictShowName"]));
    }
    if (m.find("EnDescription") != m.end() && !m["EnDescription"].empty()) {
      enDescription = make_shared<string>(boost::any_cast<string>(m["EnDescription"]));
    }
    if (m.find("EnName") != m.end() && !m["EnName"].empty()) {
      enName = make_shared<string>(boost::any_cast<string>(m["EnName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ordering") != m.end() && !m["Ordering"].empty()) {
      ordering = make_shared<long>(boost::any_cast<long>(m["Ordering"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryBusinessLocationsResponseBodyData() = default;
};
class QueryBusinessLocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryBusinessLocationsResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  QueryBusinessLocationsResponseBody() {}

  explicit QueryBusinessLocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryBusinessLocationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryBusinessLocationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryBusinessLocationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~QueryBusinessLocationsResponseBody() = default;
};
class QueryBusinessLocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBusinessLocationsResponseBody> body{};

  QueryBusinessLocationsResponse() {}

  explicit QueryBusinessLocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBusinessLocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBusinessLocationsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBusinessLocationsResponse() = default;
};
class QueryClusterDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> aclSwitch{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};

  QueryClusterDetailRequest() {}

  explicit QueryClusterDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (aclSwitch) {
      res["AclSwitch"] = boost::any(*aclSwitch);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AclSwitch") != m.end() && !m["AclSwitch"].empty()) {
      aclSwitch = make_shared<bool>(boost::any_cast<bool>(m["AclSwitch"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~QueryClusterDetailRequest() = default;
};
class QueryClusterDetailResponseBodyDataInstanceModels : public Darabonba::Model {
public:
  shared_ptr<string> creationTimestamp{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> podName{};
  shared_ptr<string> role{};
  shared_ptr<string> singleTunnelVip{};
  shared_ptr<string> zone{};

  QueryClusterDetailResponseBodyDataInstanceModels() {}

  explicit QueryClusterDetailResponseBodyDataInstanceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (singleTunnelVip) {
      res["SingleTunnelVip"] = boost::any(*singleTunnelVip);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SingleTunnelVip") != m.end() && !m["SingleTunnelVip"].empty()) {
      singleTunnelVip = make_shared<string>(boost::any_cast<string>(m["SingleTunnelVip"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~QueryClusterDetailResponseBodyDataInstanceModels() = default;
};
class QueryClusterDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryList{};
  shared_ptr<string> aclId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterAliasName{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterSpecification{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> connectionType{};
  shared_ptr<long> cpu{};
  shared_ptr<string> createTime{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<string> diskType{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> initCostTime{};
  shared_ptr<string> initStatus{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<QueryClusterDetailResponseBodyDataInstanceModels>> instanceModels{};
  shared_ptr<string> internetAddress{};
  shared_ptr<string> internetDomain{};
  shared_ptr<string> internetPort{};
  shared_ptr<string> intranetAddress{};
  shared_ptr<string> intranetDomain{};
  shared_ptr<string> intranetPort{};
  shared_ptr<long> memoryCapacity{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> netType{};
  shared_ptr<string> orderClusterVersion{};
  shared_ptr<string> payInfo{};
  shared_ptr<string> pubNetworkFlow{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  QueryClusterDetailResponseBodyData() {}

  explicit QueryClusterDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryList) {
      res["AclEntryList"] = boost::any(*aclEntryList);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterAliasName) {
      res["ClusterAliasName"] = boost::any(*clusterAliasName);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterSpecification) {
      res["ClusterSpecification"] = boost::any(*clusterSpecification);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["ClusterVersion"] = boost::any(*clusterVersion);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (initCostTime) {
      res["InitCostTime"] = boost::any(*initCostTime);
    }
    if (initStatus) {
      res["InitStatus"] = boost::any(*initStatus);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceModels) {
      vector<boost::any> temp1;
      for(auto item1:*instanceModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceModels"] = boost::any(temp1);
    }
    if (internetAddress) {
      res["InternetAddress"] = boost::any(*internetAddress);
    }
    if (internetDomain) {
      res["InternetDomain"] = boost::any(*internetDomain);
    }
    if (internetPort) {
      res["InternetPort"] = boost::any(*internetPort);
    }
    if (intranetAddress) {
      res["IntranetAddress"] = boost::any(*intranetAddress);
    }
    if (intranetDomain) {
      res["IntranetDomain"] = boost::any(*intranetDomain);
    }
    if (intranetPort) {
      res["IntranetPort"] = boost::any(*intranetPort);
    }
    if (memoryCapacity) {
      res["MemoryCapacity"] = boost::any(*memoryCapacity);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (orderClusterVersion) {
      res["OrderClusterVersion"] = boost::any(*orderClusterVersion);
    }
    if (payInfo) {
      res["PayInfo"] = boost::any(*payInfo);
    }
    if (pubNetworkFlow) {
      res["PubNetworkFlow"] = boost::any(*pubNetworkFlow);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryList") != m.end() && !m["AclEntryList"].empty()) {
      aclEntryList = make_shared<string>(boost::any_cast<string>(m["AclEntryList"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterAliasName") != m.end() && !m["ClusterAliasName"].empty()) {
      clusterAliasName = make_shared<string>(boost::any_cast<string>(m["ClusterAliasName"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterSpecification") != m.end() && !m["ClusterSpecification"].empty()) {
      clusterSpecification = make_shared<string>(boost::any_cast<string>(m["ClusterSpecification"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ClusterVersion") != m.end() && !m["ClusterVersion"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["ClusterVersion"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InitCostTime") != m.end() && !m["InitCostTime"].empty()) {
      initCostTime = make_shared<long>(boost::any_cast<long>(m["InitCostTime"]));
    }
    if (m.find("InitStatus") != m.end() && !m["InitStatus"].empty()) {
      initStatus = make_shared<string>(boost::any_cast<string>(m["InitStatus"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceModels") != m.end() && !m["InstanceModels"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceModels"].type()) {
        vector<QueryClusterDetailResponseBodyDataInstanceModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryClusterDetailResponseBodyDataInstanceModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceModels = make_shared<vector<QueryClusterDetailResponseBodyDataInstanceModels>>(expect1);
      }
    }
    if (m.find("InternetAddress") != m.end() && !m["InternetAddress"].empty()) {
      internetAddress = make_shared<string>(boost::any_cast<string>(m["InternetAddress"]));
    }
    if (m.find("InternetDomain") != m.end() && !m["InternetDomain"].empty()) {
      internetDomain = make_shared<string>(boost::any_cast<string>(m["InternetDomain"]));
    }
    if (m.find("InternetPort") != m.end() && !m["InternetPort"].empty()) {
      internetPort = make_shared<string>(boost::any_cast<string>(m["InternetPort"]));
    }
    if (m.find("IntranetAddress") != m.end() && !m["IntranetAddress"].empty()) {
      intranetAddress = make_shared<string>(boost::any_cast<string>(m["IntranetAddress"]));
    }
    if (m.find("IntranetDomain") != m.end() && !m["IntranetDomain"].empty()) {
      intranetDomain = make_shared<string>(boost::any_cast<string>(m["IntranetDomain"]));
    }
    if (m.find("IntranetPort") != m.end() && !m["IntranetPort"].empty()) {
      intranetPort = make_shared<string>(boost::any_cast<string>(m["IntranetPort"]));
    }
    if (m.find("MemoryCapacity") != m.end() && !m["MemoryCapacity"].empty()) {
      memoryCapacity = make_shared<long>(boost::any_cast<long>(m["MemoryCapacity"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("OrderClusterVersion") != m.end() && !m["OrderClusterVersion"].empty()) {
      orderClusterVersion = make_shared<string>(boost::any_cast<string>(m["OrderClusterVersion"]));
    }
    if (m.find("PayInfo") != m.end() && !m["PayInfo"].empty()) {
      payInfo = make_shared<string>(boost::any_cast<string>(m["PayInfo"]));
    }
    if (m.find("PubNetworkFlow") != m.end() && !m["PubNetworkFlow"].empty()) {
      pubNetworkFlow = make_shared<string>(boost::any_cast<string>(m["PubNetworkFlow"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~QueryClusterDetailResponseBodyData() = default;
};
class QueryClusterDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryClusterDetailResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryClusterDetailResponseBody() {}

  explicit QueryClusterDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryClusterDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryClusterDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryClusterDetailResponseBody() = default;
};
class QueryClusterDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryClusterDetailResponseBody> body{};

  QueryClusterDetailResponse() {}

  explicit QueryClusterDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryClusterDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryClusterDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryClusterDetailResponse() = default;
};
class QueryClusterDiskSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterType{};

  QueryClusterDiskSpecificationRequest() {}

  explicit QueryClusterDiskSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
  }


  virtual ~QueryClusterDiskSpecificationRequest() = default;
};
class QueryClusterDiskSpecificationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<long> step{};

  QueryClusterDiskSpecificationResponseBodyData() {}

  explicit QueryClusterDiskSpecificationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~QueryClusterDiskSpecificationResponseBodyData() = default;
};
class QueryClusterDiskSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<QueryClusterDiskSpecificationResponseBodyData> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryClusterDiskSpecificationResponseBody() {}

  explicit QueryClusterDiskSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryClusterDiskSpecificationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryClusterDiskSpecificationResponseBodyData>(model1);
      }
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryClusterDiskSpecificationResponseBody() = default;
};
class QueryClusterDiskSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryClusterDiskSpecificationResponseBody> body{};

  QueryClusterDiskSpecificationResponse() {}

  explicit QueryClusterDiskSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryClusterDiskSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryClusterDiskSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~QueryClusterDiskSpecificationResponse() = default;
};
class QueryClusterInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> aclSwitch{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  QueryClusterInfoRequest() {}

  explicit QueryClusterInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (aclSwitch) {
      res["AclSwitch"] = boost::any(*aclSwitch);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AclSwitch") != m.end() && !m["AclSwitch"].empty()) {
      aclSwitch = make_shared<bool>(boost::any_cast<bool>(m["AclSwitch"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~QueryClusterInfoRequest() = default;
};
class QueryClusterInfoResponseBodyDataInstanceModels : public Darabonba::Model {
public:
  shared_ptr<string> creationTimestamp{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> podName{};
  shared_ptr<string> role{};
  shared_ptr<string> singleTunnelVip{};
  shared_ptr<string> zone{};

  QueryClusterInfoResponseBodyDataInstanceModels() {}

  explicit QueryClusterInfoResponseBodyDataInstanceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (singleTunnelVip) {
      res["SingleTunnelVip"] = boost::any(*singleTunnelVip);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SingleTunnelVip") != m.end() && !m["SingleTunnelVip"].empty()) {
      singleTunnelVip = make_shared<string>(boost::any_cast<string>(m["SingleTunnelVip"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~QueryClusterInfoResponseBodyDataInstanceModels() = default;
};
class QueryClusterInfoResponseBodyDataMaintenancePeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  QueryClusterInfoResponseBodyDataMaintenancePeriod() {}

  explicit QueryClusterInfoResponseBodyDataMaintenancePeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~QueryClusterInfoResponseBodyDataMaintenancePeriod() = default;
};
class QueryClusterInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryList{};
  shared_ptr<string> aclId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clusterAliasName{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterSpecification{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> clusterVersion{};
  shared_ptr<string> connectionType{};
  shared_ptr<long> cpu{};
  shared_ptr<string> createTime{};
  shared_ptr<long> diskCapacity{};
  shared_ptr<string> diskType{};
  shared_ptr<string> eipInstanceId{};
  shared_ptr<string> endDate{};
  shared_ptr<vector<string>> expectZones{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> initCostTime{};
  shared_ptr<string> initStatus{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<QueryClusterInfoResponseBodyDataInstanceModels>> instanceModels{};
  shared_ptr<string> internetAddress{};
  shared_ptr<string> internetDomain{};
  shared_ptr<string> internetPort{};
  shared_ptr<string> intranetAddress{};
  shared_ptr<string> intranetDomain{};
  shared_ptr<string> intranetPort{};
  shared_ptr<QueryClusterInfoResponseBodyDataMaintenancePeriod> maintenancePeriod{};
  shared_ptr<long> memoryCapacity{};
  shared_ptr<string> mseVersion{};
  shared_ptr<string> netType{};
  shared_ptr<string> payInfo{};
  shared_ptr<string> pubNetworkFlow{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> securityGroupType{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  QueryClusterInfoResponseBodyData() {}

  explicit QueryClusterInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryList) {
      res["AclEntryList"] = boost::any(*aclEntryList);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clusterAliasName) {
      res["ClusterAliasName"] = boost::any(*clusterAliasName);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterSpecification) {
      res["ClusterSpecification"] = boost::any(*clusterSpecification);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (clusterVersion) {
      res["ClusterVersion"] = boost::any(*clusterVersion);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (diskCapacity) {
      res["DiskCapacity"] = boost::any(*diskCapacity);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (eipInstanceId) {
      res["EipInstanceId"] = boost::any(*eipInstanceId);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (expectZones) {
      res["ExpectZones"] = boost::any(*expectZones);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (initCostTime) {
      res["InitCostTime"] = boost::any(*initCostTime);
    }
    if (initStatus) {
      res["InitStatus"] = boost::any(*initStatus);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceModels) {
      vector<boost::any> temp1;
      for(auto item1:*instanceModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceModels"] = boost::any(temp1);
    }
    if (internetAddress) {
      res["InternetAddress"] = boost::any(*internetAddress);
    }
    if (internetDomain) {
      res["InternetDomain"] = boost::any(*internetDomain);
    }
    if (internetPort) {
      res["InternetPort"] = boost::any(*internetPort);
    }
    if (intranetAddress) {
      res["IntranetAddress"] = boost::any(*intranetAddress);
    }
    if (intranetDomain) {
      res["IntranetDomain"] = boost::any(*intranetDomain);
    }
    if (intranetPort) {
      res["IntranetPort"] = boost::any(*intranetPort);
    }
    if (maintenancePeriod) {
      res["MaintenancePeriod"] = maintenancePeriod ? boost::any(maintenancePeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memoryCapacity) {
      res["MemoryCapacity"] = boost::any(*memoryCapacity);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (payInfo) {
      res["PayInfo"] = boost::any(*payInfo);
    }
    if (pubNetworkFlow) {
      res["PubNetworkFlow"] = boost::any(*pubNetworkFlow);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (securityGroupType) {
      res["SecurityGroupType"] = boost::any(*securityGroupType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryList") != m.end() && !m["AclEntryList"].empty()) {
      aclEntryList = make_shared<string>(boost::any_cast<string>(m["AclEntryList"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClusterAliasName") != m.end() && !m["ClusterAliasName"].empty()) {
      clusterAliasName = make_shared<string>(boost::any_cast<string>(m["ClusterAliasName"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterSpecification") != m.end() && !m["ClusterSpecification"].empty()) {
      clusterSpecification = make_shared<string>(boost::any_cast<string>(m["ClusterSpecification"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("ClusterVersion") != m.end() && !m["ClusterVersion"].empty()) {
      clusterVersion = make_shared<string>(boost::any_cast<string>(m["ClusterVersion"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DiskCapacity") != m.end() && !m["DiskCapacity"].empty()) {
      diskCapacity = make_shared<long>(boost::any_cast<long>(m["DiskCapacity"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EipInstanceId") != m.end() && !m["EipInstanceId"].empty()) {
      eipInstanceId = make_shared<string>(boost::any_cast<string>(m["EipInstanceId"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("ExpectZones") != m.end() && !m["ExpectZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExpectZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpectZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      expectZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InitCostTime") != m.end() && !m["InitCostTime"].empty()) {
      initCostTime = make_shared<long>(boost::any_cast<long>(m["InitCostTime"]));
    }
    if (m.find("InitStatus") != m.end() && !m["InitStatus"].empty()) {
      initStatus = make_shared<string>(boost::any_cast<string>(m["InitStatus"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceModels") != m.end() && !m["InstanceModels"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceModels"].type()) {
        vector<QueryClusterInfoResponseBodyDataInstanceModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryClusterInfoResponseBodyDataInstanceModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceModels = make_shared<vector<QueryClusterInfoResponseBodyDataInstanceModels>>(expect1);
      }
    }
    if (m.find("InternetAddress") != m.end() && !m["InternetAddress"].empty()) {
      internetAddress = make_shared<string>(boost::any_cast<string>(m["InternetAddress"]));
    }
    if (m.find("InternetDomain") != m.end() && !m["InternetDomain"].empty()) {
      internetDomain = make_shared<string>(boost::any_cast<string>(m["InternetDomain"]));
    }
    if (m.find("InternetPort") != m.end() && !m["InternetPort"].empty()) {
      internetPort = make_shared<string>(boost::any_cast<string>(m["InternetPort"]));
    }
    if (m.find("IntranetAddress") != m.end() && !m["IntranetAddress"].empty()) {
      intranetAddress = make_shared<string>(boost::any_cast<string>(m["IntranetAddress"]));
    }
    if (m.find("IntranetDomain") != m.end() && !m["IntranetDomain"].empty()) {
      intranetDomain = make_shared<string>(boost::any_cast<string>(m["IntranetDomain"]));
    }
    if (m.find("IntranetPort") != m.end() && !m["IntranetPort"].empty()) {
      intranetPort = make_shared<string>(boost::any_cast<string>(m["IntranetPort"]));
    }
    if (m.find("MaintenancePeriod") != m.end() && !m["MaintenancePeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaintenancePeriod"].type()) {
        QueryClusterInfoResponseBodyDataMaintenancePeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaintenancePeriod"]));
        maintenancePeriod = make_shared<QueryClusterInfoResponseBodyDataMaintenancePeriod>(model1);
      }
    }
    if (m.find("MemoryCapacity") != m.end() && !m["MemoryCapacity"].empty()) {
      memoryCapacity = make_shared<long>(boost::any_cast<long>(m["MemoryCapacity"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<string>(boost::any_cast<string>(m["NetType"]));
    }
    if (m.find("PayInfo") != m.end() && !m["PayInfo"].empty()) {
      payInfo = make_shared<string>(boost::any_cast<string>(m["PayInfo"]));
    }
    if (m.find("PubNetworkFlow") != m.end() && !m["PubNetworkFlow"].empty()) {
      pubNetworkFlow = make_shared<string>(boost::any_cast<string>(m["PubNetworkFlow"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("SecurityGroupType") != m.end() && !m["SecurityGroupType"].empty()) {
      securityGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityGroupType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~QueryClusterInfoResponseBodyData() = default;
};
class QueryClusterInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryClusterInfoResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryClusterInfoResponseBody() {}

  explicit QueryClusterInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryClusterInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryClusterInfoResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryClusterInfoResponseBody() = default;
};
class QueryClusterInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryClusterInfoResponseBody> body{};

  QueryClusterInfoResponse() {}

  explicit QueryClusterInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryClusterInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryClusterInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryClusterInfoResponse() = default;
};
class QueryClusterSpecificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> connectType{};
  shared_ptr<string> mseVersion{};

  QueryClusterSpecificationRequest() {}

  explicit QueryClusterSpecificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (connectType) {
      res["ConnectType"] = boost::any(*connectType);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConnectType") != m.end() && !m["ConnectType"].empty()) {
      connectType = make_shared<string>(boost::any_cast<string>(m["ConnectType"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
  }


  virtual ~QueryClusterSpecificationRequest() = default;
};
class QueryClusterSpecificationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterSpecificationName{};
  shared_ptr<string> cpuCapacity{};
  shared_ptr<string> memoryCapacity{};

  QueryClusterSpecificationResponseBodyData() {}

  explicit QueryClusterSpecificationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterSpecificationName) {
      res["ClusterSpecificationName"] = boost::any(*clusterSpecificationName);
    }
    if (cpuCapacity) {
      res["CpuCapacity"] = boost::any(*cpuCapacity);
    }
    if (memoryCapacity) {
      res["MemoryCapacity"] = boost::any(*memoryCapacity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterSpecificationName") != m.end() && !m["ClusterSpecificationName"].empty()) {
      clusterSpecificationName = make_shared<string>(boost::any_cast<string>(m["ClusterSpecificationName"]));
    }
    if (m.find("CpuCapacity") != m.end() && !m["CpuCapacity"].empty()) {
      cpuCapacity = make_shared<string>(boost::any_cast<string>(m["CpuCapacity"]));
    }
    if (m.find("MemoryCapacity") != m.end() && !m["MemoryCapacity"].empty()) {
      memoryCapacity = make_shared<string>(boost::any_cast<string>(m["MemoryCapacity"]));
    }
  }


  virtual ~QueryClusterSpecificationResponseBodyData() = default;
};
class QueryClusterSpecificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<QueryClusterSpecificationResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryClusterSpecificationResponseBody() {}

  explicit QueryClusterSpecificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryClusterSpecificationResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryClusterSpecificationResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryClusterSpecificationResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryClusterSpecificationResponseBody() = default;
};
class QueryClusterSpecificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryClusterSpecificationResponseBody> body{};

  QueryClusterSpecificationResponse() {}

  explicit QueryClusterSpecificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryClusterSpecificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryClusterSpecificationResponseBody>(model1);
      }
    }
  }


  virtual ~QueryClusterSpecificationResponse() = default;
};
class QueryConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> configType{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needRunningConf{};
  shared_ptr<string> requestPars{};

  QueryConfigRequest() {}

  explicit QueryConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needRunningConf) {
      res["NeedRunningConf"] = boost::any(*needRunningConf);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedRunningConf") != m.end() && !m["NeedRunningConf"].empty()) {
      needRunningConf = make_shared<bool>(boost::any_cast<bool>(m["NeedRunningConf"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~QueryConfigRequest() = default;
};
class QueryConfigResponseBodyDataNacosRunningEnv : public Darabonba::Model {
public:
  shared_ptr<bool> emptyProtect{};

  QueryConfigResponseBodyDataNacosRunningEnv() {}

  explicit QueryConfigResponseBodyDataNacosRunningEnv(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (emptyProtect) {
      res["emptyProtect"] = boost::any(*emptyProtect);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("emptyProtect") != m.end() && !m["emptyProtect"].empty()) {
      emptyProtect = make_shared<bool>(boost::any_cast<bool>(m["emptyProtect"]));
    }
  }


  virtual ~QueryConfigResponseBodyDataNacosRunningEnv() = default;
};
class QueryConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> autopurgePurgeInterval{};
  shared_ptr<string> autopurgeSnapRetainCount{};
  shared_ptr<string> clusterName{};
  shared_ptr<bool> configAuthEnabled{};
  shared_ptr<bool> configAuthSupported{};
  shared_ptr<long> configContentLimit{};
  shared_ptr<bool> configSecretEnabled{};
  shared_ptr<bool> configSecretSupported{};
  shared_ptr<bool> consoleUIEnabled{};
  shared_ptr<bool> eurekaSupported{};
  shared_ptr<bool> extendedTypesEnable{};
  shared_ptr<string> initLimit{};
  shared_ptr<string> juteMaxbuffer{};
  shared_ptr<string> jvmFlagsCustom{};
  shared_ptr<bool> MCPEnabled{};
  shared_ptr<bool> MCPSupported{};
  shared_ptr<string> maxClientCnxns{};
  shared_ptr<string> maxSessionTimeout{};
  shared_ptr<string> minSessionTimeout{};
  shared_ptr<QueryConfigResponseBodyDataNacosRunningEnv> nacosRunningEnv{};
  shared_ptr<bool> namingAuthEnabled{};
  shared_ptr<bool> namingAuthSupported{};
  shared_ptr<bool> namingCreateServiceSupported{};
  shared_ptr<bool> openSuperAcl{};
  shared_ptr<string> passWord{};
  shared_ptr<bool> restartFlag{};
  shared_ptr<string> snapshotCount{};
  shared_ptr<string> syncLimit{};
  shared_ptr<bool> TLSEnabled{};
  shared_ptr<string> tickTime{};
  shared_ptr<string> userName{};

  QueryConfigResponseBodyData() {}

  explicit QueryConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autopurgePurgeInterval) {
      res["AutopurgePurgeInterval"] = boost::any(*autopurgePurgeInterval);
    }
    if (autopurgeSnapRetainCount) {
      res["AutopurgeSnapRetainCount"] = boost::any(*autopurgeSnapRetainCount);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (configAuthEnabled) {
      res["ConfigAuthEnabled"] = boost::any(*configAuthEnabled);
    }
    if (configAuthSupported) {
      res["ConfigAuthSupported"] = boost::any(*configAuthSupported);
    }
    if (configContentLimit) {
      res["ConfigContentLimit"] = boost::any(*configContentLimit);
    }
    if (configSecretEnabled) {
      res["ConfigSecretEnabled"] = boost::any(*configSecretEnabled);
    }
    if (configSecretSupported) {
      res["ConfigSecretSupported"] = boost::any(*configSecretSupported);
    }
    if (consoleUIEnabled) {
      res["ConsoleUIEnabled"] = boost::any(*consoleUIEnabled);
    }
    if (eurekaSupported) {
      res["EurekaSupported"] = boost::any(*eurekaSupported);
    }
    if (extendedTypesEnable) {
      res["ExtendedTypesEnable"] = boost::any(*extendedTypesEnable);
    }
    if (initLimit) {
      res["InitLimit"] = boost::any(*initLimit);
    }
    if (juteMaxbuffer) {
      res["JuteMaxbuffer"] = boost::any(*juteMaxbuffer);
    }
    if (jvmFlagsCustom) {
      res["JvmFlagsCustom"] = boost::any(*jvmFlagsCustom);
    }
    if (MCPEnabled) {
      res["MCPEnabled"] = boost::any(*MCPEnabled);
    }
    if (MCPSupported) {
      res["MCPSupported"] = boost::any(*MCPSupported);
    }
    if (maxClientCnxns) {
      res["MaxClientCnxns"] = boost::any(*maxClientCnxns);
    }
    if (maxSessionTimeout) {
      res["MaxSessionTimeout"] = boost::any(*maxSessionTimeout);
    }
    if (minSessionTimeout) {
      res["MinSessionTimeout"] = boost::any(*minSessionTimeout);
    }
    if (nacosRunningEnv) {
      res["NacosRunningEnv"] = nacosRunningEnv ? boost::any(nacosRunningEnv->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (namingAuthEnabled) {
      res["NamingAuthEnabled"] = boost::any(*namingAuthEnabled);
    }
    if (namingAuthSupported) {
      res["NamingAuthSupported"] = boost::any(*namingAuthSupported);
    }
    if (namingCreateServiceSupported) {
      res["NamingCreateServiceSupported"] = boost::any(*namingCreateServiceSupported);
    }
    if (openSuperAcl) {
      res["OpenSuperAcl"] = boost::any(*openSuperAcl);
    }
    if (passWord) {
      res["PassWord"] = boost::any(*passWord);
    }
    if (restartFlag) {
      res["RestartFlag"] = boost::any(*restartFlag);
    }
    if (snapshotCount) {
      res["SnapshotCount"] = boost::any(*snapshotCount);
    }
    if (syncLimit) {
      res["SyncLimit"] = boost::any(*syncLimit);
    }
    if (TLSEnabled) {
      res["TLSEnabled"] = boost::any(*TLSEnabled);
    }
    if (tickTime) {
      res["TickTime"] = boost::any(*tickTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutopurgePurgeInterval") != m.end() && !m["AutopurgePurgeInterval"].empty()) {
      autopurgePurgeInterval = make_shared<string>(boost::any_cast<string>(m["AutopurgePurgeInterval"]));
    }
    if (m.find("AutopurgeSnapRetainCount") != m.end() && !m["AutopurgeSnapRetainCount"].empty()) {
      autopurgeSnapRetainCount = make_shared<string>(boost::any_cast<string>(m["AutopurgeSnapRetainCount"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ConfigAuthEnabled") != m.end() && !m["ConfigAuthEnabled"].empty()) {
      configAuthEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConfigAuthEnabled"]));
    }
    if (m.find("ConfigAuthSupported") != m.end() && !m["ConfigAuthSupported"].empty()) {
      configAuthSupported = make_shared<bool>(boost::any_cast<bool>(m["ConfigAuthSupported"]));
    }
    if (m.find("ConfigContentLimit") != m.end() && !m["ConfigContentLimit"].empty()) {
      configContentLimit = make_shared<long>(boost::any_cast<long>(m["ConfigContentLimit"]));
    }
    if (m.find("ConfigSecretEnabled") != m.end() && !m["ConfigSecretEnabled"].empty()) {
      configSecretEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConfigSecretEnabled"]));
    }
    if (m.find("ConfigSecretSupported") != m.end() && !m["ConfigSecretSupported"].empty()) {
      configSecretSupported = make_shared<bool>(boost::any_cast<bool>(m["ConfigSecretSupported"]));
    }
    if (m.find("ConsoleUIEnabled") != m.end() && !m["ConsoleUIEnabled"].empty()) {
      consoleUIEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConsoleUIEnabled"]));
    }
    if (m.find("EurekaSupported") != m.end() && !m["EurekaSupported"].empty()) {
      eurekaSupported = make_shared<bool>(boost::any_cast<bool>(m["EurekaSupported"]));
    }
    if (m.find("ExtendedTypesEnable") != m.end() && !m["ExtendedTypesEnable"].empty()) {
      extendedTypesEnable = make_shared<bool>(boost::any_cast<bool>(m["ExtendedTypesEnable"]));
    }
    if (m.find("InitLimit") != m.end() && !m["InitLimit"].empty()) {
      initLimit = make_shared<string>(boost::any_cast<string>(m["InitLimit"]));
    }
    if (m.find("JuteMaxbuffer") != m.end() && !m["JuteMaxbuffer"].empty()) {
      juteMaxbuffer = make_shared<string>(boost::any_cast<string>(m["JuteMaxbuffer"]));
    }
    if (m.find("JvmFlagsCustom") != m.end() && !m["JvmFlagsCustom"].empty()) {
      jvmFlagsCustom = make_shared<string>(boost::any_cast<string>(m["JvmFlagsCustom"]));
    }
    if (m.find("MCPEnabled") != m.end() && !m["MCPEnabled"].empty()) {
      MCPEnabled = make_shared<bool>(boost::any_cast<bool>(m["MCPEnabled"]));
    }
    if (m.find("MCPSupported") != m.end() && !m["MCPSupported"].empty()) {
      MCPSupported = make_shared<bool>(boost::any_cast<bool>(m["MCPSupported"]));
    }
    if (m.find("MaxClientCnxns") != m.end() && !m["MaxClientCnxns"].empty()) {
      maxClientCnxns = make_shared<string>(boost::any_cast<string>(m["MaxClientCnxns"]));
    }
    if (m.find("MaxSessionTimeout") != m.end() && !m["MaxSessionTimeout"].empty()) {
      maxSessionTimeout = make_shared<string>(boost::any_cast<string>(m["MaxSessionTimeout"]));
    }
    if (m.find("MinSessionTimeout") != m.end() && !m["MinSessionTimeout"].empty()) {
      minSessionTimeout = make_shared<string>(boost::any_cast<string>(m["MinSessionTimeout"]));
    }
    if (m.find("NacosRunningEnv") != m.end() && !m["NacosRunningEnv"].empty()) {
      if (typeid(map<string, boost::any>) == m["NacosRunningEnv"].type()) {
        QueryConfigResponseBodyDataNacosRunningEnv model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NacosRunningEnv"]));
        nacosRunningEnv = make_shared<QueryConfigResponseBodyDataNacosRunningEnv>(model1);
      }
    }
    if (m.find("NamingAuthEnabled") != m.end() && !m["NamingAuthEnabled"].empty()) {
      namingAuthEnabled = make_shared<bool>(boost::any_cast<bool>(m["NamingAuthEnabled"]));
    }
    if (m.find("NamingAuthSupported") != m.end() && !m["NamingAuthSupported"].empty()) {
      namingAuthSupported = make_shared<bool>(boost::any_cast<bool>(m["NamingAuthSupported"]));
    }
    if (m.find("NamingCreateServiceSupported") != m.end() && !m["NamingCreateServiceSupported"].empty()) {
      namingCreateServiceSupported = make_shared<bool>(boost::any_cast<bool>(m["NamingCreateServiceSupported"]));
    }
    if (m.find("OpenSuperAcl") != m.end() && !m["OpenSuperAcl"].empty()) {
      openSuperAcl = make_shared<bool>(boost::any_cast<bool>(m["OpenSuperAcl"]));
    }
    if (m.find("PassWord") != m.end() && !m["PassWord"].empty()) {
      passWord = make_shared<string>(boost::any_cast<string>(m["PassWord"]));
    }
    if (m.find("RestartFlag") != m.end() && !m["RestartFlag"].empty()) {
      restartFlag = make_shared<bool>(boost::any_cast<bool>(m["RestartFlag"]));
    }
    if (m.find("SnapshotCount") != m.end() && !m["SnapshotCount"].empty()) {
      snapshotCount = make_shared<string>(boost::any_cast<string>(m["SnapshotCount"]));
    }
    if (m.find("SyncLimit") != m.end() && !m["SyncLimit"].empty()) {
      syncLimit = make_shared<string>(boost::any_cast<string>(m["SyncLimit"]));
    }
    if (m.find("TLSEnabled") != m.end() && !m["TLSEnabled"].empty()) {
      TLSEnabled = make_shared<bool>(boost::any_cast<bool>(m["TLSEnabled"]));
    }
    if (m.find("TickTime") != m.end() && !m["TickTime"].empty()) {
      tickTime = make_shared<string>(boost::any_cast<string>(m["TickTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~QueryConfigResponseBodyData() = default;
};
class QueryConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<QueryConfigResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryConfigResponseBody() {}

  explicit QueryConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryConfigResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryConfigResponseBody() = default;
};
class QueryConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConfigResponseBody> body{};

  QueryConfigResponse() {}

  explicit QueryConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConfigResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConfigResponse() = default;
};
class QueryGatewayRegionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  QueryGatewayRegionRequest() {}

  explicit QueryGatewayRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~QueryGatewayRegionRequest() = default;
};
class QueryGatewayRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryGatewayRegionResponseBody() {}

  explicit QueryGatewayRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryGatewayRegionResponseBody() = default;
};
class QueryGatewayRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGatewayRegionResponseBody> body{};

  QueryGatewayRegionResponse() {}

  explicit QueryGatewayRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGatewayRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGatewayRegionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGatewayRegionResponse() = default;
};
class QueryGatewayTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  QueryGatewayTypeRequest() {}

  explicit QueryGatewayTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~QueryGatewayTypeRequest() = default;
};
class QueryGatewayTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryGatewayTypeResponseBody() {}

  explicit QueryGatewayTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryGatewayTypeResponseBody() = default;
};
class QueryGatewayTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGatewayTypeResponseBody> body{};

  QueryGatewayTypeResponse() {}

  explicit QueryGatewayTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGatewayTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGatewayTypeResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGatewayTypeResponse() = default;
};
class QueryGovernanceKubernetesClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryGovernanceKubernetesClusterRequest() {}

  explicit QueryGovernanceKubernetesClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryGovernanceKubernetesClusterRequest() = default;
};
class QueryGovernanceKubernetesClusterResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> k8sVersion{};
  shared_ptr<string> namespaceInfos{};
  shared_ptr<string> pilotStartTime{};
  shared_ptr<string> region{};

  QueryGovernanceKubernetesClusterResponseBodyDataResult() {}

  explicit QueryGovernanceKubernetesClusterResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (k8sVersion) {
      res["K8sVersion"] = boost::any(*k8sVersion);
    }
    if (namespaceInfos) {
      res["NamespaceInfos"] = boost::any(*namespaceInfos);
    }
    if (pilotStartTime) {
      res["PilotStartTime"] = boost::any(*pilotStartTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("K8sVersion") != m.end() && !m["K8sVersion"].empty()) {
      k8sVersion = make_shared<string>(boost::any_cast<string>(m["K8sVersion"]));
    }
    if (m.find("NamespaceInfos") != m.end() && !m["NamespaceInfos"].empty()) {
      namespaceInfos = make_shared<string>(boost::any_cast<string>(m["NamespaceInfos"]));
    }
    if (m.find("PilotStartTime") != m.end() && !m["PilotStartTime"].empty()) {
      pilotStartTime = make_shared<string>(boost::any_cast<string>(m["PilotStartTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~QueryGovernanceKubernetesClusterResponseBodyDataResult() = default;
};
class QueryGovernanceKubernetesClusterResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<QueryGovernanceKubernetesClusterResponseBodyDataResult>> result{};
  shared_ptr<long> totalSize{};

  QueryGovernanceKubernetesClusterResponseBodyData() {}

  explicit QueryGovernanceKubernetesClusterResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryGovernanceKubernetesClusterResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryGovernanceKubernetesClusterResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryGovernanceKubernetesClusterResponseBodyDataResult>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~QueryGovernanceKubernetesClusterResponseBodyData() = default;
};
class QueryGovernanceKubernetesClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryGovernanceKubernetesClusterResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryGovernanceKubernetesClusterResponseBody() {}

  explicit QueryGovernanceKubernetesClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryGovernanceKubernetesClusterResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryGovernanceKubernetesClusterResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryGovernanceKubernetesClusterResponseBody() = default;
};
class QueryGovernanceKubernetesClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGovernanceKubernetesClusterResponseBody> body{};

  QueryGovernanceKubernetesClusterResponse() {}

  explicit QueryGovernanceKubernetesClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGovernanceKubernetesClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGovernanceKubernetesClusterResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGovernanceKubernetesClusterResponse() = default;
};
class QueryInstancesInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestPars{};

  QueryInstancesInfoRequest() {}

  explicit QueryInstancesInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~QueryInstancesInfoRequest() = default;
};
class QueryInstancesInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clientPort{};
  shared_ptr<string> creationTimestamp{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> podName{};
  shared_ptr<string> role{};
  shared_ptr<string> singleTunnelVip{};
  shared_ptr<string> zone{};
  shared_ptr<bool> zoneDistributed{};

  QueryInstancesInfoResponseBodyData() {}

  explicit QueryInstancesInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (creationTimestamp) {
      res["CreationTimestamp"] = boost::any(*creationTimestamp);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (singleTunnelVip) {
      res["SingleTunnelVip"] = boost::any(*singleTunnelVip);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    if (zoneDistributed) {
      res["ZoneDistributed"] = boost::any(*zoneDistributed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<string>(boost::any_cast<string>(m["ClientPort"]));
    }
    if (m.find("CreationTimestamp") != m.end() && !m["CreationTimestamp"].empty()) {
      creationTimestamp = make_shared<string>(boost::any_cast<string>(m["CreationTimestamp"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SingleTunnelVip") != m.end() && !m["SingleTunnelVip"].empty()) {
      singleTunnelVip = make_shared<string>(boost::any_cast<string>(m["SingleTunnelVip"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
    if (m.find("ZoneDistributed") != m.end() && !m["ZoneDistributed"].empty()) {
      zoneDistributed = make_shared<bool>(boost::any_cast<bool>(m["ZoneDistributed"]));
    }
  }


  virtual ~QueryInstancesInfoResponseBodyData() = default;
};
class QueryInstancesInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryInstancesInfoResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryInstancesInfoResponseBody() {}

  explicit QueryInstancesInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryInstancesInfoResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryInstancesInfoResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryInstancesInfoResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryInstancesInfoResponseBody() = default;
};
class QueryInstancesInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryInstancesInfoResponseBody> body{};

  QueryInstancesInfoResponse() {}

  explicit QueryInstancesInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryInstancesInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryInstancesInfoResponseBody>(model1);
      }
    }
  }


  virtual ~QueryInstancesInfoResponse() = default;
};
class QueryMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitorType{};
  shared_ptr<string> requestPars{};
  shared_ptr<long> startTime{};
  shared_ptr<long> step{};

  QueryMonitorRequest() {}

  explicit QueryMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitorType) {
      res["MonitorType"] = boost::any(*monitorType);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitorType") != m.end() && !m["MonitorType"].empty()) {
      monitorType = make_shared<string>(boost::any_cast<string>(m["MonitorType"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~QueryMonitorRequest() = default;
};
class QueryMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterNamePrefix{};
  shared_ptr<string> podName{};
  shared_ptr<vector<map<string, boost::any>>> values{};

  QueryMonitorResponseBodyData() {}

  explicit QueryMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterNamePrefix) {
      res["clusterNamePrefix"] = boost::any(*clusterNamePrefix);
    }
    if (podName) {
      res["podName"] = boost::any(*podName);
    }
    if (values) {
      res["values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterNamePrefix") != m.end() && !m["clusterNamePrefix"].empty()) {
      clusterNamePrefix = make_shared<string>(boost::any_cast<string>(m["clusterNamePrefix"]));
    }
    if (m.find("podName") != m.end() && !m["podName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["podName"]));
    }
    if (m.find("values") != m.end() && !m["values"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["values"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      values = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryMonitorResponseBodyData() = default;
};
class QueryMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMonitorResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryMonitorResponseBody() {}

  explicit QueryMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryMonitorResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMonitorResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryMonitorResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryMonitorResponseBody() = default;
};
class QueryMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMonitorResponseBody> body{};

  QueryMonitorResponse() {}

  explicit QueryMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMonitorResponse() = default;
};
class QueryNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> name{};
  shared_ptr<string> region{};

  QueryNamespaceRequest() {}

  explicit QueryNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~QueryNamespaceRequest() = default;
};
class QueryNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};

  QueryNamespaceResponseBodyData() {}

  explicit QueryNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~QueryNamespaceResponseBodyData() = default;
};
class QueryNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryNamespaceResponseBodyData>> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryNamespaceResponseBody() {}

  explicit QueryNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryNamespaceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryNamespaceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryNamespaceResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryNamespaceResponseBody() = default;
};
class QueryNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryNamespaceResponseBody> body{};

  QueryNamespaceResponse() {}

  explicit QueryNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~QueryNamespaceResponse() = default;
};
class QuerySlbSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  QuerySlbSpecRequest() {}

  explicit QuerySlbSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~QuerySlbSpecRequest() = default;
};
class QuerySlbSpecResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> maxConnection{};
  shared_ptr<string> name{};
  shared_ptr<string> newConnectionPerSecond{};
  shared_ptr<string> qps{};
  shared_ptr<string> spec{};

  QuerySlbSpecResponseBodyData() {}

  explicit QuerySlbSpecResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxConnection) {
      res["MaxConnection"] = boost::any(*maxConnection);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newConnectionPerSecond) {
      res["NewConnectionPerSecond"] = boost::any(*newConnectionPerSecond);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxConnection") != m.end() && !m["MaxConnection"].empty()) {
      maxConnection = make_shared<string>(boost::any_cast<string>(m["MaxConnection"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewConnectionPerSecond") != m.end() && !m["NewConnectionPerSecond"].empty()) {
      newConnectionPerSecond = make_shared<string>(boost::any_cast<string>(m["NewConnectionPerSecond"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~QuerySlbSpecResponseBodyData() = default;
};
class QuerySlbSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<QuerySlbSpecResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySlbSpecResponseBody() {}

  explicit QuerySlbSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QuerySlbSpecResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySlbSpecResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QuerySlbSpecResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySlbSpecResponseBody() = default;
};
class QuerySlbSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySlbSpecResponseBody> body{};

  QuerySlbSpecResponse() {}

  explicit QuerySlbSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySlbSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySlbSpecResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySlbSpecResponse() = default;
};
class QuerySwimmingLaneByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> laneId{};
  shared_ptr<string> namespace_{};

  QuerySwimmingLaneByIdRequest() {}

  explicit QuerySwimmingLaneByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (laneId) {
      res["LaneId"] = boost::any(*laneId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("LaneId") != m.end() && !m["LaneId"].empty()) {
      laneId = make_shared<long>(boost::any_cast<long>(m["LaneId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~QuerySwimmingLaneByIdRequest() = default;
};
class QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems : public Darabonba::Model {
public:
  shared_ptr<string> cond{};
  shared_ptr<string> datum{};
  shared_ptr<long> divisor{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> operator_{};
  shared_ptr<long> rate{};
  shared_ptr<long> remainder{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems() {}

  explicit QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cond) {
      res["cond"] = boost::any(*cond);
    }
    if (datum) {
      res["datum"] = boost::any(*datum);
    }
    if (divisor) {
      res["divisor"] = boost::any(*divisor);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (nameList) {
      res["nameList"] = boost::any(*nameList);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (rate) {
      res["rate"] = boost::any(*rate);
    }
    if (remainder) {
      res["remainder"] = boost::any(*remainder);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cond") != m.end() && !m["cond"].empty()) {
      cond = make_shared<string>(boost::any_cast<string>(m["cond"]));
    }
    if (m.find("datum") != m.end() && !m["datum"].empty()) {
      datum = make_shared<string>(boost::any_cast<string>(m["datum"]));
    }
    if (m.find("divisor") != m.end() && !m["divisor"].empty()) {
      divisor = make_shared<long>(boost::any_cast<long>(m["divisor"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("nameList") != m.end() && !m["nameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("rate") != m.end() && !m["rate"].empty()) {
      rate = make_shared<long>(boost::any_cast<long>(m["rate"]));
    }
    if (m.find("remainder") != m.end() && !m["remainder"].empty()) {
      remainder = make_shared<long>(boost::any_cast<long>(m["remainder"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems() = default;
};
class QuerySwimmingLaneByIdResponseBodyDataEntryRules : public Darabonba::Model {
public:
  shared_ptr<string> condition{};
  shared_ptr<string> path{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<vector<QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems>> restItems{};

  QuerySwimmingLaneByIdResponseBodyDataEntryRules() {}

  explicit QuerySwimmingLaneByIdResponseBodyDataEntryRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (condition) {
      res["condition"] = boost::any(*condition);
    }
    if (path) {
      res["path"] = boost::any(*path);
    }
    if (paths) {
      res["paths"] = boost::any(*paths);
    }
    if (restItems) {
      vector<boost::any> temp1;
      for(auto item1:*restItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restItems"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("condition") != m.end() && !m["condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["condition"]));
    }
    if (m.find("path") != m.end() && !m["path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["path"]));
    }
    if (m.find("paths") != m.end() && !m["paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("restItems") != m.end() && !m["restItems"].empty()) {
      if (typeid(vector<boost::any>) == m["restItems"].type()) {
        vector<QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restItems = make_shared<vector<QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems>>(expect1);
      }
    }
  }


  virtual ~QuerySwimmingLaneByIdResponseBodyDataEntryRules() = default;
};
class QuerySwimmingLaneByIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableRules{};
  shared_ptr<string> entryRule{};
  shared_ptr<vector<QuerySwimmingLaneByIdResponseBodyDataEntryRules>> entryRules{};
  shared_ptr<string> gatewaySwimmingLaneRouteJson{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};

  QuerySwimmingLaneByIdResponseBodyData() {}

  explicit QuerySwimmingLaneByIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (enableRules) {
      res["enableRules"] = boost::any(*enableRules);
    }
    if (entryRule) {
      res["entryRule"] = boost::any(*entryRule);
    }
    if (entryRules) {
      vector<boost::any> temp1;
      for(auto item1:*entryRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["entryRules"] = boost::any(temp1);
    }
    if (gatewaySwimmingLaneRouteJson) {
      res["gatewaySwimmingLaneRouteJson"] = boost::any(*gatewaySwimmingLaneRouteJson);
    }
    if (gmtCreate) {
      res["gmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["gmtModified"] = boost::any(*gmtModified);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tag) {
      res["tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("enableRules") != m.end() && !m["enableRules"].empty()) {
      enableRules = make_shared<bool>(boost::any_cast<bool>(m["enableRules"]));
    }
    if (m.find("entryRule") != m.end() && !m["entryRule"].empty()) {
      entryRule = make_shared<string>(boost::any_cast<string>(m["entryRule"]));
    }
    if (m.find("entryRules") != m.end() && !m["entryRules"].empty()) {
      if (typeid(vector<boost::any>) == m["entryRules"].type()) {
        vector<QuerySwimmingLaneByIdResponseBodyDataEntryRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["entryRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySwimmingLaneByIdResponseBodyDataEntryRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entryRules = make_shared<vector<QuerySwimmingLaneByIdResponseBodyDataEntryRules>>(expect1);
      }
    }
    if (m.find("gatewaySwimmingLaneRouteJson") != m.end() && !m["gatewaySwimmingLaneRouteJson"].empty()) {
      gatewaySwimmingLaneRouteJson = make_shared<string>(boost::any_cast<string>(m["gatewaySwimmingLaneRouteJson"]));
    }
    if (m.find("gmtCreate") != m.end() && !m["gmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["gmtCreate"]));
    }
    if (m.find("gmtModified") != m.end() && !m["gmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["gmtModified"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["groupId"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
    if (m.find("tag") != m.end() && !m["tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["tag"]));
    }
  }


  virtual ~QuerySwimmingLaneByIdResponseBodyData() = default;
};
class QuerySwimmingLaneByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<QuerySwimmingLaneByIdResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QuerySwimmingLaneByIdResponseBody() {}

  explicit QuerySwimmingLaneByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QuerySwimmingLaneByIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QuerySwimmingLaneByIdResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QuerySwimmingLaneByIdResponseBody() = default;
};
class QuerySwimmingLaneByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySwimmingLaneByIdResponseBody> body{};

  QuerySwimmingLaneByIdResponse() {}

  explicit QuerySwimmingLaneByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySwimmingLaneByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySwimmingLaneByIdResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySwimmingLaneByIdResponse() = default;
};
class QueryZnodeDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> path{};
  shared_ptr<string> requestPars{};

  QueryZnodeDetailRequest() {}

  explicit QueryZnodeDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~QueryZnodeDetailRequest() = default;
};
class QueryZnodeDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<bool> dir{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};

  QueryZnodeDetailResponseBodyData() {}

  explicit QueryZnodeDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<bool>(boost::any_cast<bool>(m["Dir"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~QueryZnodeDetailResponseBodyData() = default;
};
class QueryZnodeDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryZnodeDetailResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  QueryZnodeDetailResponseBody() {}

  explicit QueryZnodeDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryZnodeDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryZnodeDetailResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~QueryZnodeDetailResponseBody() = default;
};
class QueryZnodeDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryZnodeDetailResponseBody> body{};

  QueryZnodeDetailResponse() {}

  explicit QueryZnodeDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryZnodeDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryZnodeDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryZnodeDetailResponse() = default;
};
class RemoveApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};

  RemoveApplicationRequest() {}

  explicit RemoveApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~RemoveApplicationRequest() = default;
};
class RemoveApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveApplicationResponseBody() {}

  explicit RemoveApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveApplicationResponseBody() = default;
};
class RemoveApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveApplicationResponseBody> body{};

  RemoveApplicationResponse() {}

  explicit RemoveApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApplicationResponse() = default;
};
class RemoveAuthPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> policyId{};

  RemoveAuthPolicyRequest() {}

  explicit RemoveAuthPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~RemoveAuthPolicyRequest() = default;
};
class RemoveAuthPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveAuthPolicyResponseBody() {}

  explicit RemoveAuthPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveAuthPolicyResponseBody() = default;
};
class RemoveAuthPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAuthPolicyResponseBody> body{};

  RemoveAuthPolicyResponse() {}

  explicit RemoveAuthPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAuthPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAuthPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAuthPolicyResponse() = default;
};
class RestartClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> podNameList{};
  shared_ptr<string> requestPars{};

  RestartClusterRequest() {}

  explicit RestartClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (podNameList) {
      res["PodNameList"] = boost::any(*podNameList);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PodNameList") != m.end() && !m["PodNameList"].empty()) {
      podNameList = make_shared<string>(boost::any_cast<string>(m["PodNameList"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~RestartClusterRequest() = default;
};
class RestartClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RestartClusterResponseBody() {}

  explicit RestartClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RestartClusterResponseBody() = default;
};
class RestartClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartClusterResponseBody> body{};

  RestartClusterResponse() {}

  explicit RestartClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartClusterResponseBody>(model1);
      }
    }
  }


  virtual ~RestartClusterResponse() = default;
};
class RetryClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestPars{};

  RetryClusterRequest() {}

  explicit RetryClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~RetryClusterRequest() = default;
};
class RetryClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RetryClusterResponseBody() {}

  explicit RetryClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RetryClusterResponseBody() = default;
};
class RetryClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryClusterResponseBody> body{};

  RetryClusterResponse() {}

  explicit RetryClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryClusterResponseBody>(model1);
      }
    }
  }


  virtual ~RetryClusterResponse() = default;
};
class SelectGatewaySlbRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  SelectGatewaySlbRequest() {}

  explicit SelectGatewaySlbRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SelectGatewaySlbRequest() = default;
};
class SelectGatewaySlbResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> slbId{};
  shared_ptr<string> slbName{};

  SelectGatewaySlbResponseBodyData() {}

  explicit SelectGatewaySlbResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slbId) {
      res["SlbId"] = boost::any(*slbId);
    }
    if (slbName) {
      res["SlbName"] = boost::any(*slbName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlbId") != m.end() && !m["SlbId"].empty()) {
      slbId = make_shared<string>(boost::any_cast<string>(m["SlbId"]));
    }
    if (m.find("SlbName") != m.end() && !m["SlbName"].empty()) {
      slbName = make_shared<string>(boost::any_cast<string>(m["SlbName"]));
    }
  }


  virtual ~SelectGatewaySlbResponseBodyData() = default;
};
class SelectGatewaySlbResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<vector<SelectGatewaySlbResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SelectGatewaySlbResponseBody() {}

  explicit SelectGatewaySlbResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<SelectGatewaySlbResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SelectGatewaySlbResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<SelectGatewaySlbResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SelectGatewaySlbResponseBody() = default;
};
class SelectGatewaySlbResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SelectGatewaySlbResponseBody> body{};

  SelectGatewaySlbResponse() {}

  explicit SelectGatewaySlbResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SelectGatewaySlbResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SelectGatewaySlbResponseBody>(model1);
      }
    }
  }


  virtual ~SelectGatewaySlbResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> aclEntryList{};
  shared_ptr<string> instanceId{};

  UpdateAclRequest() {}

  explicit UpdateAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (aclEntryList) {
      res["AclEntryList"] = boost::any(*aclEntryList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AclEntryList") != m.end() && !m["AclEntryList"].empty()) {
      aclEntryList = make_shared<string>(boost::any_cast<string>(m["AclEntryList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateAclRequest() = default;
};
class UpdateAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAclResponseBody() {}

  explicit UpdateAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAclResponseBody() = default;
};
class UpdateAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAclResponseBody> body{};

  UpdateAclResponse() {}

  explicit UpdateAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAclResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAclResponse() = default;
};
class UpdateAuthPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> authRule{};
  shared_ptr<string> enable{};
  shared_ptr<string> id{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> name{};
  shared_ptr<string> protocol{};
  shared_ptr<string> region{};
  shared_ptr<string> source{};

  UpdateAuthPolicyRequest() {}

  explicit UpdateAuthPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authRule) {
      res["AuthRule"] = boost::any(*authRule);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthRule") != m.end() && !m["AuthRule"].empty()) {
      authRule = make_shared<string>(boost::any_cast<string>(m["AuthRule"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~UpdateAuthPolicyRequest() = default;
};
class UpdateAuthPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAuthPolicyResponseBody() {}

  explicit UpdateAuthPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAuthPolicyResponseBody() = default;
};
class UpdateAuthPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAuthPolicyResponseBody> body{};

  UpdateAuthPolicyResponse() {}

  explicit UpdateAuthPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAuthPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAuthPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAuthPolicyResponse() = default;
};
class UpdateBlackWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> content{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<bool> isWhite{};
  shared_ptr<string> name{};
  shared_ptr<string> note{};
  shared_ptr<string> resourceIdJsonList{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  UpdateBlackWhiteListRequest() {}

  explicit UpdateBlackWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isWhite) {
      res["IsWhite"] = boost::any(*isWhite);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (resourceIdJsonList) {
      res["ResourceIdJsonList"] = boost::any(*resourceIdJsonList);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsWhite") != m.end() && !m["IsWhite"].empty()) {
      isWhite = make_shared<bool>(boost::any_cast<bool>(m["IsWhite"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("ResourceIdJsonList") != m.end() && !m["ResourceIdJsonList"].empty()) {
      resourceIdJsonList = make_shared<string>(boost::any_cast<string>(m["ResourceIdJsonList"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateBlackWhiteListRequest() = default;
};
class UpdateBlackWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateBlackWhiteListResponseBody() {}

  explicit UpdateBlackWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBlackWhiteListResponseBody() = default;
};
class UpdateBlackWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBlackWhiteListResponseBody> body{};

  UpdateBlackWhiteListResponse() {}

  explicit UpdateBlackWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBlackWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBlackWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBlackWhiteListResponse() = default;
};
class UpdateCircuitBreakerRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<long> halfOpenBaseAmountPerStep{};
  shared_ptr<long> halfOpenRecoveryStepNum{};
  shared_ptr<long> maxAllowedRtMs{};
  shared_ptr<long> minRequestAmount{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> retryTimeoutMs{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> statIntervalMs{};
  shared_ptr<long> strategy{};
  shared_ptr<double> threshold{};

  UpdateCircuitBreakerRuleRequest() {}

  explicit UpdateCircuitBreakerRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (halfOpenBaseAmountPerStep) {
      res["HalfOpenBaseAmountPerStep"] = boost::any(*halfOpenBaseAmountPerStep);
    }
    if (halfOpenRecoveryStepNum) {
      res["HalfOpenRecoveryStepNum"] = boost::any(*halfOpenRecoveryStepNum);
    }
    if (maxAllowedRtMs) {
      res["MaxAllowedRtMs"] = boost::any(*maxAllowedRtMs);
    }
    if (minRequestAmount) {
      res["MinRequestAmount"] = boost::any(*minRequestAmount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (retryTimeoutMs) {
      res["RetryTimeoutMs"] = boost::any(*retryTimeoutMs);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (statIntervalMs) {
      res["StatIntervalMs"] = boost::any(*statIntervalMs);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("HalfOpenBaseAmountPerStep") != m.end() && !m["HalfOpenBaseAmountPerStep"].empty()) {
      halfOpenBaseAmountPerStep = make_shared<long>(boost::any_cast<long>(m["HalfOpenBaseAmountPerStep"]));
    }
    if (m.find("HalfOpenRecoveryStepNum") != m.end() && !m["HalfOpenRecoveryStepNum"].empty()) {
      halfOpenRecoveryStepNum = make_shared<long>(boost::any_cast<long>(m["HalfOpenRecoveryStepNum"]));
    }
    if (m.find("MaxAllowedRtMs") != m.end() && !m["MaxAllowedRtMs"].empty()) {
      maxAllowedRtMs = make_shared<long>(boost::any_cast<long>(m["MaxAllowedRtMs"]));
    }
    if (m.find("MinRequestAmount") != m.end() && !m["MinRequestAmount"].empty()) {
      minRequestAmount = make_shared<long>(boost::any_cast<long>(m["MinRequestAmount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RetryTimeoutMs") != m.end() && !m["RetryTimeoutMs"].empty()) {
      retryTimeoutMs = make_shared<long>(boost::any_cast<long>(m["RetryTimeoutMs"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("StatIntervalMs") != m.end() && !m["StatIntervalMs"].empty()) {
      statIntervalMs = make_shared<long>(boost::any_cast<long>(m["StatIntervalMs"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~UpdateCircuitBreakerRuleRequest() = default;
};
class UpdateCircuitBreakerRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<long> halfOpenBaseAmountPerStep{};
  shared_ptr<long> halfOpenRecoveryStepNum{};
  shared_ptr<long> id{};
  shared_ptr<long> maxAllowedRtMs{};
  shared_ptr<long> minRequestAmount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resource{};
  shared_ptr<long> retryTimeoutMs{};
  shared_ptr<long> statIntervalMs{};
  shared_ptr<long> strategy{};
  shared_ptr<double> threshold{};

  UpdateCircuitBreakerRuleResponseBodyData() {}

  explicit UpdateCircuitBreakerRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (halfOpenBaseAmountPerStep) {
      res["HalfOpenBaseAmountPerStep"] = boost::any(*halfOpenBaseAmountPerStep);
    }
    if (halfOpenRecoveryStepNum) {
      res["HalfOpenRecoveryStepNum"] = boost::any(*halfOpenRecoveryStepNum);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxAllowedRtMs) {
      res["MaxAllowedRtMs"] = boost::any(*maxAllowedRtMs);
    }
    if (minRequestAmount) {
      res["MinRequestAmount"] = boost::any(*minRequestAmount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (retryTimeoutMs) {
      res["RetryTimeoutMs"] = boost::any(*retryTimeoutMs);
    }
    if (statIntervalMs) {
      res["StatIntervalMs"] = boost::any(*statIntervalMs);
    }
    if (strategy) {
      res["Strategy"] = boost::any(*strategy);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("HalfOpenBaseAmountPerStep") != m.end() && !m["HalfOpenBaseAmountPerStep"].empty()) {
      halfOpenBaseAmountPerStep = make_shared<long>(boost::any_cast<long>(m["HalfOpenBaseAmountPerStep"]));
    }
    if (m.find("HalfOpenRecoveryStepNum") != m.end() && !m["HalfOpenRecoveryStepNum"].empty()) {
      halfOpenRecoveryStepNum = make_shared<long>(boost::any_cast<long>(m["HalfOpenRecoveryStepNum"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxAllowedRtMs") != m.end() && !m["MaxAllowedRtMs"].empty()) {
      maxAllowedRtMs = make_shared<long>(boost::any_cast<long>(m["MaxAllowedRtMs"]));
    }
    if (m.find("MinRequestAmount") != m.end() && !m["MinRequestAmount"].empty()) {
      minRequestAmount = make_shared<long>(boost::any_cast<long>(m["MinRequestAmount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RetryTimeoutMs") != m.end() && !m["RetryTimeoutMs"].empty()) {
      retryTimeoutMs = make_shared<long>(boost::any_cast<long>(m["RetryTimeoutMs"]));
    }
    if (m.find("StatIntervalMs") != m.end() && !m["StatIntervalMs"].empty()) {
      statIntervalMs = make_shared<long>(boost::any_cast<long>(m["StatIntervalMs"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      strategy = make_shared<long>(boost::any_cast<long>(m["Strategy"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~UpdateCircuitBreakerRuleResponseBodyData() = default;
};
class UpdateCircuitBreakerRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateCircuitBreakerRuleResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCircuitBreakerRuleResponseBody() {}

  explicit UpdateCircuitBreakerRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateCircuitBreakerRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateCircuitBreakerRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCircuitBreakerRuleResponseBody() = default;
};
class UpdateCircuitBreakerRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCircuitBreakerRuleResponseBody> body{};

  UpdateCircuitBreakerRuleResponse() {}

  explicit UpdateCircuitBreakerRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCircuitBreakerRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCircuitBreakerRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCircuitBreakerRuleResponse() = default;
};
class UpdateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterAliasName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maintenanceEndTime{};
  shared_ptr<string> maintenanceStartTime{};
  shared_ptr<string> requestPars{};

  UpdateClusterRequest() {}

  explicit UpdateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterAliasName) {
      res["ClusterAliasName"] = boost::any(*clusterAliasName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maintenanceEndTime) {
      res["MaintenanceEndTime"] = boost::any(*maintenanceEndTime);
    }
    if (maintenanceStartTime) {
      res["MaintenanceStartTime"] = boost::any(*maintenanceStartTime);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterAliasName") != m.end() && !m["ClusterAliasName"].empty()) {
      clusterAliasName = make_shared<string>(boost::any_cast<string>(m["ClusterAliasName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaintenanceEndTime") != m.end() && !m["MaintenanceEndTime"].empty()) {
      maintenanceEndTime = make_shared<string>(boost::any_cast<string>(m["MaintenanceEndTime"]));
    }
    if (m.find("MaintenanceStartTime") != m.end() && !m["MaintenanceStartTime"].empty()) {
      maintenanceStartTime = make_shared<string>(boost::any_cast<string>(m["MaintenanceStartTime"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~UpdateClusterRequest() = default;
};
class UpdateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateClusterResponseBody() {}

  explicit UpdateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateClusterResponseBody() = default;
};
class UpdateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateClusterResponseBody> body{};

  UpdateClusterResponse() {}

  explicit UpdateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateClusterResponse() = default;
};
class UpdateClusterSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterSpecification{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mseVersion{};

  UpdateClusterSpecRequest() {}

  explicit UpdateClusterSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterSpecification) {
      res["ClusterSpecification"] = boost::any(*clusterSpecification);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mseVersion) {
      res["MseVersion"] = boost::any(*mseVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterSpecification") != m.end() && !m["ClusterSpecification"].empty()) {
      clusterSpecification = make_shared<string>(boost::any_cast<string>(m["ClusterSpecification"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MseVersion") != m.end() && !m["MseVersion"].empty()) {
      mseVersion = make_shared<string>(boost::any_cast<string>(m["MseVersion"]));
    }
  }


  virtual ~UpdateClusterSpecRequest() = default;
};
class UpdateClusterSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateClusterSpecResponseBody() {}

  explicit UpdateClusterSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateClusterSpecResponseBody() = default;
};
class UpdateClusterSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateClusterSpecResponseBody> body{};

  UpdateClusterSpecResponse() {}

  explicit UpdateClusterSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateClusterSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateClusterSpecResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateClusterSpecResponse() = default;
};
class UpdateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> autopurgePurgeInterval{};
  shared_ptr<string> autopurgeSnapRetainCount{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> configAuthEnabled{};
  shared_ptr<bool> configSecretEnabled{};
  shared_ptr<string> configType{};
  shared_ptr<bool> consoleUIEnabled{};
  shared_ptr<bool> eurekaSupported{};
  shared_ptr<string> extendedTypesEnable{};
  shared_ptr<string> initLimit{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> juteMaxbuffer{};
  shared_ptr<bool> MCPEnabled{};
  shared_ptr<string> maxClientCnxns{};
  shared_ptr<string> maxSessionTimeout{};
  shared_ptr<string> minSessionTimeout{};
  shared_ptr<bool> namingAuthEnabled{};
  shared_ptr<string> openSuperAcl{};
  shared_ptr<string> passWord{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> snapshotCount{};
  shared_ptr<string> syncLimit{};
  shared_ptr<bool> TLSEnabled{};
  shared_ptr<string> tickTime{};
  shared_ptr<string> userName{};

  UpdateConfigRequest() {}

  explicit UpdateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (autopurgePurgeInterval) {
      res["AutopurgePurgeInterval"] = boost::any(*autopurgePurgeInterval);
    }
    if (autopurgeSnapRetainCount) {
      res["AutopurgeSnapRetainCount"] = boost::any(*autopurgeSnapRetainCount);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (configAuthEnabled) {
      res["ConfigAuthEnabled"] = boost::any(*configAuthEnabled);
    }
    if (configSecretEnabled) {
      res["ConfigSecretEnabled"] = boost::any(*configSecretEnabled);
    }
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (consoleUIEnabled) {
      res["ConsoleUIEnabled"] = boost::any(*consoleUIEnabled);
    }
    if (eurekaSupported) {
      res["EurekaSupported"] = boost::any(*eurekaSupported);
    }
    if (extendedTypesEnable) {
      res["ExtendedTypesEnable"] = boost::any(*extendedTypesEnable);
    }
    if (initLimit) {
      res["InitLimit"] = boost::any(*initLimit);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (juteMaxbuffer) {
      res["JuteMaxbuffer"] = boost::any(*juteMaxbuffer);
    }
    if (MCPEnabled) {
      res["MCPEnabled"] = boost::any(*MCPEnabled);
    }
    if (maxClientCnxns) {
      res["MaxClientCnxns"] = boost::any(*maxClientCnxns);
    }
    if (maxSessionTimeout) {
      res["MaxSessionTimeout"] = boost::any(*maxSessionTimeout);
    }
    if (minSessionTimeout) {
      res["MinSessionTimeout"] = boost::any(*minSessionTimeout);
    }
    if (namingAuthEnabled) {
      res["NamingAuthEnabled"] = boost::any(*namingAuthEnabled);
    }
    if (openSuperAcl) {
      res["OpenSuperAcl"] = boost::any(*openSuperAcl);
    }
    if (passWord) {
      res["PassWord"] = boost::any(*passWord);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (snapshotCount) {
      res["SnapshotCount"] = boost::any(*snapshotCount);
    }
    if (syncLimit) {
      res["SyncLimit"] = boost::any(*syncLimit);
    }
    if (TLSEnabled) {
      res["TLSEnabled"] = boost::any(*TLSEnabled);
    }
    if (tickTime) {
      res["TickTime"] = boost::any(*tickTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AutopurgePurgeInterval") != m.end() && !m["AutopurgePurgeInterval"].empty()) {
      autopurgePurgeInterval = make_shared<string>(boost::any_cast<string>(m["AutopurgePurgeInterval"]));
    }
    if (m.find("AutopurgeSnapRetainCount") != m.end() && !m["AutopurgeSnapRetainCount"].empty()) {
      autopurgeSnapRetainCount = make_shared<string>(boost::any_cast<string>(m["AutopurgeSnapRetainCount"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ConfigAuthEnabled") != m.end() && !m["ConfigAuthEnabled"].empty()) {
      configAuthEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConfigAuthEnabled"]));
    }
    if (m.find("ConfigSecretEnabled") != m.end() && !m["ConfigSecretEnabled"].empty()) {
      configSecretEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConfigSecretEnabled"]));
    }
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("ConsoleUIEnabled") != m.end() && !m["ConsoleUIEnabled"].empty()) {
      consoleUIEnabled = make_shared<bool>(boost::any_cast<bool>(m["ConsoleUIEnabled"]));
    }
    if (m.find("EurekaSupported") != m.end() && !m["EurekaSupported"].empty()) {
      eurekaSupported = make_shared<bool>(boost::any_cast<bool>(m["EurekaSupported"]));
    }
    if (m.find("ExtendedTypesEnable") != m.end() && !m["ExtendedTypesEnable"].empty()) {
      extendedTypesEnable = make_shared<string>(boost::any_cast<string>(m["ExtendedTypesEnable"]));
    }
    if (m.find("InitLimit") != m.end() && !m["InitLimit"].empty()) {
      initLimit = make_shared<string>(boost::any_cast<string>(m["InitLimit"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JuteMaxbuffer") != m.end() && !m["JuteMaxbuffer"].empty()) {
      juteMaxbuffer = make_shared<string>(boost::any_cast<string>(m["JuteMaxbuffer"]));
    }
    if (m.find("MCPEnabled") != m.end() && !m["MCPEnabled"].empty()) {
      MCPEnabled = make_shared<bool>(boost::any_cast<bool>(m["MCPEnabled"]));
    }
    if (m.find("MaxClientCnxns") != m.end() && !m["MaxClientCnxns"].empty()) {
      maxClientCnxns = make_shared<string>(boost::any_cast<string>(m["MaxClientCnxns"]));
    }
    if (m.find("MaxSessionTimeout") != m.end() && !m["MaxSessionTimeout"].empty()) {
      maxSessionTimeout = make_shared<string>(boost::any_cast<string>(m["MaxSessionTimeout"]));
    }
    if (m.find("MinSessionTimeout") != m.end() && !m["MinSessionTimeout"].empty()) {
      minSessionTimeout = make_shared<string>(boost::any_cast<string>(m["MinSessionTimeout"]));
    }
    if (m.find("NamingAuthEnabled") != m.end() && !m["NamingAuthEnabled"].empty()) {
      namingAuthEnabled = make_shared<bool>(boost::any_cast<bool>(m["NamingAuthEnabled"]));
    }
    if (m.find("OpenSuperAcl") != m.end() && !m["OpenSuperAcl"].empty()) {
      openSuperAcl = make_shared<string>(boost::any_cast<string>(m["OpenSuperAcl"]));
    }
    if (m.find("PassWord") != m.end() && !m["PassWord"].empty()) {
      passWord = make_shared<string>(boost::any_cast<string>(m["PassWord"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("SnapshotCount") != m.end() && !m["SnapshotCount"].empty()) {
      snapshotCount = make_shared<string>(boost::any_cast<string>(m["SnapshotCount"]));
    }
    if (m.find("SyncLimit") != m.end() && !m["SyncLimit"].empty()) {
      syncLimit = make_shared<string>(boost::any_cast<string>(m["SyncLimit"]));
    }
    if (m.find("TLSEnabled") != m.end() && !m["TLSEnabled"].empty()) {
      TLSEnabled = make_shared<bool>(boost::any_cast<bool>(m["TLSEnabled"]));
    }
    if (m.find("TickTime") != m.end() && !m["TickTime"].empty()) {
      tickTime = make_shared<string>(boost::any_cast<string>(m["TickTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~UpdateConfigRequest() = default;
};
class UpdateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateConfigResponseBody() {}

  explicit UpdateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateConfigResponseBody() = default;
};
class UpdateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigResponseBody> body{};

  UpdateConfigResponse() {}

  explicit UpdateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigResponse() = default;
};
class UpdateEngineNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> desc{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> serviceCount{};

  UpdateEngineNamespaceRequest() {}

  explicit UpdateEngineNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (serviceCount) {
      res["ServiceCount"] = boost::any(*serviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServiceCount") != m.end() && !m["ServiceCount"].empty()) {
      serviceCount = make_shared<long>(boost::any_cast<long>(m["ServiceCount"]));
    }
  }


  virtual ~UpdateEngineNamespaceRequest() = default;
};
class UpdateEngineNamespaceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> configCount{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceDesc{};
  shared_ptr<string> namespaceShowName{};
  shared_ptr<long> quota{};
  shared_ptr<long> type{};

  UpdateEngineNamespaceResponseBodyData() {}

  explicit UpdateEngineNamespaceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configCount) {
      res["ConfigCount"] = boost::any(*configCount);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceDesc) {
      res["NamespaceDesc"] = boost::any(*namespaceDesc);
    }
    if (namespaceShowName) {
      res["NamespaceShowName"] = boost::any(*namespaceShowName);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigCount") != m.end() && !m["ConfigCount"].empty()) {
      configCount = make_shared<long>(boost::any_cast<long>(m["ConfigCount"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceDesc") != m.end() && !m["NamespaceDesc"].empty()) {
      namespaceDesc = make_shared<string>(boost::any_cast<string>(m["NamespaceDesc"]));
    }
    if (m.find("NamespaceShowName") != m.end() && !m["NamespaceShowName"].empty()) {
      namespaceShowName = make_shared<string>(boost::any_cast<string>(m["NamespaceShowName"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~UpdateEngineNamespaceResponseBodyData() = default;
};
class UpdateEngineNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateEngineNamespaceResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateEngineNamespaceResponseBody() {}

  explicit UpdateEngineNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateEngineNamespaceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateEngineNamespaceResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEngineNamespaceResponseBody() = default;
};
class UpdateEngineNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEngineNamespaceResponseBody> body{};

  UpdateEngineNamespaceResponse() {}

  explicit UpdateEngineNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEngineNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEngineNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEngineNamespaceResponse() = default;
};
class UpdateFlowRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> controlBehavior{};
  shared_ptr<bool> enable{};
  shared_ptr<long> maxQueueingTimeMs{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> threshold{};

  UpdateFlowRuleRequest() {}

  explicit UpdateFlowRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlBehavior) {
      res["ControlBehavior"] = boost::any(*controlBehavior);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (maxQueueingTimeMs) {
      res["MaxQueueingTimeMs"] = boost::any(*maxQueueingTimeMs);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlBehavior") != m.end() && !m["ControlBehavior"].empty()) {
      controlBehavior = make_shared<long>(boost::any_cast<long>(m["ControlBehavior"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("MaxQueueingTimeMs") != m.end() && !m["MaxQueueingTimeMs"].empty()) {
      maxQueueingTimeMs = make_shared<long>(boost::any_cast<long>(m["MaxQueueingTimeMs"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<long>(boost::any_cast<long>(m["Threshold"]));
    }
  }


  virtual ~UpdateFlowRuleRequest() = default;
};
class UpdateFlowRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> controlBehavior{};
  shared_ptr<bool> enable{};
  shared_ptr<long> id{};
  shared_ptr<long> maxQueueingTimeMs{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> resource{};
  shared_ptr<double> threshold{};

  UpdateFlowRuleResponseBodyData() {}

  explicit UpdateFlowRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (controlBehavior) {
      res["ControlBehavior"] = boost::any(*controlBehavior);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxQueueingTimeMs) {
      res["MaxQueueingTimeMs"] = boost::any(*maxQueueingTimeMs);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ControlBehavior") != m.end() && !m["ControlBehavior"].empty()) {
      controlBehavior = make_shared<long>(boost::any_cast<long>(m["ControlBehavior"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxQueueingTimeMs") != m.end() && !m["MaxQueueingTimeMs"].empty()) {
      maxQueueingTimeMs = make_shared<long>(boost::any_cast<long>(m["MaxQueueingTimeMs"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~UpdateFlowRuleResponseBodyData() = default;
};
class UpdateFlowRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateFlowRuleResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFlowRuleResponseBody() {}

  explicit UpdateFlowRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateFlowRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateFlowRuleResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFlowRuleResponseBody() = default;
};
class UpdateFlowRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFlowRuleResponseBody> body{};

  UpdateFlowRuleResponse() {}

  explicit UpdateFlowRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFlowRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFlowRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFlowRuleResponse() = default;
};
class UpdateGatewayAuthConsumerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> description{};
  shared_ptr<string> encodeType{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> jwks{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyValue{};
  shared_ptr<string> tokenName{};
  shared_ptr<bool> tokenPass{};
  shared_ptr<string> tokenPosition{};
  shared_ptr<string> tokenPrefix{};

  UpdateGatewayAuthConsumerRequest() {}

  explicit UpdateGatewayAuthConsumerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encodeType) {
      res["EncodeType"] = boost::any(*encodeType);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jwks) {
      res["Jwks"] = boost::any(*jwks);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyValue) {
      res["KeyValue"] = boost::any(*keyValue);
    }
    if (tokenName) {
      res["TokenName"] = boost::any(*tokenName);
    }
    if (tokenPass) {
      res["TokenPass"] = boost::any(*tokenPass);
    }
    if (tokenPosition) {
      res["TokenPosition"] = boost::any(*tokenPosition);
    }
    if (tokenPrefix) {
      res["TokenPrefix"] = boost::any(*tokenPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EncodeType") != m.end() && !m["EncodeType"].empty()) {
      encodeType = make_shared<string>(boost::any_cast<string>(m["EncodeType"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Jwks") != m.end() && !m["Jwks"].empty()) {
      jwks = make_shared<string>(boost::any_cast<string>(m["Jwks"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyValue") != m.end() && !m["KeyValue"].empty()) {
      keyValue = make_shared<string>(boost::any_cast<string>(m["KeyValue"]));
    }
    if (m.find("TokenName") != m.end() && !m["TokenName"].empty()) {
      tokenName = make_shared<string>(boost::any_cast<string>(m["TokenName"]));
    }
    if (m.find("TokenPass") != m.end() && !m["TokenPass"].empty()) {
      tokenPass = make_shared<bool>(boost::any_cast<bool>(m["TokenPass"]));
    }
    if (m.find("TokenPosition") != m.end() && !m["TokenPosition"].empty()) {
      tokenPosition = make_shared<string>(boost::any_cast<string>(m["TokenPosition"]));
    }
    if (m.find("TokenPrefix") != m.end() && !m["TokenPrefix"].empty()) {
      tokenPrefix = make_shared<string>(boost::any_cast<string>(m["TokenPrefix"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerRequest() = default;
};
class UpdateGatewayAuthConsumerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayAuthConsumerResponseBody() {}

  explicit UpdateGatewayAuthConsumerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResponseBody() = default;
};
class UpdateGatewayAuthConsumerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayAuthConsumerResponseBody> body{};

  UpdateGatewayAuthConsumerResponse() {}

  explicit UpdateGatewayAuthConsumerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayAuthConsumerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayAuthConsumerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayAuthConsumerResponse() = default;
};
class UpdateGatewayAuthConsumerResourceRequestResourceList : public Darabonba::Model {
public:
  shared_ptr<long> routeId{};
  shared_ptr<string> routeName{};

  UpdateGatewayAuthConsumerResourceRequestResourceList() {}

  explicit UpdateGatewayAuthConsumerResourceRequestResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    if (routeName) {
      res["RouteName"] = boost::any(*routeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
    if (m.find("RouteName") != m.end() && !m["RouteName"].empty()) {
      routeName = make_shared<string>(boost::any_cast<string>(m["RouteName"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceRequestResourceList() = default;
};
class UpdateGatewayAuthConsumerResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<vector<UpdateGatewayAuthConsumerResourceRequestResourceList>> resourceList{};

  UpdateGatewayAuthConsumerResourceRequest() {}

  explicit UpdateGatewayAuthConsumerResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<UpdateGatewayAuthConsumerResourceRequestResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayAuthConsumerResourceRequestResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<UpdateGatewayAuthConsumerResourceRequestResourceList>>(expect1);
      }
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceRequest() = default;
};
class UpdateGatewayAuthConsumerResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> resourceListShrink{};

  UpdateGatewayAuthConsumerResourceShrinkRequest() {}

  explicit UpdateGatewayAuthConsumerResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (resourceListShrink) {
      res["ResourceList"] = boost::any(*resourceListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      resourceListShrink = make_shared<string>(boost::any_cast<string>(m["ResourceList"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceShrinkRequest() = default;
};
class UpdateGatewayAuthConsumerResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayAuthConsumerResourceResponseBody() {}

  explicit UpdateGatewayAuthConsumerResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceResponseBody() = default;
};
class UpdateGatewayAuthConsumerResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayAuthConsumerResourceResponseBody> body{};

  UpdateGatewayAuthConsumerResourceResponse() {}

  explicit UpdateGatewayAuthConsumerResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayAuthConsumerResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayAuthConsumerResourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceResponse() = default;
};
class UpdateGatewayAuthConsumerResourceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> consumerId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> idList{};
  shared_ptr<bool> resourceStatus{};

  UpdateGatewayAuthConsumerResourceStatusRequest() {}

  explicit UpdateGatewayAuthConsumerResourceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerId) {
      res["ConsumerId"] = boost::any(*consumerId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (idList) {
      res["IdList"] = boost::any(*idList);
    }
    if (resourceStatus) {
      res["ResourceStatus"] = boost::any(*resourceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerId") != m.end() && !m["ConsumerId"].empty()) {
      consumerId = make_shared<long>(boost::any_cast<long>(m["ConsumerId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("IdList") != m.end() && !m["IdList"].empty()) {
      idList = make_shared<string>(boost::any_cast<string>(m["IdList"]));
    }
    if (m.find("ResourceStatus") != m.end() && !m["ResourceStatus"].empty()) {
      resourceStatus = make_shared<bool>(boost::any_cast<bool>(m["ResourceStatus"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceStatusRequest() = default;
};
class UpdateGatewayAuthConsumerResourceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayAuthConsumerResourceStatusResponseBody() {}

  explicit UpdateGatewayAuthConsumerResourceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceStatusResponseBody() = default;
};
class UpdateGatewayAuthConsumerResourceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayAuthConsumerResourceStatusResponseBody> body{};

  UpdateGatewayAuthConsumerResourceStatusResponse() {}

  explicit UpdateGatewayAuthConsumerResourceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayAuthConsumerResourceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayAuthConsumerResourceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayAuthConsumerResourceStatusResponse() = default;
};
class UpdateGatewayAuthConsumerStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> consumerStatus{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  UpdateGatewayAuthConsumerStatusRequest() {}

  explicit UpdateGatewayAuthConsumerStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (consumerStatus) {
      res["ConsumerStatus"] = boost::any(*consumerStatus);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ConsumerStatus") != m.end() && !m["ConsumerStatus"].empty()) {
      consumerStatus = make_shared<bool>(boost::any_cast<bool>(m["ConsumerStatus"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerStatusRequest() = default;
};
class UpdateGatewayAuthConsumerStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayAuthConsumerStatusResponseBody() {}

  explicit UpdateGatewayAuthConsumerStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayAuthConsumerStatusResponseBody() = default;
};
class UpdateGatewayAuthConsumerStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayAuthConsumerStatusResponseBody> body{};

  UpdateGatewayAuthConsumerStatusResponse() {}

  explicit UpdateGatewayAuthConsumerStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayAuthConsumerStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayAuthConsumerStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayAuthConsumerStatusResponse() = default;
};
class UpdateGatewayDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> http2{};
  shared_ptr<long> id{};
  shared_ptr<bool> mustHttps{};
  shared_ptr<string> protocol{};
  shared_ptr<string> tlsMax{};
  shared_ptr<string> tlsMin{};

  UpdateGatewayDomainRequest() {}

  explicit UpdateGatewayDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (http2) {
      res["Http2"] = boost::any(*http2);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mustHttps) {
      res["MustHttps"] = boost::any(*mustHttps);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (tlsMax) {
      res["TlsMax"] = boost::any(*tlsMax);
    }
    if (tlsMin) {
      res["TlsMin"] = boost::any(*tlsMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Http2") != m.end() && !m["Http2"].empty()) {
      http2 = make_shared<string>(boost::any_cast<string>(m["Http2"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MustHttps") != m.end() && !m["MustHttps"].empty()) {
      mustHttps = make_shared<bool>(boost::any_cast<bool>(m["MustHttps"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TlsMax") != m.end() && !m["TlsMax"].empty()) {
      tlsMax = make_shared<string>(boost::any_cast<string>(m["TlsMax"]));
    }
    if (m.find("TlsMin") != m.end() && !m["TlsMin"].empty()) {
      tlsMin = make_shared<string>(boost::any_cast<string>(m["TlsMin"]));
    }
  }


  virtual ~UpdateGatewayDomainRequest() = default;
};
class UpdateGatewayDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayDomainResponseBody() {}

  explicit UpdateGatewayDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayDomainResponseBody() = default;
};
class UpdateGatewayDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayDomainResponseBody> body{};

  UpdateGatewayDomainResponse() {}

  explicit UpdateGatewayDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayDomainResponse() = default;
};
class UpdateGatewayNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> name{};

  UpdateGatewayNameRequest() {}

  explicit UpdateGatewayNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateGatewayNameRequest() = default;
};
class UpdateGatewayNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayNameResponseBody() {}

  explicit UpdateGatewayNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayNameResponseBody() = default;
};
class UpdateGatewayNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayNameResponseBody> body{};

  UpdateGatewayNameResponse() {}

  explicit UpdateGatewayNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayNameResponse() = default;
};
class UpdateGatewayOptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<GatewayOption> gatewayOption{};
  shared_ptr<string> gatewayUniqueId{};

  UpdateGatewayOptionRequest() {}

  explicit UpdateGatewayOptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayOption) {
      res["GatewayOption"] = gatewayOption ? boost::any(gatewayOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayOption") != m.end() && !m["GatewayOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayOption"].type()) {
        GatewayOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayOption"]));
        gatewayOption = make_shared<GatewayOption>(model1);
      }
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~UpdateGatewayOptionRequest() = default;
};
class UpdateGatewayOptionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayOptionShrink{};
  shared_ptr<string> gatewayUniqueId{};

  UpdateGatewayOptionShrinkRequest() {}

  explicit UpdateGatewayOptionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayOptionShrink) {
      res["GatewayOption"] = boost::any(*gatewayOptionShrink);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayOption") != m.end() && !m["GatewayOption"].empty()) {
      gatewayOptionShrink = make_shared<string>(boost::any_cast<string>(m["GatewayOption"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~UpdateGatewayOptionShrinkRequest() = default;
};
class UpdateGatewayOptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GatewayOption> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayOptionResponseBody() {}

  explicit UpdateGatewayOptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GatewayOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GatewayOption>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayOptionResponseBody() = default;
};
class UpdateGatewayOptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayOptionResponseBody> body{};

  UpdateGatewayOptionResponse() {}

  explicit UpdateGatewayOptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayOptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayOptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayOptionResponse() = default;
};
class UpdateGatewayRouteRequestDirectResponseJSON : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> code{};

  UpdateGatewayRouteRequestDirectResponseJSON() {}

  explicit UpdateGatewayRouteRequestDirectResponseJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestDirectResponseJSON() = default;
};
class UpdateGatewayRouteRequestFallbackServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  UpdateGatewayRouteRequestFallbackServices() {}

  explicit UpdateGatewayRouteRequestFallbackServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestFallbackServices() = default;
};
class UpdateGatewayRouteRequestPredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateGatewayRouteRequestPredicatesHeaderPredicates() {}

  explicit UpdateGatewayRouteRequestPredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestPredicatesHeaderPredicates() = default;
};
class UpdateGatewayRouteRequestPredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  UpdateGatewayRouteRequestPredicatesPathPredicates() {}

  explicit UpdateGatewayRouteRequestPredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestPredicatesPathPredicates() = default;
};
class UpdateGatewayRouteRequestPredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateGatewayRouteRequestPredicatesQueryPredicates() {}

  explicit UpdateGatewayRouteRequestPredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestPredicatesQueryPredicates() = default;
};
class UpdateGatewayRouteRequestPredicates : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGatewayRouteRequestPredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<UpdateGatewayRouteRequestPredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<UpdateGatewayRouteRequestPredicatesQueryPredicates>> queryPredicates{};

  UpdateGatewayRouteRequestPredicates() {}

  explicit UpdateGatewayRouteRequestPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<UpdateGatewayRouteRequestPredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestPredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<UpdateGatewayRouteRequestPredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        UpdateGatewayRouteRequestPredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<UpdateGatewayRouteRequestPredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<UpdateGatewayRouteRequestPredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestPredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<UpdateGatewayRouteRequestPredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~UpdateGatewayRouteRequestPredicates() = default;
};
class UpdateGatewayRouteRequestRedirectJSON : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> host{};
  shared_ptr<string> path{};

  UpdateGatewayRouteRequestRedirectJSON() {}

  explicit UpdateGatewayRouteRequestRedirectJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestRedirectJSON() = default;
};
class UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList : public Darabonba::Model {
public:
  shared_ptr<string> extractKey{};
  shared_ptr<string> extractKeySpec{};
  shared_ptr<string> mappingType{};

  UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList() {}

  explicit UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractKey) {
      res["ExtractKey"] = boost::any(*extractKey);
    }
    if (extractKeySpec) {
      res["ExtractKeySpec"] = boost::any(*extractKeySpec);
    }
    if (mappingType) {
      res["MappingType"] = boost::any(*mappingType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractKey") != m.end() && !m["ExtractKey"].empty()) {
      extractKey = make_shared<string>(boost::any_cast<string>(m["ExtractKey"]));
    }
    if (m.find("ExtractKeySpec") != m.end() && !m["ExtractKeySpec"].empty()) {
      extractKeySpec = make_shared<string>(boost::any_cast<string>(m["ExtractKeySpec"]));
    }
    if (m.find("MappingType") != m.end() && !m["MappingType"].empty()) {
      mappingType = make_shared<string>(boost::any_cast<string>(m["MappingType"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList() = default;
};
class UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList : public Darabonba::Model {
public:
  shared_ptr<string> dubboMothedName{};
  shared_ptr<string> httpMothed{};
  shared_ptr<string> mothedpath{};
  shared_ptr<vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList>> paramMapsList{};
  shared_ptr<string> passThroughAllHeaders{};
  shared_ptr<vector<string>> passThroughList{};

  UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList() {}

  explicit UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboMothedName) {
      res["DubboMothedName"] = boost::any(*dubboMothedName);
    }
    if (httpMothed) {
      res["HttpMothed"] = boost::any(*httpMothed);
    }
    if (mothedpath) {
      res["Mothedpath"] = boost::any(*mothedpath);
    }
    if (paramMapsList) {
      vector<boost::any> temp1;
      for(auto item1:*paramMapsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamMapsList"] = boost::any(temp1);
    }
    if (passThroughAllHeaders) {
      res["PassThroughAllHeaders"] = boost::any(*passThroughAllHeaders);
    }
    if (passThroughList) {
      res["PassThroughList"] = boost::any(*passThroughList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboMothedName") != m.end() && !m["DubboMothedName"].empty()) {
      dubboMothedName = make_shared<string>(boost::any_cast<string>(m["DubboMothedName"]));
    }
    if (m.find("HttpMothed") != m.end() && !m["HttpMothed"].empty()) {
      httpMothed = make_shared<string>(boost::any_cast<string>(m["HttpMothed"]));
    }
    if (m.find("Mothedpath") != m.end() && !m["Mothedpath"].empty()) {
      mothedpath = make_shared<string>(boost::any_cast<string>(m["Mothedpath"]));
    }
    if (m.find("ParamMapsList") != m.end() && !m["ParamMapsList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamMapsList"].type()) {
        vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamMapsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramMapsList = make_shared<vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList>>(expect1);
      }
    }
    if (m.find("PassThroughAllHeaders") != m.end() && !m["PassThroughAllHeaders"].empty()) {
      passThroughAllHeaders = make_shared<string>(boost::any_cast<string>(m["PassThroughAllHeaders"]));
    }
    if (m.find("PassThroughList") != m.end() && !m["PassThroughList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PassThroughList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PassThroughList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passThroughList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList() = default;
};
class UpdateGatewayRouteRequestServicesHttpDubboTranscoder : public Darabonba::Model {
public:
  shared_ptr<string> dubboServiceGroup{};
  shared_ptr<string> dubboServiceName{};
  shared_ptr<string> dubboServiceVersion{};
  shared_ptr<vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList>> mothedMapList{};

  UpdateGatewayRouteRequestServicesHttpDubboTranscoder() {}

  explicit UpdateGatewayRouteRequestServicesHttpDubboTranscoder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dubboServiceGroup) {
      res["DubboServiceGroup"] = boost::any(*dubboServiceGroup);
    }
    if (dubboServiceName) {
      res["DubboServiceName"] = boost::any(*dubboServiceName);
    }
    if (dubboServiceVersion) {
      res["DubboServiceVersion"] = boost::any(*dubboServiceVersion);
    }
    if (mothedMapList) {
      vector<boost::any> temp1;
      for(auto item1:*mothedMapList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MothedMapList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DubboServiceGroup") != m.end() && !m["DubboServiceGroup"].empty()) {
      dubboServiceGroup = make_shared<string>(boost::any_cast<string>(m["DubboServiceGroup"]));
    }
    if (m.find("DubboServiceName") != m.end() && !m["DubboServiceName"].empty()) {
      dubboServiceName = make_shared<string>(boost::any_cast<string>(m["DubboServiceName"]));
    }
    if (m.find("DubboServiceVersion") != m.end() && !m["DubboServiceVersion"].empty()) {
      dubboServiceVersion = make_shared<string>(boost::any_cast<string>(m["DubboServiceVersion"]));
    }
    if (m.find("MothedMapList") != m.end() && !m["MothedMapList"].empty()) {
      if (typeid(vector<boost::any>) == m["MothedMapList"].type()) {
        vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MothedMapList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mothedMapList = make_shared<vector<UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList>>(expect1);
      }
    }
  }


  virtual ~UpdateGatewayRouteRequestServicesHttpDubboTranscoder() = default;
};
class UpdateGatewayRouteRequestServices : public Darabonba::Model {
public:
  shared_ptr<string> agreementType{};
  shared_ptr<string> groupName{};
  shared_ptr<UpdateGatewayRouteRequestServicesHttpDubboTranscoder> httpDubboTranscoder{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<long> servicePort{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  UpdateGatewayRouteRequestServices() {}

  explicit UpdateGatewayRouteRequestServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agreementType) {
      res["AgreementType"] = boost::any(*agreementType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpDubboTranscoder) {
      res["HttpDubboTranscoder"] = httpDubboTranscoder ? boost::any(httpDubboTranscoder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgreementType") != m.end() && !m["AgreementType"].empty()) {
      agreementType = make_shared<string>(boost::any_cast<string>(m["AgreementType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpDubboTranscoder") != m.end() && !m["HttpDubboTranscoder"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpDubboTranscoder"].type()) {
        UpdateGatewayRouteRequestServicesHttpDubboTranscoder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpDubboTranscoder"]));
        httpDubboTranscoder = make_shared<UpdateGatewayRouteRequestServicesHttpDubboTranscoder>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<long>(boost::any_cast<long>(m["ServicePort"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateGatewayRouteRequestServices() = default;
};
class UpdateGatewayRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> destinationType{};
  shared_ptr<UpdateGatewayRouteRequestDirectResponseJSON> directResponseJSON{};
  shared_ptr<string> domainIdListJSON{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<vector<UpdateGatewayRouteRequestFallbackServices>> fallbackServices{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<UpdateGatewayRouteRequestPredicates> predicates{};
  shared_ptr<UpdateGatewayRouteRequestRedirectJSON> redirectJSON{};
  shared_ptr<long> routeOrder{};
  shared_ptr<vector<UpdateGatewayRouteRequestServices>> services{};

  UpdateGatewayRouteRequest() {}

  explicit UpdateGatewayRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponseJSON) {
      res["DirectResponseJSON"] = directResponseJSON ? boost::any(directResponseJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainIdListJSON) {
      res["DomainIdListJSON"] = boost::any(*domainIdListJSON);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServices) {
      vector<boost::any> temp1;
      for(auto item1:*fallbackServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FallbackServices"] = boost::any(temp1);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (predicates) {
      res["Predicates"] = predicates ? boost::any(predicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirectJSON) {
      res["RedirectJSON"] = redirectJSON ? boost::any(redirectJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (services) {
      vector<boost::any> temp1;
      for(auto item1:*services){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Services"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponseJSON") != m.end() && !m["DirectResponseJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["DirectResponseJSON"].type()) {
        UpdateGatewayRouteRequestDirectResponseJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DirectResponseJSON"]));
        directResponseJSON = make_shared<UpdateGatewayRouteRequestDirectResponseJSON>(model1);
      }
    }
    if (m.find("DomainIdListJSON") != m.end() && !m["DomainIdListJSON"].empty()) {
      domainIdListJSON = make_shared<string>(boost::any_cast<string>(m["DomainIdListJSON"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      if (typeid(vector<boost::any>) == m["FallbackServices"].type()) {
        vector<UpdateGatewayRouteRequestFallbackServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FallbackServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestFallbackServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fallbackServices = make_shared<vector<UpdateGatewayRouteRequestFallbackServices>>(expect1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Predicates"].type()) {
        UpdateGatewayRouteRequestPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Predicates"]));
        predicates = make_shared<UpdateGatewayRouteRequestPredicates>(model1);
      }
    }
    if (m.find("RedirectJSON") != m.end() && !m["RedirectJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["RedirectJSON"].type()) {
        UpdateGatewayRouteRequestRedirectJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RedirectJSON"]));
        redirectJSON = make_shared<UpdateGatewayRouteRequestRedirectJSON>(model1);
      }
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      if (typeid(vector<boost::any>) == m["Services"].type()) {
        vector<UpdateGatewayRouteRequestServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Services"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteRequestServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        services = make_shared<vector<UpdateGatewayRouteRequestServices>>(expect1);
      }
    }
  }


  virtual ~UpdateGatewayRouteRequest() = default;
};
class UpdateGatewayRouteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> destinationType{};
  shared_ptr<string> directResponseJSONShrink{};
  shared_ptr<string> domainIdListJSON{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<bool> fallback{};
  shared_ptr<string> fallbackServicesShrink{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> predicatesShrink{};
  shared_ptr<string> redirectJSONShrink{};
  shared_ptr<long> routeOrder{};
  shared_ptr<string> servicesShrink{};

  UpdateGatewayRouteShrinkRequest() {}

  explicit UpdateGatewayRouteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponseJSONShrink) {
      res["DirectResponseJSON"] = boost::any(*directResponseJSONShrink);
    }
    if (domainIdListJSON) {
      res["DomainIdListJSON"] = boost::any(*domainIdListJSON);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (fallback) {
      res["Fallback"] = boost::any(*fallback);
    }
    if (fallbackServicesShrink) {
      res["FallbackServices"] = boost::any(*fallbackServicesShrink);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (predicatesShrink) {
      res["Predicates"] = boost::any(*predicatesShrink);
    }
    if (redirectJSONShrink) {
      res["RedirectJSON"] = boost::any(*redirectJSONShrink);
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (servicesShrink) {
      res["Services"] = boost::any(*servicesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponseJSON") != m.end() && !m["DirectResponseJSON"].empty()) {
      directResponseJSONShrink = make_shared<string>(boost::any_cast<string>(m["DirectResponseJSON"]));
    }
    if (m.find("DomainIdListJSON") != m.end() && !m["DomainIdListJSON"].empty()) {
      domainIdListJSON = make_shared<string>(boost::any_cast<string>(m["DomainIdListJSON"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("Fallback") != m.end() && !m["Fallback"].empty()) {
      fallback = make_shared<bool>(boost::any_cast<bool>(m["Fallback"]));
    }
    if (m.find("FallbackServices") != m.end() && !m["FallbackServices"].empty()) {
      fallbackServicesShrink = make_shared<string>(boost::any_cast<string>(m["FallbackServices"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicatesShrink = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("RedirectJSON") != m.end() && !m["RedirectJSON"].empty()) {
      redirectJSONShrink = make_shared<string>(boost::any_cast<string>(m["RedirectJSON"]));
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      servicesShrink = make_shared<string>(boost::any_cast<string>(m["Services"]));
    }
  }


  virtual ~UpdateGatewayRouteShrinkRequest() = default;
};
class UpdateGatewayRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteResponseBody() {}

  explicit UpdateGatewayRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteResponseBody() = default;
};
class UpdateGatewayRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteResponseBody> body{};

  UpdateGatewayRouteResponse() {}

  explicit UpdateGatewayRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteResponse() = default;
};
class UpdateGatewayRouteAuthRequestAuthJSON : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  UpdateGatewayRouteAuthRequestAuthJSON() {}

  explicit UpdateGatewayRouteAuthRequestAuthJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateGatewayRouteAuthRequestAuthJSON() = default;
};
class UpdateGatewayRouteAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<UpdateGatewayRouteAuthRequestAuthJSON> authJSON{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  UpdateGatewayRouteAuthRequest() {}

  explicit UpdateGatewayRouteAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (authJSON) {
      res["AuthJSON"] = authJSON ? boost::any(authJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AuthJSON") != m.end() && !m["AuthJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthJSON"].type()) {
        UpdateGatewayRouteAuthRequestAuthJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthJSON"]));
        authJSON = make_shared<UpdateGatewayRouteAuthRequestAuthJSON>(model1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteAuthRequest() = default;
};
class UpdateGatewayRouteAuthShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> authJSONShrink{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  UpdateGatewayRouteAuthShrinkRequest() {}

  explicit UpdateGatewayRouteAuthShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (authJSONShrink) {
      res["AuthJSON"] = boost::any(*authJSONShrink);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AuthJSON") != m.end() && !m["AuthJSON"].empty()) {
      authJSONShrink = make_shared<string>(boost::any_cast<string>(m["AuthJSON"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteAuthShrinkRequest() = default;
};
class UpdateGatewayRouteAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteAuthResponseBody() {}

  explicit UpdateGatewayRouteAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteAuthResponseBody() = default;
};
class UpdateGatewayRouteAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteAuthResponseBody> body{};

  UpdateGatewayRouteAuthResponse() {}

  explicit UpdateGatewayRouteAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteAuthResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteAuthResponse() = default;
};
class UpdateGatewayRouteCORSRequestCorsJSON : public Darabonba::Model {
public:
  shared_ptr<bool> allowCredentials{};
  shared_ptr<string> allowHeaders{};
  shared_ptr<string> allowMethods{};
  shared_ptr<string> allowOrigins{};
  shared_ptr<string> exposeHeaders{};
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  UpdateGatewayRouteCORSRequestCorsJSON() {}

  explicit UpdateGatewayRouteCORSRequestCorsJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCredentials) {
      res["AllowCredentials"] = boost::any(*allowCredentials);
    }
    if (allowHeaders) {
      res["AllowHeaders"] = boost::any(*allowHeaders);
    }
    if (allowMethods) {
      res["AllowMethods"] = boost::any(*allowMethods);
    }
    if (allowOrigins) {
      res["AllowOrigins"] = boost::any(*allowOrigins);
    }
    if (exposeHeaders) {
      res["ExposeHeaders"] = boost::any(*exposeHeaders);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCredentials") != m.end() && !m["AllowCredentials"].empty()) {
      allowCredentials = make_shared<bool>(boost::any_cast<bool>(m["AllowCredentials"]));
    }
    if (m.find("AllowHeaders") != m.end() && !m["AllowHeaders"].empty()) {
      allowHeaders = make_shared<string>(boost::any_cast<string>(m["AllowHeaders"]));
    }
    if (m.find("AllowMethods") != m.end() && !m["AllowMethods"].empty()) {
      allowMethods = make_shared<string>(boost::any_cast<string>(m["AllowMethods"]));
    }
    if (m.find("AllowOrigins") != m.end() && !m["AllowOrigins"].empty()) {
      allowOrigins = make_shared<string>(boost::any_cast<string>(m["AllowOrigins"]));
    }
    if (m.find("ExposeHeaders") != m.end() && !m["ExposeHeaders"].empty()) {
      exposeHeaders = make_shared<string>(boost::any_cast<string>(m["ExposeHeaders"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~UpdateGatewayRouteCORSRequestCorsJSON() = default;
};
class UpdateGatewayRouteCORSRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<UpdateGatewayRouteCORSRequestCorsJSON> corsJSON{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  UpdateGatewayRouteCORSRequest() {}

  explicit UpdateGatewayRouteCORSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (corsJSON) {
      res["CorsJSON"] = corsJSON ? boost::any(corsJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CorsJSON") != m.end() && !m["CorsJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["CorsJSON"].type()) {
        UpdateGatewayRouteCORSRequestCorsJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CorsJSON"]));
        corsJSON = make_shared<UpdateGatewayRouteCORSRequestCorsJSON>(model1);
      }
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteCORSRequest() = default;
};
class UpdateGatewayRouteCORSShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> corsJSONShrink{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};

  UpdateGatewayRouteCORSShrinkRequest() {}

  explicit UpdateGatewayRouteCORSShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (corsJSONShrink) {
      res["CorsJSON"] = boost::any(*corsJSONShrink);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CorsJSON") != m.end() && !m["CorsJSON"].empty()) {
      corsJSONShrink = make_shared<string>(boost::any_cast<string>(m["CorsJSON"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteCORSShrinkRequest() = default;
};
class UpdateGatewayRouteCORSResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteCORSResponseBody() {}

  explicit UpdateGatewayRouteCORSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteCORSResponseBody() = default;
};
class UpdateGatewayRouteCORSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteCORSResponseBody> body{};

  UpdateGatewayRouteCORSResponse() {}

  explicit UpdateGatewayRouteCORSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteCORSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteCORSResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteCORSResponse() = default;
};
class UpdateGatewayRouteHTTPRewriteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> httpRewriteJSON{};
  shared_ptr<long> id{};

  UpdateGatewayRouteHTTPRewriteRequest() {}

  explicit UpdateGatewayRouteHTTPRewriteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (httpRewriteJSON) {
      res["HttpRewriteJSON"] = boost::any(*httpRewriteJSON);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HttpRewriteJSON") != m.end() && !m["HttpRewriteJSON"].empty()) {
      httpRewriteJSON = make_shared<string>(boost::any_cast<string>(m["HttpRewriteJSON"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteHTTPRewriteRequest() = default;
};
class UpdateGatewayRouteHTTPRewriteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteHTTPRewriteResponseBody() {}

  explicit UpdateGatewayRouteHTTPRewriteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteHTTPRewriteResponseBody() = default;
};
class UpdateGatewayRouteHTTPRewriteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteHTTPRewriteResponseBody> body{};

  UpdateGatewayRouteHTTPRewriteResponse() {}

  explicit UpdateGatewayRouteHTTPRewriteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteHTTPRewriteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteHTTPRewriteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteHTTPRewriteResponse() = default;
};
class UpdateGatewayRouteHeaderOpRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> headerOpJSON{};
  shared_ptr<long> id{};

  UpdateGatewayRouteHeaderOpRequest() {}

  explicit UpdateGatewayRouteHeaderOpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (headerOpJSON) {
      res["HeaderOpJSON"] = boost::any(*headerOpJSON);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HeaderOpJSON") != m.end() && !m["HeaderOpJSON"].empty()) {
      headerOpJSON = make_shared<string>(boost::any_cast<string>(m["HeaderOpJSON"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateGatewayRouteHeaderOpRequest() = default;
};
class UpdateGatewayRouteHeaderOpResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteHeaderOpResponseBody() {}

  explicit UpdateGatewayRouteHeaderOpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteHeaderOpResponseBody() = default;
};
class UpdateGatewayRouteHeaderOpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteHeaderOpResponseBody> body{};

  UpdateGatewayRouteHeaderOpResponse() {}

  explicit UpdateGatewayRouteHeaderOpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteHeaderOpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteHeaderOpResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteHeaderOpResponse() = default;
};
class UpdateGatewayRouteRetryRequestRetryJSON : public Darabonba::Model {
public:
  shared_ptr<long> attempts{};
  shared_ptr<vector<string>> httpCodes{};
  shared_ptr<vector<string>> retryOn{};
  shared_ptr<string> status{};

  UpdateGatewayRouteRetryRequestRetryJSON() {}

  explicit UpdateGatewayRouteRetryRequestRetryJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attempts) {
      res["Attempts"] = boost::any(*attempts);
    }
    if (httpCodes) {
      res["HttpCodes"] = boost::any(*httpCodes);
    }
    if (retryOn) {
      res["RetryOn"] = boost::any(*retryOn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attempts") != m.end() && !m["Attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["Attempts"]));
    }
    if (m.find("HttpCodes") != m.end() && !m["HttpCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HttpCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      httpCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryOn") != m.end() && !m["RetryOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RetryOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RetryOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      retryOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateGatewayRouteRetryRequestRetryJSON() = default;
};
class UpdateGatewayRouteRetryRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<UpdateGatewayRouteRetryRequestRetryJSON> retryJSON{};

  UpdateGatewayRouteRetryRequest() {}

  explicit UpdateGatewayRouteRetryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (retryJSON) {
      res["RetryJSON"] = retryJSON ? boost::any(retryJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RetryJSON") != m.end() && !m["RetryJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["RetryJSON"].type()) {
        UpdateGatewayRouteRetryRequestRetryJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RetryJSON"]));
        retryJSON = make_shared<UpdateGatewayRouteRetryRequestRetryJSON>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteRetryRequest() = default;
};
class UpdateGatewayRouteRetryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> retryJSONShrink{};

  UpdateGatewayRouteRetryShrinkRequest() {}

  explicit UpdateGatewayRouteRetryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (retryJSONShrink) {
      res["RetryJSON"] = boost::any(*retryJSONShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RetryJSON") != m.end() && !m["RetryJSON"].empty()) {
      retryJSONShrink = make_shared<string>(boost::any_cast<string>(m["RetryJSON"]));
    }
  }


  virtual ~UpdateGatewayRouteRetryShrinkRequest() = default;
};
class UpdateGatewayRouteRetryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteRetryResponseBody() {}

  explicit UpdateGatewayRouteRetryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteRetryResponseBody() = default;
};
class UpdateGatewayRouteRetryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteRetryResponseBody> body{};

  UpdateGatewayRouteRetryResponse() {}

  explicit UpdateGatewayRouteRetryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteRetryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteRetryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteRetryResponse() = default;
};
class UpdateGatewayRouteTimeoutRequestTimeoutJSON : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  UpdateGatewayRouteTimeoutRequestTimeoutJSON() {}

  explicit UpdateGatewayRouteTimeoutRequestTimeoutJSON(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~UpdateGatewayRouteTimeoutRequestTimeoutJSON() = default;
};
class UpdateGatewayRouteTimeoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<UpdateGatewayRouteTimeoutRequestTimeoutJSON> timeoutJSON{};

  UpdateGatewayRouteTimeoutRequest() {}

  explicit UpdateGatewayRouteTimeoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (timeoutJSON) {
      res["TimeoutJSON"] = timeoutJSON ? boost::any(timeoutJSON->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TimeoutJSON") != m.end() && !m["TimeoutJSON"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeoutJSON"].type()) {
        UpdateGatewayRouteTimeoutRequestTimeoutJSON model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeoutJSON"]));
        timeoutJSON = make_shared<UpdateGatewayRouteTimeoutRequestTimeoutJSON>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteTimeoutRequest() = default;
};
class UpdateGatewayRouteTimeoutShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> timeoutJSONShrink{};

  UpdateGatewayRouteTimeoutShrinkRequest() {}

  explicit UpdateGatewayRouteTimeoutShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (timeoutJSONShrink) {
      res["TimeoutJSON"] = boost::any(*timeoutJSONShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TimeoutJSON") != m.end() && !m["TimeoutJSON"].empty()) {
      timeoutJSONShrink = make_shared<string>(boost::any_cast<string>(m["TimeoutJSON"]));
    }
  }


  virtual ~UpdateGatewayRouteTimeoutShrinkRequest() = default;
};
class UpdateGatewayRouteTimeoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteTimeoutResponseBody() {}

  explicit UpdateGatewayRouteTimeoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteTimeoutResponseBody() = default;
};
class UpdateGatewayRouteTimeoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteTimeoutResponseBody> body{};

  UpdateGatewayRouteTimeoutResponse() {}

  explicit UpdateGatewayRouteTimeoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteTimeoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteTimeoutResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteTimeoutResponse() = default;
};
class UpdateGatewayRouteWafStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> routeId{};

  UpdateGatewayRouteWafStatusRequest() {}

  explicit UpdateGatewayRouteWafStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (routeId) {
      res["RouteId"] = boost::any(*routeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("RouteId") != m.end() && !m["RouteId"].empty()) {
      routeId = make_shared<long>(boost::any_cast<long>(m["RouteId"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusRequest() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataCors : public Darabonba::Model {
public:
  shared_ptr<bool> allowCredentials{};
  shared_ptr<string> allowHeaders{};
  shared_ptr<string> allowMethods{};
  shared_ptr<string> allowOrigins{};
  shared_ptr<string> exposeHeaders{};
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  UpdateGatewayRouteWafStatusResponseBodyDataCors() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataCors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowCredentials) {
      res["AllowCredentials"] = boost::any(*allowCredentials);
    }
    if (allowHeaders) {
      res["AllowHeaders"] = boost::any(*allowHeaders);
    }
    if (allowMethods) {
      res["AllowMethods"] = boost::any(*allowMethods);
    }
    if (allowOrigins) {
      res["AllowOrigins"] = boost::any(*allowOrigins);
    }
    if (exposeHeaders) {
      res["ExposeHeaders"] = boost::any(*exposeHeaders);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowCredentials") != m.end() && !m["AllowCredentials"].empty()) {
      allowCredentials = make_shared<bool>(boost::any_cast<bool>(m["AllowCredentials"]));
    }
    if (m.find("AllowHeaders") != m.end() && !m["AllowHeaders"].empty()) {
      allowHeaders = make_shared<string>(boost::any_cast<string>(m["AllowHeaders"]));
    }
    if (m.find("AllowMethods") != m.end() && !m["AllowMethods"].empty()) {
      allowMethods = make_shared<string>(boost::any_cast<string>(m["AllowMethods"]));
    }
    if (m.find("AllowOrigins") != m.end() && !m["AllowOrigins"].empty()) {
      allowOrigins = make_shared<string>(boost::any_cast<string>(m["AllowOrigins"]));
    }
    if (m.find("ExposeHeaders") != m.end() && !m["ExposeHeaders"].empty()) {
      exposeHeaders = make_shared<string>(boost::any_cast<string>(m["ExposeHeaders"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataCors() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> code{};

  UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> path{};
  shared_ptr<string> pathType{};
  shared_ptr<string> pattern{};
  shared_ptr<string> status{};
  shared_ptr<string> substitution{};

  UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathType) {
      res["PathType"] = boost::any(*pathType);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (substitution) {
      res["Substitution"] = boost::any(*substitution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathType") != m.end() && !m["PathType"].empty()) {
      pathType = make_shared<string>(boost::any_cast<string>(m["PathType"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Substitution") != m.end() && !m["Substitution"].empty()) {
      substitution = make_shared<string>(boost::any_cast<string>(m["Substitution"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems : public Darabonba::Model {
public:
  shared_ptr<string> directionType{};
  shared_ptr<string> key{};
  shared_ptr<string> opType{};
  shared_ptr<string> value{};

  UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directionType) {
      res["DirectionType"] = boost::any(*directionType);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DirectionType") != m.end() && !m["DirectionType"].empty()) {
      directionType = make_shared<string>(boost::any_cast<string>(m["DirectionType"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems>> headerOpItems{};
  shared_ptr<string> status{};

  UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerOpItems) {
      vector<boost::any> temp1;
      for(auto item1:*headerOpItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderOpItems"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderOpItems") != m.end() && !m["HeaderOpItems"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderOpItems"].type()) {
        vector<UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderOpItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerOpItems = make_shared<vector<UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRedirect : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> host{};
  shared_ptr<string> path{};

  UpdateGatewayRouteWafStatusResponseBodyDataRedirect() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRedirect() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRetry : public Darabonba::Model {
public:
  shared_ptr<long> attempts{};
  shared_ptr<vector<string>> httpCodes{};
  shared_ptr<vector<string>> retryOn{};
  shared_ptr<string> status{};

  UpdateGatewayRouteWafStatusResponseBodyDataRetry() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRetry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attempts) {
      res["Attempts"] = boost::any(*attempts);
    }
    if (httpCodes) {
      res["HttpCodes"] = boost::any(*httpCodes);
    }
    if (retryOn) {
      res["RetryOn"] = boost::any(*retryOn);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attempts") != m.end() && !m["Attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["Attempts"]));
    }
    if (m.find("HttpCodes") != m.end() && !m["HttpCodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HttpCodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpCodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      httpCodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RetryOn") != m.end() && !m["RetryOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RetryOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RetryOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      retryOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRetry() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates : public Darabonba::Model {
public:
  shared_ptr<bool> ignoreCase{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoreCase) {
      res["IgnoreCase"] = boost::any(*ignoreCase);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoreCase") != m.end() && !m["IgnoreCase"].empty()) {
      ignoreCase = make_shared<bool>(boost::any_cast<bool>(m["IgnoreCase"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates>> headerPredicates{};
  shared_ptr<vector<string>> methodPredicates{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates> pathPredicates{};
  shared_ptr<vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates>> queryPredicates{};

  UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*headerPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HeaderPredicates"] = boost::any(temp1);
    }
    if (methodPredicates) {
      res["MethodPredicates"] = boost::any(*methodPredicates);
    }
    if (pathPredicates) {
      res["PathPredicates"] = pathPredicates ? boost::any(pathPredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (queryPredicates) {
      vector<boost::any> temp1;
      for(auto item1:*queryPredicates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueryPredicates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderPredicates") != m.end() && !m["HeaderPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["HeaderPredicates"].type()) {
        vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HeaderPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headerPredicates = make_shared<vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates>>(expect1);
      }
    }
    if (m.find("MethodPredicates") != m.end() && !m["MethodPredicates"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MethodPredicates"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MethodPredicates"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methodPredicates = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PathPredicates") != m.end() && !m["PathPredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathPredicates"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathPredicates"]));
        pathPredicates = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates>(model1);
      }
    }
    if (m.find("QueryPredicates") != m.end() && !m["QueryPredicates"].empty()) {
      if (typeid(vector<boost::any>) == m["QueryPredicates"].type()) {
        vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueryPredicates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queryPredicates = make_shared<vector<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates>>(expect1);
      }
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataRouteServices : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> percent{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> version{};

  UpdateGatewayRouteWafStatusResponseBodyDataRouteServices() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataRouteServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataRouteServices() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyDataTimeout : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> timeUnit{};
  shared_ptr<long> unitNum{};

  UpdateGatewayRouteWafStatusResponseBodyDataTimeout() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyDataTimeout(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyDataTimeout() = default;
};
class UpdateGatewayRouteWafStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataCors> cors{};
  shared_ptr<long> defaultServiceId{};
  shared_ptr<string> defaultServiceName{};
  shared_ptr<string> destinationType{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse> directResponse{};
  shared_ptr<long> domainId{};
  shared_ptr<vector<long>> domainIdList{};
  shared_ptr<string> domainName{};
  shared_ptr<vector<string>> domainNameList{};
  shared_ptr<bool> enableWaf{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite> HTTPRewrite{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp> headerOp{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> predicates{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataRedirect> redirect{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataRetry> retry{};
  shared_ptr<long> routeOrder{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates> routePredicates{};
  shared_ptr<vector<UpdateGatewayRouteWafStatusResponseBodyDataRouteServices>> routeServices{};
  shared_ptr<string> services{};
  shared_ptr<long> status{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyDataTimeout> timeout{};

  UpdateGatewayRouteWafStatusResponseBodyData() {}

  explicit UpdateGatewayRouteWafStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cors) {
      res["Cors"] = cors ? boost::any(cors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (defaultServiceId) {
      res["DefaultServiceId"] = boost::any(*defaultServiceId);
    }
    if (defaultServiceName) {
      res["DefaultServiceName"] = boost::any(*defaultServiceName);
    }
    if (destinationType) {
      res["DestinationType"] = boost::any(*destinationType);
    }
    if (directResponse) {
      res["DirectResponse"] = directResponse ? boost::any(directResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainIdList) {
      res["DomainIdList"] = boost::any(*domainIdList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameList) {
      res["DomainNameList"] = boost::any(*domainNameList);
    }
    if (enableWaf) {
      res["EnableWaf"] = boost::any(*enableWaf);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (HTTPRewrite) {
      res["HTTPRewrite"] = HTTPRewrite ? boost::any(HTTPRewrite->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (headerOp) {
      res["HeaderOp"] = headerOp ? boost::any(headerOp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (predicates) {
      res["Predicates"] = boost::any(*predicates);
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (retry) {
      res["Retry"] = retry ? boost::any(retry->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeOrder) {
      res["RouteOrder"] = boost::any(*routeOrder);
    }
    if (routePredicates) {
      res["RoutePredicates"] = routePredicates ? boost::any(routePredicates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeServices) {
      vector<boost::any> temp1;
      for(auto item1:*routeServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteServices"] = boost::any(temp1);
    }
    if (services) {
      res["Services"] = boost::any(*services);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeout) {
      res["Timeout"] = timeout ? boost::any(timeout->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cors") != m.end() && !m["Cors"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cors"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataCors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cors"]));
        cors = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataCors>(model1);
      }
    }
    if (m.find("DefaultServiceId") != m.end() && !m["DefaultServiceId"].empty()) {
      defaultServiceId = make_shared<long>(boost::any_cast<long>(m["DefaultServiceId"]));
    }
    if (m.find("DefaultServiceName") != m.end() && !m["DefaultServiceName"].empty()) {
      defaultServiceName = make_shared<string>(boost::any_cast<string>(m["DefaultServiceName"]));
    }
    if (m.find("DestinationType") != m.end() && !m["DestinationType"].empty()) {
      destinationType = make_shared<string>(boost::any_cast<string>(m["DestinationType"]));
    }
    if (m.find("DirectResponse") != m.end() && !m["DirectResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["DirectResponse"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DirectResponse"]));
        directResponse = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse>(model1);
      }
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainIdList") != m.end() && !m["DomainIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DomainIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      domainIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameList") != m.end() && !m["DomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableWaf") != m.end() && !m["EnableWaf"].empty()) {
      enableWaf = make_shared<bool>(boost::any_cast<bool>(m["EnableWaf"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HTTPRewrite") != m.end() && !m["HTTPRewrite"].empty()) {
      if (typeid(map<string, boost::any>) == m["HTTPRewrite"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HTTPRewrite"]));
        HTTPRewrite = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite>(model1);
      }
    }
    if (m.find("HeaderOp") != m.end() && !m["HeaderOp"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeaderOp"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeaderOp"]));
        headerOp = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Predicates") != m.end() && !m["Predicates"].empty()) {
      predicates = make_shared<string>(boost::any_cast<string>(m["Predicates"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataRedirect>(model1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      if (typeid(map<string, boost::any>) == m["Retry"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataRetry model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Retry"]));
        retry = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataRetry>(model1);
      }
    }
    if (m.find("RouteOrder") != m.end() && !m["RouteOrder"].empty()) {
      routeOrder = make_shared<long>(boost::any_cast<long>(m["RouteOrder"]));
    }
    if (m.find("RoutePredicates") != m.end() && !m["RoutePredicates"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoutePredicates"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoutePredicates"]));
        routePredicates = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates>(model1);
      }
    }
    if (m.find("RouteServices") != m.end() && !m["RouteServices"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteServices"].type()) {
        vector<UpdateGatewayRouteWafStatusResponseBodyDataRouteServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGatewayRouteWafStatusResponseBodyDataRouteServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeServices = make_shared<vector<UpdateGatewayRouteWafStatusResponseBodyDataRouteServices>>(expect1);
      }
    }
    if (m.find("Services") != m.end() && !m["Services"].empty()) {
      services = make_shared<string>(boost::any_cast<string>(m["Services"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeout"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyDataTimeout model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeout"]));
        timeout = make_shared<UpdateGatewayRouteWafStatusResponseBodyDataTimeout>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBodyData() = default;
};
class UpdateGatewayRouteWafStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayRouteWafStatusResponseBody() {}

  explicit UpdateGatewayRouteWafStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateGatewayRouteWafStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateGatewayRouteWafStatusResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponseBody() = default;
};
class UpdateGatewayRouteWafStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayRouteWafStatusResponseBody> body{};

  UpdateGatewayRouteWafStatusResponse() {}

  explicit UpdateGatewayRouteWafStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayRouteWafStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayRouteWafStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayRouteWafStatusResponse() = default;
};
class UpdateGatewayServiceCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> check{};
  shared_ptr<vector<long>> expectedStatuses{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<string> httpHost{};
  shared_ptr<string> httpPath{};
  shared_ptr<long> interval{};
  shared_ptr<string> protocol{};
  shared_ptr<string> serviceId{};
  shared_ptr<long> timeout{};
  shared_ptr<long> unhealthyThreshold{};

  UpdateGatewayServiceCheckRequest() {}

  explicit UpdateGatewayServiceCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (expectedStatuses) {
      res["ExpectedStatuses"] = boost::any(*expectedStatuses);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (httpHost) {
      res["HttpHost"] = boost::any(*httpHost);
    }
    if (httpPath) {
      res["HttpPath"] = boost::any(*httpPath);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("ExpectedStatuses") != m.end() && !m["ExpectedStatuses"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ExpectedStatuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExpectedStatuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      expectedStatuses = make_shared<vector<long>>(toVec1);
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("HttpHost") != m.end() && !m["HttpHost"].empty()) {
      httpHost = make_shared<string>(boost::any_cast<string>(m["HttpHost"]));
    }
    if (m.find("HttpPath") != m.end() && !m["HttpPath"].empty()) {
      httpPath = make_shared<string>(boost::any_cast<string>(m["HttpPath"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~UpdateGatewayServiceCheckRequest() = default;
};
class UpdateGatewayServiceCheckShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<bool> check{};
  shared_ptr<string> expectedStatusesShrink{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> healthyThreshold{};
  shared_ptr<string> httpHost{};
  shared_ptr<string> httpPath{};
  shared_ptr<long> interval{};
  shared_ptr<string> protocol{};
  shared_ptr<string> serviceId{};
  shared_ptr<long> timeout{};
  shared_ptr<long> unhealthyThreshold{};

  UpdateGatewayServiceCheckShrinkRequest() {}

  explicit UpdateGatewayServiceCheckShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (check) {
      res["Check"] = boost::any(*check);
    }
    if (expectedStatusesShrink) {
      res["ExpectedStatuses"] = boost::any(*expectedStatusesShrink);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (healthyThreshold) {
      res["HealthyThreshold"] = boost::any(*healthyThreshold);
    }
    if (httpHost) {
      res["HttpHost"] = boost::any(*httpHost);
    }
    if (httpPath) {
      res["HttpPath"] = boost::any(*httpPath);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (unhealthyThreshold) {
      res["UnhealthyThreshold"] = boost::any(*unhealthyThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Check") != m.end() && !m["Check"].empty()) {
      check = make_shared<bool>(boost::any_cast<bool>(m["Check"]));
    }
    if (m.find("ExpectedStatuses") != m.end() && !m["ExpectedStatuses"].empty()) {
      expectedStatusesShrink = make_shared<string>(boost::any_cast<string>(m["ExpectedStatuses"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("HealthyThreshold") != m.end() && !m["HealthyThreshold"].empty()) {
      healthyThreshold = make_shared<long>(boost::any_cast<long>(m["HealthyThreshold"]));
    }
    if (m.find("HttpHost") != m.end() && !m["HttpHost"].empty()) {
      httpHost = make_shared<string>(boost::any_cast<string>(m["HttpHost"]));
    }
    if (m.find("HttpPath") != m.end() && !m["HttpPath"].empty()) {
      httpPath = make_shared<string>(boost::any_cast<string>(m["HttpPath"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UnhealthyThreshold") != m.end() && !m["UnhealthyThreshold"].empty()) {
      unhealthyThreshold = make_shared<long>(boost::any_cast<long>(m["UnhealthyThreshold"]));
    }
  }


  virtual ~UpdateGatewayServiceCheckShrinkRequest() = default;
};
class UpdateGatewayServiceCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayServiceCheckResponseBody() {}

  explicit UpdateGatewayServiceCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayServiceCheckResponseBody() = default;
};
class UpdateGatewayServiceCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayServiceCheckResponseBody> body{};

  UpdateGatewayServiceCheckResponse() {}

  explicit UpdateGatewayServiceCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayServiceCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayServiceCheckResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayServiceCheckResponse() = default;
};
class UpdateGatewayServiceTrafficPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<TrafficPolicy> gatewayTrafficPolicy{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};

  UpdateGatewayServiceTrafficPolicyRequest() {}

  explicit UpdateGatewayServiceTrafficPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayTrafficPolicy) {
      res["GatewayTrafficPolicy"] = gatewayTrafficPolicy ? boost::any(gatewayTrafficPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayTrafficPolicy") != m.end() && !m["GatewayTrafficPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["GatewayTrafficPolicy"].type()) {
        TrafficPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GatewayTrafficPolicy"]));
        gatewayTrafficPolicy = make_shared<TrafficPolicy>(model1);
      }
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
  }


  virtual ~UpdateGatewayServiceTrafficPolicyRequest() = default;
};
class UpdateGatewayServiceTrafficPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayTrafficPolicyShrink{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};

  UpdateGatewayServiceTrafficPolicyShrinkRequest() {}

  explicit UpdateGatewayServiceTrafficPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayTrafficPolicyShrink) {
      res["GatewayTrafficPolicy"] = boost::any(*gatewayTrafficPolicyShrink);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayTrafficPolicy") != m.end() && !m["GatewayTrafficPolicy"].empty()) {
      gatewayTrafficPolicyShrink = make_shared<string>(boost::any_cast<string>(m["GatewayTrafficPolicy"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
  }


  virtual ~UpdateGatewayServiceTrafficPolicyShrinkRequest() = default;
};
class UpdateGatewayServiceTrafficPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<GatewayService> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayServiceTrafficPolicyResponseBody() {}

  explicit UpdateGatewayServiceTrafficPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GatewayService model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GatewayService>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayServiceTrafficPolicyResponseBody() = default;
};
class UpdateGatewayServiceTrafficPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayServiceTrafficPolicyResponseBody> body{};

  UpdateGatewayServiceTrafficPolicyResponse() {}

  explicit UpdateGatewayServiceTrafficPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayServiceTrafficPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayServiceTrafficPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayServiceTrafficPolicyResponse() = default;
};
class UpdateGatewayServiceVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceVersion{};

  UpdateGatewayServiceVersionRequest() {}

  explicit UpdateGatewayServiceVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (serviceVersion) {
      res["ServiceVersion"] = boost::any(*serviceVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["ServiceId"]));
    }
    if (m.find("ServiceVersion") != m.end() && !m["ServiceVersion"].empty()) {
      serviceVersion = make_shared<string>(boost::any_cast<string>(m["ServiceVersion"]));
    }
  }


  virtual ~UpdateGatewayServiceVersionRequest() = default;
};
class UpdateGatewayServiceVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewayServiceVersionResponseBody() {}

  explicit UpdateGatewayServiceVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewayServiceVersionResponseBody() = default;
};
class UpdateGatewayServiceVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewayServiceVersionResponseBody> body{};

  UpdateGatewayServiceVersionResponse() {}

  explicit UpdateGatewayServiceVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewayServiceVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewayServiceVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewayServiceVersionResponse() = default;
};
class UpdateGatewaySpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> replica{};
  shared_ptr<string> spec{};

  UpdateGatewaySpecRequest() {}

  explicit UpdateGatewaySpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (replica) {
      res["Replica"] = boost::any(*replica);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Replica") != m.end() && !m["Replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["Replica"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateGatewaySpecRequest() = default;
};
class UpdateGatewaySpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGatewaySpecResponseBody() {}

  explicit UpdateGatewaySpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGatewaySpecResponseBody() = default;
};
class UpdateGatewaySpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGatewaySpecResponseBody> body{};

  UpdateGatewaySpecResponse() {}

  explicit UpdateGatewaySpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGatewaySpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGatewaySpecResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGatewaySpecResponse() = default;
};
class UpdateImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> versionCode{};

  UpdateImageRequest() {}

  explicit UpdateImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~UpdateImageRequest() = default;
};
class UpdateImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateImageResponseBody() {}

  explicit UpdateImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateImageResponseBody() = default;
};
class UpdateImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateImageResponseBody> body{};

  UpdateImageResponse() {}

  explicit UpdateImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateImageResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateImageResponse() = default;
};
class UpdateMessageQueueRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> filterSide{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};
  shared_ptr<vector<string>> tags{};

  UpdateMessageQueueRouteRequest() {}

  explicit UpdateMessageQueueRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (filterSide) {
      res["FilterSide"] = boost::any(*filterSide);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FilterSide") != m.end() && !m["FilterSide"].empty()) {
      filterSide = make_shared<string>(boost::any_cast<string>(m["FilterSide"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMessageQueueRouteRequest() = default;
};
class UpdateMessageQueueRouteShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enable{};
  shared_ptr<string> filterSide{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> region{};
  shared_ptr<string> tagsShrink{};

  UpdateMessageQueueRouteShrinkRequest() {}

  explicit UpdateMessageQueueRouteShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (filterSide) {
      res["FilterSide"] = boost::any(*filterSide);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("FilterSide") != m.end() && !m["FilterSide"].empty()) {
      filterSide = make_shared<string>(boost::any_cast<string>(m["FilterSide"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UpdateMessageQueueRouteShrinkRequest() = default;
};
class UpdateMessageQueueRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateMessageQueueRouteResponseBody() {}

  explicit UpdateMessageQueueRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMessageQueueRouteResponseBody() = default;
};
class UpdateMessageQueueRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMessageQueueRouteResponseBody> body{};

  UpdateMessageQueueRouteResponse() {}

  explicit UpdateMessageQueueRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMessageQueueRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMessageQueueRouteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMessageQueueRouteResponse() = default;
};
class UpdateMigrationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> id{};
  shared_ptr<string> originInstanceAddress{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<string> originInstanceNamespace{};
  shared_ptr<string> projectDesc{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> targetClusterName{};
  shared_ptr<string> targetClusterUrl{};
  shared_ptr<string> targetInstanceId{};

  UpdateMigrationTaskRequest() {}

  explicit UpdateMigrationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originInstanceAddress) {
      res["OriginInstanceAddress"] = boost::any(*originInstanceAddress);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (originInstanceNamespace) {
      res["OriginInstanceNamespace"] = boost::any(*originInstanceNamespace);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (targetClusterName) {
      res["TargetClusterName"] = boost::any(*targetClusterName);
    }
    if (targetClusterUrl) {
      res["TargetClusterUrl"] = boost::any(*targetClusterUrl);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OriginInstanceAddress") != m.end() && !m["OriginInstanceAddress"].empty()) {
      originInstanceAddress = make_shared<string>(boost::any_cast<string>(m["OriginInstanceAddress"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("OriginInstanceNamespace") != m.end() && !m["OriginInstanceNamespace"].empty()) {
      originInstanceNamespace = make_shared<string>(boost::any_cast<string>(m["OriginInstanceNamespace"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("TargetClusterName") != m.end() && !m["TargetClusterName"].empty()) {
      targetClusterName = make_shared<string>(boost::any_cast<string>(m["TargetClusterName"]));
    }
    if (m.find("TargetClusterUrl") != m.end() && !m["TargetClusterUrl"].empty()) {
      targetClusterUrl = make_shared<string>(boost::any_cast<string>(m["TargetClusterUrl"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~UpdateMigrationTaskRequest() = default;
};
class UpdateMigrationTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> originInstanceAddress{};
  shared_ptr<string> originInstanceName{};
  shared_ptr<string> originInstanceNamespace{};
  shared_ptr<string> projectDesc{};
  shared_ptr<string> targetClusterName{};
  shared_ptr<string> targetClusterUrl{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> userId{};

  UpdateMigrationTaskResponseBodyData() {}

  explicit UpdateMigrationTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originInstanceAddress) {
      res["OriginInstanceAddress"] = boost::any(*originInstanceAddress);
    }
    if (originInstanceName) {
      res["OriginInstanceName"] = boost::any(*originInstanceName);
    }
    if (originInstanceNamespace) {
      res["OriginInstanceNamespace"] = boost::any(*originInstanceNamespace);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    if (targetClusterName) {
      res["TargetClusterName"] = boost::any(*targetClusterName);
    }
    if (targetClusterUrl) {
      res["TargetClusterUrl"] = boost::any(*targetClusterUrl);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OriginInstanceAddress") != m.end() && !m["OriginInstanceAddress"].empty()) {
      originInstanceAddress = make_shared<string>(boost::any_cast<string>(m["OriginInstanceAddress"]));
    }
    if (m.find("OriginInstanceName") != m.end() && !m["OriginInstanceName"].empty()) {
      originInstanceName = make_shared<string>(boost::any_cast<string>(m["OriginInstanceName"]));
    }
    if (m.find("OriginInstanceNamespace") != m.end() && !m["OriginInstanceNamespace"].empty()) {
      originInstanceNamespace = make_shared<string>(boost::any_cast<string>(m["OriginInstanceNamespace"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
    if (m.find("TargetClusterName") != m.end() && !m["TargetClusterName"].empty()) {
      targetClusterName = make_shared<string>(boost::any_cast<string>(m["TargetClusterName"]));
    }
    if (m.find("TargetClusterUrl") != m.end() && !m["TargetClusterUrl"].empty()) {
      targetClusterUrl = make_shared<string>(boost::any_cast<string>(m["TargetClusterUrl"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateMigrationTaskResponseBodyData() = default;
};
class UpdateMigrationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMigrationTaskResponseBodyData> data{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateMigrationTaskResponseBody() {}

  explicit UpdateMigrationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateMigrationTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateMigrationTaskResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMigrationTaskResponseBody() = default;
};
class UpdateMigrationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMigrationTaskResponseBody> body{};

  UpdateMigrationTaskResponse() {}

  explicit UpdateMigrationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMigrationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMigrationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMigrationTaskResponse() = default;
};
class UpdateNacosClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> checkPort{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> healthChecker{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<bool> useInstancePortForCheck{};

  UpdateNacosClusterRequest() {}

  explicit UpdateNacosClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (checkPort) {
      res["CheckPort"] = boost::any(*checkPort);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (healthChecker) {
      res["HealthChecker"] = boost::any(*healthChecker);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (useInstancePortForCheck) {
      res["UseInstancePortForCheck"] = boost::any(*useInstancePortForCheck);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CheckPort") != m.end() && !m["CheckPort"].empty()) {
      checkPort = make_shared<long>(boost::any_cast<long>(m["CheckPort"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HealthChecker") != m.end() && !m["HealthChecker"].empty()) {
      healthChecker = make_shared<string>(boost::any_cast<string>(m["HealthChecker"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("UseInstancePortForCheck") != m.end() && !m["UseInstancePortForCheck"].empty()) {
      useInstancePortForCheck = make_shared<bool>(boost::any_cast<bool>(m["UseInstancePortForCheck"]));
    }
  }


  virtual ~UpdateNacosClusterRequest() = default;
};
class UpdateNacosClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNacosClusterResponseBody() {}

  explicit UpdateNacosClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNacosClusterResponseBody() = default;
};
class UpdateNacosClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNacosClusterResponseBody> body{};

  UpdateNacosClusterResponse() {}

  explicit UpdateNacosClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNacosClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNacosClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNacosClusterResponse() = default;
};
class UpdateNacosConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> appName{};
  shared_ptr<string> betaIps{};
  shared_ptr<string> content{};
  shared_ptr<string> dataId{};
  shared_ptr<string> desc{};
  shared_ptr<string> encryptedDataKey{};
  shared_ptr<string> group{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> md5{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  UpdateNacosConfigRequest() {}

  explicit UpdateNacosConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (betaIps) {
      res["BetaIps"] = boost::any(*betaIps);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataId) {
      res["DataId"] = boost::any(*dataId);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (encryptedDataKey) {
      res["EncryptedDataKey"] = boost::any(*encryptedDataKey);
    }
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BetaIps") != m.end() && !m["BetaIps"].empty()) {
      betaIps = make_shared<string>(boost::any_cast<string>(m["BetaIps"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataId") != m.end() && !m["DataId"].empty()) {
      dataId = make_shared<string>(boost::any_cast<string>(m["DataId"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("EncryptedDataKey") != m.end() && !m["EncryptedDataKey"].empty()) {
      encryptedDataKey = make_shared<string>(boost::any_cast<string>(m["EncryptedDataKey"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateNacosConfigRequest() = default;
};
class UpdateNacosConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNacosConfigResponseBody() {}

  explicit UpdateNacosConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNacosConfigResponseBody() = default;
};
class UpdateNacosConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNacosConfigResponseBody> body{};

  UpdateNacosConfigResponse() {}

  explicit UpdateNacosConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNacosConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNacosConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNacosConfigResponse() = default;
};
class UpdateNacosInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterName{};
  shared_ptr<bool> enabled{};
  shared_ptr<bool> ephemeral{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> metadata{};
  shared_ptr<string> namespaceId{};
  shared_ptr<long> port{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> weight{};

  UpdateNacosInstanceRequest() {}

  explicit UpdateNacosInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (ephemeral) {
      res["Ephemeral"] = boost::any(*ephemeral);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (metadata) {
      res["Metadata"] = boost::any(*metadata);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Ephemeral") != m.end() && !m["Ephemeral"].empty()) {
      ephemeral = make_shared<bool>(boost::any_cast<bool>(m["Ephemeral"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Metadata") != m.end() && !m["Metadata"].empty()) {
      metadata = make_shared<string>(boost::any_cast<string>(m["Metadata"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~UpdateNacosInstanceRequest() = default;
};
class UpdateNacosInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNacosInstanceResponseBody() {}

  explicit UpdateNacosInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNacosInstanceResponseBody() = default;
};
class UpdateNacosInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNacosInstanceResponseBody> body{};

  UpdateNacosInstanceResponse() {}

  explicit UpdateNacosInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNacosInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNacosInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNacosInstanceResponse() = default;
};
class UpdateNacosServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> protectThreshold{};
  shared_ptr<string> serviceName{};

  UpdateNacosServiceRequest() {}

  explicit UpdateNacosServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (protectThreshold) {
      res["ProtectThreshold"] = boost::any(*protectThreshold);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("ProtectThreshold") != m.end() && !m["ProtectThreshold"].empty()) {
      protectThreshold = make_shared<string>(boost::any_cast<string>(m["ProtectThreshold"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~UpdateNacosServiceRequest() = default;
};
class UpdateNacosServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateNacosServiceResponseBody() {}

  explicit UpdateNacosServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateNacosServiceResponseBody() = default;
};
class UpdateNacosServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNacosServiceResponseBody> body{};

  UpdateNacosServiceResponse() {}

  explicit UpdateNacosServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNacosServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNacosServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNacosServiceResponse() = default;
};
class UpdatePluginConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> config{};
  shared_ptr<long> configLevel{};
  shared_ptr<bool> enable{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> pluginId{};

  UpdatePluginConfigRequest() {}

  explicit UpdatePluginConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (configLevel) {
      res["ConfigLevel"] = boost::any(*configLevel);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ConfigLevel") != m.end() && !m["ConfigLevel"].empty()) {
      configLevel = make_shared<long>(boost::any_cast<long>(m["ConfigLevel"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<long>(boost::any_cast<long>(m["PluginId"]));
    }
  }


  virtual ~UpdatePluginConfigRequest() = default;
};
class UpdatePluginConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePluginConfigResponseBody() {}

  explicit UpdatePluginConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePluginConfigResponseBody() = default;
};
class UpdatePluginConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePluginConfigResponseBody> body{};

  UpdatePluginConfigResponse() {}

  explicit UpdatePluginConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePluginConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePluginConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePluginConfigResponse() = default;
};
class UpdateSSLCertRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> domainId{};
  shared_ptr<string> gatewayUniqueId{};

  UpdateSSLCertRequest() {}

  explicit UpdateSSLCertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
  }


  virtual ~UpdateSSLCertRequest() = default;
};
class UpdateSSLCertResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateSSLCertResponseBody() {}

  explicit UpdateSSLCertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateSSLCertResponseBody() = default;
};
class UpdateSSLCertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSSLCertResponseBody> body{};

  UpdateSSLCertResponse() {}

  explicit UpdateSSLCertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSSLCertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSSLCertResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSSLCertResponse() = default;
};
class UpdateServiceSourceRequestIngressOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableIngress{};
  shared_ptr<bool> enableStatus{};
  shared_ptr<string> ingressClass{};
  shared_ptr<string> watchNamespace{};

  UpdateServiceSourceRequestIngressOptionsRequest() {}

  explicit UpdateServiceSourceRequestIngressOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIngress) {
      res["EnableIngress"] = boost::any(*enableIngress);
    }
    if (enableStatus) {
      res["EnableStatus"] = boost::any(*enableStatus);
    }
    if (ingressClass) {
      res["IngressClass"] = boost::any(*ingressClass);
    }
    if (watchNamespace) {
      res["WatchNamespace"] = boost::any(*watchNamespace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIngress") != m.end() && !m["EnableIngress"].empty()) {
      enableIngress = make_shared<bool>(boost::any_cast<bool>(m["EnableIngress"]));
    }
    if (m.find("EnableStatus") != m.end() && !m["EnableStatus"].empty()) {
      enableStatus = make_shared<bool>(boost::any_cast<bool>(m["EnableStatus"]));
    }
    if (m.find("IngressClass") != m.end() && !m["IngressClass"].empty()) {
      ingressClass = make_shared<string>(boost::any_cast<string>(m["IngressClass"]));
    }
    if (m.find("WatchNamespace") != m.end() && !m["WatchNamespace"].empty()) {
      watchNamespace = make_shared<string>(boost::any_cast<string>(m["WatchNamespace"]));
    }
  }


  virtual ~UpdateServiceSourceRequestIngressOptionsRequest() = default;
};
class UpdateServiceSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<UpdateServiceSourceRequestIngressOptionsRequest> ingressOptionsRequest{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> pathList{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  UpdateServiceSourceRequest() {}

  explicit UpdateServiceSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ingressOptionsRequest) {
      res["IngressOptionsRequest"] = ingressOptionsRequest ? boost::any(ingressOptionsRequest->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pathList) {
      res["PathList"] = boost::any(*pathList);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IngressOptionsRequest") != m.end() && !m["IngressOptionsRequest"].empty()) {
      if (typeid(map<string, boost::any>) == m["IngressOptionsRequest"].type()) {
        UpdateServiceSourceRequestIngressOptionsRequest model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IngressOptionsRequest"]));
        ingressOptionsRequest = make_shared<UpdateServiceSourceRequestIngressOptionsRequest>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PathList") != m.end() && !m["PathList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PathList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PathList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pathList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateServiceSourceRequest() = default;
};
class UpdateServiceSourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> address{};
  shared_ptr<long> gatewayId{};
  shared_ptr<string> gatewayUniqueId{};
  shared_ptr<long> id{};
  shared_ptr<string> ingressOptionsRequestShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> pathListShrink{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};

  UpdateServiceSourceShrinkRequest() {}

  explicit UpdateServiceSourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (gatewayId) {
      res["GatewayId"] = boost::any(*gatewayId);
    }
    if (gatewayUniqueId) {
      res["GatewayUniqueId"] = boost::any(*gatewayUniqueId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ingressOptionsRequestShrink) {
      res["IngressOptionsRequest"] = boost::any(*ingressOptionsRequestShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pathListShrink) {
      res["PathList"] = boost::any(*pathListShrink);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("GatewayId") != m.end() && !m["GatewayId"].empty()) {
      gatewayId = make_shared<long>(boost::any_cast<long>(m["GatewayId"]));
    }
    if (m.find("GatewayUniqueId") != m.end() && !m["GatewayUniqueId"].empty()) {
      gatewayUniqueId = make_shared<string>(boost::any_cast<string>(m["GatewayUniqueId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IngressOptionsRequest") != m.end() && !m["IngressOptionsRequest"].empty()) {
      ingressOptionsRequestShrink = make_shared<string>(boost::any_cast<string>(m["IngressOptionsRequest"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PathList") != m.end() && !m["PathList"].empty()) {
      pathListShrink = make_shared<string>(boost::any_cast<string>(m["PathList"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateServiceSourceShrinkRequest() = default;
};
class UpdateServiceSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateServiceSourceResponseBody() {}

  explicit UpdateServiceSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateServiceSourceResponseBody() = default;
};
class UpdateServiceSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceSourceResponseBody> body{};

  UpdateServiceSourceResponse() {}

  explicit UpdateServiceSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceSourceResponse() = default;
};
class UpdateZnodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> data{};
  shared_ptr<string> path{};
  shared_ptr<string> requestPars{};

  UpdateZnodeRequest() {}

  explicit UpdateZnodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
  }


  virtual ~UpdateZnodeRequest() = default;
};
class UpdateZnodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateZnodeResponseBody() {}

  explicit UpdateZnodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateZnodeResponseBody() = default;
};
class UpdateZnodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateZnodeResponseBody> body{};

  UpdateZnodeResponse() {}

  explicit UpdateZnodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateZnodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateZnodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateZnodeResponse() = default;
};
class UpgradeClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestPars{};
  shared_ptr<string> upgradeVersion{};

  UpgradeClusterRequest() {}

  explicit UpgradeClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestPars) {
      res["RequestPars"] = boost::any(*requestPars);
    }
    if (upgradeVersion) {
      res["UpgradeVersion"] = boost::any(*upgradeVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestPars") != m.end() && !m["RequestPars"].empty()) {
      requestPars = make_shared<string>(boost::any_cast<string>(m["RequestPars"]));
    }
    if (m.find("UpgradeVersion") != m.end() && !m["UpgradeVersion"].empty()) {
      upgradeVersion = make_shared<string>(boost::any_cast<string>(m["UpgradeVersion"]));
    }
  }


  virtual ~UpgradeClusterRequest() = default;
};
class UpgradeClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpgradeClusterResponseBody() {}

  explicit UpgradeClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeClusterResponseBody() = default;
};
class UpgradeClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeClusterResponseBody> body{};

  UpgradeClusterResponse() {}

  explicit UpgradeClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeClusterResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAuthPolicyResponse addAuthPolicyWithOptions(shared_ptr<AddAuthPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAuthPolicyResponse addAuthPolicy(shared_ptr<AddAuthPolicyRequest> request);
  AddAuthResourceResponse addAuthResourceWithOptions(shared_ptr<AddAuthResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAuthResourceResponse addAuthResource(shared_ptr<AddAuthResourceRequest> request);
  AddBlackWhiteListResponse addBlackWhiteListWithOptions(shared_ptr<AddBlackWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBlackWhiteListResponse addBlackWhiteList(shared_ptr<AddBlackWhiteListRequest> request);
  AddGatewayResponse addGatewayWithOptions(shared_ptr<AddGatewayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewayResponse addGateway(shared_ptr<AddGatewayRequest> request);
  AddGatewayAuthConsumerResponse addGatewayAuthConsumerWithOptions(shared_ptr<AddGatewayAuthConsumerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewayAuthConsumerResponse addGatewayAuthConsumer(shared_ptr<AddGatewayAuthConsumerRequest> request);
  AddGatewayDomainResponse addGatewayDomainWithOptions(shared_ptr<AddGatewayDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewayDomainResponse addGatewayDomain(shared_ptr<AddGatewayDomainRequest> request);
  AddGatewayRouteResponse addGatewayRouteWithOptions(shared_ptr<AddGatewayRouteRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewayRouteResponse addGatewayRoute(shared_ptr<AddGatewayRouteRequest> request);
  AddGatewayServiceVersionResponse addGatewayServiceVersionWithOptions(shared_ptr<AddGatewayServiceVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewayServiceVersionResponse addGatewayServiceVersion(shared_ptr<AddGatewayServiceVersionRequest> request);
  AddGatewaySlbResponse addGatewaySlbWithOptions(shared_ptr<AddGatewaySlbRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddGatewaySlbResponse addGatewaySlb(shared_ptr<AddGatewaySlbRequest> request);
  AddMigrationTaskResponse addMigrationTaskWithOptions(shared_ptr<AddMigrationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMigrationTaskResponse addMigrationTask(shared_ptr<AddMigrationTaskRequest> request);
  AddMockRuleResponse addMockRuleWithOptions(shared_ptr<AddMockRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMockRuleResponse addMockRule(shared_ptr<AddMockRuleRequest> request);
  AddSSLCertResponse addSSLCertWithOptions(shared_ptr<AddSSLCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSSLCertResponse addSSLCert(shared_ptr<AddSSLCertRequest> request);
  AddSecurityGroupRuleResponse addSecurityGroupRuleWithOptions(shared_ptr<AddSecurityGroupRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSecurityGroupRuleResponse addSecurityGroupRule(shared_ptr<AddSecurityGroupRuleRequest> request);
  AddServiceSourceResponse addServiceSourceWithOptions(shared_ptr<AddServiceSourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddServiceSourceResponse addServiceSource(shared_ptr<AddServiceSourceRequest> request);
  ApplyGatewayRouteResponse applyGatewayRouteWithOptions(shared_ptr<ApplyGatewayRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyGatewayRouteResponse applyGatewayRoute(shared_ptr<ApplyGatewayRouteRequest> request);
  ApplyTagPoliciesResponse applyTagPoliciesWithOptions(shared_ptr<ApplyTagPoliciesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyTagPoliciesResponse applyTagPolicies(shared_ptr<ApplyTagPoliciesRequest> request);
  CloneNacosConfigResponse cloneNacosConfigWithOptions(shared_ptr<CloneNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloneNacosConfigResponse cloneNacosConfig(shared_ptr<CloneNacosConfigRequest> request);
  CreateApplicationResponse createApplicationWithOptions(shared_ptr<CreateApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationResponse createApplication(shared_ptr<CreateApplicationRequest> request);
  CreateCircuitBreakerRuleResponse createCircuitBreakerRuleWithOptions(shared_ptr<CreateCircuitBreakerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCircuitBreakerRuleResponse createCircuitBreakerRule(shared_ptr<CreateCircuitBreakerRuleRequest> request);
  CreateClusterResponse createClusterWithOptions(shared_ptr<CreateClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateClusterResponse createCluster(shared_ptr<CreateClusterRequest> request);
  CreateEngineNamespaceResponse createEngineNamespaceWithOptions(shared_ptr<CreateEngineNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEngineNamespaceResponse createEngineNamespace(shared_ptr<CreateEngineNamespaceRequest> request);
  CreateFlowRuleResponse createFlowRuleWithOptions(shared_ptr<CreateFlowRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowRuleResponse createFlowRule(shared_ptr<CreateFlowRuleRequest> request);
  CreateMseServiceApplicationResponse createMseServiceApplicationWithOptions(shared_ptr<CreateMseServiceApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMseServiceApplicationResponse createMseServiceApplication(shared_ptr<CreateMseServiceApplicationRequest> request);
  CreateNacosConfigResponse createNacosConfigWithOptions(shared_ptr<CreateNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNacosConfigResponse createNacosConfig(shared_ptr<CreateNacosConfigRequest> request);
  CreateNacosInstanceResponse createNacosInstanceWithOptions(shared_ptr<CreateNacosInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNacosInstanceResponse createNacosInstance(shared_ptr<CreateNacosInstanceRequest> request);
  CreateNacosServiceResponse createNacosServiceWithOptions(shared_ptr<CreateNacosServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNacosServiceResponse createNacosService(shared_ptr<CreateNacosServiceRequest> request);
  CreateOrUpdateSwimmingLaneResponse createOrUpdateSwimmingLaneWithOptions(shared_ptr<CreateOrUpdateSwimmingLaneRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSwimmingLaneResponse createOrUpdateSwimmingLane(shared_ptr<CreateOrUpdateSwimmingLaneRequest> request);
  CreateOrUpdateSwimmingLaneGroupResponse createOrUpdateSwimmingLaneGroupWithOptions(shared_ptr<CreateOrUpdateSwimmingLaneGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateSwimmingLaneGroupResponse createOrUpdateSwimmingLaneGroup(shared_ptr<CreateOrUpdateSwimmingLaneGroupRequest> request);
  CreateZnodeResponse createZnodeWithOptions(shared_ptr<CreateZnodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateZnodeResponse createZnode(shared_ptr<CreateZnodeRequest> request);
  DeleteAuthResourceResponse deleteAuthResourceWithOptions(shared_ptr<DeleteAuthResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAuthResourceResponse deleteAuthResource(shared_ptr<DeleteAuthResourceRequest> request);
  DeleteCircuitBreakerRulesResponse deleteCircuitBreakerRulesWithOptions(shared_ptr<DeleteCircuitBreakerRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCircuitBreakerRulesResponse deleteCircuitBreakerRules(shared_ptr<DeleteCircuitBreakerRulesRequest> request);
  DeleteClusterResponse deleteClusterWithOptions(shared_ptr<DeleteClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClusterResponse deleteCluster(shared_ptr<DeleteClusterRequest> request);
  DeleteEngineNamespaceResponse deleteEngineNamespaceWithOptions(shared_ptr<DeleteEngineNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEngineNamespaceResponse deleteEngineNamespace(shared_ptr<DeleteEngineNamespaceRequest> request);
  DeleteFlowRulesResponse deleteFlowRulesWithOptions(shared_ptr<DeleteFlowRulesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowRulesResponse deleteFlowRules(shared_ptr<DeleteFlowRulesRequest> request);
  DeleteGatewayResponse deleteGatewayWithOptions(shared_ptr<DeleteGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayResponse deleteGateway(shared_ptr<DeleteGatewayRequest> request);
  DeleteGatewayAuthConsumerResponse deleteGatewayAuthConsumerWithOptions(shared_ptr<DeleteGatewayAuthConsumerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayAuthConsumerResponse deleteGatewayAuthConsumer(shared_ptr<DeleteGatewayAuthConsumerRequest> request);
  DeleteGatewayAuthConsumerResourceResponse deleteGatewayAuthConsumerResourceWithOptions(shared_ptr<DeleteGatewayAuthConsumerResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayAuthConsumerResourceResponse deleteGatewayAuthConsumerResource(shared_ptr<DeleteGatewayAuthConsumerResourceRequest> request);
  DeleteGatewayDomainResponse deleteGatewayDomainWithOptions(shared_ptr<DeleteGatewayDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayDomainResponse deleteGatewayDomain(shared_ptr<DeleteGatewayDomainRequest> request);
  DeleteGatewayRouteResponse deleteGatewayRouteWithOptions(shared_ptr<DeleteGatewayRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayRouteResponse deleteGatewayRoute(shared_ptr<DeleteGatewayRouteRequest> request);
  DeleteGatewayServiceResponse deleteGatewayServiceWithOptions(shared_ptr<DeleteGatewayServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayServiceResponse deleteGatewayService(shared_ptr<DeleteGatewayServiceRequest> request);
  DeleteGatewayServiceVersionResponse deleteGatewayServiceVersionWithOptions(shared_ptr<DeleteGatewayServiceVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewayServiceVersionResponse deleteGatewayServiceVersion(shared_ptr<DeleteGatewayServiceVersionRequest> request);
  DeleteGatewaySlbResponse deleteGatewaySlbWithOptions(shared_ptr<DeleteGatewaySlbRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGatewaySlbResponse deleteGatewaySlb(shared_ptr<DeleteGatewaySlbRequest> request);
  DeleteMigrationTaskResponse deleteMigrationTaskWithOptions(shared_ptr<DeleteMigrationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMigrationTaskResponse deleteMigrationTask(shared_ptr<DeleteMigrationTaskRequest> request);
  DeleteNacosConfigResponse deleteNacosConfigWithOptions(shared_ptr<DeleteNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNacosConfigResponse deleteNacosConfig(shared_ptr<DeleteNacosConfigRequest> request);
  DeleteNacosConfigsResponse deleteNacosConfigsWithOptions(shared_ptr<DeleteNacosConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNacosConfigsResponse deleteNacosConfigs(shared_ptr<DeleteNacosConfigsRequest> request);
  DeleteNacosInstanceResponse deleteNacosInstanceWithOptions(shared_ptr<DeleteNacosInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNacosInstanceResponse deleteNacosInstance(shared_ptr<DeleteNacosInstanceRequest> request);
  DeleteNacosServiceResponse deleteNacosServiceWithOptions(shared_ptr<DeleteNacosServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNacosServiceResponse deleteNacosService(shared_ptr<DeleteNacosServiceRequest> request);
  DeleteNamespaceResponse deleteNamespaceWithOptions(shared_ptr<DeleteNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNamespaceResponse deleteNamespace(shared_ptr<DeleteNamespaceRequest> request);
  DeleteSecurityGroupRuleResponse deleteSecurityGroupRuleWithOptions(shared_ptr<DeleteSecurityGroupRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityGroupRuleResponse deleteSecurityGroupRule(shared_ptr<DeleteSecurityGroupRuleRequest> request);
  DeleteServiceSourceResponse deleteServiceSourceWithOptions(shared_ptr<DeleteServiceSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceSourceResponse deleteServiceSource(shared_ptr<DeleteServiceSourceRequest> request);
  DeleteSwimmingLaneResponse deleteSwimmingLaneWithOptions(shared_ptr<DeleteSwimmingLaneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneResponse deleteSwimmingLane(shared_ptr<DeleteSwimmingLaneRequest> request);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroupWithOptions(shared_ptr<DeleteSwimmingLaneGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSwimmingLaneGroupResponse deleteSwimmingLaneGroup(shared_ptr<DeleteSwimmingLaneGroupRequest> request);
  DeleteZnodeResponse deleteZnodeWithOptions(shared_ptr<DeleteZnodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteZnodeResponse deleteZnode(shared_ptr<DeleteZnodeRequest> request);
  ExportNacosConfigResponse exportNacosConfigWithOptions(shared_ptr<ExportNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportNacosConfigResponse exportNacosConfig(shared_ptr<ExportNacosConfigRequest> request);
  ExportZookeeperDataResponse exportZookeeperDataWithOptions(shared_ptr<ExportZookeeperDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportZookeeperDataResponse exportZookeeperData(shared_ptr<ExportZookeeperDataRequest> request);
  FetchLosslessRuleListResponse fetchLosslessRuleListWithOptions(shared_ptr<FetchLosslessRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FetchLosslessRuleListResponse fetchLosslessRuleList(shared_ptr<FetchLosslessRuleListRequest> request);
  GetAppMessageQueueRouteResponse getAppMessageQueueRouteWithOptions(shared_ptr<GetAppMessageQueueRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppMessageQueueRouteResponse getAppMessageQueueRoute(shared_ptr<GetAppMessageQueueRouteRequest> request);
  GetApplicationInstanceListResponse getApplicationInstanceListWithOptions(shared_ptr<GetApplicationInstanceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationInstanceListResponse getApplicationInstanceList(shared_ptr<GetApplicationInstanceListRequest> request);
  GetApplicationListResponse getApplicationListWithOptions(shared_ptr<GetApplicationListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationListResponse getApplicationList(shared_ptr<GetApplicationListRequest> request);
  GetBlackWhiteListResponse getBlackWhiteListWithOptions(shared_ptr<GetBlackWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBlackWhiteListResponse getBlackWhiteList(shared_ptr<GetBlackWhiteListRequest> request);
  GetEngineNamepaceResponse getEngineNamepaceWithOptions(shared_ptr<GetEngineNamepaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEngineNamepaceResponse getEngineNamepace(shared_ptr<GetEngineNamepaceRequest> request);
  GetGatewayResponse getGatewayWithOptions(shared_ptr<GetGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayResponse getGateway(shared_ptr<GetGatewayRequest> request);
  GetGatewayAuthConsumerDetailResponse getGatewayAuthConsumerDetailWithOptions(shared_ptr<GetGatewayAuthConsumerDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayAuthConsumerDetailResponse getGatewayAuthConsumerDetail(shared_ptr<GetGatewayAuthConsumerDetailRequest> request);
  GetGatewayDomainDetailResponse getGatewayDomainDetailWithOptions(shared_ptr<GetGatewayDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayDomainDetailResponse getGatewayDomainDetail(shared_ptr<GetGatewayDomainDetailRequest> request);
  GetGatewayOptionResponse getGatewayOptionWithOptions(shared_ptr<GetGatewayOptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayOptionResponse getGatewayOption(shared_ptr<GetGatewayOptionRequest> request);
  GetGatewayRouteDetailResponse getGatewayRouteDetailWithOptions(shared_ptr<GetGatewayRouteDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayRouteDetailResponse getGatewayRouteDetail(shared_ptr<GetGatewayRouteDetailRequest> request);
  GetGatewayServiceDetailResponse getGatewayServiceDetailWithOptions(shared_ptr<GetGatewayServiceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGatewayServiceDetailResponse getGatewayServiceDetail(shared_ptr<GetGatewayServiceDetailRequest> request);
  GetGovernanceKubernetesClusterResponse getGovernanceKubernetesClusterWithOptions(shared_ptr<GetGovernanceKubernetesClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGovernanceKubernetesClusterResponse getGovernanceKubernetesCluster(shared_ptr<GetGovernanceKubernetesClusterRequest> request);
  GetImageResponse getImageWithOptions(shared_ptr<GetImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImageResponse getImage(shared_ptr<GetImageRequest> request);
  GetImportFileUrlResponse getImportFileUrlWithOptions(shared_ptr<GetImportFileUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImportFileUrlResponse getImportFileUrl(shared_ptr<GetImportFileUrlRequest> request);
  GetKubernetesSourceResponse getKubernetesSourceWithOptions(shared_ptr<GetKubernetesSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetKubernetesSourceResponse getKubernetesSource(shared_ptr<GetKubernetesSourceRequest> request);
  GetLosslessRuleByAppResponse getLosslessRuleByAppWithOptions(shared_ptr<GetLosslessRuleByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLosslessRuleByAppResponse getLosslessRuleByApp(shared_ptr<GetLosslessRuleByAppRequest> request);
  GetMseFeatureSwitchResponse getMseFeatureSwitchWithOptions(shared_ptr<GetMseFeatureSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMseFeatureSwitchResponse getMseFeatureSwitch(shared_ptr<GetMseFeatureSwitchRequest> request);
  GetMseSourceResponse getMseSourceWithOptions(shared_ptr<GetMseSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMseSourceResponse getMseSource(shared_ptr<GetMseSourceRequest> request);
  GetNacosConfigResponse getNacosConfigWithOptions(shared_ptr<GetNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNacosConfigResponse getNacosConfig(shared_ptr<GetNacosConfigRequest> request);
  GetNacosHistoryConfigResponse getNacosHistoryConfigWithOptions(shared_ptr<GetNacosHistoryConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNacosHistoryConfigResponse getNacosHistoryConfig(shared_ptr<GetNacosHistoryConfigRequest> request);
  GetOverviewResponse getOverviewWithOptions(shared_ptr<GetOverviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOverviewResponse getOverview(shared_ptr<GetOverviewRequest> request);
  GetPluginConfigResponse getPluginConfigWithOptions(shared_ptr<GetPluginConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPluginConfigResponse getPluginConfig(shared_ptr<GetPluginConfigRequest> request);
  GetPluginsResponse getPluginsWithOptions(shared_ptr<GetPluginsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPluginsResponse getPlugins(shared_ptr<GetPluginsRequest> request);
  GetServiceListResponse getServiceListWithOptions(shared_ptr<GetServiceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListResponse getServiceList(shared_ptr<GetServiceListRequest> request);
  GetServiceListPageResponse getServiceListPageWithOptions(shared_ptr<GetServiceListPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListPageResponse getServiceListPage(shared_ptr<GetServiceListPageRequest> request);
  GetServiceListenersResponse getServiceListenersWithOptions(shared_ptr<GetServiceListenersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceListenersResponse getServiceListeners(shared_ptr<GetServiceListenersRequest> request);
  GetServiceMethodPageResponse getServiceMethodPageWithOptions(shared_ptr<GetServiceMethodPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceMethodPageResponse getServiceMethodPage(shared_ptr<GetServiceMethodPageRequest> request);
  GetTagsBySwimmingLaneGroupIdResponse getTagsBySwimmingLaneGroupIdWithOptions(shared_ptr<GetTagsBySwimmingLaneGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTagsBySwimmingLaneGroupIdResponse getTagsBySwimmingLaneGroupId(shared_ptr<GetTagsBySwimmingLaneGroupIdRequest> request);
  GetZookeeperDataImportUrlResponse getZookeeperDataImportUrlWithOptions(shared_ptr<GetZookeeperDataImportUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetZookeeperDataImportUrlResponse getZookeeperDataImportUrl(shared_ptr<GetZookeeperDataImportUrlRequest> request);
  ImportNacosConfigResponse importNacosConfigWithOptions(shared_ptr<ImportNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportNacosConfigResponse importNacosConfig(shared_ptr<ImportNacosConfigRequest> request);
  ImportServicesResponse importServicesWithOptions(shared_ptr<ImportServicesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportServicesResponse importServices(shared_ptr<ImportServicesRequest> request);
  ImportZookeeperDataResponse importZookeeperDataWithOptions(shared_ptr<ImportZookeeperDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportZookeeperDataResponse importZookeeperData(shared_ptr<ImportZookeeperDataRequest> request);
  ListAnsInstancesResponse listAnsInstancesWithOptions(shared_ptr<ListAnsInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnsInstancesResponse listAnsInstances(shared_ptr<ListAnsInstancesRequest> request);
  ListAnsServiceClustersResponse listAnsServiceClustersWithOptions(shared_ptr<ListAnsServiceClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnsServiceClustersResponse listAnsServiceClusters(shared_ptr<ListAnsServiceClustersRequest> request);
  ListAnsServicesResponse listAnsServicesWithOptions(shared_ptr<ListAnsServicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnsServicesResponse listAnsServices(shared_ptr<ListAnsServicesRequest> request);
  ListAppBySwimmingLaneGroupTagResponse listAppBySwimmingLaneGroupTagWithOptions(shared_ptr<ListAppBySwimmingLaneGroupTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppBySwimmingLaneGroupTagResponse listAppBySwimmingLaneGroupTag(shared_ptr<ListAppBySwimmingLaneGroupTagRequest> request);
  ListAppBySwimmingLaneGroupTagsResponse listAppBySwimmingLaneGroupTagsWithOptions(shared_ptr<ListAppBySwimmingLaneGroupTagsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppBySwimmingLaneGroupTagsResponse listAppBySwimmingLaneGroupTags(shared_ptr<ListAppBySwimmingLaneGroupTagsRequest> request);
  ListApplicationsWithTagRulesResponse listApplicationsWithTagRulesWithOptions(shared_ptr<ListApplicationsWithTagRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsWithTagRulesResponse listApplicationsWithTagRules(shared_ptr<ListApplicationsWithTagRulesRequest> request);
  ListAuthPolicyResponse listAuthPolicyWithOptions(shared_ptr<ListAuthPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuthPolicyResponse listAuthPolicy(shared_ptr<ListAuthPolicyRequest> request);
  ListCircuitBreakerRulesResponse listCircuitBreakerRulesWithOptions(shared_ptr<ListCircuitBreakerRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCircuitBreakerRulesResponse listCircuitBreakerRules(shared_ptr<ListCircuitBreakerRulesRequest> request);
  ListClusterConnectionTypesResponse listClusterConnectionTypesWithOptions(shared_ptr<ListClusterConnectionTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterConnectionTypesResponse listClusterConnectionTypes(shared_ptr<ListClusterConnectionTypesRequest> request);
  ListClusterHealthCheckTaskResponse listClusterHealthCheckTaskWithOptions(shared_ptr<ListClusterHealthCheckTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterHealthCheckTaskResponse listClusterHealthCheckTask(shared_ptr<ListClusterHealthCheckTaskRequest> request);
  ListClusterTypesResponse listClusterTypesWithOptions(shared_ptr<ListClusterTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterTypesResponse listClusterTypes(shared_ptr<ListClusterTypesRequest> request);
  ListClusterVersionsResponse listClusterVersionsWithOptions(shared_ptr<ListClusterVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterVersionsResponse listClusterVersions(shared_ptr<ListClusterVersionsRequest> request);
  ListClustersResponse listClustersWithOptions(shared_ptr<ListClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClustersResponse listClusters(shared_ptr<ListClustersRequest> request);
  ListConfigTrackResponse listConfigTrackWithOptions(shared_ptr<ListConfigTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigTrackResponse listConfigTrack(shared_ptr<ListConfigTrackRequest> request);
  ListEngineNamespacesResponse listEngineNamespacesWithOptions(shared_ptr<ListEngineNamespacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEngineNamespacesResponse listEngineNamespaces(shared_ptr<ListEngineNamespacesRequest> request);
  ListEurekaInstancesResponse listEurekaInstancesWithOptions(shared_ptr<ListEurekaInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEurekaInstancesResponse listEurekaInstances(shared_ptr<ListEurekaInstancesRequest> request);
  ListEurekaServicesResponse listEurekaServicesWithOptions(shared_ptr<ListEurekaServicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEurekaServicesResponse listEurekaServices(shared_ptr<ListEurekaServicesRequest> request);
  ListExportZookeeperDataResponse listExportZookeeperDataWithOptions(shared_ptr<ListExportZookeeperDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListExportZookeeperDataResponse listExportZookeeperData(shared_ptr<ListExportZookeeperDataRequest> request);
  ListFlowRulesResponse listFlowRulesWithOptions(shared_ptr<ListFlowRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFlowRulesResponse listFlowRules(shared_ptr<ListFlowRulesRequest> request);
  ListGatewayResponse listGatewayWithOptions(shared_ptr<ListGatewayRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayResponse listGateway(shared_ptr<ListGatewayRequest> request);
  ListGatewayAuthConsumerResponse listGatewayAuthConsumerWithOptions(shared_ptr<ListGatewayAuthConsumerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayAuthConsumerResponse listGatewayAuthConsumer(shared_ptr<ListGatewayAuthConsumerRequest> request);
  ListGatewayAuthConsumerResourceResponse listGatewayAuthConsumerResourceWithOptions(shared_ptr<ListGatewayAuthConsumerResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayAuthConsumerResourceResponse listGatewayAuthConsumerResource(shared_ptr<ListGatewayAuthConsumerResourceRequest> request);
  ListGatewayDomainResponse listGatewayDomainWithOptions(shared_ptr<ListGatewayDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayDomainResponse listGatewayDomain(shared_ptr<ListGatewayDomainRequest> request);
  ListGatewayRouteResponse listGatewayRouteWithOptions(shared_ptr<ListGatewayRouteRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayRouteResponse listGatewayRoute(shared_ptr<ListGatewayRouteRequest> request);
  ListGatewayRouteOnAuthResponse listGatewayRouteOnAuthWithOptions(shared_ptr<ListGatewayRouteOnAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayRouteOnAuthResponse listGatewayRouteOnAuth(shared_ptr<ListGatewayRouteOnAuthRequest> request);
  ListGatewayServiceResponse listGatewayServiceWithOptions(shared_ptr<ListGatewayServiceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewayServiceResponse listGatewayService(shared_ptr<ListGatewayServiceRequest> request);
  ListGatewaySlbResponse listGatewaySlbWithOptions(shared_ptr<ListGatewaySlbRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGatewaySlbResponse listGatewaySlb(shared_ptr<ListGatewaySlbRequest> request);
  ListInstanceCountResponse listInstanceCountWithOptions(shared_ptr<ListInstanceCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceCountResponse listInstanceCount(shared_ptr<ListInstanceCountRequest> request);
  ListListenersByConfigResponse listListenersByConfigWithOptions(shared_ptr<ListListenersByConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListListenersByConfigResponse listListenersByConfig(shared_ptr<ListListenersByConfigRequest> request);
  ListListenersByIpResponse listListenersByIpWithOptions(shared_ptr<ListListenersByIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListListenersByIpResponse listListenersByIp(shared_ptr<ListListenersByIpRequest> request);
  ListMigrationTaskResponse listMigrationTaskWithOptions(shared_ptr<ListMigrationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMigrationTaskResponse listMigrationTask(shared_ptr<ListMigrationTaskRequest> request);
  ListNacosConfigsResponse listNacosConfigsWithOptions(shared_ptr<ListNacosConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNacosConfigsResponse listNacosConfigs(shared_ptr<ListNacosConfigsRequest> request);
  ListNacosHistoryConfigsResponse listNacosHistoryConfigsWithOptions(shared_ptr<ListNacosHistoryConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNacosHistoryConfigsResponse listNacosHistoryConfigs(shared_ptr<ListNacosHistoryConfigsRequest> request);
  ListNamingTrackResponse listNamingTrackWithOptions(shared_ptr<ListNamingTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNamingTrackResponse listNamingTrack(shared_ptr<ListNamingTrackRequest> request);
  ListSSLCertResponse listSSLCertWithOptions(shared_ptr<ListSSLCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSSLCertResponse listSSLCert(shared_ptr<ListSSLCertRequest> request);
  ListSecurityGroupResponse listSecurityGroupWithOptions(shared_ptr<ListSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSecurityGroupResponse listSecurityGroup(shared_ptr<ListSecurityGroupRequest> request);
  ListSecurityGroupRuleResponse listSecurityGroupRuleWithOptions(shared_ptr<ListSecurityGroupRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSecurityGroupRuleResponse listSecurityGroupRule(shared_ptr<ListSecurityGroupRuleRequest> request);
  ListServiceSourceResponse listServiceSourceWithOptions(shared_ptr<ListServiceSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceSourceResponse listServiceSource(shared_ptr<ListServiceSourceRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListZkTrackResponse listZkTrackWithOptions(shared_ptr<ListZkTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListZkTrackResponse listZkTrack(shared_ptr<ListZkTrackRequest> request);
  ListZnodeChildrenResponse listZnodeChildrenWithOptions(shared_ptr<ListZnodeChildrenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListZnodeChildrenResponse listZnodeChildren(shared_ptr<ListZnodeChildrenRequest> request);
  ModifyGovernanceKubernetesClusterResponse modifyGovernanceKubernetesClusterWithOptions(shared_ptr<ModifyGovernanceKubernetesClusterRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGovernanceKubernetesClusterResponse modifyGovernanceKubernetesCluster(shared_ptr<ModifyGovernanceKubernetesClusterRequest> request);
  ModifyLosslessRuleResponse modifyLosslessRuleWithOptions(shared_ptr<ModifyLosslessRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLosslessRuleResponse modifyLosslessRule(shared_ptr<ModifyLosslessRuleRequest> request);
  OfflineGatewayRouteResponse offlineGatewayRouteWithOptions(shared_ptr<OfflineGatewayRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OfflineGatewayRouteResponse offlineGatewayRoute(shared_ptr<OfflineGatewayRouteRequest> request);
  OrderClusterHealthCheckRiskNoticeResponse orderClusterHealthCheckRiskNoticeWithOptions(shared_ptr<OrderClusterHealthCheckRiskNoticeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OrderClusterHealthCheckRiskNoticeResponse orderClusterHealthCheckRiskNotice(shared_ptr<OrderClusterHealthCheckRiskNoticeRequest> request);
  PullServicesResponse pullServicesWithOptions(shared_ptr<PullServicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PullServicesResponse pullServices(shared_ptr<PullServicesRequest> request);
  PutClusterHealthCheckTaskResponse putClusterHealthCheckTaskWithOptions(shared_ptr<PutClusterHealthCheckTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutClusterHealthCheckTaskResponse putClusterHealthCheckTask(shared_ptr<PutClusterHealthCheckTaskRequest> request);
  QueryAllSwimmingLaneResponse queryAllSwimmingLaneWithOptions(shared_ptr<QueryAllSwimmingLaneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAllSwimmingLaneResponse queryAllSwimmingLane(shared_ptr<QueryAllSwimmingLaneRequest> request);
  QueryAllSwimmingLaneGroupResponse queryAllSwimmingLaneGroupWithOptions(shared_ptr<QueryAllSwimmingLaneGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAllSwimmingLaneGroupResponse queryAllSwimmingLaneGroup(shared_ptr<QueryAllSwimmingLaneGroupRequest> request);
  QueryBusinessLocationsResponse queryBusinessLocationsWithOptions(shared_ptr<QueryBusinessLocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBusinessLocationsResponse queryBusinessLocations(shared_ptr<QueryBusinessLocationsRequest> request);
  QueryClusterDetailResponse queryClusterDetailWithOptions(shared_ptr<QueryClusterDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryClusterDetailResponse queryClusterDetail(shared_ptr<QueryClusterDetailRequest> request);
  QueryClusterDiskSpecificationResponse queryClusterDiskSpecificationWithOptions(shared_ptr<QueryClusterDiskSpecificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryClusterDiskSpecificationResponse queryClusterDiskSpecification(shared_ptr<QueryClusterDiskSpecificationRequest> request);
  QueryClusterInfoResponse queryClusterInfoWithOptions(shared_ptr<QueryClusterInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryClusterInfoResponse queryClusterInfo(shared_ptr<QueryClusterInfoRequest> request);
  QueryClusterSpecificationResponse queryClusterSpecificationWithOptions(shared_ptr<QueryClusterSpecificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryClusterSpecificationResponse queryClusterSpecification(shared_ptr<QueryClusterSpecificationRequest> request);
  QueryConfigResponse queryConfigWithOptions(shared_ptr<QueryConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConfigResponse queryConfig(shared_ptr<QueryConfigRequest> request);
  QueryGatewayRegionResponse queryGatewayRegionWithOptions(shared_ptr<QueryGatewayRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGatewayRegionResponse queryGatewayRegion(shared_ptr<QueryGatewayRegionRequest> request);
  QueryGatewayTypeResponse queryGatewayTypeWithOptions(shared_ptr<QueryGatewayTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGatewayTypeResponse queryGatewayType(shared_ptr<QueryGatewayTypeRequest> request);
  QueryGovernanceKubernetesClusterResponse queryGovernanceKubernetesClusterWithOptions(shared_ptr<QueryGovernanceKubernetesClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGovernanceKubernetesClusterResponse queryGovernanceKubernetesCluster(shared_ptr<QueryGovernanceKubernetesClusterRequest> request);
  QueryInstancesInfoResponse queryInstancesInfoWithOptions(shared_ptr<QueryInstancesInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryInstancesInfoResponse queryInstancesInfo(shared_ptr<QueryInstancesInfoRequest> request);
  QueryMonitorResponse queryMonitorWithOptions(shared_ptr<QueryMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMonitorResponse queryMonitor(shared_ptr<QueryMonitorRequest> request);
  QueryNamespaceResponse queryNamespaceWithOptions(shared_ptr<QueryNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryNamespaceResponse queryNamespace(shared_ptr<QueryNamespaceRequest> request);
  QuerySlbSpecResponse querySlbSpecWithOptions(shared_ptr<QuerySlbSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySlbSpecResponse querySlbSpec(shared_ptr<QuerySlbSpecRequest> request);
  QuerySwimmingLaneByIdResponse querySwimmingLaneByIdWithOptions(shared_ptr<QuerySwimmingLaneByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySwimmingLaneByIdResponse querySwimmingLaneById(shared_ptr<QuerySwimmingLaneByIdRequest> request);
  QueryZnodeDetailResponse queryZnodeDetailWithOptions(shared_ptr<QueryZnodeDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryZnodeDetailResponse queryZnodeDetail(shared_ptr<QueryZnodeDetailRequest> request);
  RemoveApplicationResponse removeApplicationWithOptions(shared_ptr<RemoveApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApplicationResponse removeApplication(shared_ptr<RemoveApplicationRequest> request);
  RemoveAuthPolicyResponse removeAuthPolicyWithOptions(shared_ptr<RemoveAuthPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAuthPolicyResponse removeAuthPolicy(shared_ptr<RemoveAuthPolicyRequest> request);
  RestartClusterResponse restartClusterWithOptions(shared_ptr<RestartClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartClusterResponse restartCluster(shared_ptr<RestartClusterRequest> request);
  RetryClusterResponse retryClusterWithOptions(shared_ptr<RetryClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryClusterResponse retryCluster(shared_ptr<RetryClusterRequest> request);
  SelectGatewaySlbResponse selectGatewaySlbWithOptions(shared_ptr<SelectGatewaySlbRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SelectGatewaySlbResponse selectGatewaySlb(shared_ptr<SelectGatewaySlbRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAclResponse updateAclWithOptions(shared_ptr<UpdateAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAclResponse updateAcl(shared_ptr<UpdateAclRequest> request);
  UpdateAuthPolicyResponse updateAuthPolicyWithOptions(shared_ptr<UpdateAuthPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAuthPolicyResponse updateAuthPolicy(shared_ptr<UpdateAuthPolicyRequest> request);
  UpdateBlackWhiteListResponse updateBlackWhiteListWithOptions(shared_ptr<UpdateBlackWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBlackWhiteListResponse updateBlackWhiteList(shared_ptr<UpdateBlackWhiteListRequest> request);
  UpdateCircuitBreakerRuleResponse updateCircuitBreakerRuleWithOptions(shared_ptr<UpdateCircuitBreakerRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCircuitBreakerRuleResponse updateCircuitBreakerRule(shared_ptr<UpdateCircuitBreakerRuleRequest> request);
  UpdateClusterResponse updateClusterWithOptions(shared_ptr<UpdateClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateClusterResponse updateCluster(shared_ptr<UpdateClusterRequest> request);
  UpdateClusterSpecResponse updateClusterSpecWithOptions(shared_ptr<UpdateClusterSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateClusterSpecResponse updateClusterSpec(shared_ptr<UpdateClusterSpecRequest> request);
  UpdateConfigResponse updateConfigWithOptions(shared_ptr<UpdateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigResponse updateConfig(shared_ptr<UpdateConfigRequest> request);
  UpdateEngineNamespaceResponse updateEngineNamespaceWithOptions(shared_ptr<UpdateEngineNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEngineNamespaceResponse updateEngineNamespace(shared_ptr<UpdateEngineNamespaceRequest> request);
  UpdateFlowRuleResponse updateFlowRuleWithOptions(shared_ptr<UpdateFlowRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFlowRuleResponse updateFlowRule(shared_ptr<UpdateFlowRuleRequest> request);
  UpdateGatewayAuthConsumerResponse updateGatewayAuthConsumerWithOptions(shared_ptr<UpdateGatewayAuthConsumerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayAuthConsumerResponse updateGatewayAuthConsumer(shared_ptr<UpdateGatewayAuthConsumerRequest> request);
  UpdateGatewayAuthConsumerResourceResponse updateGatewayAuthConsumerResourceWithOptions(shared_ptr<UpdateGatewayAuthConsumerResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayAuthConsumerResourceResponse updateGatewayAuthConsumerResource(shared_ptr<UpdateGatewayAuthConsumerResourceRequest> request);
  UpdateGatewayAuthConsumerResourceStatusResponse updateGatewayAuthConsumerResourceStatusWithOptions(shared_ptr<UpdateGatewayAuthConsumerResourceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayAuthConsumerResourceStatusResponse updateGatewayAuthConsumerResourceStatus(shared_ptr<UpdateGatewayAuthConsumerResourceStatusRequest> request);
  UpdateGatewayAuthConsumerStatusResponse updateGatewayAuthConsumerStatusWithOptions(shared_ptr<UpdateGatewayAuthConsumerStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayAuthConsumerStatusResponse updateGatewayAuthConsumerStatus(shared_ptr<UpdateGatewayAuthConsumerStatusRequest> request);
  UpdateGatewayDomainResponse updateGatewayDomainWithOptions(shared_ptr<UpdateGatewayDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayDomainResponse updateGatewayDomain(shared_ptr<UpdateGatewayDomainRequest> request);
  UpdateGatewayNameResponse updateGatewayNameWithOptions(shared_ptr<UpdateGatewayNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayNameResponse updateGatewayName(shared_ptr<UpdateGatewayNameRequest> request);
  UpdateGatewayOptionResponse updateGatewayOptionWithOptions(shared_ptr<UpdateGatewayOptionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayOptionResponse updateGatewayOption(shared_ptr<UpdateGatewayOptionRequest> request);
  UpdateGatewayRouteResponse updateGatewayRouteWithOptions(shared_ptr<UpdateGatewayRouteRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteResponse updateGatewayRoute(shared_ptr<UpdateGatewayRouteRequest> request);
  UpdateGatewayRouteAuthResponse updateGatewayRouteAuthWithOptions(shared_ptr<UpdateGatewayRouteAuthRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteAuthResponse updateGatewayRouteAuth(shared_ptr<UpdateGatewayRouteAuthRequest> request);
  UpdateGatewayRouteCORSResponse updateGatewayRouteCORSWithOptions(shared_ptr<UpdateGatewayRouteCORSRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteCORSResponse updateGatewayRouteCORS(shared_ptr<UpdateGatewayRouteCORSRequest> request);
  UpdateGatewayRouteHTTPRewriteResponse updateGatewayRouteHTTPRewriteWithOptions(shared_ptr<UpdateGatewayRouteHTTPRewriteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteHTTPRewriteResponse updateGatewayRouteHTTPRewrite(shared_ptr<UpdateGatewayRouteHTTPRewriteRequest> request);
  UpdateGatewayRouteHeaderOpResponse updateGatewayRouteHeaderOpWithOptions(shared_ptr<UpdateGatewayRouteHeaderOpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteHeaderOpResponse updateGatewayRouteHeaderOp(shared_ptr<UpdateGatewayRouteHeaderOpRequest> request);
  UpdateGatewayRouteRetryResponse updateGatewayRouteRetryWithOptions(shared_ptr<UpdateGatewayRouteRetryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteRetryResponse updateGatewayRouteRetry(shared_ptr<UpdateGatewayRouteRetryRequest> request);
  UpdateGatewayRouteTimeoutResponse updateGatewayRouteTimeoutWithOptions(shared_ptr<UpdateGatewayRouteTimeoutRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteTimeoutResponse updateGatewayRouteTimeout(shared_ptr<UpdateGatewayRouteTimeoutRequest> request);
  UpdateGatewayRouteWafStatusResponse updateGatewayRouteWafStatusWithOptions(shared_ptr<UpdateGatewayRouteWafStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayRouteWafStatusResponse updateGatewayRouteWafStatus(shared_ptr<UpdateGatewayRouteWafStatusRequest> request);
  UpdateGatewayServiceCheckResponse updateGatewayServiceCheckWithOptions(shared_ptr<UpdateGatewayServiceCheckRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayServiceCheckResponse updateGatewayServiceCheck(shared_ptr<UpdateGatewayServiceCheckRequest> request);
  UpdateGatewayServiceTrafficPolicyResponse updateGatewayServiceTrafficPolicyWithOptions(shared_ptr<UpdateGatewayServiceTrafficPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayServiceTrafficPolicyResponse updateGatewayServiceTrafficPolicy(shared_ptr<UpdateGatewayServiceTrafficPolicyRequest> request);
  UpdateGatewayServiceVersionResponse updateGatewayServiceVersionWithOptions(shared_ptr<UpdateGatewayServiceVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewayServiceVersionResponse updateGatewayServiceVersion(shared_ptr<UpdateGatewayServiceVersionRequest> request);
  UpdateGatewaySpecResponse updateGatewaySpecWithOptions(shared_ptr<UpdateGatewaySpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGatewaySpecResponse updateGatewaySpec(shared_ptr<UpdateGatewaySpecRequest> request);
  UpdateImageResponse updateImageWithOptions(shared_ptr<UpdateImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateImageResponse updateImage(shared_ptr<UpdateImageRequest> request);
  UpdateMessageQueueRouteResponse updateMessageQueueRouteWithOptions(shared_ptr<UpdateMessageQueueRouteRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMessageQueueRouteResponse updateMessageQueueRoute(shared_ptr<UpdateMessageQueueRouteRequest> request);
  UpdateMigrationTaskResponse updateMigrationTaskWithOptions(shared_ptr<UpdateMigrationTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMigrationTaskResponse updateMigrationTask(shared_ptr<UpdateMigrationTaskRequest> request);
  UpdateNacosClusterResponse updateNacosClusterWithOptions(shared_ptr<UpdateNacosClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNacosClusterResponse updateNacosCluster(shared_ptr<UpdateNacosClusterRequest> request);
  UpdateNacosConfigResponse updateNacosConfigWithOptions(shared_ptr<UpdateNacosConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNacosConfigResponse updateNacosConfig(shared_ptr<UpdateNacosConfigRequest> request);
  UpdateNacosInstanceResponse updateNacosInstanceWithOptions(shared_ptr<UpdateNacosInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNacosInstanceResponse updateNacosInstance(shared_ptr<UpdateNacosInstanceRequest> request);
  UpdateNacosServiceResponse updateNacosServiceWithOptions(shared_ptr<UpdateNacosServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNacosServiceResponse updateNacosService(shared_ptr<UpdateNacosServiceRequest> request);
  UpdatePluginConfigResponse updatePluginConfigWithOptions(shared_ptr<UpdatePluginConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePluginConfigResponse updatePluginConfig(shared_ptr<UpdatePluginConfigRequest> request);
  UpdateSSLCertResponse updateSSLCertWithOptions(shared_ptr<UpdateSSLCertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSSLCertResponse updateSSLCert(shared_ptr<UpdateSSLCertRequest> request);
  UpdateServiceSourceResponse updateServiceSourceWithOptions(shared_ptr<UpdateServiceSourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceSourceResponse updateServiceSource(shared_ptr<UpdateServiceSourceRequest> request);
  UpdateZnodeResponse updateZnodeWithOptions(shared_ptr<UpdateZnodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateZnodeResponse updateZnode(shared_ptr<UpdateZnodeRequest> request);
  UpgradeClusterResponse upgradeClusterWithOptions(shared_ptr<UpgradeClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeClusterResponse upgradeCluster(shared_ptr<UpgradeClusterRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Mse20190531

#endif
