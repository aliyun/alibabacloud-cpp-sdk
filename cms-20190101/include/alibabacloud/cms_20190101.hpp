// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CMS20190101_H_
#define ALIBABACLOUD_CMS20190101_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Cms20190101 {
class AlertEventMetrics : public Darabonba::Model {
public:
  shared_ptr<string> curValue{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricNameEn{};
  shared_ptr<string> metricNameZh{};
  shared_ptr<string> operator_{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> unit{};
  shared_ptr<double> unitFactor{};

  AlertEventMetrics() {}

  explicit AlertEventMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (curValue) {
      res["CurValue"] = boost::any(*curValue);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricNameEn) {
      res["MetricNameEn"] = boost::any(*metricNameEn);
    }
    if (metricNameZh) {
      res["MetricNameZh"] = boost::any(*metricNameZh);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (unitFactor) {
      res["UnitFactor"] = boost::any(*unitFactor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurValue") != m.end() && !m["CurValue"].empty()) {
      curValue = make_shared<string>(boost::any_cast<string>(m["CurValue"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricNameEn") != m.end() && !m["MetricNameEn"].empty()) {
      metricNameEn = make_shared<string>(boost::any_cast<string>(m["MetricNameEn"]));
    }
    if (m.find("MetricNameZh") != m.end() && !m["MetricNameZh"].empty()) {
      metricNameZh = make_shared<string>(boost::any_cast<string>(m["MetricNameZh"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("UnitFactor") != m.end() && !m["UnitFactor"].empty()) {
      unitFactor = make_shared<double>(boost::any_cast<double>(m["UnitFactor"]));
    }
  }


  virtual ~AlertEventMetrics() = default;
};
class AlertEvent : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> alertStatus{};
  shared_ptr<string> arn{};
  shared_ptr<string> content{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> deDupId{};
  shared_ptr<string> details{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<string> expression{};
  shared_ptr<vector<AlertEventMetrics>> metrics{};
  shared_ptr<string> product{};
  shared_ptr<map<string, boost::any>> resourceInfo{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> severity{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> traceId{};
  shared_ptr<string> userId{};

  AlertEvent() {}

  explicit AlertEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (alertStatus) {
      res["AlertStatus"] = boost::any(*alertStatus);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (deDupId) {
      res["DeDupId"] = boost::any(*deDupId);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = boost::any(*resourceInfo);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("AlertStatus") != m.end() && !m["AlertStatus"].empty()) {
      alertStatus = make_shared<string>(boost::any_cast<string>(m["AlertStatus"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DeDupId") != m.end() && !m["DeDupId"].empty()) {
      deDupId = make_shared<string>(boost::any_cast<string>(m["DeDupId"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      details = make_shared<string>(boost::any_cast<string>(m["Details"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<AlertEventMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AlertEventMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<AlertEventMetrics>>(expect1);
      }
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ResourceInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      resourceInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AlertEvent() = default;
};
class AlertStrategyRelation : public Darabonba::Model {
public:
  shared_ptr<string> alertName{};
  shared_ptr<string> strategyUuid{};

  AlertStrategyRelation() {}

  explicit AlertStrategyRelation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertName) {
      res["AlertName"] = boost::any(*alertName);
    }
    if (strategyUuid) {
      res["StrategyUuid"] = boost::any(*strategyUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertName") != m.end() && !m["AlertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["AlertName"]));
    }
    if (m.find("StrategyUuid") != m.end() && !m["StrategyUuid"].empty()) {
      strategyUuid = make_shared<string>(boost::any_cast<string>(m["StrategyUuid"]));
    }
  }


  virtual ~AlertStrategyRelation() = default;
};
class Dimension : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  Dimension() {}

  explicit Dimension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~Dimension() = default;
};
class EscalationRuleEscalationsContactGroupsByLevel : public Darabonba::Model {
public:
  shared_ptr<vector<string>> critical{};
  shared_ptr<vector<string>> error{};
  shared_ptr<vector<string>> info{};
  shared_ptr<vector<string>> resolve{};
  shared_ptr<vector<string>> warning{};

  EscalationRuleEscalationsContactGroupsByLevel() {}

  explicit EscalationRuleEscalationsContactGroupsByLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = boost::any(*critical);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (resolve) {
      res["Resolve"] = boost::any(*resolve);
    }
    if (warning) {
      res["Warning"] = boost::any(*warning);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Critical"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Critical"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      critical = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Error"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Error"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      error = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Info"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Info"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      info = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Resolve") != m.end() && !m["Resolve"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Resolve"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resolve"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resolve = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Warning") != m.end() && !m["Warning"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Warning"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Warning"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      warning = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EscalationRuleEscalationsContactGroupsByLevel() = default;
};
class EscalationRuleEscalations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> backupContactGroups{};
  shared_ptr<vector<string>> contactGroups{};
  shared_ptr<EscalationRuleEscalationsContactGroupsByLevel> contactGroupsByLevel{};
  shared_ptr<long> escalateMin{};

  EscalationRuleEscalations() {}

  explicit EscalationRuleEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupContactGroups) {
      res["BackupContactGroups"] = boost::any(*backupContactGroups);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (contactGroupsByLevel) {
      res["ContactGroupsByLevel"] = contactGroupsByLevel ? boost::any(contactGroupsByLevel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (escalateMin) {
      res["EscalateMin"] = boost::any(*escalateMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupContactGroups") != m.end() && !m["BackupContactGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BackupContactGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BackupContactGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backupContactGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactGroupsByLevel") != m.end() && !m["ContactGroupsByLevel"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroupsByLevel"].type()) {
        EscalationRuleEscalationsContactGroupsByLevel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroupsByLevel"]));
        contactGroupsByLevel = make_shared<EscalationRuleEscalationsContactGroupsByLevel>(model1);
      }
    }
    if (m.find("EscalateMin") != m.end() && !m["EscalateMin"].empty()) {
      escalateMin = make_shared<long>(boost::any_cast<long>(m["EscalateMin"]));
    }
  }


  virtual ~EscalationRuleEscalations() = default;
};
class EscalationRule : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<vector<EscalationRuleEscalations>> escalations{};
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> uuid{};

  EscalationRule() {}

  explicit EscalationRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (escalations) {
      vector<boost::any> temp1;
      for(auto item1:*escalations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Escalations"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(vector<boost::any>) == m["Escalations"].type()) {
        vector<EscalationRuleEscalations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Escalations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EscalationRuleEscalations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalations = make_shared<vector<EscalationRuleEscalations>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~EscalationRule() = default;
};
class Incident : public Darabonba::Model {
public:
  shared_ptr<long> actionTime{};
  shared_ptr<long> alertCount{};
  shared_ptr<long> endTime{};
  shared_ptr<map<string, boost::any>> groupingData{};
  shared_ptr<string> groupingId{};
  shared_ptr<string> groupingKey{};
  shared_ptr<string> incidentId{};
  shared_ptr<string> incidentStatus{};
  shared_ptr<string> severity{};
  shared_ptr<long> startTime{};
  shared_ptr<string> strategyUuid{};
  shared_ptr<string> userId{};

  Incident() {}

  explicit Incident(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionTime) {
      res["ActionTime"] = boost::any(*actionTime);
    }
    if (alertCount) {
      res["AlertCount"] = boost::any(*alertCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupingData) {
      res["GroupingData"] = boost::any(*groupingData);
    }
    if (groupingId) {
      res["GroupingId"] = boost::any(*groupingId);
    }
    if (groupingKey) {
      res["GroupingKey"] = boost::any(*groupingKey);
    }
    if (incidentId) {
      res["IncidentId"] = boost::any(*incidentId);
    }
    if (incidentStatus) {
      res["IncidentStatus"] = boost::any(*incidentStatus);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyUuid) {
      res["StrategyUuid"] = boost::any(*strategyUuid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionTime") != m.end() && !m["ActionTime"].empty()) {
      actionTime = make_shared<long>(boost::any_cast<long>(m["ActionTime"]));
    }
    if (m.find("AlertCount") != m.end() && !m["AlertCount"].empty()) {
      alertCount = make_shared<long>(boost::any_cast<long>(m["AlertCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GroupingData") != m.end() && !m["GroupingData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GroupingData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      groupingData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupingId") != m.end() && !m["GroupingId"].empty()) {
      groupingId = make_shared<string>(boost::any_cast<string>(m["GroupingId"]));
    }
    if (m.find("GroupingKey") != m.end() && !m["GroupingKey"].empty()) {
      groupingKey = make_shared<string>(boost::any_cast<string>(m["GroupingKey"]));
    }
    if (m.find("IncidentId") != m.end() && !m["IncidentId"].empty()) {
      incidentId = make_shared<string>(boost::any_cast<string>(m["IncidentId"]));
    }
    if (m.find("IncidentStatus") != m.end() && !m["IncidentStatus"].empty()) {
      incidentStatus = make_shared<string>(boost::any_cast<string>(m["IncidentStatus"]));
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<string>(boost::any_cast<string>(m["Severity"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StrategyUuid") != m.end() && !m["StrategyUuid"].empty()) {
      strategyUuid = make_shared<string>(boost::any_cast<string>(m["StrategyUuid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~Incident() = default;
};
class Matcher : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  Matcher() {}

  explicit Matcher(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~Matcher() = default;
};
class MetricStat : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> associated{};
  shared_ptr<vector<Dimension>> dimensions{};
  shared_ptr<long> logTime{};
  shared_ptr<map<string, boost::any>> measurements{};
  shared_ptr<string> metric{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> period{};
  shared_ptr<long> timestamp{};

  MetricStat() {}

  explicit MetricStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (associated) {
      res["Associated"] = boost::any(*associated);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (logTime) {
      res["LogTime"] = boost::any(*logTime);
    }
    if (measurements) {
      res["Measurements"] = boost::any(*measurements);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Associated") != m.end() && !m["Associated"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Associated"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      associated = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<Dimension> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Dimension model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<Dimension>>(expect1);
      }
    }
    if (m.find("LogTime") != m.end() && !m["LogTime"].empty()) {
      logTime = make_shared<long>(boost::any_cast<long>(m["LogTime"]));
    }
    if (m.find("Measurements") != m.end() && !m["Measurements"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Measurements"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      measurements = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~MetricStat() = default;
};
class MigrationJobPlanContactsChannels : public Darabonba::Model {
public:
  shared_ptr<long> level{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  MigrationJobPlanContactsChannels() {}

  explicit MigrationJobPlanContactsChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~MigrationJobPlanContactsChannels() = default;
};
class MigrationJobPlanContacts : public Darabonba::Model {
public:
  shared_ptr<vector<MigrationJobPlanContactsChannels>> channels{};
  shared_ptr<string> name{};

  MigrationJobPlanContacts() {}

  explicit MigrationJobPlanContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      vector<boost::any> temp1;
      for(auto item1:*channels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channels"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<MigrationJobPlanContactsChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanContactsChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channels = make_shared<vector<MigrationJobPlanContactsChannels>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~MigrationJobPlanContacts() = default;
};
class MigrationJobPlanEscalationsEscalationsLevelGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> critical{};
  shared_ptr<vector<string>> info{};
  shared_ptr<vector<string>> resolved{};
  shared_ptr<vector<string>> warning{};

  MigrationJobPlanEscalationsEscalationsLevelGroups() {}

  explicit MigrationJobPlanEscalationsEscalationsLevelGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = boost::any(*critical);
    }
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (resolved) {
      res["Resolved"] = boost::any(*resolved);
    }
    if (warning) {
      res["Warning"] = boost::any(*warning);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Critical"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Critical"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      critical = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Info"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Info"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      info = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Resolved") != m.end() && !m["Resolved"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Resolved"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resolved"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resolved = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Warning") != m.end() && !m["Warning"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Warning"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Warning"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      warning = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~MigrationJobPlanEscalationsEscalationsLevelGroups() = default;
};
class MigrationJobPlanEscalationsEscalations : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groups{};
  shared_ptr<MigrationJobPlanEscalationsEscalationsLevelGroups> levelGroups{};

  MigrationJobPlanEscalationsEscalations() {}

  explicit MigrationJobPlanEscalationsEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      res["Groups"] = boost::any(*groups);
    }
    if (levelGroups) {
      res["LevelGroups"] = levelGroups ? boost::any(levelGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelGroups") != m.end() && !m["LevelGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["LevelGroups"].type()) {
        MigrationJobPlanEscalationsEscalationsLevelGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LevelGroups"]));
        levelGroups = make_shared<MigrationJobPlanEscalationsEscalationsLevelGroups>(model1);
      }
    }
  }


  virtual ~MigrationJobPlanEscalationsEscalations() = default;
};
class MigrationJobPlanEscalations : public Darabonba::Model {
public:
  shared_ptr<vector<MigrationJobPlanEscalationsEscalations>> escalations{};
  shared_ptr<string> name{};
  shared_ptr<string> uuid{};

  MigrationJobPlanEscalations() {}

  explicit MigrationJobPlanEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      vector<boost::any> temp1;
      for(auto item1:*escalations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Escalations"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(vector<boost::any>) == m["Escalations"].type()) {
        vector<MigrationJobPlanEscalationsEscalations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Escalations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanEscalationsEscalations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalations = make_shared<vector<MigrationJobPlanEscalationsEscalations>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~MigrationJobPlanEscalations() = default;
};
class MigrationJobPlanGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contacts{};
  shared_ptr<string> name{};

  MigrationJobPlanGroups() {}

  explicit MigrationJobPlanGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      res["Contacts"] = boost::any(*contacts);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contacts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contacts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~MigrationJobPlanGroups() = default;
};
class MigrationJobPlanStrategiesEscalationSetting : public Darabonba::Model {
public:
  shared_ptr<string> escalationUuid{};

  MigrationJobPlanStrategiesEscalationSetting() {}

  explicit MigrationJobPlanStrategiesEscalationSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationUuid) {
      res["escalationUuid"] = boost::any(*escalationUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationUuid") != m.end() && !m["escalationUuid"].empty()) {
      escalationUuid = make_shared<string>(boost::any_cast<string>(m["escalationUuid"]));
    }
  }


  virtual ~MigrationJobPlanStrategiesEscalationSetting() = default;
};
class MigrationJobPlanStrategiesPushingSetting : public Darabonba::Model {
public:
  shared_ptr<vector<string>> targetUuids{};

  MigrationJobPlanStrategiesPushingSetting() {}

  explicit MigrationJobPlanStrategiesPushingSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetUuids) {
      res["TargetUuids"] = boost::any(*targetUuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetUuids") != m.end() && !m["TargetUuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetUuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetUuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetUuids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~MigrationJobPlanStrategiesPushingSetting() = default;
};
class MigrationJobPlanStrategies : public Darabonba::Model {
public:
  shared_ptr<MigrationJobPlanStrategiesEscalationSetting> escalationSetting{};
  shared_ptr<string> name{};
  shared_ptr<MigrationJobPlanStrategiesPushingSetting> pushingSetting{};

  MigrationJobPlanStrategies() {}

  explicit MigrationJobPlanStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationSetting) {
      res["EscalationSetting"] = escalationSetting ? boost::any(escalationSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pushingSetting) {
      res["PushingSetting"] = pushingSetting ? boost::any(pushingSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EscalationSetting") != m.end() && !m["EscalationSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["EscalationSetting"].type()) {
        MigrationJobPlanStrategiesEscalationSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EscalationSetting"]));
        escalationSetting = make_shared<MigrationJobPlanStrategiesEscalationSetting>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PushingSetting") != m.end() && !m["PushingSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushingSetting"].type()) {
        MigrationJobPlanStrategiesPushingSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushingSetting"]));
        pushingSetting = make_shared<MigrationJobPlanStrategiesPushingSetting>(model1);
      }
    }
  }


  virtual ~MigrationJobPlanStrategies() = default;
};
class MigrationJobPlanSubscriptionsConditions : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> op{};
  shared_ptr<string> value{};

  MigrationJobPlanSubscriptionsConditions() {}

  explicit MigrationJobPlanSubscriptionsConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~MigrationJobPlanSubscriptionsConditions() = default;
};
class MigrationJobPlanSubscriptions : public Darabonba::Model {
public:
  shared_ptr<vector<MigrationJobPlanSubscriptionsConditions>> conditions{};
  shared_ptr<string> name{};
  shared_ptr<string> strategyUuid{};

  MigrationJobPlanSubscriptions() {}

  explicit MigrationJobPlanSubscriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (strategyUuid) {
      res["StrategyUuid"] = boost::any(*strategyUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<MigrationJobPlanSubscriptionsConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanSubscriptionsConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<MigrationJobPlanSubscriptionsConditions>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StrategyUuid") != m.end() && !m["StrategyUuid"].empty()) {
      strategyUuid = make_shared<string>(boost::any_cast<string>(m["StrategyUuid"]));
    }
  }


  virtual ~MigrationJobPlanSubscriptions() = default;
};
class MigrationJobPlanTargetsHttpRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<string> method{};
  shared_ptr<string> url{};

  MigrationJobPlanTargetsHttpRequestTarget() {}

  explicit MigrationJobPlanTargetsHttpRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~MigrationJobPlanTargetsHttpRequestTarget() = default;
};
class MigrationJobPlanTargets : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<MigrationJobPlanTargetsHttpRequestTarget> httpRequestTarget{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  MigrationJobPlanTargets() {}

  explicit MigrationJobPlanTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (httpRequestTarget) {
      res["HttpRequestTarget"] = httpRequestTarget ? boost::any(httpRequestTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("HttpRequestTarget") != m.end() && !m["HttpRequestTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpRequestTarget"].type()) {
        MigrationJobPlanTargetsHttpRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpRequestTarget"]));
        httpRequestTarget = make_shared<MigrationJobPlanTargetsHttpRequestTarget>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~MigrationJobPlanTargets() = default;
};
class MigrationJobPlan : public Darabonba::Model {
public:
  shared_ptr<vector<MigrationJobPlanContacts>> contacts{};
  shared_ptr<vector<MigrationJobPlanEscalations>> escalations{};
  shared_ptr<vector<MigrationJobPlanGroups>> groups{};
  shared_ptr<vector<string>> ruleNames{};
  shared_ptr<vector<MigrationJobPlanStrategies>> strategies{};
  shared_ptr<vector<MigrationJobPlanSubscriptions>> subscriptions{};
  shared_ptr<vector<MigrationJobPlanTargets>> targets{};

  MigrationJobPlan() {}

  explicit MigrationJobPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (escalations) {
      vector<boost::any> temp1;
      for(auto item1:*escalations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Escalations"] = boost::any(temp1);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategies"] = boost::any(temp1);
    }
    if (subscriptions) {
      vector<boost::any> temp1;
      for(auto item1:*subscriptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subscriptions"] = boost::any(temp1);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<MigrationJobPlanContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<MigrationJobPlanContacts>>(expect1);
      }
    }
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(vector<boost::any>) == m["Escalations"].type()) {
        vector<MigrationJobPlanEscalations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Escalations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanEscalations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalations = make_shared<vector<MigrationJobPlanEscalations>>(expect1);
      }
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<MigrationJobPlanGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<MigrationJobPlanGroups>>(expect1);
      }
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategies"].type()) {
        vector<MigrationJobPlanStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<MigrationJobPlanStrategies>>(expect1);
      }
    }
    if (m.find("Subscriptions") != m.end() && !m["Subscriptions"].empty()) {
      if (typeid(vector<boost::any>) == m["Subscriptions"].type()) {
        vector<MigrationJobPlanSubscriptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subscriptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanSubscriptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subscriptions = make_shared<vector<MigrationJobPlanSubscriptions>>(expect1);
      }
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<MigrationJobPlanTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobPlanTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<MigrationJobPlanTargets>>(expect1);
      }
    }
  }


  virtual ~MigrationJobPlan() = default;
};
class MigrationJobSourceRuleKeywordFilter : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> relation{};

  MigrationJobSourceRuleKeywordFilter() {}

  explicit MigrationJobSourceRuleKeywordFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~MigrationJobSourceRuleKeywordFilter() = default;
};
class MigrationJobSourceRulePrimaryFilters : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> opType{};
  shared_ptr<string> value{};

  MigrationJobSourceRulePrimaryFilters() {}

  explicit MigrationJobSourceRulePrimaryFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~MigrationJobSourceRulePrimaryFilters() = default;
};
class MigrationJobSourceRule : public Darabonba::Model {
public:
  shared_ptr<MigrationJobSourceRuleKeywordFilter> keywordFilter{};
  shared_ptr<string> name{};
  shared_ptr<vector<MigrationJobSourceRulePrimaryFilters>> primaryFilters{};

  MigrationJobSourceRule() {}

  explicit MigrationJobSourceRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywordFilter) {
      res["KeywordFilter"] = keywordFilter ? boost::any(keywordFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (primaryFilters) {
      vector<boost::any> temp1;
      for(auto item1:*primaryFilters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrimaryFilters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeywordFilter") != m.end() && !m["KeywordFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeywordFilter"].type()) {
        MigrationJobSourceRuleKeywordFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeywordFilter"]));
        keywordFilter = make_shared<MigrationJobSourceRuleKeywordFilter>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PrimaryFilters") != m.end() && !m["PrimaryFilters"].empty()) {
      if (typeid(vector<boost::any>) == m["PrimaryFilters"].type()) {
        vector<MigrationJobSourceRulePrimaryFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrimaryFilters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobSourceRulePrimaryFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        primaryFilters = make_shared<vector<MigrationJobSourceRulePrimaryFilters>>(expect1);
      }
    }
  }


  virtual ~MigrationJobSourceRule() = default;
};
class MigrationJobSourceTargetsContent : public Darabonba::Model {
public:
  shared_ptr<string> group{};
  shared_ptr<string> level{};
  shared_ptr<string> method{};
  shared_ptr<string> region{};
  shared_ptr<string> resourcePath{};
  shared_ptr<string> url{};

  MigrationJobSourceTargetsContent() {}

  explicit MigrationJobSourceTargetsContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = boost::any(*group);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourcePath) {
      res["ResourcePath"] = boost::any(*resourcePath);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      group = make_shared<string>(boost::any_cast<string>(m["Group"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourcePath") != m.end() && !m["ResourcePath"].empty()) {
      resourcePath = make_shared<string>(boost::any_cast<string>(m["ResourcePath"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~MigrationJobSourceTargetsContent() = default;
};
class MigrationJobSourceTargets : public Darabonba::Model {
public:
  shared_ptr<MigrationJobSourceTargetsContent> content{};
  shared_ptr<string> type{};

  MigrationJobSourceTargets() {}

  explicit MigrationJobSourceTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        MigrationJobSourceTargetsContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<MigrationJobSourceTargetsContent>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~MigrationJobSourceTargets() = default;
};
class MigrationJobSource : public Darabonba::Model {
public:
  shared_ptr<MigrationJobSourceRule> rule{};
  shared_ptr<vector<MigrationJobSourceTargets>> targets{};

  MigrationJobSource() {}

  explicit MigrationJobSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        MigrationJobSourceRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<MigrationJobSourceRule>(model1);
      }
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<MigrationJobSourceTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobSourceTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<MigrationJobSourceTargets>>(expect1);
      }
    }
  }


  virtual ~MigrationJobSource() = default;
};
class MigrationJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> detail{};
  shared_ptr<string> jobStatus{};
  shared_ptr<MigrationJobPlan> plan{};
  shared_ptr<vector<string>> ruleNames{};
  shared_ptr<vector<MigrationJobSource>> source{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uuid{};

  MigrationJob() {}

  explicit MigrationJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (plan) {
      res["Plan"] = plan ? boost::any(plan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("Plan") != m.end() && !m["Plan"].empty()) {
      if (typeid(map<string, boost::any>) == m["Plan"].type()) {
        MigrationJobPlan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Plan"]));
        plan = make_shared<MigrationJobPlan>(model1);
      }
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<MigrationJobSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MigrationJobSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<MigrationJobSource>>(expect1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~MigrationJob() = default;
};
class NotificationStrategyEscalationSettingCustomChannels : public Darabonba::Model {
public:
  shared_ptr<string> channelType{};
  shared_ptr<vector<string>> severities{};
  shared_ptr<string> templateUuid{};

  NotificationStrategyEscalationSettingCustomChannels() {}

  explicit NotificationStrategyEscalationSettingCustomChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelType) {
      res["ChannelType"] = boost::any(*channelType);
    }
    if (severities) {
      res["Severities"] = boost::any(*severities);
    }
    if (templateUuid) {
      res["TemplateUuid"] = boost::any(*templateUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelType") != m.end() && !m["ChannelType"].empty()) {
      channelType = make_shared<string>(boost::any_cast<string>(m["ChannelType"]));
    }
    if (m.find("Severities") != m.end() && !m["Severities"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Severities"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Severities"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      severities = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TemplateUuid") != m.end() && !m["TemplateUuid"].empty()) {
      templateUuid = make_shared<string>(boost::any_cast<string>(m["TemplateUuid"]));
    }
  }


  virtual ~NotificationStrategyEscalationSettingCustomChannels() = default;
};
class NotificationStrategyEscalationSetting : public Darabonba::Model {
public:
  shared_ptr<long> autoResolveMin{};
  shared_ptr<vector<NotificationStrategyEscalationSettingCustomChannels>> customChannels{};
  shared_ptr<string> escalationLevel{};
  shared_ptr<string> escalationUuid{};
  shared_ptr<string> range{};
  shared_ptr<long> retriggerMin{};

  NotificationStrategyEscalationSetting() {}

  explicit NotificationStrategyEscalationSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoResolveMin) {
      res["AutoResolveMin"] = boost::any(*autoResolveMin);
    }
    if (customChannels) {
      vector<boost::any> temp1;
      for(auto item1:*customChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomChannels"] = boost::any(temp1);
    }
    if (escalationLevel) {
      res["EscalationLevel"] = boost::any(*escalationLevel);
    }
    if (escalationUuid) {
      res["EscalationUuid"] = boost::any(*escalationUuid);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (retriggerMin) {
      res["RetriggerMin"] = boost::any(*retriggerMin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoResolveMin") != m.end() && !m["AutoResolveMin"].empty()) {
      autoResolveMin = make_shared<long>(boost::any_cast<long>(m["AutoResolveMin"]));
    }
    if (m.find("CustomChannels") != m.end() && !m["CustomChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomChannels"].type()) {
        vector<NotificationStrategyEscalationSettingCustomChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NotificationStrategyEscalationSettingCustomChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customChannels = make_shared<vector<NotificationStrategyEscalationSettingCustomChannels>>(expect1);
      }
    }
    if (m.find("EscalationLevel") != m.end() && !m["EscalationLevel"].empty()) {
      escalationLevel = make_shared<string>(boost::any_cast<string>(m["EscalationLevel"]));
    }
    if (m.find("EscalationUuid") != m.end() && !m["EscalationUuid"].empty()) {
      escalationUuid = make_shared<string>(boost::any_cast<string>(m["EscalationUuid"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("RetriggerMin") != m.end() && !m["RetriggerMin"].empty()) {
      retriggerMin = make_shared<long>(boost::any_cast<long>(m["RetriggerMin"]));
    }
  }


  virtual ~NotificationStrategyEscalationSetting() = default;
};
class NotificationStrategyFilterSettingBlackList : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> op{};
  shared_ptr<string> value{};

  NotificationStrategyFilterSettingBlackList() {}

  explicit NotificationStrategyFilterSettingBlackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~NotificationStrategyFilterSettingBlackList() = default;
};
class NotificationStrategyFilterSettingWhiteList : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> op{};
  shared_ptr<string> value{};

  NotificationStrategyFilterSettingWhiteList() {}

  explicit NotificationStrategyFilterSettingWhiteList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~NotificationStrategyFilterSettingWhiteList() = default;
};
class NotificationStrategyFilterSetting : public Darabonba::Model {
public:
  shared_ptr<vector<vector<undefined>>> blackList{};
  shared_ptr<vector<vector<undefined>>> whiteList{};

  NotificationStrategyFilterSetting() {}

  explicit NotificationStrategyFilterSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      vector<boost::any> temp1;
      for(auto item1:*blackList){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["BlackList"] = boost::any(temp1);
    }
    if (whiteList) {
      vector<boost::any> temp1;
      for(auto item1:*whiteList){
        vector<boost::any> temp2;
        for(auto item2:item1){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1 = boost::any(temp2);
      }
      res["WhiteList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      if (typeid(vector<boost::any>) == m["BlackList"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlackList"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        blackList = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      if (typeid(vector<boost::any>) == m["WhiteList"].type()) {
        vector<vector<undefined>> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WhiteList"])){
          if (typeid(vector<boost::any>) == item1.type()) {
            vector<undefined> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                undefined model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1.push_back(expect2);
          }
        }
        whiteList = make_shared<vector<vector<undefined>>>(expect1);
      }
    }
  }


  virtual ~NotificationStrategyFilterSetting() = default;
};
class NotificationStrategyGroupingSettingGroupingItems : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keys{};
  shared_ptr<string> type{};

  NotificationStrategyGroupingSettingGroupingItems() {}

  explicit NotificationStrategyGroupingSettingGroupingItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      res["Keys"] = boost::any(*keys);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~NotificationStrategyGroupingSettingGroupingItems() = default;
};
class NotificationStrategyGroupingSetting : public Darabonba::Model {
public:
  shared_ptr<bool> enableRawAlertDispatching{};
  shared_ptr<vector<NotificationStrategyGroupingSettingGroupingItems>> groupingItems{};
  shared_ptr<long> periodMin{};
  shared_ptr<long> silenceSec{};
  shared_ptr<long> times{};

  NotificationStrategyGroupingSetting() {}

  explicit NotificationStrategyGroupingSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableRawAlertDispatching) {
      res["EnableRawAlertDispatching"] = boost::any(*enableRawAlertDispatching);
    }
    if (groupingItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupingItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupingItems"] = boost::any(temp1);
    }
    if (periodMin) {
      res["PeriodMin"] = boost::any(*periodMin);
    }
    if (silenceSec) {
      res["SilenceSec"] = boost::any(*silenceSec);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableRawAlertDispatching") != m.end() && !m["EnableRawAlertDispatching"].empty()) {
      enableRawAlertDispatching = make_shared<bool>(boost::any_cast<bool>(m["EnableRawAlertDispatching"]));
    }
    if (m.find("GroupingItems") != m.end() && !m["GroupingItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupingItems"].type()) {
        vector<NotificationStrategyGroupingSettingGroupingItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupingItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NotificationStrategyGroupingSettingGroupingItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupingItems = make_shared<vector<NotificationStrategyGroupingSettingGroupingItems>>(expect1);
      }
    }
    if (m.find("PeriodMin") != m.end() && !m["PeriodMin"].empty()) {
      periodMin = make_shared<long>(boost::any_cast<long>(m["PeriodMin"]));
    }
    if (m.find("SilenceSec") != m.end() && !m["SilenceSec"].empty()) {
      silenceSec = make_shared<long>(boost::any_cast<long>(m["SilenceSec"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~NotificationStrategyGroupingSetting() = default;
};
class NotificationStrategyPushingSetting : public Darabonba::Model {
public:
  shared_ptr<string> pushingDataFormat{};
  shared_ptr<string> range{};
  shared_ptr<vector<string>> targetUuids{};
  shared_ptr<string> templateUuid{};

  NotificationStrategyPushingSetting() {}

  explicit NotificationStrategyPushingSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushingDataFormat) {
      res["PushingDataFormat"] = boost::any(*pushingDataFormat);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (targetUuids) {
      res["TargetUuids"] = boost::any(*targetUuids);
    }
    if (templateUuid) {
      res["TemplateUuid"] = boost::any(*templateUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushingDataFormat") != m.end() && !m["PushingDataFormat"].empty()) {
      pushingDataFormat = make_shared<string>(boost::any_cast<string>(m["PushingDataFormat"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("TargetUuids") != m.end() && !m["TargetUuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetUuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetUuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetUuids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TemplateUuid") != m.end() && !m["TemplateUuid"].empty()) {
      templateUuid = make_shared<string>(boost::any_cast<string>(m["TemplateUuid"]));
    }
  }


  virtual ~NotificationStrategyPushingSetting() = default;
};
class NotificationStrategyRouteSettingRoutesConditions : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> op{};
  shared_ptr<string> value{};

  NotificationStrategyRouteSettingRoutesConditions() {}

  explicit NotificationStrategyRouteSettingRoutesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~NotificationStrategyRouteSettingRoutesConditions() = default;
};
class NotificationStrategyRouteSettingRoutes : public Darabonba::Model {
public:
  shared_ptr<vector<NotificationStrategyRouteSettingRoutesConditions>> conditions{};
  shared_ptr<string> escalationUuid{};

  NotificationStrategyRouteSettingRoutes() {}

  explicit NotificationStrategyRouteSettingRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (escalationUuid) {
      res["EscalationUuid"] = boost::any(*escalationUuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<NotificationStrategyRouteSettingRoutesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NotificationStrategyRouteSettingRoutesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<NotificationStrategyRouteSettingRoutesConditions>>(expect1);
      }
    }
    if (m.find("EscalationUuid") != m.end() && !m["EscalationUuid"].empty()) {
      escalationUuid = make_shared<string>(boost::any_cast<string>(m["EscalationUuid"]));
    }
  }


  virtual ~NotificationStrategyRouteSettingRoutes() = default;
};
class NotificationStrategyRouteSetting : public Darabonba::Model {
public:
  shared_ptr<vector<NotificationStrategyRouteSettingRoutes>> routes{};

  NotificationStrategyRouteSetting() {}

  explicit NotificationStrategyRouteSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routes) {
      vector<boost::any> temp1;
      for(auto item1:*routes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Routes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      if (typeid(vector<boost::any>) == m["Routes"].type()) {
        vector<NotificationStrategyRouteSettingRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            NotificationStrategyRouteSettingRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routes = make_shared<vector<NotificationStrategyRouteSettingRoutes>>(expect1);
      }
    }
  }


  virtual ~NotificationStrategyRouteSetting() = default;
};
class NotificationStrategy : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<NotificationStrategyEscalationSetting> escalationSetting{};
  shared_ptr<NotificationStrategyFilterSetting> filterSetting{};
  shared_ptr<NotificationStrategyGroupingSetting> groupingSetting{};
  shared_ptr<string> name{};
  shared_ptr<string> product{};
  shared_ptr<NotificationStrategyPushingSetting> pushingSetting{};
  shared_ptr<NotificationStrategyRouteSetting> routeSetting{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> uuid{};

  NotificationStrategy() {}

  explicit NotificationStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (escalationSetting) {
      res["EscalationSetting"] = escalationSetting ? boost::any(escalationSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterSetting) {
      res["FilterSetting"] = filterSetting ? boost::any(filterSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupingSetting) {
      res["GroupingSetting"] = groupingSetting ? boost::any(groupingSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (pushingSetting) {
      res["PushingSetting"] = pushingSetting ? boost::any(pushingSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routeSetting) {
      res["RouteSetting"] = routeSetting ? boost::any(routeSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EscalationSetting") != m.end() && !m["EscalationSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["EscalationSetting"].type()) {
        NotificationStrategyEscalationSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EscalationSetting"]));
        escalationSetting = make_shared<NotificationStrategyEscalationSetting>(model1);
      }
    }
    if (m.find("FilterSetting") != m.end() && !m["FilterSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterSetting"].type()) {
        NotificationStrategyFilterSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterSetting"]));
        filterSetting = make_shared<NotificationStrategyFilterSetting>(model1);
      }
    }
    if (m.find("GroupingSetting") != m.end() && !m["GroupingSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupingSetting"].type()) {
        NotificationStrategyGroupingSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupingSetting"]));
        groupingSetting = make_shared<NotificationStrategyGroupingSetting>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("PushingSetting") != m.end() && !m["PushingSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushingSetting"].type()) {
        NotificationStrategyPushingSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushingSetting"]));
        pushingSetting = make_shared<NotificationStrategyPushingSetting>(model1);
      }
    }
    if (m.find("RouteSetting") != m.end() && !m["RouteSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteSetting"].type()) {
        NotificationStrategyRouteSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteSetting"]));
        routeSetting = make_shared<NotificationStrategyRouteSetting>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~NotificationStrategy() = default;
};
class NotificationTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> enContent{};
  shared_ptr<string> enItemContent{};
  shared_ptr<string> enTitle{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> uuid{};
  shared_ptr<string> wraperType{};
  shared_ptr<string> zhContent{};
  shared_ptr<string> zhItemContent{};
  shared_ptr<string> zhTitle{};

  NotificationTemplate() {}

  explicit NotificationTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enContent) {
      res["EnContent"] = boost::any(*enContent);
    }
    if (enItemContent) {
      res["EnItemContent"] = boost::any(*enItemContent);
    }
    if (enTitle) {
      res["EnTitle"] = boost::any(*enTitle);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (wraperType) {
      res["WraperType"] = boost::any(*wraperType);
    }
    if (zhContent) {
      res["ZhContent"] = boost::any(*zhContent);
    }
    if (zhItemContent) {
      res["ZhItemContent"] = boost::any(*zhItemContent);
    }
    if (zhTitle) {
      res["ZhTitle"] = boost::any(*zhTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnContent") != m.end() && !m["EnContent"].empty()) {
      enContent = make_shared<string>(boost::any_cast<string>(m["EnContent"]));
    }
    if (m.find("EnItemContent") != m.end() && !m["EnItemContent"].empty()) {
      enItemContent = make_shared<string>(boost::any_cast<string>(m["EnItemContent"]));
    }
    if (m.find("EnTitle") != m.end() && !m["EnTitle"].empty()) {
      enTitle = make_shared<string>(boost::any_cast<string>(m["EnTitle"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("WraperType") != m.end() && !m["WraperType"].empty()) {
      wraperType = make_shared<string>(boost::any_cast<string>(m["WraperType"]));
    }
    if (m.find("ZhContent") != m.end() && !m["ZhContent"].empty()) {
      zhContent = make_shared<string>(boost::any_cast<string>(m["ZhContent"]));
    }
    if (m.find("ZhItemContent") != m.end() && !m["ZhItemContent"].empty()) {
      zhItemContent = make_shared<string>(boost::any_cast<string>(m["ZhItemContent"]));
    }
    if (m.find("ZhTitle") != m.end() && !m["ZhTitle"].empty()) {
      zhTitle = make_shared<string>(boost::any_cast<string>(m["ZhTitle"]));
    }
  }


  virtual ~NotificationTemplate() = default;
};
class PushingTargetHttpRequestTargetHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PushingTargetHttpRequestTargetHeaders() {}

  explicit PushingTargetHttpRequestTargetHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PushingTargetHttpRequestTargetHeaders() = default;
};
class PushingTargetHttpRequestTarget : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<string> encryptString{};
  shared_ptr<vector<PushingTargetHttpRequestTargetHeaders>> headers{};
  shared_ptr<string> method{};
  shared_ptr<string> url{};

  PushingTargetHttpRequestTarget() {}

  explicit PushingTargetHttpRequestTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (encryptString) {
      res["EncryptString"] = boost::any(*encryptString);
    }
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("EncryptString") != m.end() && !m["EncryptString"].empty()) {
      encryptString = make_shared<string>(boost::any_cast<string>(m["EncryptString"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<PushingTargetHttpRequestTargetHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PushingTargetHttpRequestTargetHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<PushingTargetHttpRequestTargetHeaders>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~PushingTargetHttpRequestTarget() = default;
};
class PushingTarget : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<PushingTargetHttpRequestTarget> httpRequestTarget{};
  shared_ptr<string> name{};
  shared_ptr<string> range{};
  shared_ptr<string> templateUuid{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> userId{};
  shared_ptr<string> uuid{};

  PushingTarget() {}

  explicit PushingTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (httpRequestTarget) {
      res["HttpRequestTarget"] = httpRequestTarget ? boost::any(httpRequestTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (range) {
      res["Range"] = boost::any(*range);
    }
    if (templateUuid) {
      res["TemplateUuid"] = boost::any(*templateUuid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HttpRequestTarget") != m.end() && !m["HttpRequestTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpRequestTarget"].type()) {
        PushingTargetHttpRequestTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpRequestTarget"]));
        httpRequestTarget = make_shared<PushingTargetHttpRequestTarget>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      range = make_shared<string>(boost::any_cast<string>(m["Range"]));
    }
    if (m.find("TemplateUuid") != m.end() && !m["TemplateUuid"].empty()) {
      templateUuid = make_shared<string>(boost::any_cast<string>(m["TemplateUuid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~PushingTarget() = default;
};
class SubscriptionConditions : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  SubscriptionConditions() {}

  explicit SubscriptionConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SubscriptionConditions() = default;
};
class Subscription : public Darabonba::Model {
public:
  shared_ptr<vector<SubscriptionConditions>> conditions{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> name{};
  shared_ptr<string> product{};
  shared_ptr<string> relation{};
  shared_ptr<string> strategyUuid{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> uuid{};

  Subscription() {}

  explicit Subscription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    if (strategyUuid) {
      res["StrategyUuid"] = boost::any(*strategyUuid);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<SubscriptionConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubscriptionConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<SubscriptionConditions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
    if (m.find("StrategyUuid") != m.end() && !m["StrategyUuid"].empty()) {
      strategyUuid = make_shared<string>(boost::any_cast<string>(m["StrategyUuid"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~Subscription() = default;
};
class AddTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddTagsRequestTag() {}

  explicit AddTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddTagsRequestTag() = default;
};
class AddTagsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<AddTagsRequestTag>> tag{};

  AddTagsRequest() {}

  explicit AddTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~AddTagsRequest() = default;
};
class AddTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddTagsResponseBody() {}

  explicit AddTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddTagsResponseBody() = default;
};
class AddTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTagsResponseBody> body{};

  AddTagsResponse() {}

  explicit AddTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTagsResponseBody>(model1);
      }
    }
  }


  virtual ~AddTagsResponse() = default;
};
class ApplyMetricRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appendMode{};
  shared_ptr<string> applyMode{};
  shared_ptr<long> enableEndTime{};
  shared_ptr<long> enableStartTime{};
  shared_ptr<long> groupId{};
  shared_ptr<long> notifyLevel{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> templateIds{};
  shared_ptr<string> webhook{};

  ApplyMetricRuleTemplateRequest() {}

  explicit ApplyMetricRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appendMode) {
      res["AppendMode"] = boost::any(*appendMode);
    }
    if (applyMode) {
      res["ApplyMode"] = boost::any(*applyMode);
    }
    if (enableEndTime) {
      res["EnableEndTime"] = boost::any(*enableEndTime);
    }
    if (enableStartTime) {
      res["EnableStartTime"] = boost::any(*enableStartTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (notifyLevel) {
      res["NotifyLevel"] = boost::any(*notifyLevel);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppendMode") != m.end() && !m["AppendMode"].empty()) {
      appendMode = make_shared<string>(boost::any_cast<string>(m["AppendMode"]));
    }
    if (m.find("ApplyMode") != m.end() && !m["ApplyMode"].empty()) {
      applyMode = make_shared<string>(boost::any_cast<string>(m["ApplyMode"]));
    }
    if (m.find("EnableEndTime") != m.end() && !m["EnableEndTime"].empty()) {
      enableEndTime = make_shared<long>(boost::any_cast<long>(m["EnableEndTime"]));
    }
    if (m.find("EnableStartTime") != m.end() && !m["EnableStartTime"].empty()) {
      enableStartTime = make_shared<long>(boost::any_cast<long>(m["EnableStartTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("NotifyLevel") != m.end() && !m["NotifyLevel"].empty()) {
      notifyLevel = make_shared<long>(boost::any_cast<long>(m["NotifyLevel"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~ApplyMetricRuleTemplateRequest() = default;
};
class ApplyMetricRuleTemplateResponseBodyResourceAlertResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<bool> success{};

  ApplyMetricRuleTemplateResponseBodyResourceAlertResults() {}

  explicit ApplyMetricRuleTemplateResponseBodyResourceAlertResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyMetricRuleTemplateResponseBodyResourceAlertResults() = default;
};
class ApplyMetricRuleTemplateResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<vector<ApplyMetricRuleTemplateResponseBodyResourceAlertResults>> alertResults{};
  shared_ptr<long> groupId{};

  ApplyMetricRuleTemplateResponseBodyResource() {}

  explicit ApplyMetricRuleTemplateResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertResults) {
      vector<boost::any> temp1;
      for(auto item1:*alertResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertResults"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertResults") != m.end() && !m["AlertResults"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertResults"].type()) {
        vector<ApplyMetricRuleTemplateResponseBodyResourceAlertResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApplyMetricRuleTemplateResponseBodyResourceAlertResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertResults = make_shared<vector<ApplyMetricRuleTemplateResponseBodyResourceAlertResults>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~ApplyMetricRuleTemplateResponseBodyResource() = default;
};
class ApplyMetricRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ApplyMetricRuleTemplateResponseBodyResource> resource{};
  shared_ptr<bool> success{};

  ApplyMetricRuleTemplateResponseBody() {}

  explicit ApplyMetricRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        ApplyMetricRuleTemplateResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<ApplyMetricRuleTemplateResponseBodyResource>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApplyMetricRuleTemplateResponseBody() = default;
};
class ApplyMetricRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyMetricRuleTemplateResponseBody> body{};

  ApplyMetricRuleTemplateResponse() {}

  explicit ApplyMetricRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyMetricRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyMetricRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyMetricRuleTemplateResponse() = default;
};
class BatchCreateInstantSiteMonitorRequestTaskList : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> ispCities{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  BatchCreateInstantSiteMonitorRequestTaskList() {}

  explicit BatchCreateInstantSiteMonitorRequestTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (ispCities) {
      res["IspCities"] = boost::any(*ispCities);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("IspCities") != m.end() && !m["IspCities"].empty()) {
      ispCities = make_shared<string>(boost::any_cast<string>(m["IspCities"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~BatchCreateInstantSiteMonitorRequestTaskList() = default;
};
class BatchCreateInstantSiteMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<BatchCreateInstantSiteMonitorRequestTaskList>> taskList{};

  BatchCreateInstantSiteMonitorRequest() {}

  explicit BatchCreateInstantSiteMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<BatchCreateInstantSiteMonitorRequestTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateInstantSiteMonitorRequestTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<BatchCreateInstantSiteMonitorRequestTaskList>>(expect1);
      }
    }
  }


  virtual ~BatchCreateInstantSiteMonitorRequest() = default;
};
class BatchCreateInstantSiteMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  BatchCreateInstantSiteMonitorResponseBodyData() {}

  explicit BatchCreateInstantSiteMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~BatchCreateInstantSiteMonitorResponseBodyData() = default;
};
class BatchCreateInstantSiteMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<BatchCreateInstantSiteMonitorResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchCreateInstantSiteMonitorResponseBody() {}

  explicit BatchCreateInstantSiteMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<BatchCreateInstantSiteMonitorResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateInstantSiteMonitorResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<BatchCreateInstantSiteMonitorResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchCreateInstantSiteMonitorResponseBody() = default;
};
class BatchCreateInstantSiteMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateInstantSiteMonitorResponseBody> body{};

  BatchCreateInstantSiteMonitorResponse() {}

  explicit BatchCreateInstantSiteMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateInstantSiteMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateInstantSiteMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateInstantSiteMonitorResponse() = default;
};
class BatchExportRequest : public Darabonba::Model {
public:
  shared_ptr<string> cursor{};
  shared_ptr<long> length{};
  shared_ptr<vector<string>> measurements{};
  shared_ptr<string> metric{};
  shared_ptr<string> namespace_{};

  BatchExportRequest() {}

  explicit BatchExportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (measurements) {
      res["Measurements"] = boost::any(*measurements);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<string>(boost::any_cast<string>(m["Cursor"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Measurements") != m.end() && !m["Measurements"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Measurements"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Measurements"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      measurements = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchExportRequest() = default;
};
class BatchExportShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cursor{};
  shared_ptr<long> length{};
  shared_ptr<string> measurementsShrink{};
  shared_ptr<string> metric{};
  shared_ptr<string> namespace_{};

  BatchExportShrinkRequest() {}

  explicit BatchExportShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (measurementsShrink) {
      res["Measurements"] = boost::any(*measurementsShrink);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<string>(boost::any_cast<string>(m["Cursor"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Measurements") != m.end() && !m["Measurements"].empty()) {
      measurementsShrink = make_shared<string>(boost::any_cast<string>(m["Measurements"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~BatchExportShrinkRequest() = default;
};
class BatchExportResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> anchor{};
  shared_ptr<long> code{};
  shared_ptr<string> cursor{};
  shared_ptr<vector<MetricStat>> dataResults{};
  shared_ptr<bool> hasNext{};
  shared_ptr<long> length{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  BatchExportResponseBody() {}

  explicit BatchExportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchor) {
      res["Anchor"] = boost::any(*anchor);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (dataResults) {
      vector<boost::any> temp1;
      for(auto item1:*dataResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataResults"] = boost::any(temp1);
    }
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Anchor") != m.end() && !m["Anchor"].empty()) {
      anchor = make_shared<long>(boost::any_cast<long>(m["Anchor"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<string>(boost::any_cast<string>(m["Cursor"]));
    }
    if (m.find("DataResults") != m.end() && !m["DataResults"].empty()) {
      if (typeid(vector<boost::any>) == m["DataResults"].type()) {
        vector<MetricStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MetricStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataResults = make_shared<vector<MetricStat>>(expect1);
      }
    }
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BatchExportResponseBody() = default;
};
class BatchExportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchExportResponseBody> body{};

  BatchExportResponse() {}

  explicit BatchExportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchExportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchExportResponseBody>(model1);
      }
    }
  }


  virtual ~BatchExportResponse() = default;
};
class CreateDynamicTagGroupRequestMatchExpress : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagValueMatchFunction{};

  CreateDynamicTagGroupRequestMatchExpress() {}

  explicit CreateDynamicTagGroupRequestMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagValueMatchFunction) {
      res["TagValueMatchFunction"] = boost::any(*tagValueMatchFunction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagValueMatchFunction") != m.end() && !m["TagValueMatchFunction"].empty()) {
      tagValueMatchFunction = make_shared<string>(boost::any_cast<string>(m["TagValueMatchFunction"]));
    }
  }


  virtual ~CreateDynamicTagGroupRequestMatchExpress() = default;
};
class CreateDynamicTagGroupRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroupList{};
  shared_ptr<bool> enableInstallAgent{};
  shared_ptr<bool> enableSubscribeEvent{};
  shared_ptr<vector<CreateDynamicTagGroupRequestMatchExpress>> matchExpress{};
  shared_ptr<string> matchExpressFilterRelation{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagRegionId{};
  shared_ptr<vector<string>> templateIdList{};

  CreateDynamicTagGroupRequest() {}

  explicit CreateDynamicTagGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupList) {
      res["ContactGroupList"] = boost::any(*contactGroupList);
    }
    if (enableInstallAgent) {
      res["EnableInstallAgent"] = boost::any(*enableInstallAgent);
    }
    if (enableSubscribeEvent) {
      res["EnableSubscribeEvent"] = boost::any(*enableSubscribeEvent);
    }
    if (matchExpress) {
      vector<boost::any> temp1;
      for(auto item1:*matchExpress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchExpress"] = boost::any(temp1);
    }
    if (matchExpressFilterRelation) {
      res["MatchExpressFilterRelation"] = boost::any(*matchExpressFilterRelation);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagRegionId) {
      res["TagRegionId"] = boost::any(*tagRegionId);
    }
    if (templateIdList) {
      res["TemplateIdList"] = boost::any(*templateIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupList") != m.end() && !m["ContactGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableInstallAgent") != m.end() && !m["EnableInstallAgent"].empty()) {
      enableInstallAgent = make_shared<bool>(boost::any_cast<bool>(m["EnableInstallAgent"]));
    }
    if (m.find("EnableSubscribeEvent") != m.end() && !m["EnableSubscribeEvent"].empty()) {
      enableSubscribeEvent = make_shared<bool>(boost::any_cast<bool>(m["EnableSubscribeEvent"]));
    }
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchExpress"].type()) {
        vector<CreateDynamicTagGroupRequestMatchExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchExpress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDynamicTagGroupRequestMatchExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchExpress = make_shared<vector<CreateDynamicTagGroupRequestMatchExpress>>(expect1);
      }
    }
    if (m.find("MatchExpressFilterRelation") != m.end() && !m["MatchExpressFilterRelation"].empty()) {
      matchExpressFilterRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressFilterRelation"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagRegionId") != m.end() && !m["TagRegionId"].empty()) {
      tagRegionId = make_shared<string>(boost::any_cast<string>(m["TagRegionId"]));
    }
    if (m.find("TemplateIdList") != m.end() && !m["TemplateIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDynamicTagGroupRequest() = default;
};
class CreateDynamicTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDynamicTagGroupResponseBody() {}

  explicit CreateDynamicTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDynamicTagGroupResponseBody() = default;
};
class CreateDynamicTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDynamicTagGroupResponseBody> body{};

  CreateDynamicTagGroupResponse() {}

  explicit CreateDynamicTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDynamicTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDynamicTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDynamicTagGroupResponse() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<string>(boost::any_cast<string>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<string>(boost::any_cast<string>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<string>(boost::any_cast<string>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRulesEscalations : public Darabonba::Model {
public:
  shared_ptr<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical> critical{};
  shared_ptr<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo> info{};
  shared_ptr<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn> warn{};

  CreateGroupMetricRulesRequestGroupMetricRulesEscalations() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRulesEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn>(model1);
      }
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRulesEscalations() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateGroupMetricRulesRequestGroupMetricRulesLabels() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRulesLabels() = default;
};
class CreateGroupMetricRulesRequestGroupMetricRules : public Darabonba::Model {
public:
  shared_ptr<CreateGroupMetricRulesRequestGroupMetricRulesEscalations> escalations{};
  shared_ptr<string> category{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> interval{};
  shared_ptr<vector<CreateGroupMetricRulesRequestGroupMetricRulesLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> options{};
  shared_ptr<string> period{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> webhook{};

  CreateGroupMetricRulesRequestGroupMetricRules() {}

  explicit CreateGroupMetricRulesRequestGroupMetricRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        CreateGroupMetricRulesRequestGroupMetricRulesEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<CreateGroupMetricRulesRequestGroupMetricRulesEscalations>(model1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<CreateGroupMetricRulesRequestGroupMetricRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMetricRulesRequestGroupMetricRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<CreateGroupMetricRulesRequestGroupMetricRulesLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequestGroupMetricRules() = default;
};
class CreateGroupMetricRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<vector<CreateGroupMetricRulesRequestGroupMetricRules>> groupMetricRules{};
  shared_ptr<string> regionId{};

  CreateGroupMetricRulesRequest() {}

  explicit CreateGroupMetricRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMetricRules) {
      vector<boost::any> temp1;
      for(auto item1:*groupMetricRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupMetricRules"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupMetricRules") != m.end() && !m["GroupMetricRules"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupMetricRules"].type()) {
        vector<CreateGroupMetricRulesRequestGroupMetricRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupMetricRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMetricRulesRequestGroupMetricRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupMetricRules = make_shared<vector<CreateGroupMetricRulesRequestGroupMetricRules>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateGroupMetricRulesRequest() = default;
};
class CreateGroupMetricRulesResponseBodyResourcesAlertResult : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<bool> success{};

  CreateGroupMetricRulesResponseBodyResourcesAlertResult() {}

  explicit CreateGroupMetricRulesResponseBodyResourcesAlertResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateGroupMetricRulesResponseBodyResourcesAlertResult() = default;
};
class CreateGroupMetricRulesResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<CreateGroupMetricRulesResponseBodyResourcesAlertResult>> alertResult{};

  CreateGroupMetricRulesResponseBodyResources() {}

  explicit CreateGroupMetricRulesResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertResult) {
      vector<boost::any> temp1;
      for(auto item1:*alertResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertResult") != m.end() && !m["AlertResult"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertResult"].type()) {
        vector<CreateGroupMetricRulesResponseBodyResourcesAlertResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMetricRulesResponseBodyResourcesAlertResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertResult = make_shared<vector<CreateGroupMetricRulesResponseBodyResourcesAlertResult>>(expect1);
      }
    }
  }


  virtual ~CreateGroupMetricRulesResponseBodyResources() = default;
};
class CreateGroupMetricRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateGroupMetricRulesResponseBodyResources> resources{};
  shared_ptr<bool> success{};

  CreateGroupMetricRulesResponseBody() {}

  explicit CreateGroupMetricRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        CreateGroupMetricRulesResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<CreateGroupMetricRulesResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateGroupMetricRulesResponseBody() = default;
};
class CreateGroupMetricRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGroupMetricRulesResponseBody> body{};

  CreateGroupMetricRulesResponse() {}

  explicit CreateGroupMetricRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGroupMetricRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGroupMetricRulesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGroupMetricRulesResponse() = default;
};
class CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList() {}

  explicit CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList() = default;
};
class CreateGroupMonitoringAgentProcessRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> escalationsLevel{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> silenceTime{};
  shared_ptr<string> statistics{};
  shared_ptr<vector<CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList>> targetList{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};
  shared_ptr<string> webhook{};

  CreateGroupMonitoringAgentProcessRequestAlertConfig() {}

  explicit CreateGroupMonitoringAgentProcessRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (escalationsLevel) {
      res["EscalationsLevel"] = boost::any(*escalationsLevel);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EscalationsLevel") != m.end() && !m["EscalationsLevel"].empty()) {
      escalationsLevel = make_shared<string>(boost::any_cast<string>(m["EscalationsLevel"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList>>(expect1);
      }
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessRequestAlertConfig() = default;
};
class CreateGroupMonitoringAgentProcessRequestMatchExpress : public Darabonba::Model {
public:
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateGroupMonitoringAgentProcessRequestMatchExpress() {}

  explicit CreateGroupMonitoringAgentProcessRequestMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessRequestMatchExpress() = default;
};
class CreateGroupMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateGroupMonitoringAgentProcessRequestAlertConfig>> alertConfig{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<CreateGroupMonitoringAgentProcessRequestMatchExpress>> matchExpress{};
  shared_ptr<string> matchExpressFilterRelation{};
  shared_ptr<string> processName{};
  shared_ptr<string> regionId{};

  CreateGroupMonitoringAgentProcessRequest() {}

  explicit CreateGroupMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (matchExpress) {
      vector<boost::any> temp1;
      for(auto item1:*matchExpress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchExpress"] = boost::any(temp1);
    }
    if (matchExpressFilterRelation) {
      res["MatchExpressFilterRelation"] = boost::any(*matchExpressFilterRelation);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<CreateGroupMonitoringAgentProcessRequestAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMonitoringAgentProcessRequestAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<CreateGroupMonitoringAgentProcessRequestAlertConfig>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchExpress"].type()) {
        vector<CreateGroupMonitoringAgentProcessRequestMatchExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchExpress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateGroupMonitoringAgentProcessRequestMatchExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchExpress = make_shared<vector<CreateGroupMonitoringAgentProcessRequestMatchExpress>>(expect1);
      }
    }
    if (m.find("MatchExpressFilterRelation") != m.end() && !m["MatchExpressFilterRelation"].empty()) {
      matchExpressFilterRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressFilterRelation"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessRequest() = default;
};
class CreateGroupMonitoringAgentProcessResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<string> groupProcessId{};

  CreateGroupMonitoringAgentProcessResponseBodyResource() {}

  explicit CreateGroupMonitoringAgentProcessResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupProcessId) {
      res["GroupProcessId"] = boost::any(*groupProcessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupProcessId") != m.end() && !m["GroupProcessId"].empty()) {
      groupProcessId = make_shared<string>(boost::any_cast<string>(m["GroupProcessId"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessResponseBodyResource() = default;
};
class CreateGroupMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateGroupMonitoringAgentProcessResponseBodyResource> resource{};
  shared_ptr<bool> success{};

  CreateGroupMonitoringAgentProcessResponseBody() {}

  explicit CreateGroupMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        CreateGroupMonitoringAgentProcessResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<CreateGroupMonitoringAgentProcessResponseBodyResource>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessResponseBody() = default;
};
class CreateGroupMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGroupMonitoringAgentProcessResponseBody> body{};

  CreateGroupMonitoringAgentProcessResponse() {}

  explicit CreateGroupMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGroupMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGroupMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGroupMonitoringAgentProcessResponse() = default;
};
class CreateHostAvailabilityRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> notifyType{};
  shared_ptr<long> silenceTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> webHook{};

  CreateHostAvailabilityRequestAlertConfig() {}

  explicit CreateHostAvailabilityRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (webHook) {
      res["WebHook"] = boost::any(*webHook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<long>(boost::any_cast<long>(m["NotifyType"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("WebHook") != m.end() && !m["WebHook"].empty()) {
      webHook = make_shared<string>(boost::any_cast<string>(m["WebHook"]));
    }
  }


  virtual ~CreateHostAvailabilityRequestAlertConfig() = default;
};
class CreateHostAvailabilityRequestTaskOption : public Darabonba::Model {
public:
  shared_ptr<string> httpHeader{};
  shared_ptr<string> httpMethod{};
  shared_ptr<bool> httpNegative{};
  shared_ptr<string> httpPostContent{};
  shared_ptr<string> httpResponseCharset{};
  shared_ptr<string> httpResponseMatchContent{};
  shared_ptr<string> httpURI{};
  shared_ptr<long> interval{};
  shared_ptr<string> telnetOrPingHost{};

  CreateHostAvailabilityRequestTaskOption() {}

  explicit CreateHostAvailabilityRequestTaskOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpHeader) {
      res["HttpHeader"] = boost::any(*httpHeader);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpNegative) {
      res["HttpNegative"] = boost::any(*httpNegative);
    }
    if (httpPostContent) {
      res["HttpPostContent"] = boost::any(*httpPostContent);
    }
    if (httpResponseCharset) {
      res["HttpResponseCharset"] = boost::any(*httpResponseCharset);
    }
    if (httpResponseMatchContent) {
      res["HttpResponseMatchContent"] = boost::any(*httpResponseMatchContent);
    }
    if (httpURI) {
      res["HttpURI"] = boost::any(*httpURI);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (telnetOrPingHost) {
      res["TelnetOrPingHost"] = boost::any(*telnetOrPingHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpHeader") != m.end() && !m["HttpHeader"].empty()) {
      httpHeader = make_shared<string>(boost::any_cast<string>(m["HttpHeader"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpNegative") != m.end() && !m["HttpNegative"].empty()) {
      httpNegative = make_shared<bool>(boost::any_cast<bool>(m["HttpNegative"]));
    }
    if (m.find("HttpPostContent") != m.end() && !m["HttpPostContent"].empty()) {
      httpPostContent = make_shared<string>(boost::any_cast<string>(m["HttpPostContent"]));
    }
    if (m.find("HttpResponseCharset") != m.end() && !m["HttpResponseCharset"].empty()) {
      httpResponseCharset = make_shared<string>(boost::any_cast<string>(m["HttpResponseCharset"]));
    }
    if (m.find("HttpResponseMatchContent") != m.end() && !m["HttpResponseMatchContent"].empty()) {
      httpResponseMatchContent = make_shared<string>(boost::any_cast<string>(m["HttpResponseMatchContent"]));
    }
    if (m.find("HttpURI") != m.end() && !m["HttpURI"].empty()) {
      httpURI = make_shared<string>(boost::any_cast<string>(m["HttpURI"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TelnetOrPingHost") != m.end() && !m["TelnetOrPingHost"].empty()) {
      telnetOrPingHost = make_shared<string>(boost::any_cast<string>(m["TelnetOrPingHost"]));
    }
  }


  virtual ~CreateHostAvailabilityRequestTaskOption() = default;
};
class CreateHostAvailabilityRequestAlertConfigEscalationList : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricName{};
  shared_ptr<string> operator_{};
  shared_ptr<long> times{};
  shared_ptr<string> value{};

  CreateHostAvailabilityRequestAlertConfigEscalationList() {}

  explicit CreateHostAvailabilityRequestAlertConfigEscalationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateHostAvailabilityRequestAlertConfigEscalationList() = default;
};
class CreateHostAvailabilityRequestAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  CreateHostAvailabilityRequestAlertConfigTargetList() {}

  explicit CreateHostAvailabilityRequestAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~CreateHostAvailabilityRequestAlertConfigTargetList() = default;
};
class CreateHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<CreateHostAvailabilityRequestAlertConfig> alertConfig{};
  shared_ptr<CreateHostAvailabilityRequestTaskOption> taskOption{};
  shared_ptr<vector<CreateHostAvailabilityRequestAlertConfigEscalationList>> alertConfigEscalationList{};
  shared_ptr<vector<CreateHostAvailabilityRequestAlertConfigTargetList>> alertConfigTargetList{};
  shared_ptr<long> groupId{};
  shared_ptr<vector<string>> instanceList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskScope{};
  shared_ptr<string> taskType{};

  CreateHostAvailabilityRequest() {}

  explicit CreateHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskOption) {
      res["TaskOption"] = taskOption ? boost::any(taskOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertConfigEscalationList) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfigEscalationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfigEscalationList"] = boost::any(temp1);
    }
    if (alertConfigTargetList) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfigTargetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfigTargetList"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceList) {
      res["InstanceList"] = boost::any(*instanceList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskScope) {
      res["TaskScope"] = boost::any(*taskScope);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        CreateHostAvailabilityRequestAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<CreateHostAvailabilityRequestAlertConfig>(model1);
      }
    }
    if (m.find("TaskOption") != m.end() && !m["TaskOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskOption"].type()) {
        CreateHostAvailabilityRequestTaskOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskOption"]));
        taskOption = make_shared<CreateHostAvailabilityRequestTaskOption>(model1);
      }
    }
    if (m.find("AlertConfigEscalationList") != m.end() && !m["AlertConfigEscalationList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfigEscalationList"].type()) {
        vector<CreateHostAvailabilityRequestAlertConfigEscalationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfigEscalationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHostAvailabilityRequestAlertConfigEscalationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfigEscalationList = make_shared<vector<CreateHostAvailabilityRequestAlertConfigEscalationList>>(expect1);
      }
    }
    if (m.find("AlertConfigTargetList") != m.end() && !m["AlertConfigTargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfigTargetList"].type()) {
        vector<CreateHostAvailabilityRequestAlertConfigTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfigTargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHostAvailabilityRequestAlertConfigTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfigTargetList = make_shared<vector<CreateHostAvailabilityRequestAlertConfigTargetList>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskScope") != m.end() && !m["TaskScope"].empty()) {
      taskScope = make_shared<string>(boost::any_cast<string>(m["TaskScope"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~CreateHostAvailabilityRequest() = default;
};
class CreateHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> taskId{};

  CreateHostAvailabilityResponseBody() {}

  explicit CreateHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateHostAvailabilityResponseBody() = default;
};
class CreateHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHostAvailabilityResponseBody> body{};

  CreateHostAvailabilityResponse() {}

  explicit CreateHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHostAvailabilityResponse() = default;
};
class CreateHybridMonitorNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceRegion{};
  shared_ptr<string> namespaceType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spec{};

  CreateHybridMonitorNamespaceRequest() {}

  explicit CreateHybridMonitorNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceRegion) {
      res["NamespaceRegion"] = boost::any(*namespaceRegion);
    }
    if (namespaceType) {
      res["NamespaceType"] = boost::any(*namespaceType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceRegion") != m.end() && !m["NamespaceRegion"].empty()) {
      namespaceRegion = make_shared<string>(boost::any_cast<string>(m["NamespaceRegion"]));
    }
    if (m.find("NamespaceType") != m.end() && !m["NamespaceType"].empty()) {
      namespaceType = make_shared<string>(boost::any_cast<string>(m["NamespaceType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~CreateHybridMonitorNamespaceRequest() = default;
};
class CreateHybridMonitorNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateHybridMonitorNamespaceResponseBody() {}

  explicit CreateHybridMonitorNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateHybridMonitorNamespaceResponseBody() = default;
};
class CreateHybridMonitorNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHybridMonitorNamespaceResponseBody> body{};

  CreateHybridMonitorNamespaceResponse() {}

  explicit CreateHybridMonitorNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHybridMonitorNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHybridMonitorNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHybridMonitorNamespaceResponse() = default;
};
class CreateHybridMonitorSLSGroupRequestSLSGroupConfig : public Darabonba::Model {
public:
  shared_ptr<string> SLSLogstore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> SLSUserId{};

  CreateHybridMonitorSLSGroupRequestSLSGroupConfig() {}

  explicit CreateHybridMonitorSLSGroupRequestSLSGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLSLogstore) {
      res["SLSLogstore"] = boost::any(*SLSLogstore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (SLSUserId) {
      res["SLSUserId"] = boost::any(*SLSUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLSLogstore") != m.end() && !m["SLSLogstore"].empty()) {
      SLSLogstore = make_shared<string>(boost::any_cast<string>(m["SLSLogstore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SLSUserId") != m.end() && !m["SLSUserId"].empty()) {
      SLSUserId = make_shared<string>(boost::any_cast<string>(m["SLSUserId"]));
    }
  }


  virtual ~CreateHybridMonitorSLSGroupRequestSLSGroupConfig() = default;
};
class CreateHybridMonitorSLSGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateHybridMonitorSLSGroupRequestSLSGroupConfig>> SLSGroupConfig{};
  shared_ptr<string> SLSGroupDescription{};
  shared_ptr<string> SLSGroupName{};

  CreateHybridMonitorSLSGroupRequest() {}

  explicit CreateHybridMonitorSLSGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSGroupConfig) {
      vector<boost::any> temp1;
      for(auto item1:*SLSGroupConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SLSGroupConfig"] = boost::any(temp1);
    }
    if (SLSGroupDescription) {
      res["SLSGroupDescription"] = boost::any(*SLSGroupDescription);
    }
    if (SLSGroupName) {
      res["SLSGroupName"] = boost::any(*SLSGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSGroupConfig") != m.end() && !m["SLSGroupConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SLSGroupConfig"].type()) {
        vector<CreateHybridMonitorSLSGroupRequestSLSGroupConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SLSGroupConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorSLSGroupRequestSLSGroupConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SLSGroupConfig = make_shared<vector<CreateHybridMonitorSLSGroupRequestSLSGroupConfig>>(expect1);
      }
    }
    if (m.find("SLSGroupDescription") != m.end() && !m["SLSGroupDescription"].empty()) {
      SLSGroupDescription = make_shared<string>(boost::any_cast<string>(m["SLSGroupDescription"]));
    }
    if (m.find("SLSGroupName") != m.end() && !m["SLSGroupName"].empty()) {
      SLSGroupName = make_shared<string>(boost::any_cast<string>(m["SLSGroupName"]));
    }
  }


  virtual ~CreateHybridMonitorSLSGroupRequest() = default;
};
class CreateHybridMonitorSLSGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateHybridMonitorSLSGroupResponseBody() {}

  explicit CreateHybridMonitorSLSGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateHybridMonitorSLSGroupResponseBody() = default;
};
class CreateHybridMonitorSLSGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHybridMonitorSLSGroupResponseBody> body{};

  CreateHybridMonitorSLSGroupResponse() {}

  explicit CreateHybridMonitorSLSGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHybridMonitorSLSGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHybridMonitorSLSGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHybridMonitorSLSGroupResponse() = default;
};
class CreateHybridMonitorTaskRequestAttachLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  CreateHybridMonitorTaskRequestAttachLabels() {}

  explicit CreateHybridMonitorTaskRequestAttachLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestAttachLabels() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfigExpress : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> express{};

  CreateHybridMonitorTaskRequestSLSProcessConfigExpress() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfigExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfigExpress() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> SLSKeyName{};
  shared_ptr<string> value{};

  CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfigFilter : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters>> filters{};
  shared_ptr<string> relation{};

  CreateHybridMonitorTaskRequestSLSProcessConfigFilter() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfigFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters>>(expect1);
      }
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfigFilter() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> SLSKeyName{};

  CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfigStatistics : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> function{};
  shared_ptr<string> parameter1{};
  shared_ptr<string> parameter2{};
  shared_ptr<string> SLSKeyName{};

  CreateHybridMonitorTaskRequestSLSProcessConfigStatistics() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfigStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (parameter1) {
      res["Parameter1"] = boost::any(*parameter1);
    }
    if (parameter2) {
      res["Parameter2"] = boost::any(*parameter2);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Parameter1") != m.end() && !m["Parameter1"].empty()) {
      parameter1 = make_shared<string>(boost::any_cast<string>(m["Parameter1"]));
    }
    if (m.find("Parameter2") != m.end() && !m["Parameter2"].empty()) {
      parameter2 = make_shared<string>(boost::any_cast<string>(m["Parameter2"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfigStatistics() = default;
};
class CreateHybridMonitorTaskRequestSLSProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHybridMonitorTaskRequestSLSProcessConfigExpress>> express{};
  shared_ptr<CreateHybridMonitorTaskRequestSLSProcessConfigFilter> filter{};
  shared_ptr<vector<CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy>> groupBy{};
  shared_ptr<vector<CreateHybridMonitorTaskRequestSLSProcessConfigStatistics>> statistics{};

  CreateHybridMonitorTaskRequestSLSProcessConfig() {}

  explicit CreateHybridMonitorTaskRequestSLSProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (express) {
      vector<boost::any> temp1;
      for(auto item1:*express){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Express"] = boost::any(temp1);
    }
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupBy) {
      vector<boost::any> temp1;
      for(auto item1:*groupBy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupBy"] = boost::any(temp1);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      if (typeid(vector<boost::any>) == m["Express"].type()) {
        vector<CreateHybridMonitorTaskRequestSLSProcessConfigExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Express"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorTaskRequestSLSProcessConfigExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        express = make_shared<vector<CreateHybridMonitorTaskRequestSLSProcessConfigExpress>>(expect1);
      }
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        CreateHybridMonitorTaskRequestSLSProcessConfigFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<CreateHybridMonitorTaskRequestSLSProcessConfigFilter>(model1);
      }
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupBy"].type()) {
        vector<CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupBy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupBy = make_shared<vector<CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy>>(expect1);
      }
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<CreateHybridMonitorTaskRequestSLSProcessConfigStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorTaskRequestSLSProcessConfigStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<CreateHybridMonitorTaskRequestSLSProcessConfigStatistics>>(expect1);
      }
    }
  }


  virtual ~CreateHybridMonitorTaskRequestSLSProcessConfig() = default;
};
class CreateHybridMonitorTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHybridMonitorTaskRequestAttachLabels>> attachLabels{};
  shared_ptr<vector<string>> cloudAccessId{};
  shared_ptr<string> collectInterval{};
  shared_ptr<string> collectTargetType{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<CreateHybridMonitorTaskRequestSLSProcessConfig> SLSProcessConfig{};
  shared_ptr<string> targetUserId{};
  shared_ptr<string> targetUserIdList{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> YARMConfig{};

  CreateHybridMonitorTaskRequest() {}

  explicit CreateHybridMonitorTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachLabels) {
      vector<boost::any> temp1;
      for(auto item1:*attachLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachLabels"] = boost::any(temp1);
    }
    if (cloudAccessId) {
      res["CloudAccessId"] = boost::any(*cloudAccessId);
    }
    if (collectInterval) {
      res["CollectInterval"] = boost::any(*collectInterval);
    }
    if (collectTargetType) {
      res["CollectTargetType"] = boost::any(*collectTargetType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSProcessConfig) {
      res["SLSProcessConfig"] = SLSProcessConfig ? boost::any(SLSProcessConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (targetUserIdList) {
      res["TargetUserIdList"] = boost::any(*targetUserIdList);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (YARMConfig) {
      res["YARMConfig"] = boost::any(*YARMConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachLabels") != m.end() && !m["AttachLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachLabels"].type()) {
        vector<CreateHybridMonitorTaskRequestAttachLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHybridMonitorTaskRequestAttachLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachLabels = make_shared<vector<CreateHybridMonitorTaskRequestAttachLabels>>(expect1);
      }
    }
    if (m.find("CloudAccessId") != m.end() && !m["CloudAccessId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CloudAccessId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CloudAccessId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cloudAccessId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CollectInterval") != m.end() && !m["CollectInterval"].empty()) {
      collectInterval = make_shared<string>(boost::any_cast<string>(m["CollectInterval"]));
    }
    if (m.find("CollectTargetType") != m.end() && !m["CollectTargetType"].empty()) {
      collectTargetType = make_shared<string>(boost::any_cast<string>(m["CollectTargetType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSProcessConfig") != m.end() && !m["SLSProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLSProcessConfig"].type()) {
        CreateHybridMonitorTaskRequestSLSProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLSProcessConfig"]));
        SLSProcessConfig = make_shared<CreateHybridMonitorTaskRequestSLSProcessConfig>(model1);
      }
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("TargetUserIdList") != m.end() && !m["TargetUserIdList"].empty()) {
      targetUserIdList = make_shared<string>(boost::any_cast<string>(m["TargetUserIdList"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("YARMConfig") != m.end() && !m["YARMConfig"].empty()) {
      YARMConfig = make_shared<string>(boost::any_cast<string>(m["YARMConfig"]));
    }
  }


  virtual ~CreateHybridMonitorTaskRequest() = default;
};
class CreateHybridMonitorTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> taskId{};

  CreateHybridMonitorTaskResponseBody() {}

  explicit CreateHybridMonitorTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateHybridMonitorTaskResponseBody() = default;
};
class CreateHybridMonitorTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHybridMonitorTaskResponseBody> body{};

  CreateHybridMonitorTaskResponse() {}

  explicit CreateHybridMonitorTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHybridMonitorTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHybridMonitorTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHybridMonitorTaskResponse() = default;
};
class CreateInstantSiteMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> ispCities{};
  shared_ptr<string> optionsJson{};
  shared_ptr<long> randomIspCity{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  CreateInstantSiteMonitorRequest() {}

  explicit CreateInstantSiteMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (ispCities) {
      res["IspCities"] = boost::any(*ispCities);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (randomIspCity) {
      res["RandomIspCity"] = boost::any(*randomIspCity);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("IspCities") != m.end() && !m["IspCities"].empty()) {
      ispCities = make_shared<string>(boost::any_cast<string>(m["IspCities"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RandomIspCity") != m.end() && !m["RandomIspCity"].empty()) {
      randomIspCity = make_shared<long>(boost::any_cast<long>(m["RandomIspCity"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~CreateInstantSiteMonitorRequest() = default;
};
class CreateInstantSiteMonitorResponseBodyCreateResultList : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  CreateInstantSiteMonitorResponseBodyCreateResultList() {}

  explicit CreateInstantSiteMonitorResponseBodyCreateResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateInstantSiteMonitorResponseBodyCreateResultList() = default;
};
class CreateInstantSiteMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CreateInstantSiteMonitorResponseBodyCreateResultList>> createResultList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateInstantSiteMonitorResponseBody() {}

  explicit CreateInstantSiteMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResultList) {
      vector<boost::any> temp1;
      for(auto item1:*createResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CreateResultList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResultList") != m.end() && !m["CreateResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["CreateResultList"].type()) {
        vector<CreateInstantSiteMonitorResponseBodyCreateResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CreateResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstantSiteMonitorResponseBodyCreateResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        createResultList = make_shared<vector<CreateInstantSiteMonitorResponseBodyCreateResultList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateInstantSiteMonitorResponseBody() = default;
};
class CreateInstantSiteMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstantSiteMonitorResponseBody> body{};

  CreateInstantSiteMonitorResponse() {}

  explicit CreateInstantSiteMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstantSiteMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstantSiteMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstantSiteMonitorResponse() = default;
};
class CreateMetricRuleBlackListRequestMetrics : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> resource{};

  CreateMetricRuleBlackListRequestMetrics() {}

  explicit CreateMetricRuleBlackListRequestMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~CreateMetricRuleBlackListRequestMetrics() = default;
};
class CreateMetricRuleBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> enableEndTime{};
  shared_ptr<string> enableStartTime{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<vector<CreateMetricRuleBlackListRequestMetrics>> metrics{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scopeType{};
  shared_ptr<string> scopeValue{};

  CreateMetricRuleBlackListRequest() {}

  explicit CreateMetricRuleBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (enableEndTime) {
      res["EnableEndTime"] = boost::any(*enableEndTime);
    }
    if (enableStartTime) {
      res["EnableStartTime"] = boost::any(*enableStartTime);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("EnableEndTime") != m.end() && !m["EnableEndTime"].empty()) {
      enableEndTime = make_shared<string>(boost::any_cast<string>(m["EnableEndTime"]));
    }
    if (m.find("EnableStartTime") != m.end() && !m["EnableStartTime"].empty()) {
      enableStartTime = make_shared<string>(boost::any_cast<string>(m["EnableStartTime"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<CreateMetricRuleBlackListRequestMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMetricRuleBlackListRequestMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<CreateMetricRuleBlackListRequestMetrics>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      scopeValue = make_shared<string>(boost::any_cast<string>(m["ScopeValue"]));
    }
  }


  virtual ~CreateMetricRuleBlackListRequest() = default;
};
class CreateMetricRuleBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMetricRuleBlackListResponseBody() {}

  explicit CreateMetricRuleBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMetricRuleBlackListResponseBody() = default;
};
class CreateMetricRuleBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMetricRuleBlackListResponseBody> body{};

  CreateMetricRuleBlackListResponse() {}

  explicit CreateMetricRuleBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetricRuleBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetricRuleBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetricRuleBlackListResponse() = default;
};
class CreateMetricRuleResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> overwrite{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};

  CreateMetricRuleResourcesRequest() {}

  explicit CreateMetricRuleResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<string>(boost::any_cast<string>(m["Overwrite"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~CreateMetricRuleResourcesRequest() = default;
};
class CreateMetricRuleResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMetricRuleResourcesResponseBody() {}

  explicit CreateMetricRuleResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMetricRuleResourcesResponseBody() = default;
};
class CreateMetricRuleResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMetricRuleResourcesResponseBody> body{};

  CreateMetricRuleResourcesResponse() {}

  explicit CreateMetricRuleResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetricRuleResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetricRuleResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetricRuleResourcesResponse() = default;
};
class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical() {}

  explicit CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical() = default;
};
class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo() {}

  explicit CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo() = default;
};
class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn() {}

  explicit CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn() = default;
};
class CreateMetricRuleTemplateRequestAlertTemplatesEscalations : public Darabonba::Model {
public:
  shared_ptr<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical> critical{};
  shared_ptr<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo> info{};
  shared_ptr<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn> warn{};

  CreateMetricRuleTemplateRequestAlertTemplatesEscalations() {}

  explicit CreateMetricRuleTemplateRequestAlertTemplatesEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn>(model1);
      }
    }
  }


  virtual ~CreateMetricRuleTemplateRequestAlertTemplatesEscalations() = default;
};
class CreateMetricRuleTemplateRequestAlertTemplates : public Darabonba::Model {
public:
  shared_ptr<CreateMetricRuleTemplateRequestAlertTemplatesEscalations> escalations{};
  shared_ptr<string> category{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> period{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> selector{};
  shared_ptr<string> webhook{};

  CreateMetricRuleTemplateRequestAlertTemplates() {}

  explicit CreateMetricRuleTemplateRequestAlertTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        CreateMetricRuleTemplateRequestAlertTemplatesEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<CreateMetricRuleTemplateRequestAlertTemplatesEscalations>(model1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<string>(boost::any_cast<string>(m["Selector"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~CreateMetricRuleTemplateRequestAlertTemplates() = default;
};
class CreateMetricRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMetricRuleTemplateRequestAlertTemplates>> alertTemplates{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  CreateMetricRuleTemplateRequest() {}

  explicit CreateMetricRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*alertTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertTemplates"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTemplates") != m.end() && !m["AlertTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertTemplates"].type()) {
        vector<CreateMetricRuleTemplateRequestAlertTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMetricRuleTemplateRequestAlertTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertTemplates = make_shared<vector<CreateMetricRuleTemplateRequestAlertTemplates>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMetricRuleTemplateRequest() = default;
};
class CreateMetricRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMetricRuleTemplateResponseBody() {}

  explicit CreateMetricRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMetricRuleTemplateResponseBody() = default;
};
class CreateMetricRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMetricRuleTemplateResponseBody> body{};

  CreateMetricRuleTemplateResponse() {}

  explicit CreateMetricRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetricRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetricRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetricRuleTemplateResponse() = default;
};
class CreateMonitorAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> processName{};
  shared_ptr<string> processUser{};
  shared_ptr<string> regionId{};

  CreateMonitorAgentProcessRequest() {}

  explicit CreateMonitorAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (processUser) {
      res["ProcessUser"] = boost::any(*processUser);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("ProcessUser") != m.end() && !m["ProcessUser"].empty()) {
      processUser = make_shared<string>(boost::any_cast<string>(m["ProcessUser"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMonitorAgentProcessRequest() = default;
};
class CreateMonitorAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMonitorAgentProcessResponseBody() {}

  explicit CreateMonitorAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMonitorAgentProcessResponseBody() = default;
};
class CreateMonitorAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorAgentProcessResponseBody> body{};

  CreateMonitorAgentProcessResponse() {}

  explicit CreateMonitorAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorAgentProcessResponse() = default;
};
class CreateMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroups{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  CreateMonitorGroupRequest() {}

  explicit CreateMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMonitorGroupRequest() = default;
};
class CreateMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<long> groupId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMonitorGroupResponseBody() {}

  explicit CreateMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMonitorGroupResponseBody() = default;
};
class CreateMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorGroupResponseBody> body{};

  CreateMonitorGroupResponse() {}

  explicit CreateMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupResponse() = default;
};
class CreateMonitorGroupByResourceGroupIdRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroupList{};
  shared_ptr<bool> enableInstallAgent{};
  shared_ptr<bool> enableSubscribeEvent{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> resourceGroupName{};

  CreateMonitorGroupByResourceGroupIdRequest() {}

  explicit CreateMonitorGroupByResourceGroupIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupList) {
      res["ContactGroupList"] = boost::any(*contactGroupList);
    }
    if (enableInstallAgent) {
      res["EnableInstallAgent"] = boost::any(*enableInstallAgent);
    }
    if (enableSubscribeEvent) {
      res["EnableSubscribeEvent"] = boost::any(*enableSubscribeEvent);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (resourceGroupName) {
      res["ResourceGroupName"] = boost::any(*resourceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupList") != m.end() && !m["ContactGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableInstallAgent") != m.end() && !m["EnableInstallAgent"].empty()) {
      enableInstallAgent = make_shared<bool>(boost::any_cast<bool>(m["EnableInstallAgent"]));
    }
    if (m.find("EnableSubscribeEvent") != m.end() && !m["EnableSubscribeEvent"].empty()) {
      enableSubscribeEvent = make_shared<bool>(boost::any_cast<bool>(m["EnableSubscribeEvent"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ResourceGroupName") != m.end() && !m["ResourceGroupName"].empty()) {
      resourceGroupName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupName"]));
    }
  }


  virtual ~CreateMonitorGroupByResourceGroupIdRequest() = default;
};
class CreateMonitorGroupByResourceGroupIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMonitorGroupByResourceGroupIdResponseBody() {}

  explicit CreateMonitorGroupByResourceGroupIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMonitorGroupByResourceGroupIdResponseBody() = default;
};
class CreateMonitorGroupByResourceGroupIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorGroupByResourceGroupIdResponseBody> body{};

  CreateMonitorGroupByResourceGroupIdResponse() {}

  explicit CreateMonitorGroupByResourceGroupIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupByResourceGroupIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupByResourceGroupIdResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupByResourceGroupIdResponse() = default;
};
class CreateMonitorGroupInstancesRequestInstances : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  CreateMonitorGroupInstancesRequestInstances() {}

  explicit CreateMonitorGroupInstancesRequestInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMonitorGroupInstancesRequestInstances() = default;
};
class CreateMonitorGroupInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<vector<CreateMonitorGroupInstancesRequestInstances>> instances{};
  shared_ptr<string> regionId{};

  CreateMonitorGroupInstancesRequest() {}

  explicit CreateMonitorGroupInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<CreateMonitorGroupInstancesRequestInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMonitorGroupInstancesRequestInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<CreateMonitorGroupInstancesRequestInstances>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMonitorGroupInstancesRequest() = default;
};
class CreateMonitorGroupInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMonitorGroupInstancesResponseBody() {}

  explicit CreateMonitorGroupInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMonitorGroupInstancesResponseBody() = default;
};
class CreateMonitorGroupInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorGroupInstancesResponseBody> body{};

  CreateMonitorGroupInstancesResponse() {}

  explicit CreateMonitorGroupInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupInstancesResponse() = default;
};
class CreateMonitorGroupNotifyPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> policyType{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTime{};

  CreateMonitorGroupNotifyPolicyRequest() {}

  explicit CreateMonitorGroupNotifyPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~CreateMonitorGroupNotifyPolicyRequest() = default;
};
class CreateMonitorGroupNotifyPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};
  shared_ptr<string> success{};

  CreateMonitorGroupNotifyPolicyResponseBody() {}

  explicit CreateMonitorGroupNotifyPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateMonitorGroupNotifyPolicyResponseBody() = default;
};
class CreateMonitorGroupNotifyPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorGroupNotifyPolicyResponseBody> body{};

  CreateMonitorGroupNotifyPolicyResponse() {}

  explicit CreateMonitorGroupNotifyPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupNotifyPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupNotifyPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupNotifyPolicyResponse() = default;
};
class CreateMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> processName{};
  shared_ptr<string> processUser{};
  shared_ptr<string> regionId{};

  CreateMonitoringAgentProcessRequest() {}

  explicit CreateMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (processUser) {
      res["ProcessUser"] = boost::any(*processUser);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("ProcessUser") != m.end() && !m["ProcessUser"].empty()) {
      processUser = make_shared<string>(boost::any_cast<string>(m["ProcessUser"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateMonitoringAgentProcessRequest() = default;
};
class CreateMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> id{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateMonitoringAgentProcessResponseBody() {}

  explicit CreateMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMonitoringAgentProcessResponseBody() = default;
};
class CreateMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitoringAgentProcessResponseBody> body{};

  CreateMonitoringAgentProcessResponse() {}

  explicit CreateMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitoringAgentProcessResponse() = default;
};
class CreateSiteMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> alertIds{};
  shared_ptr<string> customSchedule{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispCities{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> vpcConfig{};

  CreateSiteMonitorRequest() {}

  explicit CreateSiteMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (customSchedule) {
      res["CustomSchedule"] = boost::any(*customSchedule);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCities) {
      res["IspCities"] = boost::any(*ispCities);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (vpcConfig) {
      res["VpcConfig"] = boost::any(*vpcConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("CustomSchedule") != m.end() && !m["CustomSchedule"].empty()) {
      customSchedule = make_shared<string>(boost::any_cast<string>(m["CustomSchedule"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspCities") != m.end() && !m["IspCities"].empty()) {
      ispCities = make_shared<string>(boost::any_cast<string>(m["IspCities"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      vpcConfig = make_shared<string>(boost::any_cast<string>(m["VpcConfig"]));
    }
  }


  virtual ~CreateSiteMonitorRequest() = default;
};
class CreateSiteMonitorResponseBodyCreateResultListCreateResultList : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  CreateSiteMonitorResponseBodyCreateResultListCreateResultList() {}

  explicit CreateSiteMonitorResponseBodyCreateResultListCreateResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateSiteMonitorResponseBodyCreateResultListCreateResultList() = default;
};
class CreateSiteMonitorResponseBodyCreateResultList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteMonitorResponseBodyCreateResultListCreateResultList>> createResultList{};

  CreateSiteMonitorResponseBodyCreateResultList() {}

  explicit CreateSiteMonitorResponseBodyCreateResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createResultList) {
      vector<boost::any> temp1;
      for(auto item1:*createResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CreateResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateResultList") != m.end() && !m["CreateResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["CreateResultList"].type()) {
        vector<CreateSiteMonitorResponseBodyCreateResultListCreateResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CreateResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteMonitorResponseBodyCreateResultListCreateResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        createResultList = make_shared<vector<CreateSiteMonitorResponseBodyCreateResultListCreateResultList>>(expect1);
      }
    }
  }


  virtual ~CreateSiteMonitorResponseBodyCreateResultList() = default;
};
class CreateSiteMonitorResponseBodyDataAttachAlertResultContact : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> success{};

  CreateSiteMonitorResponseBodyDataAttachAlertResultContact() {}

  explicit CreateSiteMonitorResponseBodyDataAttachAlertResultContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSiteMonitorResponseBodyDataAttachAlertResultContact() = default;
};
class CreateSiteMonitorResponseBodyDataAttachAlertResult : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSiteMonitorResponseBodyDataAttachAlertResultContact>> contact{};

  CreateSiteMonitorResponseBodyDataAttachAlertResult() {}

  explicit CreateSiteMonitorResponseBodyDataAttachAlertResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      vector<boost::any> temp1;
      for(auto item1:*contact){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contact"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<CreateSiteMonitorResponseBodyDataAttachAlertResultContact> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contact"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSiteMonitorResponseBodyDataAttachAlertResultContact model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contact = make_shared<vector<CreateSiteMonitorResponseBodyDataAttachAlertResultContact>>(expect1);
      }
    }
  }


  virtual ~CreateSiteMonitorResponseBodyDataAttachAlertResult() = default;
};
class CreateSiteMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CreateSiteMonitorResponseBodyDataAttachAlertResult> attachAlertResult{};

  CreateSiteMonitorResponseBodyData() {}

  explicit CreateSiteMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachAlertResult) {
      res["AttachAlertResult"] = attachAlertResult ? boost::any(attachAlertResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachAlertResult") != m.end() && !m["AttachAlertResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttachAlertResult"].type()) {
        CreateSiteMonitorResponseBodyDataAttachAlertResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttachAlertResult"]));
        attachAlertResult = make_shared<CreateSiteMonitorResponseBodyDataAttachAlertResult>(model1);
      }
    }
  }


  virtual ~CreateSiteMonitorResponseBodyData() = default;
};
class CreateSiteMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSiteMonitorResponseBodyCreateResultList> createResultList{};
  shared_ptr<CreateSiteMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateSiteMonitorResponseBody() {}

  explicit CreateSiteMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResultList) {
      res["CreateResultList"] = createResultList ? boost::any(createResultList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResultList") != m.end() && !m["CreateResultList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResultList"].type()) {
        CreateSiteMonitorResponseBodyCreateResultList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResultList"]));
        createResultList = make_shared<CreateSiteMonitorResponseBodyCreateResultList>(model1);
      }
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSiteMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSiteMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSiteMonitorResponseBody() = default;
};
class CreateSiteMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSiteMonitorResponseBody> body{};

  CreateSiteMonitorResponse() {}

  explicit CreateSiteMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSiteMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSiteMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSiteMonitorResponse() = default;
};
class CursorRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<vector<Matcher>> matchers{};
  shared_ptr<string> metric{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> period{};
  shared_ptr<string> startTime{};

  CursorRequest() {}

  explicit CursorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (matchers) {
      vector<boost::any> temp1;
      for(auto item1:*matchers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Matchers"] = boost::any(temp1);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Matchers") != m.end() && !m["Matchers"].empty()) {
      if (typeid(vector<boost::any>) == m["Matchers"].type()) {
        vector<Matcher> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Matchers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Matcher model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchers = make_shared<vector<Matcher>>(expect1);
      }
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CursorRequest() = default;
};
class CursorShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> matchersShrink{};
  shared_ptr<string> metric{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> period{};
  shared_ptr<string> startTime{};

  CursorShrinkRequest() {}

  explicit CursorShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (matchersShrink) {
      res["Matchers"] = boost::any(*matchersShrink);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Matchers") != m.end() && !m["Matchers"].empty()) {
      matchersShrink = make_shared<string>(boost::any_cast<string>(m["Matchers"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~CursorShrinkRequest() = default;
};
class CursorResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> cursor{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CursorResponseBody() {}

  explicit CursorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cursor) {
      res["Cursor"] = boost::any(*cursor);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Cursor") != m.end() && !m["Cursor"].empty()) {
      cursor = make_shared<string>(boost::any_cast<string>(m["Cursor"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CursorResponseBody() = default;
};
class CursorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CursorResponseBody> body{};

  CursorResponse() {}

  explicit CursorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CursorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CursorResponseBody>(model1);
      }
    }
  }


  virtual ~CursorResponse() = default;
};
class DeleteContactRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactName{};

  DeleteContactRequest() {}

  explicit DeleteContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
  }


  virtual ~DeleteContactRequest() = default;
};
class DeleteContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteContactResponseBody() {}

  explicit DeleteContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteContactResponseBody() = default;
};
class DeleteContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactResponseBody> body{};

  DeleteContactResponse() {}

  explicit DeleteContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactResponse() = default;
};
class DeleteContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};

  DeleteContactGroupRequest() {}

  explicit DeleteContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
  }


  virtual ~DeleteContactGroupRequest() = default;
};
class DeleteContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteContactGroupResponseBody() {}

  explicit DeleteContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteContactGroupResponseBody() = default;
};
class DeleteContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteContactGroupResponseBody> body{};

  DeleteContactGroupResponse() {}

  explicit DeleteContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteContactGroupResponse() = default;
};
class DeleteCustomMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> md5{};
  shared_ptr<string> metricName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> UUID{};

  DeleteCustomMetricRequest() {}

  explicit DeleteCustomMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
  }


  virtual ~DeleteCustomMetricRequest() = default;
};
class DeleteCustomMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteCustomMetricResponseBody() {}

  explicit DeleteCustomMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomMetricResponseBody() = default;
};
class DeleteCustomMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomMetricResponseBody> body{};

  DeleteCustomMetricResponse() {}

  explicit DeleteCustomMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomMetricResponse() = default;
};
class DeleteDynamicTagGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicTagRuleId{};
  shared_ptr<string> regionId{};

  DeleteDynamicTagGroupRequest() {}

  explicit DeleteDynamicTagGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicTagRuleId) {
      res["DynamicTagRuleId"] = boost::any(*dynamicTagRuleId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicTagRuleId") != m.end() && !m["DynamicTagRuleId"].empty()) {
      dynamicTagRuleId = make_shared<string>(boost::any_cast<string>(m["DynamicTagRuleId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDynamicTagGroupRequest() = default;
};
class DeleteDynamicTagGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDynamicTagGroupResponseBody() {}

  explicit DeleteDynamicTagGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDynamicTagGroupResponseBody() = default;
};
class DeleteDynamicTagGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDynamicTagGroupResponseBody> body{};

  DeleteDynamicTagGroupResponse() {}

  explicit DeleteDynamicTagGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDynamicTagGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDynamicTagGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDynamicTagGroupResponse() = default;
};
class DeleteEventRuleTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ids{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};

  DeleteEventRuleTargetsRequest() {}

  explicit DeleteEventRuleTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DeleteEventRuleTargetsRequest() = default;
};
class DeleteEventRuleTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEventRuleTargetsResponseBody() {}

  explicit DeleteEventRuleTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEventRuleTargetsResponseBody() = default;
};
class DeleteEventRuleTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventRuleTargetsResponseBody> body{};

  DeleteEventRuleTargetsResponse() {}

  explicit DeleteEventRuleTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventRuleTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventRuleTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventRuleTargetsResponse() = default;
};
class DeleteEventRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleNames{};

  DeleteEventRulesRequest() {}

  explicit DeleteEventRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteEventRulesRequest() = default;
};
class DeleteEventRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteEventRulesResponseBody() {}

  explicit DeleteEventRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteEventRulesResponseBody() = default;
};
class DeleteEventRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEventRulesResponseBody> body{};

  DeleteEventRulesResponse() {}

  explicit DeleteEventRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEventRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEventRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEventRulesResponse() = default;
};
class DeleteExporterOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> destName{};
  shared_ptr<string> regionId{};

  DeleteExporterOutputRequest() {}

  explicit DeleteExporterOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteExporterOutputRequest() = default;
};
class DeleteExporterOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteExporterOutputResponseBody() {}

  explicit DeleteExporterOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteExporterOutputResponseBody() = default;
};
class DeleteExporterOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExporterOutputResponseBody> body{};

  DeleteExporterOutputResponse() {}

  explicit DeleteExporterOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExporterOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExporterOutputResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExporterOutputResponse() = default;
};
class DeleteExporterRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};

  DeleteExporterRuleRequest() {}

  explicit DeleteExporterRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DeleteExporterRuleRequest() = default;
};
class DeleteExporterRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteExporterRuleResponseBody() {}

  explicit DeleteExporterRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteExporterRuleResponseBody() = default;
};
class DeleteExporterRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteExporterRuleResponseBody> body{};

  DeleteExporterRuleResponse() {}

  explicit DeleteExporterRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteExporterRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteExporterRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteExporterRuleResponse() = default;
};
class DeleteGroupMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DeleteGroupMonitoringAgentProcessRequest() {}

  explicit DeleteGroupMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteGroupMonitoringAgentProcessRequest() = default;
};
class DeleteGroupMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGroupMonitoringAgentProcessResponseBody() {}

  explicit DeleteGroupMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGroupMonitoringAgentProcessResponseBody() = default;
};
class DeleteGroupMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGroupMonitoringAgentProcessResponseBody> body{};

  DeleteGroupMonitoringAgentProcessResponse() {}

  explicit DeleteGroupMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupMonitoringAgentProcessResponse() = default;
};
class DeleteHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> id{};
  shared_ptr<string> regionId{};

  DeleteHostAvailabilityRequest() {}

  explicit DeleteHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Id"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Id"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      id = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHostAvailabilityRequest() = default;
};
class DeleteHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHostAvailabilityResponseBody() {}

  explicit DeleteHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHostAvailabilityResponseBody() = default;
};
class DeleteHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHostAvailabilityResponseBody> body{};

  DeleteHostAvailabilityResponse() {}

  explicit DeleteHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHostAvailabilityResponse() = default;
};
class DeleteHybridMonitorNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};

  DeleteHybridMonitorNamespaceRequest() {}

  explicit DeleteHybridMonitorNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteHybridMonitorNamespaceRequest() = default;
};
class DeleteHybridMonitorNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteHybridMonitorNamespaceResponseBody() {}

  explicit DeleteHybridMonitorNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteHybridMonitorNamespaceResponseBody() = default;
};
class DeleteHybridMonitorNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHybridMonitorNamespaceResponseBody> body{};

  DeleteHybridMonitorNamespaceResponse() {}

  explicit DeleteHybridMonitorNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHybridMonitorNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHybridMonitorNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHybridMonitorNamespaceResponse() = default;
};
class DeleteHybridMonitorSLSGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> SLSGroupName{};

  DeleteHybridMonitorSLSGroupRequest() {}

  explicit DeleteHybridMonitorSLSGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSGroupName) {
      res["SLSGroupName"] = boost::any(*SLSGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSGroupName") != m.end() && !m["SLSGroupName"].empty()) {
      SLSGroupName = make_shared<string>(boost::any_cast<string>(m["SLSGroupName"]));
    }
  }


  virtual ~DeleteHybridMonitorSLSGroupRequest() = default;
};
class DeleteHybridMonitorSLSGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteHybridMonitorSLSGroupResponseBody() {}

  explicit DeleteHybridMonitorSLSGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteHybridMonitorSLSGroupResponseBody() = default;
};
class DeleteHybridMonitorSLSGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHybridMonitorSLSGroupResponseBody> body{};

  DeleteHybridMonitorSLSGroupResponse() {}

  explicit DeleteHybridMonitorSLSGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHybridMonitorSLSGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHybridMonitorSLSGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHybridMonitorSLSGroupResponse() = default;
};
class DeleteHybridMonitorTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetUserId{};
  shared_ptr<string> taskId{};

  DeleteHybridMonitorTaskRequest() {}

  explicit DeleteHybridMonitorTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteHybridMonitorTaskRequest() = default;
};
class DeleteHybridMonitorTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteHybridMonitorTaskResponseBody() {}

  explicit DeleteHybridMonitorTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteHybridMonitorTaskResponseBody() = default;
};
class DeleteHybridMonitorTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHybridMonitorTaskResponseBody> body{};

  DeleteHybridMonitorTaskResponse() {}

  explicit DeleteHybridMonitorTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHybridMonitorTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHybridMonitorTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHybridMonitorTaskResponse() = default;
};
class DeleteLogMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> logId{};
  shared_ptr<string> regionId{};

  DeleteLogMonitorRequest() {}

  explicit DeleteLogMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<long>(boost::any_cast<long>(m["LogId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteLogMonitorRequest() = default;
};
class DeleteLogMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteLogMonitorResponseBody() {}

  explicit DeleteLogMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteLogMonitorResponseBody() = default;
};
class DeleteLogMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogMonitorResponseBody> body{};

  DeleteLogMonitorResponse() {}

  explicit DeleteLogMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogMonitorResponse() = default;
};
class DeleteMetricRuleBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> regionId{};

  DeleteMetricRuleBlackListRequest() {}

  explicit DeleteMetricRuleBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMetricRuleBlackListRequest() = default;
};
class DeleteMetricRuleBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> count{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMetricRuleBlackListResponseBody() {}

  explicit DeleteMetricRuleBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetricRuleBlackListResponseBody() = default;
};
class DeleteMetricRuleBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetricRuleBlackListResponseBody> body{};

  DeleteMetricRuleBlackListResponse() {}

  explicit DeleteMetricRuleBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetricRuleBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetricRuleBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetricRuleBlackListResponse() = default;
};
class DeleteMetricRuleResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};

  DeleteMetricRuleResourcesRequest() {}

  explicit DeleteMetricRuleResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DeleteMetricRuleResourcesRequest() = default;
};
class DeleteMetricRuleResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMetricRuleResourcesResponseBody() {}

  explicit DeleteMetricRuleResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetricRuleResourcesResponseBody() = default;
};
class DeleteMetricRuleResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetricRuleResourcesResponseBody> body{};

  DeleteMetricRuleResourcesResponse() {}

  explicit DeleteMetricRuleResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetricRuleResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetricRuleResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetricRuleResourcesResponse() = default;
};
class DeleteMetricRuleTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<vector<string>> targetIds{};

  DeleteMetricRuleTargetsRequest() {}

  explicit DeleteMetricRuleTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (targetIds) {
      res["TargetIds"] = boost::any(*targetIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("TargetIds") != m.end() && !m["TargetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteMetricRuleTargetsRequest() = default;
};
class DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> targetId{};

  DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds() {}

  explicit DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds() = default;
};
class DeleteMetricRuleTargetsResponseBodyFailIds : public Darabonba::Model {
public:
  shared_ptr<DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds> targetIds{};

  DeleteMetricRuleTargetsResponseBodyFailIds() {}

  explicit DeleteMetricRuleTargetsResponseBodyFailIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetIds) {
      res["TargetIds"] = targetIds ? boost::any(targetIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetIds") != m.end() && !m["TargetIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetIds"].type()) {
        DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetIds"]));
        targetIds = make_shared<DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds>(model1);
      }
    }
  }


  virtual ~DeleteMetricRuleTargetsResponseBodyFailIds() = default;
};
class DeleteMetricRuleTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteMetricRuleTargetsResponseBodyFailIds> failIds{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMetricRuleTargetsResponseBody() {}

  explicit DeleteMetricRuleTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failIds) {
      res["FailIds"] = failIds ? boost::any(failIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailIds") != m.end() && !m["FailIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailIds"].type()) {
        DeleteMetricRuleTargetsResponseBodyFailIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailIds"]));
        failIds = make_shared<DeleteMetricRuleTargetsResponseBodyFailIds>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetricRuleTargetsResponseBody() = default;
};
class DeleteMetricRuleTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetricRuleTargetsResponseBody> body{};

  DeleteMetricRuleTargetsResponse() {}

  explicit DeleteMetricRuleTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetricRuleTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetricRuleTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetricRuleTargetsResponse() = default;
};
class DeleteMetricRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  DeleteMetricRuleTemplateRequest() {}

  explicit DeleteMetricRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMetricRuleTemplateRequest() = default;
};
class DeleteMetricRuleTemplateResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteMetricRuleTemplateResponseBodyResource() {}

  explicit DeleteMetricRuleTemplateResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMetricRuleTemplateResponseBodyResource() = default;
};
class DeleteMetricRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteMetricRuleTemplateResponseBodyResource> resource{};
  shared_ptr<bool> success{};

  DeleteMetricRuleTemplateResponseBody() {}

  explicit DeleteMetricRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DeleteMetricRuleTemplateResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DeleteMetricRuleTemplateResponseBodyResource>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetricRuleTemplateResponseBody() = default;
};
class DeleteMetricRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetricRuleTemplateResponseBody> body{};

  DeleteMetricRuleTemplateResponse() {}

  explicit DeleteMetricRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetricRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetricRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetricRuleTemplateResponse() = default;
};
class DeleteMetricRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> id{};
  shared_ptr<string> regionId{};

  DeleteMetricRulesRequest() {}

  explicit DeleteMetricRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Id"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Id"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      id = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMetricRulesRequest() = default;
};
class DeleteMetricRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMetricRulesResponseBody() {}

  explicit DeleteMetricRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetricRulesResponseBody() = default;
};
class DeleteMetricRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMetricRulesResponseBody> body{};

  DeleteMetricRulesResponse() {}

  explicit DeleteMetricRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetricRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetricRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetricRulesResponse() = default;
};
class DeleteMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> regionId{};

  DeleteMonitorGroupRequest() {}

  explicit DeleteMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMonitorGroupRequest() = default;
};
class DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup() {}

  explicit DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup() = default;
};
class DeleteMonitorGroupResponseBodyGroupContactGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup>> contactGroup{};

  DeleteMonitorGroupResponseBodyGroupContactGroups() {}

  explicit DeleteMonitorGroupResponseBodyGroupContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroup = make_shared<vector<DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup>>(expect1);
      }
    }
  }


  virtual ~DeleteMonitorGroupResponseBodyGroupContactGroups() = default;
};
class DeleteMonitorGroupResponseBodyGroup : public Darabonba::Model {
public:
  shared_ptr<DeleteMonitorGroupResponseBodyGroupContactGroups> contactGroups{};
  shared_ptr<string> groupName{};

  DeleteMonitorGroupResponseBodyGroup() {}

  explicit DeleteMonitorGroupResponseBodyGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      res["ContactGroups"] = contactGroups ? boost::any(contactGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroups"].type()) {
        DeleteMonitorGroupResponseBodyGroupContactGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroups"]));
        contactGroups = make_shared<DeleteMonitorGroupResponseBodyGroupContactGroups>(model1);
      }
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteMonitorGroupResponseBodyGroup() = default;
};
class DeleteMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DeleteMonitorGroupResponseBodyGroup> group{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMonitorGroupResponseBody() {}

  explicit DeleteMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (group) {
      res["Group"] = group ? boost::any(group->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(map<string, boost::any>) == m["Group"].type()) {
        DeleteMonitorGroupResponseBodyGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Group"]));
        group = make_shared<DeleteMonitorGroupResponseBodyGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMonitorGroupResponseBody() = default;
};
class DeleteMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitorGroupResponseBody> body{};

  DeleteMonitorGroupResponse() {}

  explicit DeleteMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitorGroupResponse() = default;
};
class DeleteMonitorGroupDynamicRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> groupId{};
  shared_ptr<string> regionId{};

  DeleteMonitorGroupDynamicRuleRequest() {}

  explicit DeleteMonitorGroupDynamicRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMonitorGroupDynamicRuleRequest() = default;
};
class DeleteMonitorGroupDynamicRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMonitorGroupDynamicRuleResponseBody() {}

  explicit DeleteMonitorGroupDynamicRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMonitorGroupDynamicRuleResponseBody() = default;
};
class DeleteMonitorGroupDynamicRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitorGroupDynamicRuleResponseBody> body{};

  DeleteMonitorGroupDynamicRuleResponse() {}

  explicit DeleteMonitorGroupDynamicRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitorGroupDynamicRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitorGroupDynamicRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitorGroupDynamicRuleResponse() = default;
};
class DeleteMonitorGroupInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceIdList{};
  shared_ptr<string> regionId{};

  DeleteMonitorGroupInstancesRequest() {}

  explicit DeleteMonitorGroupInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceIdList) {
      res["InstanceIdList"] = boost::any(*instanceIdList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceIdList") != m.end() && !m["InstanceIdList"].empty()) {
      instanceIdList = make_shared<string>(boost::any_cast<string>(m["InstanceIdList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMonitorGroupInstancesRequest() = default;
};
class DeleteMonitorGroupInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMonitorGroupInstancesResponseBody() {}

  explicit DeleteMonitorGroupInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMonitorGroupInstancesResponseBody() = default;
};
class DeleteMonitorGroupInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitorGroupInstancesResponseBody> body{};

  DeleteMonitorGroupInstancesResponse() {}

  explicit DeleteMonitorGroupInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitorGroupInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitorGroupInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitorGroupInstancesResponse() = default;
};
class DeleteMonitorGroupNotifyPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> policyType{};
  shared_ptr<string> regionId{};

  DeleteMonitorGroupNotifyPolicyRequest() {}

  explicit DeleteMonitorGroupNotifyPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMonitorGroupNotifyPolicyRequest() = default;
};
class DeleteMonitorGroupNotifyPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> result{};
  shared_ptr<string> success{};

  DeleteMonitorGroupNotifyPolicyResponseBody() {}

  explicit DeleteMonitorGroupNotifyPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteMonitorGroupNotifyPolicyResponseBody() = default;
};
class DeleteMonitorGroupNotifyPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitorGroupNotifyPolicyResponseBody> body{};

  DeleteMonitorGroupNotifyPolicyResponse() {}

  explicit DeleteMonitorGroupNotifyPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitorGroupNotifyPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitorGroupNotifyPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitorGroupNotifyPolicyResponse() = default;
};
class DeleteMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> processId{};
  shared_ptr<string> processName{};
  shared_ptr<string> regionId{};

  DeleteMonitoringAgentProcessRequest() {}

  explicit DeleteMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<string>(boost::any_cast<string>(m["ProcessId"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteMonitoringAgentProcessRequest() = default;
};
class DeleteMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMonitoringAgentProcessResponseBody() {}

  explicit DeleteMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMonitoringAgentProcessResponseBody() = default;
};
class DeleteMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitoringAgentProcessResponseBody> body{};

  DeleteMonitoringAgentProcessResponse() {}

  explicit DeleteMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitoringAgentProcessResponse() = default;
};
class DeleteSiteMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isDeleteAlarms{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIds{};

  DeleteSiteMonitorsRequest() {}

  explicit DeleteSiteMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDeleteAlarms) {
      res["IsDeleteAlarms"] = boost::any(*isDeleteAlarms);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDeleteAlarms") != m.end() && !m["IsDeleteAlarms"].empty()) {
      isDeleteAlarms = make_shared<bool>(boost::any_cast<bool>(m["IsDeleteAlarms"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~DeleteSiteMonitorsRequest() = default;
};
class DeleteSiteMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  DeleteSiteMonitorsResponseBodyData() {}

  explicit DeleteSiteMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~DeleteSiteMonitorsResponseBodyData() = default;
};
class DeleteSiteMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteSiteMonitorsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteSiteMonitorsResponseBody() {}

  explicit DeleteSiteMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteSiteMonitorsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteSiteMonitorsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteSiteMonitorsResponseBody() = default;
};
class DeleteSiteMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSiteMonitorsResponseBody> body{};

  DeleteSiteMonitorsResponse() {}

  explicit DeleteSiteMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSiteMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSiteMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSiteMonitorsResponse() = default;
};
class DescribeActiveMetricRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> product{};

  DescribeActiveMetricRuleListRequest() {}

  explicit DescribeActiveMetricRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (product) {
      res["Product"] = boost::any(*product);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListRequest() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};

  DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};

  DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};

  DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations : public Darabonba::Model {
public:
  shared_ptr<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical> critical{};
  shared_ptr<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo> info{};
  shared_ptr<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn> warn{};

  DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn>(model1);
      }
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertListAlert : public Darabonba::Model {
public:
  shared_ptr<string> alertState{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<bool> enableState{};
  shared_ptr<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations> escalations{};
  shared_ptr<string> mailSubject{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> period{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> silenceTime{};
  shared_ptr<string> webhook{};

  DescribeActiveMetricRuleListResponseBodyAlertListAlert() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertListAlert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertState) {
      res["AlertState"] = boost::any(*alertState);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (enableState) {
      res["EnableState"] = boost::any(*enableState);
    }
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mailSubject) {
      res["MailSubject"] = boost::any(*mailSubject);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertState") != m.end() && !m["AlertState"].empty()) {
      alertState = make_shared<string>(boost::any_cast<string>(m["AlertState"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EnableState") != m.end() && !m["EnableState"].empty()) {
      enableState = make_shared<bool>(boost::any_cast<bool>(m["EnableState"]));
    }
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations>(model1);
      }
    }
    if (m.find("MailSubject") != m.end() && !m["MailSubject"].empty()) {
      mailSubject = make_shared<string>(boost::any_cast<string>(m["MailSubject"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertListAlert() = default;
};
class DescribeActiveMetricRuleListResponseBodyAlertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeActiveMetricRuleListResponseBodyAlertListAlert>> alert{};

  DescribeActiveMetricRuleListResponseBodyAlertList() {}

  explicit DescribeActiveMetricRuleListResponseBodyAlertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alert) {
      vector<boost::any> temp1;
      for(auto item1:*alert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alert") != m.end() && !m["Alert"].empty()) {
      if (typeid(vector<boost::any>) == m["Alert"].type()) {
        vector<DescribeActiveMetricRuleListResponseBodyAlertListAlert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeActiveMetricRuleListResponseBodyAlertListAlert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alert = make_shared<vector<DescribeActiveMetricRuleListResponseBodyAlertListAlert>>(expect1);
      }
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyAlertList() = default;
};
class DescribeActiveMetricRuleListResponseBodyDatapointsAlarm : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> enable{};
  shared_ptr<string> endTime{};
  shared_ptr<string> evaluationCount{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> period{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> silenceTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> webhook{};

  DescribeActiveMetricRuleListResponseBodyDatapointsAlarm() {}

  explicit DescribeActiveMetricRuleListResponseBodyDatapointsAlarm(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<string>(boost::any_cast<string>(m["EvaluationCount"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyDatapointsAlarm() = default;
};
class DescribeActiveMetricRuleListResponseBodyDatapoints : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeActiveMetricRuleListResponseBodyDatapointsAlarm>> alarm{};

  DescribeActiveMetricRuleListResponseBodyDatapoints() {}

  explicit DescribeActiveMetricRuleListResponseBodyDatapoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarm) {
      vector<boost::any> temp1;
      for(auto item1:*alarm){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alarm"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarm") != m.end() && !m["Alarm"].empty()) {
      if (typeid(vector<boost::any>) == m["Alarm"].type()) {
        vector<DescribeActiveMetricRuleListResponseBodyDatapointsAlarm> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alarm"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeActiveMetricRuleListResponseBodyDatapointsAlarm model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarm = make_shared<vector<DescribeActiveMetricRuleListResponseBodyDatapointsAlarm>>(expect1);
      }
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBodyDatapoints() = default;
};
class DescribeActiveMetricRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeActiveMetricRuleListResponseBodyAlertList> alertList{};
  shared_ptr<string> code{};
  shared_ptr<DescribeActiveMetricRuleListResponseBodyDatapoints> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeActiveMetricRuleListResponseBody() {}

  explicit DescribeActiveMetricRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertList) {
      res["AlertList"] = alertList ? boost::any(alertList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = datapoints ? boost::any(datapoints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertList") != m.end() && !m["AlertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertList"].type()) {
        DescribeActiveMetricRuleListResponseBodyAlertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertList"]));
        alertList = make_shared<DescribeActiveMetricRuleListResponseBodyAlertList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      if (typeid(map<string, boost::any>) == m["Datapoints"].type()) {
        DescribeActiveMetricRuleListResponseBodyDatapoints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Datapoints"]));
        datapoints = make_shared<DescribeActiveMetricRuleListResponseBodyDatapoints>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeActiveMetricRuleListResponseBody() = default;
};
class DescribeActiveMetricRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeActiveMetricRuleListResponseBody> body{};

  DescribeActiveMetricRuleListResponse() {}

  explicit DescribeActiveMetricRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeActiveMetricRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeActiveMetricRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeActiveMetricRuleListResponse() = default;
};
class DescribeAlertHistoryListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> ascending{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> status{};

  DescribeAlertHistoryListRequest() {}

  explicit DescribeAlertHistoryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ascending) {
      res["Ascending"] = boost::any(*ascending);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ascending") != m.end() && !m["Ascending"].empty()) {
      ascending = make_shared<bool>(boost::any_cast<bool>(m["Ascending"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAlertHistoryListRequest() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactALIIM{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactALIIM) {
      res["ContactALIIM"] = boost::any(*contactALIIM);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactALIIM") != m.end() && !m["ContactALIIM"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactALIIM"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactALIIM"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactALIIM = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroup{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactMail{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactMail) {
      res["ContactMail"] = boost::any(*contactMail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactMail") != m.end() && !m["ContactMail"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactMail"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactMail"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactMail = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactSms{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactSms) {
      res["ContactSms"] = boost::any(*contactSms);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactSms") != m.end() && !m["ContactSms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactSms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactSms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactSms = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contact{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contact"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contact = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory : public Darabonba::Model {
public:
  shared_ptr<long> alertTime{};
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs> contactALIIMs{};
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups> contactGroups{};
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails> contactMails{};
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses> contactSmses{};
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts> contacts{};
  shared_ptr<string> dimensions{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> expression{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> lastTime{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> state{};
  shared_ptr<long> status{};
  shared_ptr<string> value{};
  shared_ptr<string> webhooks{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (contactALIIMs) {
      res["ContactALIIMs"] = contactALIIMs ? boost::any(contactALIIMs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = contactGroups ? boost::any(contactGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactMails) {
      res["ContactMails"] = contactMails ? boost::any(contactMails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactSmses) {
      res["ContactSmses"] = contactSmses ? boost::any(contactSmses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contacts) {
      res["Contacts"] = contacts ? boost::any(contacts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (webhooks) {
      res["Webhooks"] = boost::any(*webhooks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<long>(boost::any_cast<long>(m["AlertTime"]));
    }
    if (m.find("ContactALIIMs") != m.end() && !m["ContactALIIMs"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactALIIMs"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactALIIMs"]));
        contactALIIMs = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroups"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroups"]));
        contactGroups = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups>(model1);
      }
    }
    if (m.find("ContactMails") != m.end() && !m["ContactMails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactMails"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactMails"]));
        contactMails = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails>(model1);
      }
    }
    if (m.find("ContactSmses") != m.end() && !m["ContactSmses"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactSmses"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactSmses"]));
        contactSmses = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses>(model1);
      }
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contacts"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contacts"]));
        contacts = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts>(model1);
      }
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Webhooks") != m.end() && !m["Webhooks"].empty()) {
      webhooks = make_shared<string>(boost::any_cast<string>(m["Webhooks"]));
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory() = default;
};
class DescribeAlertHistoryListResponseBodyAlarmHistoryList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory>> alarmHistory{};

  DescribeAlertHistoryListResponseBodyAlarmHistoryList() {}

  explicit DescribeAlertHistoryListResponseBodyAlarmHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*alarmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlarmHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmHistory") != m.end() && !m["AlarmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["AlarmHistory"].type()) {
        vector<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlarmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarmHistory = make_shared<vector<DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertHistoryListResponseBodyAlarmHistoryList() = default;
};
class DescribeAlertHistoryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAlertHistoryListResponseBodyAlarmHistoryList> alarmHistoryList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> total{};

  DescribeAlertHistoryListResponseBody() {}

  explicit DescribeAlertHistoryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmHistoryList) {
      res["AlarmHistoryList"] = alarmHistoryList ? boost::any(alarmHistoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmHistoryList") != m.end() && !m["AlarmHistoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmHistoryList"].type()) {
        DescribeAlertHistoryListResponseBodyAlarmHistoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmHistoryList"]));
        alarmHistoryList = make_shared<DescribeAlertHistoryListResponseBodyAlarmHistoryList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeAlertHistoryListResponseBody() = default;
};
class DescribeAlertHistoryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertHistoryListResponseBody> body{};

  DescribeAlertHistoryListResponse() {}

  explicit DescribeAlertHistoryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertHistoryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertHistoryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertHistoryListResponse() = default;
};
class DescribeAlertLogCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroup{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupBy{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lastMin{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sendStatus{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> startTime{};

  DescribeAlertLogCountRequest() {}

  explicit DescribeAlertLogCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupBy) {
      res["GroupBy"] = boost::any(*groupBy);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lastMin) {
      res["LastMin"] = boost::any(*lastMin);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      contactGroup = make_shared<string>(boost::any_cast<string>(m["ContactGroup"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      groupBy = make_shared<string>(boost::any_cast<string>(m["GroupBy"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("LastMin") != m.end() && !m["LastMin"].empty()) {
      lastMin = make_shared<string>(boost::any_cast<string>(m["LastMin"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<string>(boost::any_cast<string>(m["SendStatus"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeAlertLogCountRequest() = default;
};
class DescribeAlertLogCountResponseBodyAlertLogCountLogs : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeAlertLogCountResponseBodyAlertLogCountLogs() {}

  explicit DescribeAlertLogCountResponseBodyAlertLogCountLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAlertLogCountResponseBodyAlertLogCountLogs() = default;
};
class DescribeAlertLogCountResponseBodyAlertLogCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeAlertLogCountResponseBodyAlertLogCountLogs>> logs{};

  DescribeAlertLogCountResponseBodyAlertLogCount() {}

  explicit DescribeAlertLogCountResponseBodyAlertLogCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribeAlertLogCountResponseBodyAlertLogCountLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogCountResponseBodyAlertLogCountLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribeAlertLogCountResponseBodyAlertLogCountLogs>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertLogCountResponseBodyAlertLogCount() = default;
};
class DescribeAlertLogCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertLogCountResponseBodyAlertLogCount>> alertLogCount{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeAlertLogCountResponseBody() {}

  explicit DescribeAlertLogCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertLogCount) {
      vector<boost::any> temp1;
      for(auto item1:*alertLogCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertLogCount"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertLogCount") != m.end() && !m["AlertLogCount"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertLogCount"].type()) {
        vector<DescribeAlertLogCountResponseBodyAlertLogCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertLogCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogCountResponseBodyAlertLogCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertLogCount = make_shared<vector<DescribeAlertLogCountResponseBodyAlertLogCount>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAlertLogCountResponseBody() = default;
};
class DescribeAlertLogCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertLogCountResponseBody> body{};

  DescribeAlertLogCountResponse() {}

  explicit DescribeAlertLogCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertLogCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertLogCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertLogCountResponse() = default;
};
class DescribeAlertLogHistogramRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroup{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupBy{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lastMin{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sendStatus{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> startTime{};

  DescribeAlertLogHistogramRequest() {}

  explicit DescribeAlertLogHistogramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupBy) {
      res["GroupBy"] = boost::any(*groupBy);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lastMin) {
      res["LastMin"] = boost::any(*lastMin);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      contactGroup = make_shared<string>(boost::any_cast<string>(m["ContactGroup"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      groupBy = make_shared<string>(boost::any_cast<string>(m["GroupBy"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("LastMin") != m.end() && !m["LastMin"].empty()) {
      lastMin = make_shared<string>(boost::any_cast<string>(m["LastMin"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<string>(boost::any_cast<string>(m["SendStatus"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeAlertLogHistogramRequest() = default;
};
class DescribeAlertLogHistogramResponseBodyAlertLogHistogramList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> from{};
  shared_ptr<long> to{};

  DescribeAlertLogHistogramResponseBodyAlertLogHistogramList() {}

  explicit DescribeAlertLogHistogramResponseBodyAlertLogHistogramList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<long>(boost::any_cast<long>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<long>(boost::any_cast<long>(m["To"]));
    }
  }


  virtual ~DescribeAlertLogHistogramResponseBodyAlertLogHistogramList() = default;
};
class DescribeAlertLogHistogramResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertLogHistogramResponseBodyAlertLogHistogramList>> alertLogHistogramList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeAlertLogHistogramResponseBody() {}

  explicit DescribeAlertLogHistogramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertLogHistogramList) {
      vector<boost::any> temp1;
      for(auto item1:*alertLogHistogramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertLogHistogramList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertLogHistogramList") != m.end() && !m["AlertLogHistogramList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertLogHistogramList"].type()) {
        vector<DescribeAlertLogHistogramResponseBodyAlertLogHistogramList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertLogHistogramList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogHistogramResponseBodyAlertLogHistogramList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertLogHistogramList = make_shared<vector<DescribeAlertLogHistogramResponseBodyAlertLogHistogramList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAlertLogHistogramResponseBody() = default;
};
class DescribeAlertLogHistogramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertLogHistogramResponseBody> body{};

  DescribeAlertLogHistogramResponse() {}

  explicit DescribeAlertLogHistogramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertLogHistogramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertLogHistogramResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertLogHistogramResponse() = default;
};
class DescribeAlertLogListRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroup{};
  shared_ptr<long> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupBy{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lastMin{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sendStatus{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> startTime{};

  DescribeAlertLogListRequest() {}

  explicit DescribeAlertLogListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupBy) {
      res["GroupBy"] = boost::any(*groupBy);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lastMin) {
      res["LastMin"] = boost::any(*lastMin);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      contactGroup = make_shared<string>(boost::any_cast<string>(m["ContactGroup"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      groupBy = make_shared<string>(boost::any_cast<string>(m["GroupBy"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("LastMin") != m.end() && !m["LastMin"].empty()) {
      lastMin = make_shared<string>(boost::any_cast<string>(m["LastMin"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<string>(boost::any_cast<string>(m["SendStatus"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeAlertLogListRequest() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListDimensions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAlertLogListResponseBodyAlertLogListDimensions() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListDimensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListDimensions() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListEscalation : public Darabonba::Model {
public:
  shared_ptr<string> expression{};
  shared_ptr<string> level{};
  shared_ptr<long> times{};

  DescribeAlertLogListResponseBodyAlertLogListEscalation() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListEscalation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListEscalation() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListExtendedInfo : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeAlertLogListResponseBodyAlertLogListExtendedInfo() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListExtendedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListExtendedInfo() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> detail{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<string>> notifyTargetList{};

  DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (notifyTargetList) {
      res["notifyTargetList"] = boost::any(*notifyTargetList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("notifyTargetList") != m.end() && !m["notifyTargetList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyTargetList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyTargetList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyTargetList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList>> resultList{};

  DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (resultList) {
      vector<boost::any> temp1;
      for(auto item1:*resultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultList = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListSendDetail : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList>> channelResultList{};
  shared_ptr<string> resultCode{};

  DescribeAlertLogListResponseBodyAlertLogListSendDetail() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListSendDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelResultList) {
      vector<boost::any> temp1;
      for(auto item1:*channelResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelResultList"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelResultList") != m.end() && !m["ChannelResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelResultList"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelResultList = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListSendDetail() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListSendResultList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeAlertLogListResponseBodyAlertLogListSendResultList() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListSendResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListSendResultList() = default;
};
class DescribeAlertLogListResponseBodyAlertLogListWebhookList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> url{};

  DescribeAlertLogListResponseBodyAlertLogListWebhookList() {}

  explicit DescribeAlertLogListResponseBodyAlertLogListWebhookList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogListWebhookList() = default;
};
class DescribeAlertLogListResponseBodyAlertLogList : public Darabonba::Model {
public:
  shared_ptr<string> alertTime{};
  shared_ptr<string> blackListDetail{};
  shared_ptr<string> blackListName{};
  shared_ptr<string> blackListUUID{};
  shared_ptr<vector<string>> contactALIIWWList{};
  shared_ptr<vector<string>> contactDingList{};
  shared_ptr<vector<string>> contactGroups{};
  shared_ptr<vector<string>> contactMailList{};
  shared_ptr<vector<string>> contactOnCallList{};
  shared_ptr<vector<string>> contactSMSList{};
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListDimensions>> dimensions{};
  shared_ptr<vector<string>> dingdingWebhookList{};
  shared_ptr<DescribeAlertLogListResponseBodyAlertLogListEscalation> escalation{};
  shared_ptr<string> eventName{};
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListExtendedInfo>> extendedInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> level{};
  shared_ptr<string> levelChange{};
  shared_ptr<string> logId{};
  shared_ptr<string> message{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> product{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<DescribeAlertLogListResponseBodyAlertLogListSendDetail> sendDetail{};
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListSendResultList>> sendResultList{};
  shared_ptr<string> sendStatus{};
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogListWebhookList>> webhookList{};

  DescribeAlertLogListResponseBodyAlertLogList() {}

  explicit DescribeAlertLogListResponseBodyAlertLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (blackListDetail) {
      res["BlackListDetail"] = boost::any(*blackListDetail);
    }
    if (blackListName) {
      res["BlackListName"] = boost::any(*blackListName);
    }
    if (blackListUUID) {
      res["BlackListUUID"] = boost::any(*blackListUUID);
    }
    if (contactALIIWWList) {
      res["ContactALIIWWList"] = boost::any(*contactALIIWWList);
    }
    if (contactDingList) {
      res["ContactDingList"] = boost::any(*contactDingList);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (contactMailList) {
      res["ContactMailList"] = boost::any(*contactMailList);
    }
    if (contactOnCallList) {
      res["ContactOnCallList"] = boost::any(*contactOnCallList);
    }
    if (contactSMSList) {
      res["ContactSMSList"] = boost::any(*contactSMSList);
    }
    if (dimensions) {
      vector<boost::any> temp1;
      for(auto item1:*dimensions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dimensions"] = boost::any(temp1);
    }
    if (dingdingWebhookList) {
      res["DingdingWebhookList"] = boost::any(*dingdingWebhookList);
    }
    if (escalation) {
      res["Escalation"] = escalation ? boost::any(escalation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (extendedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*extendedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtendedInfo"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (levelChange) {
      res["LevelChange"] = boost::any(*levelChange);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (sendDetail) {
      res["SendDetail"] = sendDetail ? boost::any(sendDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sendResultList) {
      vector<boost::any> temp1;
      for(auto item1:*sendResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SendResultList"] = boost::any(temp1);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    if (webhookList) {
      vector<boost::any> temp1;
      for(auto item1:*webhookList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebhookList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<string>(boost::any_cast<string>(m["AlertTime"]));
    }
    if (m.find("BlackListDetail") != m.end() && !m["BlackListDetail"].empty()) {
      blackListDetail = make_shared<string>(boost::any_cast<string>(m["BlackListDetail"]));
    }
    if (m.find("BlackListName") != m.end() && !m["BlackListName"].empty()) {
      blackListName = make_shared<string>(boost::any_cast<string>(m["BlackListName"]));
    }
    if (m.find("BlackListUUID") != m.end() && !m["BlackListUUID"].empty()) {
      blackListUUID = make_shared<string>(boost::any_cast<string>(m["BlackListUUID"]));
    }
    if (m.find("ContactALIIWWList") != m.end() && !m["ContactALIIWWList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactALIIWWList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactALIIWWList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactALIIWWList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactDingList") != m.end() && !m["ContactDingList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactDingList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactDingList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactDingList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactMailList") != m.end() && !m["ContactMailList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactMailList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactMailList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactMailList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactOnCallList") != m.end() && !m["ContactOnCallList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactOnCallList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactOnCallList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactOnCallList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ContactSMSList") != m.end() && !m["ContactSMSList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactSMSList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactSMSList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactSMSList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      if (typeid(vector<boost::any>) == m["Dimensions"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListDimensions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dimensions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListDimensions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dimensions = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListDimensions>>(expect1);
      }
    }
    if (m.find("DingdingWebhookList") != m.end() && !m["DingdingWebhookList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DingdingWebhookList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DingdingWebhookList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dingdingWebhookList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Escalation") != m.end() && !m["Escalation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalation"].type()) {
        DescribeAlertLogListResponseBodyAlertLogListEscalation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalation"]));
        escalation = make_shared<DescribeAlertLogListResponseBodyAlertLogListEscalation>(model1);
      }
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("ExtendedInfo") != m.end() && !m["ExtendedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtendedInfo"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListExtendedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtendedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListExtendedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendedInfo = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListExtendedInfo>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LevelChange") != m.end() && !m["LevelChange"].empty()) {
      levelChange = make_shared<string>(boost::any_cast<string>(m["LevelChange"]));
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<string>(boost::any_cast<string>(m["LogId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SendDetail") != m.end() && !m["SendDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["SendDetail"].type()) {
        DescribeAlertLogListResponseBodyAlertLogListSendDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SendDetail"]));
        sendDetail = make_shared<DescribeAlertLogListResponseBodyAlertLogListSendDetail>(model1);
      }
    }
    if (m.find("SendResultList") != m.end() && !m["SendResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["SendResultList"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListSendResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SendResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListSendResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sendResultList = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListSendResultList>>(expect1);
      }
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<string>(boost::any_cast<string>(m["SendStatus"]));
    }
    if (m.find("WebhookList") != m.end() && !m["WebhookList"].empty()) {
      if (typeid(vector<boost::any>) == m["WebhookList"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogListWebhookList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebhookList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogListWebhookList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webhookList = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogListWebhookList>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertLogListResponseBodyAlertLogList() = default;
};
class DescribeAlertLogListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertLogListResponseBodyAlertLogList>> alertLogList{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeAlertLogListResponseBody() {}

  explicit DescribeAlertLogListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertLogList) {
      vector<boost::any> temp1;
      for(auto item1:*alertLogList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertLogList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertLogList") != m.end() && !m["AlertLogList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertLogList"].type()) {
        vector<DescribeAlertLogListResponseBodyAlertLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertLogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertLogListResponseBodyAlertLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertLogList = make_shared<vector<DescribeAlertLogListResponseBodyAlertLogList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAlertLogListResponseBody() = default;
};
class DescribeAlertLogListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertLogListResponseBody> body{};

  DescribeAlertLogListResponse() {}

  explicit DescribeAlertLogListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertLogListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertLogListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertLogListResponse() = default;
};
class DescribeAlertingMetricRuleResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertBeforeTime{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> groupId{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  DescribeAlertingMetricRuleResourcesRequest() {}

  explicit DescribeAlertingMetricRuleResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertBeforeTime) {
      res["AlertBeforeTime"] = boost::any(*alertBeforeTime);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertBeforeTime") != m.end() && !m["AlertBeforeTime"].empty()) {
      alertBeforeTime = make_shared<string>(boost::any_cast<string>(m["AlertBeforeTime"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesRequest() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<string> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList>> expressionList{};

  DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionList) {
      vector<boost::any> temp1;
      for(auto item1:*expressionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExpressionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpressionList") != m.end() && !m["ExpressionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ExpressionList"].type()) {
        vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExpressionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressionList = make_shared<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> expression{};
  shared_ptr<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList> expressionList{};
  shared_ptr<string> expressionListJoin{};
  shared_ptr<string> expressionRaw{};
  shared_ptr<long> level{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> tag{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (expressionList) {
      res["ExpressionList"] = expressionList ? boost::any(expressionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expressionListJoin) {
      res["ExpressionListJoin"] = boost::any(*expressionListJoin);
    }
    if (expressionRaw) {
      res["ExpressionRaw"] = boost::any(*expressionRaw);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("ExpressionList") != m.end() && !m["ExpressionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExpressionList"].type()) {
        DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExpressionList"]));
        expressionList = make_shared<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList>(model1);
      }
    }
    if (m.find("ExpressionListJoin") != m.end() && !m["ExpressionListJoin"].empty()) {
      expressionListJoin = make_shared<string>(boost::any_cast<string>(m["ExpressionListJoin"]));
    }
    if (m.find("ExpressionRaw") != m.end() && !m["ExpressionRaw"].empty()) {
      expressionRaw = make_shared<string>(boost::any_cast<string>(m["ExpressionRaw"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource>> resource{};

  DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> enable{};
  shared_ptr<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation> escalation{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lastAlertTime{};
  shared_ptr<string> lastModifyTime{};
  shared_ptr<long> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> metricValues{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> productCategory{};
  shared_ptr<string> resource{};
  shared_ptr<string> retryTimes{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (escalation) {
      res["Escalation"] = escalation ? boost::any(escalation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lastAlertTime) {
      res["LastAlertTime"] = boost::any(*lastAlertTime);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (metricValues) {
      res["MetricValues"] = boost::any(*metricValues);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (productCategory) {
      res["ProductCategory"] = boost::any(*productCategory);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (retryTimes) {
      res["RetryTimes"] = boost::any(*retryTimes);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Escalation") != m.end() && !m["Escalation"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalation"].type()) {
        DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalation"]));
        escalation = make_shared<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("LastAlertTime") != m.end() && !m["LastAlertTime"].empty()) {
      lastAlertTime = make_shared<string>(boost::any_cast<string>(m["LastAlertTime"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<string>(boost::any_cast<string>(m["LastModifyTime"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("MetricValues") != m.end() && !m["MetricValues"].empty()) {
      metricValues = make_shared<string>(boost::any_cast<string>(m["MetricValues"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ProductCategory") != m.end() && !m["ProductCategory"].empty()) {
      productCategory = make_shared<string>(boost::any_cast<string>(m["ProductCategory"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RetryTimes") != m.end() && !m["RetryTimes"].empty()) {
      retryTimes = make_shared<string>(boost::any_cast<string>(m["RetryTimes"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource>> resource{};

  DescribeAlertingMetricRuleResourcesResponseBodyResources() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBodyResources() = default;
};
class DescribeAlertingMetricRuleResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAlertingMetricRuleResourcesResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeAlertingMetricRuleResourcesResponseBody() {}

  explicit DescribeAlertingMetricRuleResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeAlertingMetricRuleResourcesResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeAlertingMetricRuleResourcesResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponseBody() = default;
};
class DescribeAlertingMetricRuleResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlertingMetricRuleResourcesResponseBody> body{};

  DescribeAlertingMetricRuleResourcesResponse() {}

  explicit DescribeAlertingMetricRuleResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlertingMetricRuleResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlertingMetricRuleResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlertingMetricRuleResourcesResponse() = default;
};
class DescribeContactGroupListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeContactGroupListRequest() {}

  explicit DescribeContactGroupListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeContactGroupListRequest() = default;
};
class DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contact{};

  DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts() {}

  explicit DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contact"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contact = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts() = default;
};
class DescribeContactGroupListResponseBodyContactGroupListContactGroup : public Darabonba::Model {
public:
  shared_ptr<DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts> contacts{};
  shared_ptr<long> createTime{};
  shared_ptr<string> describe{};
  shared_ptr<bool> enableSubscribed{};
  shared_ptr<bool> enabledWeeklyReport{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};

  DescribeContactGroupListResponseBodyContactGroupListContactGroup() {}

  explicit DescribeContactGroupListResponseBodyContactGroupListContactGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      res["Contacts"] = contacts ? boost::any(contacts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (enableSubscribed) {
      res["EnableSubscribed"] = boost::any(*enableSubscribed);
    }
    if (enabledWeeklyReport) {
      res["EnabledWeeklyReport"] = boost::any(*enabledWeeklyReport);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contacts"].type()) {
        DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contacts"]));
        contacts = make_shared<DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("EnableSubscribed") != m.end() && !m["EnableSubscribed"].empty()) {
      enableSubscribed = make_shared<bool>(boost::any_cast<bool>(m["EnableSubscribed"]));
    }
    if (m.find("EnabledWeeklyReport") != m.end() && !m["EnabledWeeklyReport"].empty()) {
      enabledWeeklyReport = make_shared<bool>(boost::any_cast<bool>(m["EnabledWeeklyReport"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeContactGroupListResponseBodyContactGroupListContactGroup() = default;
};
class DescribeContactGroupListResponseBodyContactGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactGroupListResponseBodyContactGroupListContactGroup>> contactGroup{};

  DescribeContactGroupListResponseBodyContactGroupList() {}

  explicit DescribeContactGroupListResponseBodyContactGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<DescribeContactGroupListResponseBodyContactGroupListContactGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactGroupListResponseBodyContactGroupListContactGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroup = make_shared<vector<DescribeContactGroupListResponseBodyContactGroupListContactGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeContactGroupListResponseBodyContactGroupList() = default;
};
class DescribeContactGroupListResponseBodyContactGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroup{};

  DescribeContactGroupListResponseBodyContactGroups() {}

  explicit DescribeContactGroupListResponseBodyContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeContactGroupListResponseBodyContactGroups() = default;
};
class DescribeContactGroupListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeContactGroupListResponseBodyContactGroupList> contactGroupList{};
  shared_ptr<DescribeContactGroupListResponseBodyContactGroups> contactGroups{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeContactGroupListResponseBody() {}

  explicit DescribeContactGroupListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactGroupList) {
      res["ContactGroupList"] = contactGroupList ? boost::any(contactGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = contactGroups ? boost::any(contactGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactGroupList") != m.end() && !m["ContactGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroupList"].type()) {
        DescribeContactGroupListResponseBodyContactGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroupList"]));
        contactGroupList = make_shared<DescribeContactGroupListResponseBodyContactGroupList>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroups"].type()) {
        DescribeContactGroupListResponseBodyContactGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroups"]));
        contactGroups = make_shared<DescribeContactGroupListResponseBodyContactGroups>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactGroupListResponseBody() = default;
};
class DescribeContactGroupListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactGroupListResponseBody> body{};

  DescribeContactGroupListResponse() {}

  explicit DescribeContactGroupListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactGroupListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactGroupListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactGroupListResponse() = default;
};
class DescribeContactListRequest : public Darabonba::Model {
public:
  shared_ptr<string> chanelType{};
  shared_ptr<string> chanelValue{};
  shared_ptr<string> contactName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeContactListRequest() {}

  explicit DescribeContactListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chanelType) {
      res["ChanelType"] = boost::any(*chanelType);
    }
    if (chanelValue) {
      res["ChanelValue"] = boost::any(*chanelValue);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChanelType") != m.end() && !m["ChanelType"].empty()) {
      chanelType = make_shared<string>(boost::any_cast<string>(m["ChanelType"]));
    }
    if (m.find("ChanelValue") != m.end() && !m["ChanelValue"].empty()) {
      chanelValue = make_shared<string>(boost::any_cast<string>(m["ChanelValue"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeContactListRequest() = default;
};
class DescribeContactListResponseBodyContactsContactChannels : public Darabonba::Model {
public:
  shared_ptr<string> aliIM{};
  shared_ptr<string> dingWebHook{};
  shared_ptr<string> mail{};
  shared_ptr<string> SMS{};

  DescribeContactListResponseBodyContactsContactChannels() {}

  explicit DescribeContactListResponseBodyContactsContactChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliIM) {
      res["AliIM"] = boost::any(*aliIM);
    }
    if (dingWebHook) {
      res["DingWebHook"] = boost::any(*dingWebHook);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (SMS) {
      res["SMS"] = boost::any(*SMS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliIM") != m.end() && !m["AliIM"].empty()) {
      aliIM = make_shared<string>(boost::any_cast<string>(m["AliIM"]));
    }
    if (m.find("DingWebHook") != m.end() && !m["DingWebHook"].empty()) {
      dingWebHook = make_shared<string>(boost::any_cast<string>(m["DingWebHook"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("SMS") != m.end() && !m["SMS"].empty()) {
      SMS = make_shared<string>(boost::any_cast<string>(m["SMS"]));
    }
  }


  virtual ~DescribeContactListResponseBodyContactsContactChannels() = default;
};
class DescribeContactListResponseBodyContactsContactChannelsState : public Darabonba::Model {
public:
  shared_ptr<string> aliIM{};
  shared_ptr<string> dingWebHook{};
  shared_ptr<string> mail{};
  shared_ptr<string> SMS{};

  DescribeContactListResponseBodyContactsContactChannelsState() {}

  explicit DescribeContactListResponseBodyContactsContactChannelsState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliIM) {
      res["AliIM"] = boost::any(*aliIM);
    }
    if (dingWebHook) {
      res["DingWebHook"] = boost::any(*dingWebHook);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (SMS) {
      res["SMS"] = boost::any(*SMS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliIM") != m.end() && !m["AliIM"].empty()) {
      aliIM = make_shared<string>(boost::any_cast<string>(m["AliIM"]));
    }
    if (m.find("DingWebHook") != m.end() && !m["DingWebHook"].empty()) {
      dingWebHook = make_shared<string>(boost::any_cast<string>(m["DingWebHook"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("SMS") != m.end() && !m["SMS"].empty()) {
      SMS = make_shared<string>(boost::any_cast<string>(m["SMS"]));
    }
  }


  virtual ~DescribeContactListResponseBodyContactsContactChannelsState() = default;
};
class DescribeContactListResponseBodyContactsContactContactGroups : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroup{};

  DescribeContactListResponseBodyContactsContactContactGroups() {}

  explicit DescribeContactListResponseBodyContactsContactContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      res["ContactGroup"] = boost::any(*contactGroup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroup"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroup = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeContactListResponseBodyContactsContactContactGroups() = default;
};
class DescribeContactListResponseBodyContactsContact : public Darabonba::Model {
public:
  shared_ptr<DescribeContactListResponseBodyContactsContactChannels> channels{};
  shared_ptr<DescribeContactListResponseBodyContactsContactChannelsState> channelsState{};
  shared_ptr<DescribeContactListResponseBodyContactsContactContactGroups> contactGroups{};
  shared_ptr<long> createTime{};
  shared_ptr<string> desc{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};

  DescribeContactListResponseBodyContactsContact() {}

  explicit DescribeContactListResponseBodyContactsContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (channelsState) {
      res["ChannelsState"] = channelsState ? boost::any(channelsState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = contactGroups ? boost::any(contactGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        DescribeContactListResponseBodyContactsContactChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<DescribeContactListResponseBodyContactsContactChannels>(model1);
      }
    }
    if (m.find("ChannelsState") != m.end() && !m["ChannelsState"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChannelsState"].type()) {
        DescribeContactListResponseBodyContactsContactChannelsState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChannelsState"]));
        channelsState = make_shared<DescribeContactListResponseBodyContactsContactChannelsState>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroups"].type()) {
        DescribeContactListResponseBodyContactsContactContactGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroups"]));
        contactGroups = make_shared<DescribeContactListResponseBodyContactsContactContactGroups>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeContactListResponseBodyContactsContact() = default;
};
class DescribeContactListResponseBodyContacts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactListResponseBodyContactsContact>> contact{};

  DescribeContactListResponseBodyContacts() {}

  explicit DescribeContactListResponseBodyContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      vector<boost::any> temp1;
      for(auto item1:*contact){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contact"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<DescribeContactListResponseBodyContactsContact> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contact"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactListResponseBodyContactsContact model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contact = make_shared<vector<DescribeContactListResponseBodyContactsContact>>(expect1);
      }
    }
  }


  virtual ~DescribeContactListResponseBodyContacts() = default;
};
class DescribeContactListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeContactListResponseBodyContacts> contacts{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeContactListResponseBody() {}

  explicit DescribeContactListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contacts) {
      res["Contacts"] = contacts ? boost::any(contacts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contacts"].type()) {
        DescribeContactListResponseBodyContacts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contacts"]));
        contacts = make_shared<DescribeContactListResponseBodyContacts>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeContactListResponseBody() = default;
};
class DescribeContactListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactListResponseBody> body{};

  DescribeContactListResponse() {}

  explicit DescribeContactListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactListResponse() = default;
};
class DescribeContactListByContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> regionId{};

  DescribeContactListByContactGroupRequest() {}

  explicit DescribeContactListByContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeContactListByContactGroupRequest() = default;
};
class DescribeContactListByContactGroupResponseBodyContactsContactChannels : public Darabonba::Model {
public:
  shared_ptr<string> aliIM{};
  shared_ptr<string> dingWebHook{};
  shared_ptr<string> mail{};
  shared_ptr<string> SMS{};

  DescribeContactListByContactGroupResponseBodyContactsContactChannels() {}

  explicit DescribeContactListByContactGroupResponseBodyContactsContactChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliIM) {
      res["AliIM"] = boost::any(*aliIM);
    }
    if (dingWebHook) {
      res["DingWebHook"] = boost::any(*dingWebHook);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (SMS) {
      res["SMS"] = boost::any(*SMS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliIM") != m.end() && !m["AliIM"].empty()) {
      aliIM = make_shared<string>(boost::any_cast<string>(m["AliIM"]));
    }
    if (m.find("DingWebHook") != m.end() && !m["DingWebHook"].empty()) {
      dingWebHook = make_shared<string>(boost::any_cast<string>(m["DingWebHook"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("SMS") != m.end() && !m["SMS"].empty()) {
      SMS = make_shared<string>(boost::any_cast<string>(m["SMS"]));
    }
  }


  virtual ~DescribeContactListByContactGroupResponseBodyContactsContactChannels() = default;
};
class DescribeContactListByContactGroupResponseBodyContactsContact : public Darabonba::Model {
public:
  shared_ptr<DescribeContactListByContactGroupResponseBodyContactsContactChannels> channels{};
  shared_ptr<long> createTime{};
  shared_ptr<string> desc{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};

  DescribeContactListByContactGroupResponseBodyContactsContact() {}

  explicit DescribeContactListByContactGroupResponseBodyContactsContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        DescribeContactListByContactGroupResponseBodyContactsContactChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<DescribeContactListByContactGroupResponseBodyContactsContactChannels>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeContactListByContactGroupResponseBodyContactsContact() = default;
};
class DescribeContactListByContactGroupResponseBodyContacts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContactListByContactGroupResponseBodyContactsContact>> contact{};

  DescribeContactListByContactGroupResponseBodyContacts() {}

  explicit DescribeContactListByContactGroupResponseBodyContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contact) {
      vector<boost::any> temp1;
      for(auto item1:*contact){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contact"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(vector<boost::any>) == m["Contact"].type()) {
        vector<DescribeContactListByContactGroupResponseBodyContactsContact> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contact"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContactListByContactGroupResponseBodyContactsContact model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contact = make_shared<vector<DescribeContactListByContactGroupResponseBodyContactsContact>>(expect1);
      }
    }
  }


  virtual ~DescribeContactListByContactGroupResponseBodyContacts() = default;
};
class DescribeContactListByContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeContactListByContactGroupResponseBodyContacts> contacts{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeContactListByContactGroupResponseBody() {}

  explicit DescribeContactListByContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contacts) {
      res["Contacts"] = contacts ? boost::any(contacts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contacts"].type()) {
        DescribeContactListByContactGroupResponseBodyContacts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contacts"]));
        contacts = make_shared<DescribeContactListByContactGroupResponseBodyContacts>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeContactListByContactGroupResponseBody() = default;
};
class DescribeContactListByContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContactListByContactGroupResponseBody> body{};

  DescribeContactListByContactGroupResponse() {}

  explicit DescribeContactListByContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContactListByContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContactListByContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContactListByContactGroupResponse() = default;
};
class DescribeCustomEventAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};

  DescribeCustomEventAttributeRequest() {}

  explicit DescribeCustomEventAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCustomEventAttributeRequest() = default;
};
class DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> time{};

  DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent() {}

  explicit DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent() = default;
};
class DescribeCustomEventAttributeResponseBodyCustomEvents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent>> customEvent{};

  DescribeCustomEventAttributeResponseBodyCustomEvents() {}

  explicit DescribeCustomEventAttributeResponseBodyCustomEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEvent) {
      vector<boost::any> temp1;
      for(auto item1:*customEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomEvent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEvent") != m.end() && !m["CustomEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomEvent"].type()) {
        vector<DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customEvent = make_shared<vector<DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomEventAttributeResponseBodyCustomEvents() = default;
};
class DescribeCustomEventAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCustomEventAttributeResponseBodyCustomEvents> customEvents{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCustomEventAttributeResponseBody() {}

  explicit DescribeCustomEventAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (customEvents) {
      res["CustomEvents"] = customEvents ? boost::any(customEvents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CustomEvents") != m.end() && !m["CustomEvents"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomEvents"].type()) {
        DescribeCustomEventAttributeResponseBodyCustomEvents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomEvents"]));
        customEvents = make_shared<DescribeCustomEventAttributeResponseBodyCustomEvents>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCustomEventAttributeResponseBody() = default;
};
class DescribeCustomEventAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomEventAttributeResponseBody> body{};

  DescribeCustomEventAttributeResponse() {}

  explicit DescribeCustomEventAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomEventAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomEventAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomEventAttributeResponse() = default;
};
class DescribeCustomEventCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};

  DescribeCustomEventCountRequest() {}

  explicit DescribeCustomEventCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCustomEventCountRequest() = default;
};
class DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> num{};
  shared_ptr<long> time{};

  DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount() {}

  explicit DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["Num"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount() = default;
};
class DescribeCustomEventCountResponseBodyCustomEventCounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount>> customEventCount{};

  DescribeCustomEventCountResponseBodyCustomEventCounts() {}

  explicit DescribeCustomEventCountResponseBodyCustomEventCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customEventCount) {
      vector<boost::any> temp1;
      for(auto item1:*customEventCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomEventCount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomEventCount") != m.end() && !m["CustomEventCount"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomEventCount"].type()) {
        vector<DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomEventCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customEventCount = make_shared<vector<DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomEventCountResponseBodyCustomEventCounts() = default;
};
class DescribeCustomEventCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCustomEventCountResponseBodyCustomEventCounts> customEventCounts{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeCustomEventCountResponseBody() {}

  explicit DescribeCustomEventCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (customEventCounts) {
      res["CustomEventCounts"] = customEventCounts ? boost::any(customEventCounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CustomEventCounts") != m.end() && !m["CustomEventCounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomEventCounts"].type()) {
        DescribeCustomEventCountResponseBodyCustomEventCounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomEventCounts"]));
        customEventCounts = make_shared<DescribeCustomEventCountResponseBodyCustomEventCounts>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCustomEventCountResponseBody() = default;
};
class DescribeCustomEventCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomEventCountResponseBody> body{};

  DescribeCustomEventCountResponse() {}

  explicit DescribeCustomEventCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomEventCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomEventCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomEventCountResponse() = default;
};
class DescribeCustomEventHistogramRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};

  DescribeCustomEventHistogramRequest() {}

  explicit DescribeCustomEventHistogramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeCustomEventHistogramRequest() = default;
};
class DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram() {}

  explicit DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram() = default;
};
class DescribeCustomEventHistogramResponseBodyEventHistograms : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram>> eventHistogram{};

  DescribeCustomEventHistogramResponseBodyEventHistograms() {}

  explicit DescribeCustomEventHistogramResponseBodyEventHistograms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventHistogram) {
      vector<boost::any> temp1;
      for(auto item1:*eventHistogram){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventHistogram"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventHistogram") != m.end() && !m["EventHistogram"].empty()) {
      if (typeid(vector<boost::any>) == m["EventHistogram"].type()) {
        vector<DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventHistogram"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventHistogram = make_shared<vector<DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomEventHistogramResponseBodyEventHistograms() = default;
};
class DescribeCustomEventHistogramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeCustomEventHistogramResponseBodyEventHistograms> eventHistograms{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeCustomEventHistogramResponseBody() {}

  explicit DescribeCustomEventHistogramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (eventHistograms) {
      res["EventHistograms"] = eventHistograms ? boost::any(eventHistograms->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EventHistograms") != m.end() && !m["EventHistograms"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventHistograms"].type()) {
        DescribeCustomEventHistogramResponseBodyEventHistograms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventHistograms"]));
        eventHistograms = make_shared<DescribeCustomEventHistogramResponseBodyEventHistograms>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeCustomEventHistogramResponseBody() = default;
};
class DescribeCustomEventHistogramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomEventHistogramResponseBody> body{};

  DescribeCustomEventHistogramResponse() {}

  explicit DescribeCustomEventHistogramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomEventHistogramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomEventHistogramResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomEventHistogramResponse() = default;
};
class DescribeCustomMetricListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> groupId{};
  shared_ptr<string> md5{};
  shared_ptr<string> metricName{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  DescribeCustomMetricListRequest() {}

  explicit DescribeCustomMetricListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomMetricListRequest() = default;
};
class DescribeCustomMetricListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DescribeCustomMetricListResponseBody() {}

  explicit DescribeCustomMetricListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribeCustomMetricListResponseBody() = default;
};
class DescribeCustomMetricListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomMetricListResponseBody> body{};

  DescribeCustomMetricListResponse() {}

  explicit DescribeCustomMetricListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomMetricListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomMetricListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomMetricListResponse() = default;
};
class DescribeDynamicTagRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicTagRuleId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagRegionId{};
  shared_ptr<string> tagValue{};

  DescribeDynamicTagRuleListRequest() {}

  explicit DescribeDynamicTagRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicTagRuleId) {
      res["DynamicTagRuleId"] = boost::any(*dynamicTagRuleId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagRegionId) {
      res["TagRegionId"] = boost::any(*tagRegionId);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicTagRuleId") != m.end() && !m["DynamicTagRuleId"].empty()) {
      dynamicTagRuleId = make_shared<string>(boost::any_cast<string>(m["DynamicTagRuleId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagRegionId") != m.end() && !m["TagRegionId"].empty()) {
      tagRegionId = make_shared<string>(boost::any_cast<string>(m["TagRegionId"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeDynamicTagRuleListRequest() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contactGroupList{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupList) {
      res["ContactGroupList"] = boost::any(*contactGroupList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupList") != m.end() && !m["ContactGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactGroupList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> tagValueMatchFunction{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (tagValueMatchFunction) {
      res["TagValueMatchFunction"] = boost::any(*tagValueMatchFunction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("TagValueMatchFunction") != m.end() && !m["TagValueMatchFunction"].empty()) {
      tagValueMatchFunction = make_shared<string>(boost::any_cast<string>(m["TagValueMatchFunction"]));
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress>> matchExpress{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchExpress) {
      vector<boost::any> temp1;
      for(auto item1:*matchExpress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchExpress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchExpress"].type()) {
        vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchExpress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchExpress = make_shared<vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress>>(expect1);
      }
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tagValueBlacklist{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValueBlacklist) {
      res["TagValueBlacklist"] = boost::any(*tagValueBlacklist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValueBlacklist") != m.end() && !m["TagValueBlacklist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValueBlacklist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValueBlacklist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValueBlacklist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> templateIdList{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateIdList) {
      res["TemplateIdList"] = boost::any(*templateIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateIdList") != m.end() && !m["TemplateIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup : public Darabonba::Model {
public:
  shared_ptr<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList> contactGroupList{};
  shared_ptr<string> dynamicTagRuleId{};
  shared_ptr<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress> matchExpress{};
  shared_ptr<string> matchExpressFilterRelation{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> tagKey{};
  shared_ptr<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist> tagValueBlacklist{};
  shared_ptr<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList> templateIdList{};

  DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupList) {
      res["ContactGroupList"] = contactGroupList ? boost::any(contactGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicTagRuleId) {
      res["DynamicTagRuleId"] = boost::any(*dynamicTagRuleId);
    }
    if (matchExpress) {
      res["MatchExpress"] = matchExpress ? boost::any(matchExpress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (matchExpressFilterRelation) {
      res["MatchExpressFilterRelation"] = boost::any(*matchExpressFilterRelation);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValueBlacklist) {
      res["TagValueBlacklist"] = tagValueBlacklist ? boost::any(tagValueBlacklist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateIdList) {
      res["TemplateIdList"] = templateIdList ? boost::any(templateIdList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupList") != m.end() && !m["ContactGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroupList"].type()) {
        DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroupList"]));
        contactGroupList = make_shared<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList>(model1);
      }
    }
    if (m.find("DynamicTagRuleId") != m.end() && !m["DynamicTagRuleId"].empty()) {
      dynamicTagRuleId = make_shared<string>(boost::any_cast<string>(m["DynamicTagRuleId"]));
    }
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(map<string, boost::any>) == m["MatchExpress"].type()) {
        DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MatchExpress"]));
        matchExpress = make_shared<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress>(model1);
      }
    }
    if (m.find("MatchExpressFilterRelation") != m.end() && !m["MatchExpressFilterRelation"].empty()) {
      matchExpressFilterRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressFilterRelation"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValueBlacklist") != m.end() && !m["TagValueBlacklist"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagValueBlacklist"].type()) {
        DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagValueBlacklist"]));
        tagValueBlacklist = make_shared<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTagValueBlacklist>(model1);
      }
    }
    if (m.find("TemplateIdList") != m.end() && !m["TemplateIdList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateIdList"].type()) {
        DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateIdList"]));
        templateIdList = make_shared<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList>(model1);
      }
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup() = default;
};
class DescribeDynamicTagRuleListResponseBodyTagGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup>> tagGroup{};

  DescribeDynamicTagRuleListResponseBodyTagGroupList() {}

  explicit DescribeDynamicTagRuleListResponseBodyTagGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagGroup) {
      vector<boost::any> temp1;
      for(auto item1:*tagGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagGroup") != m.end() && !m["TagGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["TagGroup"].type()) {
        vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagGroup = make_shared<vector<DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBodyTagGroupList() = default;
};
class DescribeDynamicTagRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeDynamicTagRuleListResponseBodyTagGroupList> tagGroupList{};
  shared_ptr<long> total{};

  DescribeDynamicTagRuleListResponseBody() {}

  explicit DescribeDynamicTagRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagGroupList) {
      res["TagGroupList"] = tagGroupList ? boost::any(tagGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagGroupList") != m.end() && !m["TagGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagGroupList"].type()) {
        DescribeDynamicTagRuleListResponseBodyTagGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagGroupList"]));
        tagGroupList = make_shared<DescribeDynamicTagRuleListResponseBodyTagGroupList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDynamicTagRuleListResponseBody() = default;
};
class DescribeDynamicTagRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDynamicTagRuleListResponseBody> body{};

  DescribeDynamicTagRuleListResponse() {}

  explicit DescribeDynamicTagRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDynamicTagRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDynamicTagRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDynamicTagRuleListResponse() = default;
};
class DescribeEventRuleAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> silenceTime{};

  DescribeEventRuleAttributeRequest() {}

  explicit DescribeEventRuleAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
  }


  virtual ~DescribeEventRuleAttributeRequest() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eventTypeList{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keyword{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyword") != m.end() && !m["keyword"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["keyword"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["keyword"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keyword = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj : public Darabonba::Model {
public:
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords> keywords{};
  shared_ptr<string> relation{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = keywords ? boost::any(keywords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      if (typeid(map<string, boost::any>) == m["Keywords"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Keywords"]));
        keywords = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords>(model1);
      }
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> levelList{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelList) {
      res["LevelList"] = boost::any(*levelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nameList{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternNameList() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameList) {
      res["NameList"] = boost::any(*nameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternNameList() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> statusList{};

  DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList() = default;
};
class DescribeEventRuleAttributeResponseBodyResultEventPattern : public Darabonba::Model {
public:
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList> eventTypeList{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj> keywordFilterObj{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList> levelList{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternNameList> nameList{};
  shared_ptr<string> product{};
  shared_ptr<string> SQLFilter{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList> statusList{};

  DescribeEventRuleAttributeResponseBodyResultEventPattern() {}

  explicit DescribeEventRuleAttributeResponseBodyResultEventPattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTypeList) {
      res["EventTypeList"] = eventTypeList ? boost::any(eventTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keywordFilterObj) {
      res["KeywordFilterObj"] = keywordFilterObj ? boost::any(keywordFilterObj->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (levelList) {
      res["LevelList"] = levelList ? boost::any(levelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nameList) {
      res["NameList"] = nameList ? boost::any(nameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (SQLFilter) {
      res["SQLFilter"] = boost::any(*SQLFilter);
    }
    if (statusList) {
      res["StatusList"] = statusList ? boost::any(statusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventTypeList"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventTypeList"]));
        eventTypeList = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList>(model1);
      }
    }
    if (m.find("KeywordFilterObj") != m.end() && !m["KeywordFilterObj"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeywordFilterObj"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeywordFilterObj"]));
        keywordFilterObj = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj>(model1);
      }
    }
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LevelList"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LevelList"]));
        levelList = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList>(model1);
      }
    }
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NameList"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NameList"]));
        nameList = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternNameList>(model1);
      }
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("SQLFilter") != m.end() && !m["SQLFilter"].empty()) {
      SQLFilter = make_shared<string>(boost::any_cast<string>(m["SQLFilter"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusList"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusList"]));
        statusList = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList>(model1);
      }
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResultEventPattern() = default;
};
class DescribeEventRuleAttributeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResultEventPattern> eventPattern{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};

  DescribeEventRuleAttributeResponseBodyResult() {}

  explicit DescribeEventRuleAttributeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eventPattern) {
      res["EventPattern"] = eventPattern ? boost::any(eventPattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EventPattern") != m.end() && !m["EventPattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventPattern"].type()) {
        DescribeEventRuleAttributeResponseBodyResultEventPattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventPattern"]));
        eventPattern = make_shared<DescribeEventRuleAttributeResponseBodyResultEventPattern>(model1);
      }
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBodyResult() = default;
};
class DescribeEventRuleAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventRuleAttributeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEventRuleAttributeResponseBody() {}

  explicit DescribeEventRuleAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEventRuleAttributeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEventRuleAttributeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEventRuleAttributeResponseBody() = default;
};
class DescribeEventRuleAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventRuleAttributeResponseBody> body{};

  DescribeEventRuleAttributeResponse() {}

  explicit DescribeEventRuleAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventRuleAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventRuleAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventRuleAttributeResponse() = default;
};
class DescribeEventRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> isEnable{};
  shared_ptr<string> namePrefix{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  DescribeEventRuleListRequest() {}

  explicit DescribeEventRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (namePrefix) {
      res["NamePrefix"] = boost::any(*namePrefix);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<bool>(boost::any_cast<bool>(m["IsEnable"]));
    }
    if (m.find("NamePrefix") != m.end() && !m["NamePrefix"].empty()) {
      namePrefix = make_shared<string>(boost::any_cast<string>(m["NamePrefix"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEventRuleListRequest() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> eventTypeList{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keywords{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter : public Darabonba::Model {
public:
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords> keywords{};
  shared_ptr<string> relation{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = keywords ? boost::any(keywords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      if (typeid(map<string, boost::any>) == m["Keywords"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Keywords"]));
        keywords = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords>(model1);
      }
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> levelList{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelList) {
      res["LevelList"] = boost::any(*levelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nameList{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameList) {
      res["NameList"] = boost::any(*nameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern : public Darabonba::Model {
public:
  shared_ptr<string> customFilters{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList> eventTypeList{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter> keywordFilter{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList> levelList{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList> nameList{};
  shared_ptr<string> product{};
  shared_ptr<string> SQLFilter{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customFilters) {
      res["CustomFilters"] = boost::any(*customFilters);
    }
    if (eventTypeList) {
      res["EventTypeList"] = eventTypeList ? boost::any(eventTypeList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keywordFilter) {
      res["KeywordFilter"] = keywordFilter ? boost::any(keywordFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (levelList) {
      res["LevelList"] = levelList ? boost::any(levelList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nameList) {
      res["NameList"] = nameList ? boost::any(nameList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (SQLFilter) {
      res["SQLFilter"] = boost::any(*SQLFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomFilters") != m.end() && !m["CustomFilters"].empty()) {
      customFilters = make_shared<string>(boost::any_cast<string>(m["CustomFilters"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventTypeList"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventTypeList"]));
        eventTypeList = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList>(model1);
      }
    }
    if (m.find("KeywordFilter") != m.end() && !m["KeywordFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeywordFilter"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeywordFilter"]));
        keywordFilter = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter>(model1);
      }
    }
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LevelList"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LevelList"]));
        levelList = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList>(model1);
      }
    }
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NameList"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NameList"]));
        nameList = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList>(model1);
      }
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("SQLFilter") != m.end() && !m["SQLFilter"].empty()) {
      SQLFilter = make_shared<string>(boost::any_cast<string>(m["SQLFilter"]));
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern>> eventPattern{};

  DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventPattern) {
      vector<boost::any> temp1;
      for(auto item1:*eventPattern){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventPattern"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventPattern") != m.end() && !m["EventPattern"].empty()) {
      if (typeid(vector<boost::any>) == m["EventPattern"].type()) {
        vector<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventPattern"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventPattern = make_shared<vector<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern() = default;
};
class DescribeEventRuleListResponseBodyEventRulesEventRule : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern> eventPattern{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> name{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> state{};

  DescribeEventRuleListResponseBodyEventRulesEventRule() {}

  explicit DescribeEventRuleListResponseBodyEventRulesEventRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eventPattern) {
      res["EventPattern"] = eventPattern ? boost::any(eventPattern->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EventPattern") != m.end() && !m["EventPattern"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventPattern"].type()) {
        DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventPattern"]));
        eventPattern = make_shared<DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern>(model1);
      }
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRulesEventRule() = default;
};
class DescribeEventRuleListResponseBodyEventRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleListResponseBodyEventRulesEventRule>> eventRule{};

  DescribeEventRuleListResponseBodyEventRules() {}

  explicit DescribeEventRuleListResponseBodyEventRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventRule) {
      vector<boost::any> temp1;
      for(auto item1:*eventRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventRule") != m.end() && !m["EventRule"].empty()) {
      if (typeid(vector<boost::any>) == m["EventRule"].type()) {
        vector<DescribeEventRuleListResponseBodyEventRulesEventRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleListResponseBodyEventRulesEventRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventRule = make_shared<vector<DescribeEventRuleListResponseBodyEventRulesEventRule>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleListResponseBodyEventRules() = default;
};
class DescribeEventRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeEventRuleListResponseBodyEventRules> eventRules{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeEventRuleListResponseBody() {}

  explicit DescribeEventRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (eventRules) {
      res["EventRules"] = eventRules ? boost::any(eventRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EventRules") != m.end() && !m["EventRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventRules"].type()) {
        DescribeEventRuleListResponseBodyEventRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventRules"]));
        eventRules = make_shared<DescribeEventRuleListResponseBodyEventRules>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeEventRuleListResponseBody() = default;
};
class DescribeEventRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventRuleListResponseBody> body{};

  DescribeEventRuleListResponse() {}

  explicit DescribeEventRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventRuleListResponse() = default;
};
class DescribeEventRuleTargetListRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};

  DescribeEventRuleTargetListRequest() {}

  explicit DescribeEventRuleTargetListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DescribeEventRuleTargetListRequest() = default;
};
class DescribeEventRuleTargetListResponseBodyContactParametersContactParameter : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> id{};
  shared_ptr<string> level{};

  DescribeEventRuleTargetListResponseBodyContactParametersContactParameter() {}

  explicit DescribeEventRuleTargetListResponseBodyContactParametersContactParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyContactParametersContactParameter() = default;
};
class DescribeEventRuleTargetListResponseBodyContactParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodyContactParametersContactParameter>> contactParameter{};

  DescribeEventRuleTargetListResponseBodyContactParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyContactParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactParameter) {
      vector<boost::any> temp1;
      for(auto item1:*contactParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactParameter") != m.end() && !m["ContactParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactParameter"].type()) {
        vector<DescribeEventRuleTargetListResponseBodyContactParametersContactParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodyContactParametersContactParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactParameter = make_shared<vector<DescribeEventRuleTargetListResponseBodyContactParametersContactParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyContactParameters() = default;
};
class DescribeEventRuleTargetListResponseBodyFcParametersFCParameter : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> functionName{};
  shared_ptr<string> id{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};

  DescribeEventRuleTargetListResponseBodyFcParametersFCParameter() {}

  explicit DescribeEventRuleTargetListResponseBodyFcParametersFCParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyFcParametersFCParameter() = default;
};
class DescribeEventRuleTargetListResponseBodyFcParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodyFcParametersFCParameter>> FCParameter{};

  DescribeEventRuleTargetListResponseBodyFcParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyFcParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FCParameter) {
      vector<boost::any> temp1;
      for(auto item1:*FCParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FCParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FCParameter") != m.end() && !m["FCParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["FCParameter"].type()) {
        vector<DescribeEventRuleTargetListResponseBodyFcParametersFCParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FCParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodyFcParametersFCParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        FCParameter = make_shared<vector<DescribeEventRuleTargetListResponseBodyFcParametersFCParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyFcParameters() = default;
};
class DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> queue{};
  shared_ptr<string> region{};
  shared_ptr<string> topic{};

  DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter() {}

  explicit DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter() = default;
};
class DescribeEventRuleTargetListResponseBodyMnsParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter>> mnsParameter{};

  DescribeEventRuleTargetListResponseBodyMnsParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyMnsParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mnsParameter) {
      vector<boost::any> temp1;
      for(auto item1:*mnsParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MnsParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MnsParameter") != m.end() && !m["MnsParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["MnsParameter"].type()) {
        vector<DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MnsParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mnsParameter = make_shared<vector<DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyMnsParameters() = default;
};
class DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> product{};
  shared_ptr<string> region{};
  shared_ptr<string> role{};
  shared_ptr<string> version{};

  DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters() = default;
};
class DescribeEventRuleTargetListResponseBodyOpenApiParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters>> openApiParameters{};

  DescribeEventRuleTargetListResponseBodyOpenApiParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyOpenApiParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openApiParameters) {
      vector<boost::any> temp1;
      for(auto item1:*openApiParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpenApiParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenApiParameters") != m.end() && !m["OpenApiParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["OpenApiParameters"].type()) {
        vector<DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpenApiParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        openApiParameters = make_shared<vector<DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyOpenApiParameters() = default;
};
class DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter() {}

  explicit DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter() = default;
};
class DescribeEventRuleTargetListResponseBodySlsParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter>> slsParameter{};

  DescribeEventRuleTargetListResponseBodySlsParameters() {}

  explicit DescribeEventRuleTargetListResponseBodySlsParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (slsParameter) {
      vector<boost::any> temp1;
      for(auto item1:*slsParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlsParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SlsParameter") != m.end() && !m["SlsParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SlsParameter"].type()) {
        vector<DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlsParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slsParameter = make_shared<vector<DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodySlsParameters() = default;
};
class DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> method{};
  shared_ptr<string> protocol{};
  shared_ptr<string> url{};

  DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter() {}

  explicit DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter() = default;
};
class DescribeEventRuleTargetListResponseBodyWebhookParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter>> webhookParameter{};

  DescribeEventRuleTargetListResponseBodyWebhookParameters() {}

  explicit DescribeEventRuleTargetListResponseBodyWebhookParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webhookParameter) {
      vector<boost::any> temp1;
      for(auto item1:*webhookParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebhookParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebhookParameter") != m.end() && !m["WebhookParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["WebhookParameter"].type()) {
        vector<DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebhookParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webhookParameter = make_shared<vector<DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBodyWebhookParameters() = default;
};
class DescribeEventRuleTargetListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeEventRuleTargetListResponseBodyContactParameters> contactParameters{};
  shared_ptr<DescribeEventRuleTargetListResponseBodyFcParameters> fcParameters{};
  shared_ptr<string> message{};
  shared_ptr<DescribeEventRuleTargetListResponseBodyMnsParameters> mnsParameters{};
  shared_ptr<DescribeEventRuleTargetListResponseBodyOpenApiParameters> openApiParameters{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventRuleTargetListResponseBodySlsParameters> slsParameters{};
  shared_ptr<DescribeEventRuleTargetListResponseBodyWebhookParameters> webhookParameters{};

  DescribeEventRuleTargetListResponseBody() {}

  explicit DescribeEventRuleTargetListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactParameters) {
      res["ContactParameters"] = contactParameters ? boost::any(contactParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fcParameters) {
      res["FcParameters"] = fcParameters ? boost::any(fcParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (mnsParameters) {
      res["MnsParameters"] = mnsParameters ? boost::any(mnsParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (openApiParameters) {
      res["OpenApiParameters"] = openApiParameters ? boost::any(openApiParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsParameters) {
      res["SlsParameters"] = slsParameters ? boost::any(slsParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhookParameters) {
      res["WebhookParameters"] = webhookParameters ? boost::any(webhookParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactParameters") != m.end() && !m["ContactParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactParameters"].type()) {
        DescribeEventRuleTargetListResponseBodyContactParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactParameters"]));
        contactParameters = make_shared<DescribeEventRuleTargetListResponseBodyContactParameters>(model1);
      }
    }
    if (m.find("FcParameters") != m.end() && !m["FcParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["FcParameters"].type()) {
        DescribeEventRuleTargetListResponseBodyFcParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FcParameters"]));
        fcParameters = make_shared<DescribeEventRuleTargetListResponseBodyFcParameters>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MnsParameters") != m.end() && !m["MnsParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["MnsParameters"].type()) {
        DescribeEventRuleTargetListResponseBodyMnsParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MnsParameters"]));
        mnsParameters = make_shared<DescribeEventRuleTargetListResponseBodyMnsParameters>(model1);
      }
    }
    if (m.find("OpenApiParameters") != m.end() && !m["OpenApiParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenApiParameters"].type()) {
        DescribeEventRuleTargetListResponseBodyOpenApiParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenApiParameters"]));
        openApiParameters = make_shared<DescribeEventRuleTargetListResponseBodyOpenApiParameters>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsParameters") != m.end() && !m["SlsParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlsParameters"].type()) {
        DescribeEventRuleTargetListResponseBodySlsParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlsParameters"]));
        slsParameters = make_shared<DescribeEventRuleTargetListResponseBodySlsParameters>(model1);
      }
    }
    if (m.find("WebhookParameters") != m.end() && !m["WebhookParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebhookParameters"].type()) {
        DescribeEventRuleTargetListResponseBodyWebhookParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebhookParameters"]));
        webhookParameters = make_shared<DescribeEventRuleTargetListResponseBodyWebhookParameters>(model1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponseBody() = default;
};
class DescribeEventRuleTargetListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventRuleTargetListResponseBody> body{};

  DescribeEventRuleTargetListResponse() {}

  explicit DescribeEventRuleTargetListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventRuleTargetListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventRuleTargetListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventRuleTargetListResponse() = default;
};
class DescribeExporterOutputListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeExporterOutputListRequest() {}

  explicit DescribeExporterOutputListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeExporterOutputListRequest() = default;
};
class DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson : public Darabonba::Model {
public:
  shared_ptr<string> ak{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> logstore{};
  shared_ptr<string> project{};

  DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson() {}

  explicit DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ak) {
      res["ak"] = boost::any(*ak);
    }
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (logstore) {
      res["logstore"] = boost::any(*logstore);
    }
    if (project) {
      res["project"] = boost::any(*project);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ak") != m.end() && !m["ak"].empty()) {
      ak = make_shared<string>(boost::any_cast<string>(m["ak"]));
    }
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("logstore") != m.end() && !m["logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["logstore"]));
    }
    if (m.find("project") != m.end() && !m["project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["project"]));
    }
  }


  virtual ~DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson() = default;
};
class DescribeExporterOutputListResponseBodyDatapointsDatapoint : public Darabonba::Model {
public:
  shared_ptr<DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson> configJson{};
  shared_ptr<long> createTime{};
  shared_ptr<string> destName{};
  shared_ptr<string> destType{};

  DescribeExporterOutputListResponseBodyDatapointsDatapoint() {}

  explicit DescribeExporterOutputListResponseBodyDatapointsDatapoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configJson) {
      res["ConfigJson"] = configJson ? boost::any(configJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigJson") != m.end() && !m["ConfigJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigJson"].type()) {
        DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigJson"]));
        configJson = make_shared<DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
  }


  virtual ~DescribeExporterOutputListResponseBodyDatapointsDatapoint() = default;
};
class DescribeExporterOutputListResponseBodyDatapoints : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExporterOutputListResponseBodyDatapointsDatapoint>> datapoint{};

  DescribeExporterOutputListResponseBodyDatapoints() {}

  explicit DescribeExporterOutputListResponseBodyDatapoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datapoint) {
      vector<boost::any> temp1;
      for(auto item1:*datapoint){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Datapoint"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Datapoint") != m.end() && !m["Datapoint"].empty()) {
      if (typeid(vector<boost::any>) == m["Datapoint"].type()) {
        vector<DescribeExporterOutputListResponseBodyDatapointsDatapoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Datapoint"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExporterOutputListResponseBodyDatapointsDatapoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datapoint = make_shared<vector<DescribeExporterOutputListResponseBodyDatapointsDatapoint>>(expect1);
      }
    }
  }


  virtual ~DescribeExporterOutputListResponseBodyDatapoints() = default;
};
class DescribeExporterOutputListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeExporterOutputListResponseBodyDatapoints> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeExporterOutputListResponseBody() {}

  explicit DescribeExporterOutputListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = datapoints ? boost::any(datapoints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      if (typeid(map<string, boost::any>) == m["Datapoints"].type()) {
        DescribeExporterOutputListResponseBodyDatapoints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Datapoints"]));
        datapoints = make_shared<DescribeExporterOutputListResponseBodyDatapoints>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeExporterOutputListResponseBody() = default;
};
class DescribeExporterOutputListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExporterOutputListResponseBody> body{};

  DescribeExporterOutputListResponse() {}

  explicit DescribeExporterOutputListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExporterOutputListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExporterOutputListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExporterOutputListResponse() = default;
};
class DescribeExporterRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeExporterRuleListRequest() {}

  explicit DescribeExporterRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeExporterRuleListRequest() = default;
};
class DescribeExporterRuleListResponseBodyDatapointsDatapointDstName : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dstName{};

  DescribeExporterRuleListResponseBodyDatapointsDatapointDstName() {}

  explicit DescribeExporterRuleListResponseBodyDatapointsDatapointDstName(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstName) {
      res["DstName"] = boost::any(*dstName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstName") != m.end() && !m["DstName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeExporterRuleListResponseBodyDatapointsDatapointDstName() = default;
};
class DescribeExporterRuleListResponseBodyDatapointsDatapoint : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> describe{};
  shared_ptr<string> dimension{};
  shared_ptr<DescribeExporterRuleListResponseBodyDatapointsDatapointDstName> dstName{};
  shared_ptr<bool> enabled{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> targetWindows{};

  DescribeExporterRuleListResponseBodyDatapointsDatapoint() {}

  explicit DescribeExporterRuleListResponseBodyDatapointsDatapoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (dstName) {
      res["DstName"] = dstName ? boost::any(dstName->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (targetWindows) {
      res["TargetWindows"] = boost::any(*targetWindows);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("DstName") != m.end() && !m["DstName"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstName"].type()) {
        DescribeExporterRuleListResponseBodyDatapointsDatapointDstName model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstName"]));
        dstName = make_shared<DescribeExporterRuleListResponseBodyDatapointsDatapointDstName>(model1);
      }
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TargetWindows") != m.end() && !m["TargetWindows"].empty()) {
      targetWindows = make_shared<string>(boost::any_cast<string>(m["TargetWindows"]));
    }
  }


  virtual ~DescribeExporterRuleListResponseBodyDatapointsDatapoint() = default;
};
class DescribeExporterRuleListResponseBodyDatapoints : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExporterRuleListResponseBodyDatapointsDatapoint>> datapoint{};

  DescribeExporterRuleListResponseBodyDatapoints() {}

  explicit DescribeExporterRuleListResponseBodyDatapoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datapoint) {
      vector<boost::any> temp1;
      for(auto item1:*datapoint){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Datapoint"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Datapoint") != m.end() && !m["Datapoint"].empty()) {
      if (typeid(vector<boost::any>) == m["Datapoint"].type()) {
        vector<DescribeExporterRuleListResponseBodyDatapointsDatapoint> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Datapoint"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExporterRuleListResponseBodyDatapointsDatapoint model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datapoint = make_shared<vector<DescribeExporterRuleListResponseBodyDatapointsDatapoint>>(expect1);
      }
    }
  }


  virtual ~DescribeExporterRuleListResponseBodyDatapoints() = default;
};
class DescribeExporterRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeExporterRuleListResponseBodyDatapoints> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeExporterRuleListResponseBody() {}

  explicit DescribeExporterRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = datapoints ? boost::any(datapoints->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      if (typeid(map<string, boost::any>) == m["Datapoints"].type()) {
        DescribeExporterRuleListResponseBodyDatapoints model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Datapoints"]));
        datapoints = make_shared<DescribeExporterRuleListResponseBodyDatapoints>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeExporterRuleListResponseBody() = default;
};
class DescribeExporterRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExporterRuleListResponseBody> body{};

  DescribeExporterRuleListResponse() {}

  explicit DescribeExporterRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExporterRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExporterRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExporterRuleListResponse() = default;
};
class DescribeGroupMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processName{};
  shared_ptr<string> regionId{};

  DescribeGroupMonitoringAgentProcessRequest() {}

  explicit DescribeGroupMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessRequest() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParmas{};
  shared_ptr<string> level{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParmas) {
      res["JsonParmas"] = boost::any(*jsonParmas);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParmas") != m.end() && !m["JsonParmas"].empty()) {
      jsonParmas = make_shared<string>(boost::any_cast<string>(m["JsonParmas"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget>> target{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      vector<boost::any> temp1;
      for(auto item1:*target){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Target"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(vector<boost::any>) == m["Target"].type()) {
        vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Target"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        target = make_shared<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> escalationsLevel{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> silenceTime{};
  shared_ptr<string> statistics{};
  shared_ptr<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList> targetList{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};
  shared_ptr<string> webhook{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (escalationsLevel) {
      res["EscalationsLevel"] = boost::any(*escalationsLevel);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (targetList) {
      res["TargetList"] = targetList ? boost::any(targetList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EscalationsLevel") != m.end() && !m["EscalationsLevel"].empty()) {
      escalationsLevel = make_shared<string>(boost::any_cast<string>(m["EscalationsLevel"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetList"].type()) {
        DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetList"]));
        targetList = make_shared<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList>(model1);
      }
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig>> alertConfig{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress : public Darabonba::Model {
public:
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress>> matchExpress{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchExpress) {
      vector<boost::any> temp1;
      for(auto item1:*matchExpress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchExpress"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchExpress"].type()) {
        vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchExpress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchExpress = make_shared<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess : public Darabonba::Model {
public:
  shared_ptr<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig> alertConfig{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress> matchExpress{};
  shared_ptr<string> matchExpressFilterRelation{};
  shared_ptr<string> processName{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchExpress) {
      res["MatchExpress"] = matchExpress ? boost::any(matchExpress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (matchExpressFilterRelation) {
      res["MatchExpressFilterRelation"] = boost::any(*matchExpressFilterRelation);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(map<string, boost::any>) == m["MatchExpress"].type()) {
        DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MatchExpress"]));
        matchExpress = make_shared<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress>(model1);
      }
    }
    if (m.find("MatchExpressFilterRelation") != m.end() && !m["MatchExpressFilterRelation"].empty()) {
      matchExpressFilterRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressFilterRelation"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBodyProcesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess>> process{};

  DescribeGroupMonitoringAgentProcessResponseBodyProcesses() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBodyProcesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (process) {
      vector<boost::any> temp1;
      for(auto item1:*process){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Process"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      if (typeid(vector<boost::any>) == m["Process"].type()) {
        vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Process"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        process = make_shared<vector<DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBodyProcesses() = default;
};
class DescribeGroupMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<DescribeGroupMonitoringAgentProcessResponseBodyProcesses> processes{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> total{};

  DescribeGroupMonitoringAgentProcessResponseBody() {}

  explicit DescribeGroupMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processes) {
      res["Processes"] = processes ? boost::any(processes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Processes") != m.end() && !m["Processes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Processes"].type()) {
        DescribeGroupMonitoringAgentProcessResponseBodyProcesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Processes"]));
        processes = make_shared<DescribeGroupMonitoringAgentProcessResponseBodyProcesses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponseBody() = default;
};
class DescribeGroupMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupMonitoringAgentProcessResponseBody> body{};

  DescribeGroupMonitoringAgentProcessResponse() {}

  explicit DescribeGroupMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupMonitoringAgentProcessResponse() = default;
};
class DescribeHostAvailabilityListRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> ids{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};

  DescribeHostAvailabilityListRequest() {}

  explicit DescribeHostAvailabilityListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeHostAvailabilityListRequest() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> times{};
  shared_ptr<string> value{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList>> escalationList{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationList) {
      vector<boost::any> temp1;
      for(auto item1:*escalationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationList") != m.end() && !m["escalationList"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationList"].type()) {
        vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationList = make_shared<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList>>(expect1);
      }
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget>> target{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      vector<boost::any> temp1;
      for(auto item1:*target){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Target"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(vector<boost::any>) == m["Target"].type()) {
        vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Target"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        target = make_shared<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget>>(expect1);
      }
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList> escalationList{};
  shared_ptr<long> notifyType{};
  shared_ptr<long> silenceTime{};
  shared_ptr<long> startTime{};
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList> targetList{};
  shared_ptr<string> webHook{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (escalationList) {
      res["EscalationList"] = escalationList ? boost::any(escalationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (targetList) {
      res["TargetList"] = targetList ? boost::any(targetList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webHook) {
      res["WebHook"] = boost::any(*webHook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EscalationList") != m.end() && !m["EscalationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["EscalationList"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EscalationList"]));
        escalationList = make_shared<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList>(model1);
      }
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<long>(boost::any_cast<long>(m["NotifyType"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetList"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetList"]));
        targetList = make_shared<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList>(model1);
      }
    }
    if (m.find("WebHook") != m.end() && !m["WebHook"].empty()) {
      webHook = make_shared<string>(boost::any_cast<string>(m["WebHook"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instance{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Instance"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Instance"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instance = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption : public Darabonba::Model {
public:
  shared_ptr<string> httpKeyword{};
  shared_ptr<string> httpMethod{};
  shared_ptr<bool> httpNegative{};
  shared_ptr<string> httpPostContent{};
  shared_ptr<string> httpResponseCharset{};
  shared_ptr<string> httpURI{};
  shared_ptr<long> interval{};
  shared_ptr<string> telnetOrPingHost{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpKeyword) {
      res["HttpKeyword"] = boost::any(*httpKeyword);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpNegative) {
      res["HttpNegative"] = boost::any(*httpNegative);
    }
    if (httpPostContent) {
      res["HttpPostContent"] = boost::any(*httpPostContent);
    }
    if (httpResponseCharset) {
      res["HttpResponseCharset"] = boost::any(*httpResponseCharset);
    }
    if (httpURI) {
      res["HttpURI"] = boost::any(*httpURI);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (telnetOrPingHost) {
      res["TelnetOrPingHost"] = boost::any(*telnetOrPingHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpKeyword") != m.end() && !m["HttpKeyword"].empty()) {
      httpKeyword = make_shared<string>(boost::any_cast<string>(m["HttpKeyword"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpNegative") != m.end() && !m["HttpNegative"].empty()) {
      httpNegative = make_shared<bool>(boost::any_cast<bool>(m["HttpNegative"]));
    }
    if (m.find("HttpPostContent") != m.end() && !m["HttpPostContent"].empty()) {
      httpPostContent = make_shared<string>(boost::any_cast<string>(m["HttpPostContent"]));
    }
    if (m.find("HttpResponseCharset") != m.end() && !m["HttpResponseCharset"].empty()) {
      httpResponseCharset = make_shared<string>(boost::any_cast<string>(m["HttpResponseCharset"]));
    }
    if (m.find("HttpURI") != m.end() && !m["HttpURI"].empty()) {
      httpURI = make_shared<string>(boost::any_cast<string>(m["HttpURI"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TelnetOrPingHost") != m.end() && !m["TelnetOrPingHost"].empty()) {
      telnetOrPingHost = make_shared<string>(boost::any_cast<string>(m["TelnetOrPingHost"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig> alertConfig{};
  shared_ptr<bool> disabled{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances> instances{};
  shared_ptr<string> taskName{};
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption> taskOption{};
  shared_ptr<string> taskScope{};
  shared_ptr<string> taskType{};

  DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (disabled) {
      res["Disabled"] = boost::any(*disabled);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskOption) {
      res["TaskOption"] = taskOption ? boost::any(taskOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskScope) {
      res["TaskScope"] = boost::any(*taskScope);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig>(model1);
      }
    }
    if (m.find("Disabled") != m.end() && !m["Disabled"].empty()) {
      disabled = make_shared<bool>(boost::any_cast<bool>(m["Disabled"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances>(model1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskOption") != m.end() && !m["TaskOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskOption"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskOption"]));
        taskOption = make_shared<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption>(model1);
      }
    }
    if (m.find("TaskScope") != m.end() && !m["TaskScope"].empty()) {
      taskScope = make_shared<string>(boost::any_cast<string>(m["TaskScope"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig() = default;
};
class DescribeHostAvailabilityListResponseBodyTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig>> nodeTaskConfig{};

  DescribeHostAvailabilityListResponseBodyTaskList() {}

  explicit DescribeHostAvailabilityListResponseBodyTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeTaskConfig) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTaskConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTaskConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeTaskConfig") != m.end() && !m["NodeTaskConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTaskConfig"].type()) {
        vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTaskConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTaskConfig = make_shared<vector<DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBodyTaskList() = default;
};
class DescribeHostAvailabilityListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeHostAvailabilityListResponseBodyTaskList> taskList{};
  shared_ptr<long> total{};

  DescribeHostAvailabilityListResponseBody() {}

  explicit DescribeHostAvailabilityListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        DescribeHostAvailabilityListResponseBodyTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<DescribeHostAvailabilityListResponseBodyTaskList>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeHostAvailabilityListResponseBody() = default;
};
class DescribeHostAvailabilityListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHostAvailabilityListResponseBody> body{};

  DescribeHostAvailabilityListResponse() {}

  explicit DescribeHostAvailabilityListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHostAvailabilityListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHostAvailabilityListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHostAvailabilityListResponse() = default;
};
class DescribeHybridMonitorDataListRequest : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> period{};
  shared_ptr<string> promSQL{};
  shared_ptr<string> regionId{};
  shared_ptr<long> start{};

  DescribeHybridMonitorDataListRequest() {}

  explicit DescribeHybridMonitorDataListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (promSQL) {
      res["PromSQL"] = boost::any(*promSQL);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("PromSQL") != m.end() && !m["PromSQL"].empty()) {
      promSQL = make_shared<string>(boost::any_cast<string>(m["PromSQL"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeHybridMonitorDataListRequest() = default;
};
class DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels : public Darabonba::Model {
public:
  shared_ptr<string> k{};
  shared_ptr<string> v{};

  DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels() {}

  explicit DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (k) {
      res["K"] = boost::any(*k);
    }
    if (v) {
      res["V"] = boost::any(*v);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("K") != m.end() && !m["K"].empty()) {
      k = make_shared<string>(boost::any_cast<string>(m["K"]));
    }
    if (m.find("V") != m.end() && !m["V"].empty()) {
      v = make_shared<string>(boost::any_cast<string>(m["V"]));
    }
  }


  virtual ~DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels() = default;
};
class DescribeHybridMonitorDataListResponseBodyTimeSeriesValues : public Darabonba::Model {
public:
  shared_ptr<string> ts{};
  shared_ptr<string> v{};

  DescribeHybridMonitorDataListResponseBodyTimeSeriesValues() {}

  explicit DescribeHybridMonitorDataListResponseBodyTimeSeriesValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ts) {
      res["Ts"] = boost::any(*ts);
    }
    if (v) {
      res["V"] = boost::any(*v);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ts") != m.end() && !m["Ts"].empty()) {
      ts = make_shared<string>(boost::any_cast<string>(m["Ts"]));
    }
    if (m.find("V") != m.end() && !m["V"].empty()) {
      v = make_shared<string>(boost::any_cast<string>(m["V"]));
    }
  }


  virtual ~DescribeHybridMonitorDataListResponseBodyTimeSeriesValues() = default;
};
class DescribeHybridMonitorDataListResponseBodyTimeSeries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesValues>> values{};

  DescribeHybridMonitorDataListResponseBodyTimeSeries() {}

  explicit DescribeHybridMonitorDataListResponseBodyTimeSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (values) {
      vector<boost::any> temp1;
      for(auto item1:*values){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Values"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesValues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Values"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorDataListResponseBodyTimeSeriesValues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        values = make_shared<vector<DescribeHybridMonitorDataListResponseBodyTimeSeriesValues>>(expect1);
      }
    }
  }


  virtual ~DescribeHybridMonitorDataListResponseBodyTimeSeries() = default;
};
class DescribeHybridMonitorDataListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<vector<DescribeHybridMonitorDataListResponseBodyTimeSeries>> timeSeries{};

  DescribeHybridMonitorDataListResponseBody() {}

  explicit DescribeHybridMonitorDataListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeSeries) {
      vector<boost::any> temp1;
      for(auto item1:*timeSeries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TimeSeries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TimeSeries") != m.end() && !m["TimeSeries"].empty()) {
      if (typeid(vector<boost::any>) == m["TimeSeries"].type()) {
        vector<DescribeHybridMonitorDataListResponseBodyTimeSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TimeSeries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorDataListResponseBodyTimeSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timeSeries = make_shared<vector<DescribeHybridMonitorDataListResponseBodyTimeSeries>>(expect1);
      }
    }
  }


  virtual ~DescribeHybridMonitorDataListResponseBody() = default;
};
class DescribeHybridMonitorDataListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridMonitorDataListResponseBody> body{};

  DescribeHybridMonitorDataListResponse() {}

  explicit DescribeHybridMonitorDataListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridMonitorDataListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridMonitorDataListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridMonitorDataListResponse() = default;
};
class DescribeHybridMonitorNamespaceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> showTaskStatistic{};

  DescribeHybridMonitorNamespaceListRequest() {}

  explicit DescribeHybridMonitorNamespaceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showTaskStatistic) {
      res["ShowTaskStatistic"] = boost::any(*showTaskStatistic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowTaskStatistic") != m.end() && !m["ShowTaskStatistic"].empty()) {
      showTaskStatistic = make_shared<bool>(boost::any_cast<bool>(m["ShowTaskStatistic"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListRequest() = default;
};
class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> list{};
  shared_ptr<long> period{};

  DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList() {}

  explicit DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = boost::any(*list);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["List"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      list = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList() = default;
};
class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList>> metricList{};
  shared_ptr<string> namespace_{};

  DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList() {}

  explicit DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricList) {
      vector<boost::any> temp1;
      for(auto item1:*metricList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetricList"] = boost::any(temp1);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricList") != m.end() && !m["MetricList"].empty()) {
      if (typeid(vector<boost::any>) == m["MetricList"].type()) {
        vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetricList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricList = make_shared<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList>>(expect1);
      }
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList() = default;
};
class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList>> namespaceList{};
  shared_ptr<long> userId{};
  shared_ptr<string> YAMLConfig{};

  DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList() {}

  explicit DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceList) {
      vector<boost::any> temp1;
      for(auto item1:*namespaceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NamespaceList"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (YAMLConfig) {
      res["YAMLConfig"] = boost::any(*YAMLConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NamespaceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaceList = make_shared<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
    if (m.find("YAMLConfig") != m.end() && !m["YAMLConfig"].empty()) {
      YAMLConfig = make_shared<string>(boost::any_cast<string>(m["YAMLConfig"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList() = default;
};
class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail : public Darabonba::Model {
public:
  shared_ptr<string> namespaceRegion{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> spec{};

  DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail() {}

  explicit DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaceRegion) {
      res["NamespaceRegion"] = boost::any(*namespaceRegion);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NamespaceRegion") != m.end() && !m["NamespaceRegion"].empty()) {
      namespaceRegion = make_shared<string>(boost::any_cast<string>(m["NamespaceRegion"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail() = default;
};
class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList>> aliyunProductMetricList{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail> detail{};
  shared_ptr<string> id{};
  shared_ptr<long> isDelete{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceType{};
  shared_ptr<long> notAliyunTaskNumber{};

  DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace() {}

  explicit DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunProductMetricList) {
      vector<boost::any> temp1;
      for(auto item1:*aliyunProductMetricList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AliyunProductMetricList"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceType) {
      res["NamespaceType"] = boost::any(*namespaceType);
    }
    if (notAliyunTaskNumber) {
      res["NotAliyunTaskNumber"] = boost::any(*notAliyunTaskNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunProductMetricList") != m.end() && !m["AliyunProductMetricList"].empty()) {
      if (typeid(vector<boost::any>) == m["AliyunProductMetricList"].type()) {
        vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AliyunProductMetricList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliyunProductMetricList = make_shared<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<long>(boost::any_cast<long>(m["IsDelete"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceType") != m.end() && !m["NamespaceType"].empty()) {
      namespaceType = make_shared<string>(boost::any_cast<string>(m["NamespaceType"]));
    }
    if (m.find("NotAliyunTaskNumber") != m.end() && !m["NotAliyunTaskNumber"].empty()) {
      notAliyunTaskNumber = make_shared<long>(boost::any_cast<long>(m["NotAliyunTaskNumber"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace() = default;
};
class DescribeHybridMonitorNamespaceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace>> describeHybridMonitorNamespace{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  DescribeHybridMonitorNamespaceListResponseBody() {}

  explicit DescribeHybridMonitorNamespaceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (describeHybridMonitorNamespace) {
      vector<boost::any> temp1;
      for(auto item1:*describeHybridMonitorNamespace){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeHybridMonitorNamespace"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DescribeHybridMonitorNamespace") != m.end() && !m["DescribeHybridMonitorNamespace"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeHybridMonitorNamespace"].type()) {
        vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeHybridMonitorNamespace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeHybridMonitorNamespace = make_shared<vector<DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponseBody() = default;
};
class DescribeHybridMonitorNamespaceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridMonitorNamespaceListResponseBody> body{};

  DescribeHybridMonitorNamespaceListResponse() {}

  explicit DescribeHybridMonitorNamespaceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridMonitorNamespaceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridMonitorNamespaceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridMonitorNamespaceListResponse() = default;
};
class DescribeHybridMonitorSLSGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> SLSGroupName{};

  DescribeHybridMonitorSLSGroupRequest() {}

  explicit DescribeHybridMonitorSLSGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSGroupName) {
      res["SLSGroupName"] = boost::any(*SLSGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSGroupName") != m.end() && !m["SLSGroupName"].empty()) {
      SLSGroupName = make_shared<string>(boost::any_cast<string>(m["SLSGroupName"]));
    }
  }


  virtual ~DescribeHybridMonitorSLSGroupRequest() = default;
};
class DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig : public Darabonba::Model {
public:
  shared_ptr<string> SLSLogstore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> SLSUserId{};

  DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig() {}

  explicit DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLSLogstore) {
      res["SLSLogstore"] = boost::any(*SLSLogstore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (SLSUserId) {
      res["SLSUserId"] = boost::any(*SLSUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLSLogstore") != m.end() && !m["SLSLogstore"].empty()) {
      SLSLogstore = make_shared<string>(boost::any_cast<string>(m["SLSLogstore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SLSUserId") != m.end() && !m["SLSUserId"].empty()) {
      SLSUserId = make_shared<string>(boost::any_cast<string>(m["SLSUserId"]));
    }
  }


  virtual ~DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig() = default;
};
class DescribeHybridMonitorSLSGroupResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<vector<DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig>> SLSGroupConfig{};
  shared_ptr<string> SLSGroupDescription{};
  shared_ptr<string> SLSGroupName{};
  shared_ptr<string> updateTime{};

  DescribeHybridMonitorSLSGroupResponseBodyList() {}

  explicit DescribeHybridMonitorSLSGroupResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (SLSGroupConfig) {
      vector<boost::any> temp1;
      for(auto item1:*SLSGroupConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SLSGroupConfig"] = boost::any(temp1);
    }
    if (SLSGroupDescription) {
      res["SLSGroupDescription"] = boost::any(*SLSGroupDescription);
    }
    if (SLSGroupName) {
      res["SLSGroupName"] = boost::any(*SLSGroupName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("SLSGroupConfig") != m.end() && !m["SLSGroupConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SLSGroupConfig"].type()) {
        vector<DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SLSGroupConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SLSGroupConfig = make_shared<vector<DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig>>(expect1);
      }
    }
    if (m.find("SLSGroupDescription") != m.end() && !m["SLSGroupDescription"].empty()) {
      SLSGroupDescription = make_shared<string>(boost::any_cast<string>(m["SLSGroupDescription"]));
    }
    if (m.find("SLSGroupName") != m.end() && !m["SLSGroupName"].empty()) {
      SLSGroupName = make_shared<string>(boost::any_cast<string>(m["SLSGroupName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeHybridMonitorSLSGroupResponseBodyList() = default;
};
class DescribeHybridMonitorSLSGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeHybridMonitorSLSGroupResponseBodyList>> list{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  DescribeHybridMonitorSLSGroupResponseBody() {}

  explicit DescribeHybridMonitorSLSGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeHybridMonitorSLSGroupResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorSLSGroupResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeHybridMonitorSLSGroupResponseBodyList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeHybridMonitorSLSGroupResponseBody() = default;
};
class DescribeHybridMonitorSLSGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridMonitorSLSGroupResponseBody> body{};

  DescribeHybridMonitorSLSGroupResponse() {}

  explicit DescribeHybridMonitorSLSGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridMonitorSLSGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridMonitorSLSGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridMonitorSLSGroupResponse() = default;
};
class DescribeHybridMonitorTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<bool> includeAliyunTask{};
  shared_ptr<string> keyword{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> targetUserId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  DescribeHybridMonitorTaskListRequest() {}

  explicit DescribeHybridMonitorTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (includeAliyunTask) {
      res["IncludeAliyunTask"] = boost::any(*includeAliyunTask);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IncludeAliyunTask") != m.end() && !m["IncludeAliyunTask"].empty()) {
      includeAliyunTask = make_shared<bool>(boost::any_cast<bool>(m["IncludeAliyunTask"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<long>(boost::any_cast<long>(m["TargetUserId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListRequest() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress : public Darabonba::Model {
public:
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> express{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> SLSKeyName{};
  shared_ptr<string> value{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters>> filters{};
  shared_ptr<string> relation{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters>>(expect1);
      }
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> SLSKeyName{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> function{};
  shared_ptr<string> parameter1{};
  shared_ptr<string> parameter2{};
  shared_ptr<string> SLSKeyName{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (parameter1) {
      res["Parameter1"] = boost::any(*parameter1);
    }
    if (parameter2) {
      res["Parameter2"] = boost::any(*parameter2);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Parameter1") != m.end() && !m["Parameter1"].empty()) {
      parameter1 = make_shared<string>(boost::any_cast<string>(m["Parameter1"]));
    }
    if (m.find("Parameter2") != m.end() && !m["Parameter2"].empty()) {
      parameter2 = make_shared<string>(boost::any_cast<string>(m["Parameter2"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress>> express{};
  shared_ptr<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter> filter{};
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy>> groupBy{};
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics>> statistics{};

  DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (express) {
      vector<boost::any> temp1;
      for(auto item1:*express){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Express"] = boost::any(temp1);
    }
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupBy) {
      vector<boost::any> temp1;
      for(auto item1:*groupBy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupBy"] = boost::any(temp1);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      if (typeid(vector<boost::any>) == m["Express"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Express"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        express = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress>>(expect1);
      }
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter>(model1);
      }
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupBy"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupBy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupBy = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy>>(expect1);
      }
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig() = default;
};
class DescribeHybridMonitorTaskListResponseBodyTaskList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels>> attachLabels{};
  shared_ptr<long> collectInterval{};
  shared_ptr<string> collectTargetEndpoint{};
  shared_ptr<string> collectTargetPath{};
  shared_ptr<string> collectTargetType{};
  shared_ptr<long> collectTimout{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<string> logFilePath{};
  shared_ptr<string> logProcess{};
  shared_ptr<string> logSample{};
  shared_ptr<string> logSplit{};
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress>> matchExpress{};
  shared_ptr<string> matchExpressRelation{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> networkType{};
  shared_ptr<string> SLSProcess{};
  shared_ptr<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig> SLSProcessConfig{};
  shared_ptr<string> targetUserId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> uploadRegion{};
  shared_ptr<string> YARMConfig{};

  DescribeHybridMonitorTaskListResponseBodyTaskList() {}

  explicit DescribeHybridMonitorTaskListResponseBodyTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachLabels) {
      vector<boost::any> temp1;
      for(auto item1:*attachLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachLabels"] = boost::any(temp1);
    }
    if (collectInterval) {
      res["CollectInterval"] = boost::any(*collectInterval);
    }
    if (collectTargetEndpoint) {
      res["CollectTargetEndpoint"] = boost::any(*collectTargetEndpoint);
    }
    if (collectTargetPath) {
      res["CollectTargetPath"] = boost::any(*collectTargetPath);
    }
    if (collectTargetType) {
      res["CollectTargetType"] = boost::any(*collectTargetType);
    }
    if (collectTimout) {
      res["CollectTimout"] = boost::any(*collectTimout);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (logFilePath) {
      res["LogFilePath"] = boost::any(*logFilePath);
    }
    if (logProcess) {
      res["LogProcess"] = boost::any(*logProcess);
    }
    if (logSample) {
      res["LogSample"] = boost::any(*logSample);
    }
    if (logSplit) {
      res["LogSplit"] = boost::any(*logSplit);
    }
    if (matchExpress) {
      vector<boost::any> temp1;
      for(auto item1:*matchExpress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MatchExpress"] = boost::any(temp1);
    }
    if (matchExpressRelation) {
      res["MatchExpressRelation"] = boost::any(*matchExpressRelation);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (SLSProcess) {
      res["SLSProcess"] = boost::any(*SLSProcess);
    }
    if (SLSProcessConfig) {
      res["SLSProcessConfig"] = SLSProcessConfig ? boost::any(SLSProcessConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetUserId) {
      res["TargetUserId"] = boost::any(*targetUserId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (uploadRegion) {
      res["UploadRegion"] = boost::any(*uploadRegion);
    }
    if (YARMConfig) {
      res["YARMConfig"] = boost::any(*YARMConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachLabels") != m.end() && !m["AttachLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachLabels"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachLabels = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels>>(expect1);
      }
    }
    if (m.find("CollectInterval") != m.end() && !m["CollectInterval"].empty()) {
      collectInterval = make_shared<long>(boost::any_cast<long>(m["CollectInterval"]));
    }
    if (m.find("CollectTargetEndpoint") != m.end() && !m["CollectTargetEndpoint"].empty()) {
      collectTargetEndpoint = make_shared<string>(boost::any_cast<string>(m["CollectTargetEndpoint"]));
    }
    if (m.find("CollectTargetPath") != m.end() && !m["CollectTargetPath"].empty()) {
      collectTargetPath = make_shared<string>(boost::any_cast<string>(m["CollectTargetPath"]));
    }
    if (m.find("CollectTargetType") != m.end() && !m["CollectTargetType"].empty()) {
      collectTargetType = make_shared<string>(boost::any_cast<string>(m["CollectTargetType"]));
    }
    if (m.find("CollectTimout") != m.end() && !m["CollectTimout"].empty()) {
      collectTimout = make_shared<long>(boost::any_cast<long>(m["CollectTimout"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LogFilePath") != m.end() && !m["LogFilePath"].empty()) {
      logFilePath = make_shared<string>(boost::any_cast<string>(m["LogFilePath"]));
    }
    if (m.find("LogProcess") != m.end() && !m["LogProcess"].empty()) {
      logProcess = make_shared<string>(boost::any_cast<string>(m["LogProcess"]));
    }
    if (m.find("LogSample") != m.end() && !m["LogSample"].empty()) {
      logSample = make_shared<string>(boost::any_cast<string>(m["LogSample"]));
    }
    if (m.find("LogSplit") != m.end() && !m["LogSplit"].empty()) {
      logSplit = make_shared<string>(boost::any_cast<string>(m["LogSplit"]));
    }
    if (m.find("MatchExpress") != m.end() && !m["MatchExpress"].empty()) {
      if (typeid(vector<boost::any>) == m["MatchExpress"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MatchExpress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        matchExpress = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress>>(expect1);
      }
    }
    if (m.find("MatchExpressRelation") != m.end() && !m["MatchExpressRelation"].empty()) {
      matchExpressRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressRelation"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("SLSProcess") != m.end() && !m["SLSProcess"].empty()) {
      SLSProcess = make_shared<string>(boost::any_cast<string>(m["SLSProcess"]));
    }
    if (m.find("SLSProcessConfig") != m.end() && !m["SLSProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLSProcessConfig"].type()) {
        DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLSProcessConfig"]));
        SLSProcessConfig = make_shared<DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig>(model1);
      }
    }
    if (m.find("TargetUserId") != m.end() && !m["TargetUserId"].empty()) {
      targetUserId = make_shared<string>(boost::any_cast<string>(m["TargetUserId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UploadRegion") != m.end() && !m["UploadRegion"].empty()) {
      uploadRegion = make_shared<string>(boost::any_cast<string>(m["UploadRegion"]));
    }
    if (m.find("YARMConfig") != m.end() && !m["YARMConfig"].empty()) {
      YARMConfig = make_shared<string>(boost::any_cast<string>(m["YARMConfig"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBodyTaskList() = default;
};
class DescribeHybridMonitorTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<vector<DescribeHybridMonitorTaskListResponseBodyTaskList>> taskList{};
  shared_ptr<long> total{};

  DescribeHybridMonitorTaskListResponseBody() {}

  explicit DescribeHybridMonitorTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<DescribeHybridMonitorTaskListResponseBodyTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridMonitorTaskListResponseBodyTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<DescribeHybridMonitorTaskListResponseBodyTaskList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponseBody() = default;
};
class DescribeHybridMonitorTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridMonitorTaskListResponseBody> body{};

  DescribeHybridMonitorTaskListResponse() {}

  explicit DescribeHybridMonitorTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridMonitorTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridMonitorTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridMonitorTaskListResponse() = default;
};
class DescribeLogMonitorAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> regionId{};

  DescribeLogMonitorAttributeRequest() {}

  explicit DescribeLogMonitorAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeLogMonitorAttributeRequest() = default;
};
class DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> function{};
  shared_ptr<string> max{};
  shared_ptr<string> min{};

  DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates() {}

  explicit DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<string>(boost::any_cast<string>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<string>(boost::any_cast<string>(m["Min"]));
    }
  }


  virtual ~DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates() = default;
};
class DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter() {}

  explicit DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter() = default;
};
class DescribeLogMonitorAttributeResponseBodyLogMonitor : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates>> aggregates{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> groupId{};
  shared_ptr<vector<string>> groupbys{};
  shared_ptr<long> logId{};
  shared_ptr<string> metricExpress{};
  shared_ptr<string> metricName{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<vector<string>> tumblingwindows{};
  shared_ptr<vector<DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter>> valueFilter{};
  shared_ptr<string> valueFilterRelation{};

  DescribeLogMonitorAttributeResponseBodyLogMonitor() {}

  explicit DescribeLogMonitorAttributeResponseBodyLogMonitor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregates) {
      vector<boost::any> temp1;
      for(auto item1:*aggregates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregates"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupbys) {
      res["Groupbys"] = boost::any(*groupbys);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (metricExpress) {
      res["MetricExpress"] = boost::any(*metricExpress);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (tumblingwindows) {
      res["Tumblingwindows"] = boost::any(*tumblingwindows);
    }
    if (valueFilter) {
      vector<boost::any> temp1;
      for(auto item1:*valueFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueFilter"] = boost::any(temp1);
    }
    if (valueFilterRelation) {
      res["ValueFilterRelation"] = boost::any(*valueFilterRelation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregates") != m.end() && !m["Aggregates"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregates"].type()) {
        vector<DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregates = make_shared<vector<DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Groupbys") != m.end() && !m["Groupbys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groupbys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groupbys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupbys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<long>(boost::any_cast<long>(m["LogId"]));
    }
    if (m.find("MetricExpress") != m.end() && !m["MetricExpress"].empty()) {
      metricExpress = make_shared<string>(boost::any_cast<string>(m["MetricExpress"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("Tumblingwindows") != m.end() && !m["Tumblingwindows"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tumblingwindows"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tumblingwindows"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tumblingwindows = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ValueFilter") != m.end() && !m["ValueFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueFilter"].type()) {
        vector<DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueFilter = make_shared<vector<DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter>>(expect1);
      }
    }
    if (m.find("ValueFilterRelation") != m.end() && !m["ValueFilterRelation"].empty()) {
      valueFilterRelation = make_shared<string>(boost::any_cast<string>(m["ValueFilterRelation"]));
    }
  }


  virtual ~DescribeLogMonitorAttributeResponseBodyLogMonitor() = default;
};
class DescribeLogMonitorAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeLogMonitorAttributeResponseBodyLogMonitor> logMonitor{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeLogMonitorAttributeResponseBody() {}

  explicit DescribeLogMonitorAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logMonitor) {
      res["LogMonitor"] = logMonitor ? boost::any(logMonitor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogMonitor") != m.end() && !m["LogMonitor"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogMonitor"].type()) {
        DescribeLogMonitorAttributeResponseBodyLogMonitor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogMonitor"]));
        logMonitor = make_shared<DescribeLogMonitorAttributeResponseBodyLogMonitor>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeLogMonitorAttributeResponseBody() = default;
};
class DescribeLogMonitorAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogMonitorAttributeResponseBody> body{};

  DescribeLogMonitorAttributeResponse() {}

  explicit DescribeLogMonitorAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogMonitorAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogMonitorAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogMonitorAttributeResponse() = default;
};
class DescribeLogMonitorListRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchValue{};

  DescribeLogMonitorListRequest() {}

  explicit DescribeLogMonitorListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
  }


  virtual ~DescribeLogMonitorListRequest() = default;
};
class DescribeLogMonitorListResponseBodyLogMonitorListValueFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  DescribeLogMonitorListResponseBodyLogMonitorListValueFilter() {}

  explicit DescribeLogMonitorListResponseBodyLogMonitorListValueFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeLogMonitorListResponseBodyLogMonitorListValueFilter() = default;
};
class DescribeLogMonitorListResponseBodyLogMonitorList : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> groupId{};
  shared_ptr<long> logId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<vector<DescribeLogMonitorListResponseBodyLogMonitorListValueFilter>> valueFilter{};
  shared_ptr<string> valueFilterRelation{};

  DescribeLogMonitorListResponseBodyLogMonitorList() {}

  explicit DescribeLogMonitorListResponseBodyLogMonitorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (valueFilter) {
      vector<boost::any> temp1;
      for(auto item1:*valueFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueFilter"] = boost::any(temp1);
    }
    if (valueFilterRelation) {
      res["ValueFilterRelation"] = boost::any(*valueFilterRelation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<long>(boost::any_cast<long>(m["LogId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("ValueFilter") != m.end() && !m["ValueFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueFilter"].type()) {
        vector<DescribeLogMonitorListResponseBodyLogMonitorListValueFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogMonitorListResponseBodyLogMonitorListValueFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueFilter = make_shared<vector<DescribeLogMonitorListResponseBodyLogMonitorListValueFilter>>(expect1);
      }
    }
    if (m.find("ValueFilterRelation") != m.end() && !m["ValueFilterRelation"].empty()) {
      valueFilterRelation = make_shared<string>(boost::any_cast<string>(m["ValueFilterRelation"]));
    }
  }


  virtual ~DescribeLogMonitorListResponseBodyLogMonitorList() = default;
};
class DescribeLogMonitorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeLogMonitorListResponseBodyLogMonitorList>> logMonitorList{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeLogMonitorListResponseBody() {}

  explicit DescribeLogMonitorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logMonitorList) {
      vector<boost::any> temp1;
      for(auto item1:*logMonitorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogMonitorList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogMonitorList") != m.end() && !m["LogMonitorList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogMonitorList"].type()) {
        vector<DescribeLogMonitorListResponseBodyLogMonitorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogMonitorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogMonitorListResponseBodyLogMonitorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logMonitorList = make_shared<vector<DescribeLogMonitorListResponseBodyLogMonitorList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeLogMonitorListResponseBody() = default;
};
class DescribeLogMonitorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogMonitorListResponseBody> body{};

  DescribeLogMonitorListResponse() {}

  explicit DescribeLogMonitorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogMonitorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogMonitorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogMonitorListResponse() = default;
};
class DescribeMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> endTime{};
  shared_ptr<string> express{};
  shared_ptr<string> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeMetricDataRequest() {}

  explicit DescribeMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricDataRequest() = default;
};
class DescribeMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> period{};
  shared_ptr<string> requestId{};

  DescribeMetricDataResponseBody() {}

  explicit DescribeMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = boost::any(*datapoints);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      datapoints = make_shared<string>(boost::any_cast<string>(m["Datapoints"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMetricDataResponseBody() = default;
};
class DescribeMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricDataResponseBody> body{};

  DescribeMetricDataResponse() {}

  explicit DescribeMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricDataResponse() = default;
};
class DescribeMetricLastRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> endTime{};
  shared_ptr<string> express{};
  shared_ptr<string> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeMetricLastRequest() {}

  explicit DescribeMetricLastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricLastRequest() = default;
};
class DescribeMetricLastResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> period{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMetricLastResponseBody() {}

  explicit DescribeMetricLastResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = boost::any(*datapoints);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      datapoints = make_shared<string>(boost::any_cast<string>(m["Datapoints"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMetricLastResponseBody() = default;
};
class DescribeMetricLastResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricLastResponseBody> body{};

  DescribeMetricLastResponse() {}

  explicit DescribeMetricLastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricLastResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricLastResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricLastResponse() = default;
};
class DescribeMetricListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> endTime{};
  shared_ptr<string> express{};
  shared_ptr<string> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeMetricListRequest() {}

  explicit DescribeMetricListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricListRequest() = default;
};
class DescribeMetricListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> period{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMetricListResponseBody() {}

  explicit DescribeMetricListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = boost::any(*datapoints);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      datapoints = make_shared<string>(boost::any_cast<string>(m["Datapoints"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMetricListResponseBody() = default;
};
class DescribeMetricListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricListResponseBody> body{};

  DescribeMetricListResponse() {}

  explicit DescribeMetricListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricListResponse() = default;
};
class DescribeMetricMetaListRequest : public Darabonba::Model {
public:
  shared_ptr<string> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeMetricMetaListRequest() {}

  explicit DescribeMetricMetaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeMetricMetaListRequest() = default;
};
class DescribeMetricMetaListResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> periods{};
  shared_ptr<string> statistics{};
  shared_ptr<string> unit{};

  DescribeMetricMetaListResponseBodyResourcesResource() {}

  explicit DescribeMetricMetaListResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (periods) {
      res["Periods"] = boost::any(*periods);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Periods") != m.end() && !m["Periods"].empty()) {
      periods = make_shared<string>(boost::any_cast<string>(m["Periods"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
  }


  virtual ~DescribeMetricMetaListResponseBodyResourcesResource() = default;
};
class DescribeMetricMetaListResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricMetaListResponseBodyResourcesResource>> resource{};

  DescribeMetricMetaListResponseBodyResources() {}

  explicit DescribeMetricMetaListResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeMetricMetaListResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricMetaListResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeMetricMetaListResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricMetaListResponseBodyResources() = default;
};
class DescribeMetricMetaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMetricMetaListResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<string> totalCount{};

  DescribeMetricMetaListResponseBody() {}

  explicit DescribeMetricMetaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeMetricMetaListResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeMetricMetaListResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeMetricMetaListResponseBody() = default;
};
class DescribeMetricMetaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricMetaListResponseBody> body{};

  DescribeMetricMetaListResponse() {}

  explicit DescribeMetricMetaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricMetaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricMetaListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricMetaListResponse() = default;
};
class DescribeMetricRuleBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<vector<string>> ids{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<bool> isEnable{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scopeType{};

  DescribeMetricRuleBlackListRequest() {}

  explicit DescribeMetricRuleBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<bool>(boost::any_cast<bool>(m["IsEnable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
  }


  virtual ~DescribeMetricRuleBlackListRequest() = default;
};
class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> resource{};

  DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics() {}

  explicit DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics() = default;
};
class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<long> enableEndTime{};
  shared_ptr<long> enableStartTime{};
  shared_ptr<string> id{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<bool> isEnable{};
  shared_ptr<vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics>> metrics{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> scopeType{};
  shared_ptr<vector<string>> scopeValue{};
  shared_ptr<string> updateTime{};

  DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList() {}

  explicit DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (enableEndTime) {
      res["EnableEndTime"] = boost::any(*enableEndTime);
    }
    if (enableStartTime) {
      res["EnableStartTime"] = boost::any(*enableStartTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("EnableEndTime") != m.end() && !m["EnableEndTime"].empty()) {
      enableEndTime = make_shared<long>(boost::any_cast<long>(m["EnableEndTime"]));
    }
    if (m.find("EnableStartTime") != m.end() && !m["EnableStartTime"].empty()) {
      enableStartTime = make_shared<long>(boost::any_cast<long>(m["EnableStartTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<bool>(boost::any_cast<bool>(m["IsEnable"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList() = default;
};
class DescribeMetricRuleBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList>> describeMetricRuleBlackList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeMetricRuleBlackListResponseBody() {}

  explicit DescribeMetricRuleBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (describeMetricRuleBlackList) {
      vector<boost::any> temp1;
      for(auto item1:*describeMetricRuleBlackList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DescribeMetricRuleBlackList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DescribeMetricRuleBlackList") != m.end() && !m["DescribeMetricRuleBlackList"].empty()) {
      if (typeid(vector<boost::any>) == m["DescribeMetricRuleBlackList"].type()) {
        vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DescribeMetricRuleBlackList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        describeMetricRuleBlackList = make_shared<vector<DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMetricRuleBlackListResponseBody() = default;
};
class DescribeMetricRuleBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleBlackListResponseBody> body{};

  DescribeMetricRuleBlackListResponse() {}

  explicit DescribeMetricRuleBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleBlackListResponse() = default;
};
class DescribeMetricRuleCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};

  DescribeMetricRuleCountRequest() {}

  explicit DescribeMetricRuleCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMetricRuleCountRequest() = default;
};
class DescribeMetricRuleCountResponseBodyMetricRuleCount : public Darabonba::Model {
public:
  shared_ptr<long> alarm{};
  shared_ptr<long> disable{};
  shared_ptr<long> nodata{};
  shared_ptr<long> ok{};
  shared_ptr<long> total{};

  DescribeMetricRuleCountResponseBodyMetricRuleCount() {}

  explicit DescribeMetricRuleCountResponseBodyMetricRuleCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarm) {
      res["Alarm"] = boost::any(*alarm);
    }
    if (disable) {
      res["Disable"] = boost::any(*disable);
    }
    if (nodata) {
      res["Nodata"] = boost::any(*nodata);
    }
    if (ok) {
      res["Ok"] = boost::any(*ok);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarm") != m.end() && !m["Alarm"].empty()) {
      alarm = make_shared<long>(boost::any_cast<long>(m["Alarm"]));
    }
    if (m.find("Disable") != m.end() && !m["Disable"].empty()) {
      disable = make_shared<long>(boost::any_cast<long>(m["Disable"]));
    }
    if (m.find("Nodata") != m.end() && !m["Nodata"].empty()) {
      nodata = make_shared<long>(boost::any_cast<long>(m["Nodata"]));
    }
    if (m.find("Ok") != m.end() && !m["Ok"].empty()) {
      ok = make_shared<long>(boost::any_cast<long>(m["Ok"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMetricRuleCountResponseBodyMetricRuleCount() = default;
};
class DescribeMetricRuleCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeMetricRuleCountResponseBodyMetricRuleCount> metricRuleCount{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMetricRuleCountResponseBody() {}

  explicit DescribeMetricRuleCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricRuleCount) {
      res["MetricRuleCount"] = metricRuleCount ? boost::any(metricRuleCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricRuleCount") != m.end() && !m["MetricRuleCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricRuleCount"].type()) {
        DescribeMetricRuleCountResponseBodyMetricRuleCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricRuleCount"]));
        metricRuleCount = make_shared<DescribeMetricRuleCountResponseBodyMetricRuleCount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMetricRuleCountResponseBody() = default;
};
class DescribeMetricRuleCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleCountResponseBody> body{};

  DescribeMetricRuleCountResponse() {}

  explicit DescribeMetricRuleCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleCountResponse() = default;
};
class DescribeMetricRuleListRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertState{};
  shared_ptr<string> dimensions{};
  shared_ptr<bool> enableState{};
  shared_ptr<string> groupId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleIds{};
  shared_ptr<string> ruleName{};

  DescribeMetricRuleListRequest() {}

  explicit DescribeMetricRuleListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertState) {
      res["AlertState"] = boost::any(*alertState);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (enableState) {
      res["EnableState"] = boost::any(*enableState);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertState") != m.end() && !m["AlertState"].empty()) {
      alertState = make_shared<string>(boost::any_cast<string>(m["AlertState"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EnableState") != m.end() && !m["EnableState"].empty()) {
      enableState = make_shared<bool>(boost::any_cast<bool>(m["EnableState"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DescribeMetricRuleListRequest() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList>> expressionList{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionList) {
      vector<boost::any> temp1;
      for(auto item1:*expressionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExpressionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpressionList") != m.end() && !m["ExpressionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ExpressionList"].type()) {
        vector<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExpressionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressionList = make_shared<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList> expressionList{};
  shared_ptr<string> expressionListJoin{};
  shared_ptr<string> expressionRaw{};
  shared_ptr<string> level{};
  shared_ptr<long> times{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionList) {
      res["ExpressionList"] = expressionList ? boost::any(expressionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expressionListJoin) {
      res["ExpressionListJoin"] = boost::any(*expressionListJoin);
    }
    if (expressionRaw) {
      res["ExpressionRaw"] = boost::any(*expressionRaw);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpressionList") != m.end() && !m["ExpressionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExpressionList"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExpressionList"]));
        expressionList = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList>(model1);
      }
    }
    if (m.find("ExpressionListJoin") != m.end() && !m["ExpressionListJoin"].empty()) {
      expressionListJoin = make_shared<string>(boost::any_cast<string>(m["ExpressionListJoin"]));
    }
    if (m.find("ExpressionRaw") != m.end() && !m["ExpressionRaw"].empty()) {
      expressionRaw = make_shared<string>(boost::any_cast<string>(m["ExpressionRaw"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical> critical{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo> info{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn> warn{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmLabels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels>> labels{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmLabels() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmLabels() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations>> annotations{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations> annotations{};
  shared_ptr<string> level{};
  shared_ptr<string> promQL{};
  shared_ptr<long> times{};

  DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = annotations ? boost::any(annotations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Annotations"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Annotations"]));
        annotations = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations>(model1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus() = default;
};
class DescribeMetricRuleListResponseBodyAlarmsAlarm : public Darabonba::Model {
public:
  shared_ptr<string> alertState{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression> compositeExpression{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<bool> enableState{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations> escalations{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmLabels> labels{};
  shared_ptr<string> mailSubject{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> period{};
  shared_ptr<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus> prometheus{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> webhook{};

  DescribeMetricRuleListResponseBodyAlarmsAlarm() {}

  explicit DescribeMetricRuleListResponseBodyAlarmsAlarm(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertState) {
      res["AlertState"] = boost::any(*alertState);
    }
    if (compositeExpression) {
      res["CompositeExpression"] = compositeExpression ? boost::any(compositeExpression->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (enableState) {
      res["EnableState"] = boost::any(*enableState);
    }
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (labels) {
      res["Labels"] = labels ? boost::any(labels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mailSubject) {
      res["MailSubject"] = boost::any(*mailSubject);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (prometheus) {
      res["Prometheus"] = prometheus ? boost::any(prometheus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertState") != m.end() && !m["AlertState"].empty()) {
      alertState = make_shared<string>(boost::any_cast<string>(m["AlertState"]));
    }
    if (m.find("CompositeExpression") != m.end() && !m["CompositeExpression"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompositeExpression"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompositeExpression"]));
        compositeExpression = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EnableState") != m.end() && !m["EnableState"].empty()) {
      enableState = make_shared<bool>(boost::any_cast<bool>(m["EnableState"]));
    }
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Labels"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmLabels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Labels"]));
        labels = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmLabels>(model1);
      }
    }
    if (m.find("MailSubject") != m.end() && !m["MailSubject"].empty()) {
      mailSubject = make_shared<string>(boost::any_cast<string>(m["MailSubject"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Prometheus") != m.end() && !m["Prometheus"].empty()) {
      if (typeid(map<string, boost::any>) == m["Prometheus"].type()) {
        DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Prometheus"]));
        prometheus = make_shared<DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus>(model1);
      }
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarmsAlarm() = default;
};
class DescribeMetricRuleListResponseBodyAlarms : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleListResponseBodyAlarmsAlarm>> alarm{};

  DescribeMetricRuleListResponseBodyAlarms() {}

  explicit DescribeMetricRuleListResponseBodyAlarms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarm) {
      vector<boost::any> temp1;
      for(auto item1:*alarm){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alarm"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarm") != m.end() && !m["Alarm"].empty()) {
      if (typeid(vector<boost::any>) == m["Alarm"].type()) {
        vector<DescribeMetricRuleListResponseBodyAlarmsAlarm> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alarm"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleListResponseBodyAlarmsAlarm model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alarm = make_shared<vector<DescribeMetricRuleListResponseBodyAlarmsAlarm>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponseBodyAlarms() = default;
};
class DescribeMetricRuleListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleListResponseBodyAlarms> alarms{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> total{};

  DescribeMetricRuleListResponseBody() {}

  explicit DescribeMetricRuleListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarms) {
      res["Alarms"] = alarms ? boost::any(alarms->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alarms") != m.end() && !m["Alarms"].empty()) {
      if (typeid(map<string, boost::any>) == m["Alarms"].type()) {
        DescribeMetricRuleListResponseBodyAlarms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Alarms"]));
        alarms = make_shared<DescribeMetricRuleListResponseBodyAlarms>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeMetricRuleListResponseBody() = default;
};
class DescribeMetricRuleListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleListResponseBody> body{};

  DescribeMetricRuleListResponse() {}

  explicit DescribeMetricRuleListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleListResponse() = default;
};
class DescribeMetricRuleTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};

  DescribeMetricRuleTargetsRequest() {}

  explicit DescribeMetricRuleTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DescribeMetricRuleTargetsRequest() = default;
};
class DescribeMetricRuleTargetsResponseBodyTargetsTarget : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  DescribeMetricRuleTargetsResponseBodyTargetsTarget() {}

  explicit DescribeMetricRuleTargetsResponseBodyTargetsTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DescribeMetricRuleTargetsResponseBodyTargetsTarget() = default;
};
class DescribeMetricRuleTargetsResponseBodyTargets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleTargetsResponseBodyTargetsTarget>> target{};

  DescribeMetricRuleTargetsResponseBodyTargets() {}

  explicit DescribeMetricRuleTargetsResponseBodyTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      vector<boost::any> temp1;
      for(auto item1:*target){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Target"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(vector<boost::any>) == m["Target"].type()) {
        vector<DescribeMetricRuleTargetsResponseBodyTargetsTarget> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Target"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleTargetsResponseBodyTargetsTarget model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        target = make_shared<vector<DescribeMetricRuleTargetsResponseBodyTargetsTarget>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleTargetsResponseBodyTargets() = default;
};
class DescribeMetricRuleTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeMetricRuleTargetsResponseBodyTargets> targets{};

  DescribeMetricRuleTargetsResponseBody() {}

  explicit DescribeMetricRuleTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (targets) {
      res["Targets"] = targets ? boost::any(targets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Targets"].type()) {
        DescribeMetricRuleTargetsResponseBodyTargets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Targets"]));
        targets = make_shared<DescribeMetricRuleTargetsResponseBodyTargets>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleTargetsResponseBody() = default;
};
class DescribeMetricRuleTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleTargetsResponseBody> body{};

  DescribeMetricRuleTargetsResponse() {}

  explicit DescribeMetricRuleTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleTargetsResponse() = default;
};
class DescribeMetricRuleTemplateAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> templateId{};

  DescribeMetricRuleTemplateAttributeRequest() {}

  explicit DescribeMetricRuleTemplateAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeRequest() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical> critical{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo> info{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn> warn{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels>> labels{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations> escalations{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> selector{};
  shared_ptr<string> webhook{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labels) {
      res["Labels"] = labels ? boost::any(labels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations>(model1);
      }
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Labels"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Labels"]));
        labels = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels>(model1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<string>(boost::any_cast<string>(m["Selector"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate>> alertTemplate{};

  DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTemplate) {
      vector<boost::any> temp1;
      for(auto item1:*alertTemplate){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertTemplate"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTemplate") != m.end() && !m["AlertTemplate"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertTemplate"].type()) {
        vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertTemplate"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertTemplate = make_shared<vector<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates> alertTemplates{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> restVersion{};
  shared_ptr<string> templateId{};

  DescribeMetricRuleTemplateAttributeResponseBodyResource() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTemplates) {
      res["AlertTemplates"] = alertTemplates ? boost::any(alertTemplates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (restVersion) {
      res["RestVersion"] = boost::any(*restVersion);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTemplates") != m.end() && !m["AlertTemplates"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertTemplates"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertTemplates"]));
        alertTemplates = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RestVersion") != m.end() && !m["RestVersion"].empty()) {
      restVersion = make_shared<string>(boost::any_cast<string>(m["RestVersion"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBodyResource() = default;
};
class DescribeMetricRuleTemplateAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBodyResource> resource{};
  shared_ptr<bool> success{};

  DescribeMetricRuleTemplateAttributeResponseBody() {}

  explicit DescribeMetricRuleTemplateAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeMetricRuleTemplateAttributeResponseBodyResource>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponseBody() = default;
};
class DescribeMetricRuleTemplateAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleTemplateAttributeResponseBody> body{};

  DescribeMetricRuleTemplateAttributeResponse() {}

  explicit DescribeMetricRuleTemplateAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleTemplateAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleTemplateAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateAttributeResponse() = default;
};
class DescribeMetricRuleTemplateListRequest : public Darabonba::Model {
public:
  shared_ptr<bool> history{};
  shared_ptr<string> keyword{};
  shared_ptr<string> name{};
  shared_ptr<bool> order{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<long> templateId{};

  DescribeMetricRuleTemplateListRequest() {}

  explicit DescribeMetricRuleTemplateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (history) {
      res["History"] = boost::any(*history);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("History") != m.end() && !m["History"].empty()) {
      history = make_shared<bool>(boost::any_cast<bool>(m["History"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<bool>(boost::any_cast<bool>(m["Order"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateListRequest() = default;
};
class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory : public Darabonba::Model {
public:
  shared_ptr<long> applyTime{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};

  DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory() {}

  explicit DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyTime) {
      res["ApplyTime"] = boost::any(*applyTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyTime") != m.end() && !m["ApplyTime"].empty()) {
      applyTime = make_shared<long>(boost::any_cast<long>(m["ApplyTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory() = default;
};
class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory>> applyHistory{};

  DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories() {}

  explicit DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistory) {
      vector<boost::any> temp1;
      for(auto item1:*applyHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyHistory"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistory") != m.end() && !m["ApplyHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyHistory"].type()) {
        vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyHistory = make_shared<vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories() = default;
};
class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories> applyHistories{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> restVersion{};
  shared_ptr<long> templateId{};

  DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate() {}

  explicit DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistories) {
      res["ApplyHistories"] = applyHistories ? boost::any(applyHistories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (restVersion) {
      res["RestVersion"] = boost::any(*restVersion);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistories") != m.end() && !m["ApplyHistories"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyHistories"].type()) {
        DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyHistories"]));
        applyHistories = make_shared<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RestVersion") != m.end() && !m["RestVersion"].empty()) {
      restVersion = make_shared<long>(boost::any_cast<long>(m["RestVersion"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate() = default;
};
class DescribeMetricRuleTemplateListResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate>> template_{};

  DescribeMetricRuleTemplateListResponseBodyTemplates() {}

  explicit DescribeMetricRuleTemplateListResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponseBodyTemplates() = default;
};
class DescribeMetricRuleTemplateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeMetricRuleTemplateListResponseBodyTemplates> templates{};
  shared_ptr<long> total{};

  DescribeMetricRuleTemplateListResponseBody() {}

  explicit DescribeMetricRuleTemplateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        DescribeMetricRuleTemplateListResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<DescribeMetricRuleTemplateListResponseBodyTemplates>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponseBody() = default;
};
class DescribeMetricRuleTemplateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricRuleTemplateListResponseBody> body{};

  DescribeMetricRuleTemplateListResponse() {}

  explicit DescribeMetricRuleTemplateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricRuleTemplateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricRuleTemplateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricRuleTemplateListResponse() = default;
};
class DescribeMetricTopRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> endTime{};
  shared_ptr<string> express{};
  shared_ptr<string> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> orderDesc{};
  shared_ptr<string> orderby{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};

  DescribeMetricTopRequest() {}

  explicit DescribeMetricTopRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (orderDesc) {
      res["OrderDesc"] = boost::any(*orderDesc);
    }
    if (orderby) {
      res["Orderby"] = boost::any(*orderby);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("OrderDesc") != m.end() && !m["OrderDesc"].empty()) {
      orderDesc = make_shared<string>(boost::any_cast<string>(m["OrderDesc"]));
    }
    if (m.find("Orderby") != m.end() && !m["Orderby"].empty()) {
      orderby = make_shared<string>(boost::any_cast<string>(m["Orderby"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricTopRequest() = default;
};
class DescribeMetricTopResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> period{};
  shared_ptr<string> requestId{};

  DescribeMetricTopResponseBody() {}

  explicit DescribeMetricTopResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = boost::any(*datapoints);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      datapoints = make_shared<string>(boost::any_cast<string>(m["Datapoints"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMetricTopResponseBody() = default;
};
class DescribeMetricTopResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricTopResponseBody> body{};

  DescribeMetricTopResponse() {}

  explicit DescribeMetricTopResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricTopResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricTopResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricTopResponse() = default;
};
class DescribeMonitorGroupCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupCategoriesRequest() {}

  explicit DescribeMonitorGroupCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupCategoriesRequest() = default;
};
class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> count{};

  DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem() {}

  explicit DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem() = default;
};
class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem>> categoryItem{};

  DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory() {}

  explicit DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryItem) {
      vector<boost::any> temp1;
      for(auto item1:*categoryItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CategoryItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryItem") != m.end() && !m["CategoryItem"].empty()) {
      if (typeid(vector<boost::any>) == m["CategoryItem"].type()) {
        vector<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CategoryItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categoryItem = make_shared<vector<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory() = default;
};
class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory> monitorGroupCategory{};

  DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories() {}

  explicit DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (monitorGroupCategory) {
      res["MonitorGroupCategory"] = monitorGroupCategory ? boost::any(monitorGroupCategory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("MonitorGroupCategory") != m.end() && !m["MonitorGroupCategory"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorGroupCategory"].type()) {
        DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorGroupCategory"]));
        monitorGroupCategory = make_shared<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories() = default;
};
class DescribeMonitorGroupCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories> monitorGroupCategories{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMonitorGroupCategoriesResponseBody() {}

  explicit DescribeMonitorGroupCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (monitorGroupCategories) {
      res["MonitorGroupCategories"] = monitorGroupCategories ? boost::any(monitorGroupCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MonitorGroupCategories") != m.end() && !m["MonitorGroupCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["MonitorGroupCategories"].type()) {
        DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MonitorGroupCategories"]));
        monitorGroupCategories = make_shared<DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitorGroupCategoriesResponseBody() = default;
};
class DescribeMonitorGroupCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupCategoriesResponseBody> body{};

  DescribeMonitorGroupCategoriesResponse() {}

  explicit DescribeMonitorGroupCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupCategoriesResponse() = default;
};
class DescribeMonitorGroupDynamicRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupDynamicRulesRequest() {}

  explicit DescribeMonitorGroupDynamicRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesRequest() = default;
};
class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter : public Darabonba::Model {
public:
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter() {}

  explicit DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter() = default;
};
class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter>> filter{};

  DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters() {}

  explicit DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      vector<boost::any> temp1;
      for(auto item1:*filter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(vector<boost::any>) == m["Filter"].type()) {
        vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filter = make_shared<vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters() = default;
};
class DescribeMonitorGroupDynamicRulesResponseBodyResourceResource : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> filterRelation{};
  shared_ptr<DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters> filters{};

  DescribeMonitorGroupDynamicRulesResponseBodyResourceResource() {}

  explicit DescribeMonitorGroupDynamicRulesResponseBodyResourceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (filterRelation) {
      res["FilterRelation"] = boost::any(*filterRelation);
    }
    if (filters) {
      res["Filters"] = filters ? boost::any(filters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("FilterRelation") != m.end() && !m["FilterRelation"].empty()) {
      filterRelation = make_shared<string>(boost::any_cast<string>(m["FilterRelation"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filters"].type()) {
        DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filters"]));
        filters = make_shared<DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponseBodyResourceResource() = default;
};
class DescribeMonitorGroupDynamicRulesResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResource>> resource{};

  DescribeMonitorGroupDynamicRulesResponseBodyResource() {}

  explicit DescribeMonitorGroupDynamicRulesResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupDynamicRulesResponseBodyResourceResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeMonitorGroupDynamicRulesResponseBodyResourceResource>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponseBodyResource() = default;
};
class DescribeMonitorGroupDynamicRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorGroupDynamicRulesResponseBodyResource> resource{};
  shared_ptr<bool> success{};

  DescribeMonitorGroupDynamicRulesResponseBody() {}

  explicit DescribeMonitorGroupDynamicRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeMonitorGroupDynamicRulesResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeMonitorGroupDynamicRulesResponseBodyResource>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponseBody() = default;
};
class DescribeMonitorGroupDynamicRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupDynamicRulesResponseBody> body{};

  DescribeMonitorGroupDynamicRulesResponse() {}

  explicit DescribeMonitorGroupDynamicRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupDynamicRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupDynamicRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupDynamicRulesResponse() = default;
};
class DescribeMonitorGroupInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> total{};

  DescribeMonitorGroupInstanceAttributeRequest() {}

  explicit DescribeMonitorGroupInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<bool>(boost::any_cast<bool>(m["Total"]));
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeRequest() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion : public Darabonba::Model {
public:
  shared_ptr<string> availabilityZone{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availabilityZone) {
      res["AvailabilityZone"] = boost::any(*availabilityZone);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailabilityZone") != m.end() && !m["AvailabilityZone"].empty()) {
      availabilityZone = make_shared<string>(boost::any_cast<string>(m["AvailabilityZone"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag>> tag{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc : public Darabonba::Model {
public:
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<string> vswitchInstanceId{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (vswitchInstanceId) {
      res["VswitchInstanceId"] = boost::any(*vswitchInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
    if (m.find("VswitchInstanceId") != m.end() && !m["VswitchInstanceId"].empty()) {
      vswitchInstanceId = make_shared<string>(boost::any_cast<string>(m["VswitchInstanceId"]));
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> desc{};
  shared_ptr<string> dimension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> networkType{};
  shared_ptr<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion> region{};
  shared_ptr<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags> tags{};
  shared_ptr<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc> vpc{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (region) {
      res["Region"] = region ? boost::any(region->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpc) {
      res["Vpc"] = vpc ? boost::any(vpc->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(map<string, boost::any>) == m["Region"].type()) {
        DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Region"]));
        region = make_shared<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags>(model1);
      }
    }
    if (m.find("Vpc") != m.end() && !m["Vpc"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vpc"].type()) {
        DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vpc"]));
        vpc = make_shared<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource>> resource{};

  DescribeMonitorGroupInstanceAttributeResponseBodyResources() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBodyResources() = default;
};
class DescribeMonitorGroupInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorGroupInstanceAttributeResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeMonitorGroupInstanceAttributeResponseBody() {}

  explicit DescribeMonitorGroupInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeMonitorGroupInstanceAttributeResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeMonitorGroupInstanceAttributeResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponseBody() = default;
};
class DescribeMonitorGroupInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupInstanceAttributeResponseBody> body{};

  DescribeMonitorGroupInstanceAttributeResponse() {}

  explicit DescribeMonitorGroupInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstanceAttributeResponse() = default;
};
class DescribeMonitorGroupInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupInstancesRequest() {}

  explicit DescribeMonitorGroupInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupInstancesRequest() = default;
};
class DescribeMonitorGroupInstancesResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupInstancesResponseBodyResourcesResource() {}

  explicit DescribeMonitorGroupInstancesResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupInstancesResponseBodyResourcesResource() = default;
};
class DescribeMonitorGroupInstancesResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupInstancesResponseBodyResourcesResource>> resource{};

  DescribeMonitorGroupInstancesResponseBodyResources() {}

  explicit DescribeMonitorGroupInstancesResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeMonitorGroupInstancesResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupInstancesResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeMonitorGroupInstancesResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstancesResponseBodyResources() = default;
};
class DescribeMonitorGroupInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorGroupInstancesResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeMonitorGroupInstancesResponseBody() {}

  explicit DescribeMonitorGroupInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeMonitorGroupInstancesResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeMonitorGroupInstancesResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMonitorGroupInstancesResponseBody() = default;
};
class DescribeMonitorGroupInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupInstancesResponseBody> body{};

  DescribeMonitorGroupInstancesResponse() {}

  explicit DescribeMonitorGroupInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupInstancesResponse() = default;
};
class DescribeMonitorGroupNotifyPolicyListRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyType{};
  shared_ptr<string> regionId{};

  DescribeMonitorGroupNotifyPolicyListRequest() {}

  explicit DescribeMonitorGroupNotifyPolicyListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitorGroupNotifyPolicyListRequest() = default;
};
class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy() {}

  explicit DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy() = default;
};
class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy>> notifyPolicy{};

  DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList() {}

  explicit DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*notifyPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NotifyPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotifyPolicy") != m.end() && !m["NotifyPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["NotifyPolicy"].type()) {
        vector<DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NotifyPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyPolicy = make_shared<vector<DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList() = default;
};
class DescribeMonitorGroupNotifyPolicyListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList> notifyPolicyList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  DescribeMonitorGroupNotifyPolicyListResponseBody() {}

  explicit DescribeMonitorGroupNotifyPolicyListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (notifyPolicyList) {
      res["NotifyPolicyList"] = notifyPolicyList ? boost::any(notifyPolicyList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NotifyPolicyList") != m.end() && !m["NotifyPolicyList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NotifyPolicyList"].type()) {
        DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NotifyPolicyList"]));
        notifyPolicyList = make_shared<DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMonitorGroupNotifyPolicyListResponseBody() = default;
};
class DescribeMonitorGroupNotifyPolicyListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupNotifyPolicyListResponseBody> body{};

  DescribeMonitorGroupNotifyPolicyListResponse() {}

  explicit DescribeMonitorGroupNotifyPolicyListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupNotifyPolicyListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupNotifyPolicyListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupNotifyPolicyListResponse() = default;
};
class DescribeMonitorGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMonitorGroupsRequestTag() {}

  explicit DescribeMonitorGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMonitorGroupsRequestTag() = default;
};
class DescribeMonitorGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicTagRuleId{};
  shared_ptr<string> groupFounderTagKey{};
  shared_ptr<string> groupFounderTagValue{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> includeTemplateHistory{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> selectContactGroups{};
  shared_ptr<vector<DescribeMonitorGroupsRequestTag>> tag{};
  shared_ptr<string> type{};
  shared_ptr<string> types{};

  DescribeMonitorGroupsRequest() {}

  explicit DescribeMonitorGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicTagRuleId) {
      res["DynamicTagRuleId"] = boost::any(*dynamicTagRuleId);
    }
    if (groupFounderTagKey) {
      res["GroupFounderTagKey"] = boost::any(*groupFounderTagKey);
    }
    if (groupFounderTagValue) {
      res["GroupFounderTagValue"] = boost::any(*groupFounderTagValue);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (includeTemplateHistory) {
      res["IncludeTemplateHistory"] = boost::any(*includeTemplateHistory);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (selectContactGroups) {
      res["SelectContactGroups"] = boost::any(*selectContactGroups);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicTagRuleId") != m.end() && !m["DynamicTagRuleId"].empty()) {
      dynamicTagRuleId = make_shared<string>(boost::any_cast<string>(m["DynamicTagRuleId"]));
    }
    if (m.find("GroupFounderTagKey") != m.end() && !m["GroupFounderTagKey"].empty()) {
      groupFounderTagKey = make_shared<string>(boost::any_cast<string>(m["GroupFounderTagKey"]));
    }
    if (m.find("GroupFounderTagValue") != m.end() && !m["GroupFounderTagValue"].empty()) {
      groupFounderTagValue = make_shared<string>(boost::any_cast<string>(m["GroupFounderTagValue"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IncludeTemplateHistory") != m.end() && !m["IncludeTemplateHistory"].empty()) {
      includeTemplateHistory = make_shared<bool>(boost::any_cast<bool>(m["IncludeTemplateHistory"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SelectContactGroups") != m.end() && !m["SelectContactGroups"].empty()) {
      selectContactGroups = make_shared<bool>(boost::any_cast<bool>(m["SelectContactGroups"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMonitorGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMonitorGroupsRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~DescribeMonitorGroupsRequest() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup>> contactGroup{};

  DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroup) {
      vector<boost::any> temp1;
      for(auto item1:*contactGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroup") != m.end() && !m["ContactGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactGroup"].type()) {
        vector<DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactGroup = make_shared<vector<DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResourceTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag>> tag{};

  DescribeMonitorGroupsResponseBodyResourcesResourceTags() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResourceTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResourceTags() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> templateId{};

  DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds() = default;
};
class DescribeMonitorGroupsResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> bindUrl{};
  shared_ptr<DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups> contactGroups{};
  shared_ptr<string> dynamicTagRuleId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupFounderTagKey{};
  shared_ptr<string> groupFounderTagValue{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> serviceId{};
  shared_ptr<DescribeMonitorGroupsResponseBodyResourcesResourceTags> tags{};
  shared_ptr<DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds> templateIds{};
  shared_ptr<string> type{};

  DescribeMonitorGroupsResponseBodyResourcesResource() {}

  explicit DescribeMonitorGroupsResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindUrl) {
      res["BindUrl"] = boost::any(*bindUrl);
    }
    if (contactGroups) {
      res["ContactGroups"] = contactGroups ? boost::any(contactGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dynamicTagRuleId) {
      res["DynamicTagRuleId"] = boost::any(*dynamicTagRuleId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupFounderTagKey) {
      res["GroupFounderTagKey"] = boost::any(*groupFounderTagKey);
    }
    if (groupFounderTagValue) {
      res["GroupFounderTagValue"] = boost::any(*groupFounderTagValue);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceId) {
      res["ServiceId"] = boost::any(*serviceId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateIds) {
      res["TemplateIds"] = templateIds ? boost::any(templateIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindUrl") != m.end() && !m["BindUrl"].empty()) {
      bindUrl = make_shared<string>(boost::any_cast<string>(m["BindUrl"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactGroups"].type()) {
        DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactGroups"]));
        contactGroups = make_shared<DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups>(model1);
      }
    }
    if (m.find("DynamicTagRuleId") != m.end() && !m["DynamicTagRuleId"].empty()) {
      dynamicTagRuleId = make_shared<string>(boost::any_cast<string>(m["DynamicTagRuleId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupFounderTagKey") != m.end() && !m["GroupFounderTagKey"].empty()) {
      groupFounderTagKey = make_shared<string>(boost::any_cast<string>(m["GroupFounderTagKey"]));
    }
    if (m.find("GroupFounderTagValue") != m.end() && !m["GroupFounderTagValue"].empty()) {
      groupFounderTagValue = make_shared<string>(boost::any_cast<string>(m["GroupFounderTagValue"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ServiceId") != m.end() && !m["ServiceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["ServiceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeMonitorGroupsResponseBodyResourcesResourceTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeMonitorGroupsResponseBodyResourcesResourceTags>(model1);
      }
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateIds"].type()) {
        DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateIds"]));
        templateIds = make_shared<DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResourcesResource() = default;
};
class DescribeMonitorGroupsResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitorGroupsResponseBodyResourcesResource>> resource{};

  DescribeMonitorGroupsResponseBodyResources() {}

  explicit DescribeMonitorGroupsResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeMonitorGroupsResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitorGroupsResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeMonitorGroupsResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitorGroupsResponseBodyResources() = default;
};
class DescribeMonitorGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorGroupsResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeMonitorGroupsResponseBody() {}

  explicit DescribeMonitorGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeMonitorGroupsResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeMonitorGroupsResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMonitorGroupsResponseBody() = default;
};
class DescribeMonitorGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorGroupsResponseBody> body{};

  DescribeMonitorGroupsResponse() {}

  explicit DescribeMonitorGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorGroupsResponse() = default;
};
class DescribeMonitorResourceQuotaAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<bool> showUsed{};

  DescribeMonitorResourceQuotaAttributeRequest() {}

  explicit DescribeMonitorResourceQuotaAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (showUsed) {
      res["ShowUsed"] = boost::any(*showUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShowUsed") != m.end() && !m["ShowUsed"].empty()) {
      showUsed = make_shared<bool>(boost::any_cast<bool>(m["ShowUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeRequest() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> suitInfo{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (suitInfo) {
      res["SuitInfo"] = boost::any(*suitInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SuitInfo") != m.end() && !m["SuitInfo"].empty()) {
      suitInfo = make_shared<string>(boost::any_cast<string>(m["SuitInfo"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask : public Darabonba::Model {
public:
  shared_ptr<long> quotaLimit{};
  shared_ptr<long> quotaPackage{};
  shared_ptr<long> quotaUsed{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quotaLimit) {
      res["QuotaLimit"] = boost::any(*quotaLimit);
    }
    if (quotaPackage) {
      res["QuotaPackage"] = boost::any(*quotaPackage);
    }
    if (quotaUsed) {
      res["QuotaUsed"] = boost::any(*quotaUsed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuotaLimit") != m.end() && !m["QuotaLimit"].empty()) {
      quotaLimit = make_shared<long>(boost::any_cast<long>(m["QuotaLimit"]));
    }
    if (m.find("QuotaPackage") != m.end() && !m["QuotaPackage"].empty()) {
      quotaPackage = make_shared<long>(boost::any_cast<long>(m["QuotaPackage"]));
    }
    if (m.find("QuotaUsed") != m.end() && !m["QuotaUsed"].empty()) {
      quotaUsed = make_shared<long>(boost::any_cast<long>(m["QuotaUsed"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota : public Darabonba::Model {
public:
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi> api{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor> customMonitor{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota> enterpriseQuota{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor> eventMonitor{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor> logMonitor{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone> phone{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS> SMS{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser> siteMonitorBrowser{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe> siteMonitorEcsProbe{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile> siteMonitorMobile{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe> siteMonitorOperatorProbe{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask> siteMonitorTask{};
  shared_ptr<string> suitInfo{};

  DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      res["Api"] = api ? boost::any(api->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customMonitor) {
      res["CustomMonitor"] = customMonitor ? boost::any(customMonitor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enterpriseQuota) {
      res["EnterpriseQuota"] = enterpriseQuota ? boost::any(enterpriseQuota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventMonitor) {
      res["EventMonitor"] = eventMonitor ? boost::any(eventMonitor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logMonitor) {
      res["LogMonitor"] = logMonitor ? boost::any(logMonitor->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phone) {
      res["Phone"] = phone ? boost::any(phone->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (SMS) {
      res["SMS"] = SMS ? boost::any(SMS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteMonitorBrowser) {
      res["SiteMonitorBrowser"] = siteMonitorBrowser ? boost::any(siteMonitorBrowser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteMonitorEcsProbe) {
      res["SiteMonitorEcsProbe"] = siteMonitorEcsProbe ? boost::any(siteMonitorEcsProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteMonitorMobile) {
      res["SiteMonitorMobile"] = siteMonitorMobile ? boost::any(siteMonitorMobile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteMonitorOperatorProbe) {
      res["SiteMonitorOperatorProbe"] = siteMonitorOperatorProbe ? boost::any(siteMonitorOperatorProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (siteMonitorTask) {
      res["SiteMonitorTask"] = siteMonitorTask ? boost::any(siteMonitorTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suitInfo) {
      res["SuitInfo"] = boost::any(*suitInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(map<string, boost::any>) == m["Api"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Api"]));
        api = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi>(model1);
      }
    }
    if (m.find("CustomMonitor") != m.end() && !m["CustomMonitor"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomMonitor"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomMonitor"]));
        customMonitor = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor>(model1);
      }
    }
    if (m.find("EnterpriseQuota") != m.end() && !m["EnterpriseQuota"].empty()) {
      if (typeid(map<string, boost::any>) == m["EnterpriseQuota"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EnterpriseQuota"]));
        enterpriseQuota = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota>(model1);
      }
    }
    if (m.find("EventMonitor") != m.end() && !m["EventMonitor"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventMonitor"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventMonitor"]));
        eventMonitor = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor>(model1);
      }
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogMonitor") != m.end() && !m["LogMonitor"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogMonitor"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogMonitor"]));
        logMonitor = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor>(model1);
      }
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      if (typeid(map<string, boost::any>) == m["Phone"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Phone"]));
        phone = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone>(model1);
      }
    }
    if (m.find("SMS") != m.end() && !m["SMS"].empty()) {
      if (typeid(map<string, boost::any>) == m["SMS"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SMS"]));
        SMS = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS>(model1);
      }
    }
    if (m.find("SiteMonitorBrowser") != m.end() && !m["SiteMonitorBrowser"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitorBrowser"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitorBrowser"]));
        siteMonitorBrowser = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser>(model1);
      }
    }
    if (m.find("SiteMonitorEcsProbe") != m.end() && !m["SiteMonitorEcsProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitorEcsProbe"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitorEcsProbe"]));
        siteMonitorEcsProbe = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe>(model1);
      }
    }
    if (m.find("SiteMonitorMobile") != m.end() && !m["SiteMonitorMobile"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitorMobile"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitorMobile"]));
        siteMonitorMobile = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile>(model1);
      }
    }
    if (m.find("SiteMonitorOperatorProbe") != m.end() && !m["SiteMonitorOperatorProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitorOperatorProbe"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitorOperatorProbe"]));
        siteMonitorOperatorProbe = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe>(model1);
      }
    }
    if (m.find("SiteMonitorTask") != m.end() && !m["SiteMonitorTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitorTask"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitorTask"]));
        siteMonitorTask = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask>(model1);
      }
    }
    if (m.find("SuitInfo") != m.end() && !m["SuitInfo"].empty()) {
      suitInfo = make_shared<string>(boost::any_cast<string>(m["SuitInfo"]));
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota() = default;
};
class DescribeMonitorResourceQuotaAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota> resourceQuota{};

  DescribeMonitorResourceQuotaAttributeResponseBody() {}

  explicit DescribeMonitorResourceQuotaAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceQuota) {
      res["ResourceQuota"] = resourceQuota ? boost::any(resourceQuota->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceQuota") != m.end() && !m["ResourceQuota"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceQuota"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceQuota"]));
        resourceQuota = make_shared<DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota>(model1);
      }
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponseBody() = default;
};
class DescribeMonitorResourceQuotaAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitorResourceQuotaAttributeResponseBody> body{};

  DescribeMonitorResourceQuotaAttributeResponse() {}

  explicit DescribeMonitorResourceQuotaAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitorResourceQuotaAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitorResourceQuotaAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitorResourceQuotaAttributeResponse() = default;
};
class DescribeMonitoringAgentAccessKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeMonitoringAgentAccessKeyRequest() {}

  explicit DescribeMonitoringAgentAccessKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitoringAgentAccessKeyRequest() = default;
};
class DescribeMonitoringAgentAccessKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> secretKey{};
  shared_ptr<bool> success{};

  DescribeMonitoringAgentAccessKeyResponseBody() {}

  explicit DescribeMonitoringAgentAccessKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitoringAgentAccessKeyResponseBody() = default;
};
class DescribeMonitoringAgentAccessKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringAgentAccessKeyResponseBody> body{};

  DescribeMonitoringAgentAccessKeyResponse() {}

  explicit DescribeMonitoringAgentAccessKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringAgentAccessKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringAgentAccessKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentAccessKeyResponse() = default;
};
class DescribeMonitoringAgentConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeMonitoringAgentConfigRequest() {}

  explicit DescribeMonitoringAgentConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitoringAgentConfigRequest() = default;
};
class DescribeMonitoringAgentConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoInstall{};
  shared_ptr<string> code{};
  shared_ptr<string> enableActiveAlert{};
  shared_ptr<bool> enableInstallAgentNewECS{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMonitoringAgentConfigResponseBody() {}

  explicit DescribeMonitoringAgentConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (enableActiveAlert) {
      res["EnableActiveAlert"] = boost::any(*enableActiveAlert);
    }
    if (enableInstallAgentNewECS) {
      res["EnableInstallAgentNewECS"] = boost::any(*enableInstallAgentNewECS);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<bool>(boost::any_cast<bool>(m["AutoInstall"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EnableActiveAlert") != m.end() && !m["EnableActiveAlert"].empty()) {
      enableActiveAlert = make_shared<string>(boost::any_cast<string>(m["EnableActiveAlert"]));
    }
    if (m.find("EnableInstallAgentNewECS") != m.end() && !m["EnableInstallAgentNewECS"].empty()) {
      enableInstallAgentNewECS = make_shared<bool>(boost::any_cast<bool>(m["EnableInstallAgentNewECS"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitoringAgentConfigResponseBody() = default;
};
class DescribeMonitoringAgentConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringAgentConfigResponseBody> body{};

  DescribeMonitoringAgentConfigResponse() {}

  explicit DescribeMonitoringAgentConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringAgentConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringAgentConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentConfigResponse() = default;
};
class DescribeMonitoringAgentHostsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> aliyunHost{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> instanceRegionId{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumbers{};
  shared_ptr<string> status{};
  shared_ptr<string> sysomStatus{};

  DescribeMonitoringAgentHostsRequest() {}

  explicit DescribeMonitoringAgentHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunHost) {
      res["AliyunHost"] = boost::any(*aliyunHost);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceRegionId) {
      res["InstanceRegionId"] = boost::any(*instanceRegionId);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumbers) {
      res["SerialNumbers"] = boost::any(*serialNumbers);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (sysomStatus) {
      res["SysomStatus"] = boost::any(*sysomStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunHost") != m.end() && !m["AliyunHost"].empty()) {
      aliyunHost = make_shared<bool>(boost::any_cast<bool>(m["AliyunHost"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("InstanceRegionId") != m.end() && !m["InstanceRegionId"].empty()) {
      instanceRegionId = make_shared<string>(boost::any_cast<string>(m["InstanceRegionId"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumbers") != m.end() && !m["SerialNumbers"].empty()) {
      serialNumbers = make_shared<string>(boost::any_cast<string>(m["SerialNumbers"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SysomStatus") != m.end() && !m["SysomStatus"].empty()) {
      sysomStatus = make_shared<string>(boost::any_cast<string>(m["SysomStatus"]));
    }
  }


  virtual ~DescribeMonitoringAgentHostsRequest() = default;
};
class DescribeMonitoringAgentHostsResponseBodyHostsHost : public Darabonba::Model {
public:
  shared_ptr<string> agentVersion{};
  shared_ptr<long> aliUid{};
  shared_ptr<string> eipAddress{};
  shared_ptr<string> eipId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceTypeFamily{};
  shared_ptr<string> ipGroup{};
  shared_ptr<string> natIp{};
  shared_ptr<string> networkType{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> region{};
  shared_ptr<string> serialNumber{};
  shared_ptr<bool> isAliyunHost{};

  DescribeMonitoringAgentHostsResponseBodyHostsHost() {}

  explicit DescribeMonitoringAgentHostsResponseBodyHostsHost(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentVersion) {
      res["AgentVersion"] = boost::any(*agentVersion);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (eipAddress) {
      res["EipAddress"] = boost::any(*eipAddress);
    }
    if (eipId) {
      res["EipId"] = boost::any(*eipId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceTypeFamily) {
      res["InstanceTypeFamily"] = boost::any(*instanceTypeFamily);
    }
    if (ipGroup) {
      res["IpGroup"] = boost::any(*ipGroup);
    }
    if (natIp) {
      res["NatIp"] = boost::any(*natIp);
    }
    if (networkType) {
      res["NetworkType"] = boost::any(*networkType);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (isAliyunHost) {
      res["isAliyunHost"] = boost::any(*isAliyunHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentVersion") != m.end() && !m["AgentVersion"].empty()) {
      agentVersion = make_shared<string>(boost::any_cast<string>(m["AgentVersion"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("EipAddress") != m.end() && !m["EipAddress"].empty()) {
      eipAddress = make_shared<string>(boost::any_cast<string>(m["EipAddress"]));
    }
    if (m.find("EipId") != m.end() && !m["EipId"].empty()) {
      eipId = make_shared<string>(boost::any_cast<string>(m["EipId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceTypeFamily") != m.end() && !m["InstanceTypeFamily"].empty()) {
      instanceTypeFamily = make_shared<string>(boost::any_cast<string>(m["InstanceTypeFamily"]));
    }
    if (m.find("IpGroup") != m.end() && !m["IpGroup"].empty()) {
      ipGroup = make_shared<string>(boost::any_cast<string>(m["IpGroup"]));
    }
    if (m.find("NatIp") != m.end() && !m["NatIp"].empty()) {
      natIp = make_shared<string>(boost::any_cast<string>(m["NatIp"]));
    }
    if (m.find("NetworkType") != m.end() && !m["NetworkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["NetworkType"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("isAliyunHost") != m.end() && !m["isAliyunHost"].empty()) {
      isAliyunHost = make_shared<bool>(boost::any_cast<bool>(m["isAliyunHost"]));
    }
  }


  virtual ~DescribeMonitoringAgentHostsResponseBodyHostsHost() = default;
};
class DescribeMonitoringAgentHostsResponseBodyHosts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitoringAgentHostsResponseBodyHostsHost>> host{};

  DescribeMonitoringAgentHostsResponseBodyHosts() {}

  explicit DescribeMonitoringAgentHostsResponseBodyHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      vector<boost::any> temp1;
      for(auto item1:*host){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Host"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      if (typeid(vector<boost::any>) == m["Host"].type()) {
        vector<DescribeMonitoringAgentHostsResponseBodyHostsHost> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Host"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitoringAgentHostsResponseBodyHostsHost model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        host = make_shared<vector<DescribeMonitoringAgentHostsResponseBodyHostsHost>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentHostsResponseBodyHosts() = default;
};
class DescribeMonitoringAgentHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeMonitoringAgentHostsResponseBodyHosts> hosts{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageTotal{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  DescribeMonitoringAgentHostsResponseBody() {}

  explicit DescribeMonitoringAgentHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (hosts) {
      res["Hosts"] = hosts ? boost::any(hosts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageTotal) {
      res["PageTotal"] = boost::any(*pageTotal);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Hosts") != m.end() && !m["Hosts"].empty()) {
      if (typeid(map<string, boost::any>) == m["Hosts"].type()) {
        DescribeMonitoringAgentHostsResponseBodyHosts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Hosts"]));
        hosts = make_shared<DescribeMonitoringAgentHostsResponseBodyHosts>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageTotal") != m.end() && !m["PageTotal"].empty()) {
      pageTotal = make_shared<long>(boost::any_cast<long>(m["PageTotal"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMonitoringAgentHostsResponseBody() = default;
};
class DescribeMonitoringAgentHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringAgentHostsResponseBody> body{};

  DescribeMonitoringAgentHostsResponse() {}

  explicit DescribeMonitoringAgentHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringAgentHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringAgentHostsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentHostsResponse() = default;
};
class DescribeMonitoringAgentProcessesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeMonitoringAgentProcessesRequest() {}

  explicit DescribeMonitoringAgentProcessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitoringAgentProcessesRequest() = default;
};
class DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> processId{};
  shared_ptr<string> processName{};
  shared_ptr<string> processUser{};

  DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess() {}

  explicit DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (processUser) {
      res["ProcessUser"] = boost::any(*processUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("ProcessUser") != m.end() && !m["ProcessUser"].empty()) {
      processUser = make_shared<string>(boost::any_cast<string>(m["ProcessUser"]));
    }
  }


  virtual ~DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess() = default;
};
class DescribeMonitoringAgentProcessesResponseBodyNodeProcesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess>> nodeProcess{};

  DescribeMonitoringAgentProcessesResponseBodyNodeProcesses() {}

  explicit DescribeMonitoringAgentProcessesResponseBodyNodeProcesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeProcess) {
      vector<boost::any> temp1;
      for(auto item1:*nodeProcess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeProcess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeProcess") != m.end() && !m["NodeProcess"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeProcess"].type()) {
        vector<DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeProcess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeProcess = make_shared<vector<DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentProcessesResponseBodyNodeProcesses() = default;
};
class DescribeMonitoringAgentProcessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeMonitoringAgentProcessesResponseBodyNodeProcesses> nodeProcesses{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMonitoringAgentProcessesResponseBody() {}

  explicit DescribeMonitoringAgentProcessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeProcesses) {
      res["NodeProcesses"] = nodeProcesses ? boost::any(nodeProcesses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeProcesses") != m.end() && !m["NodeProcesses"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeProcesses"].type()) {
        DescribeMonitoringAgentProcessesResponseBodyNodeProcesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeProcesses"]));
        nodeProcesses = make_shared<DescribeMonitoringAgentProcessesResponseBodyNodeProcesses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitoringAgentProcessesResponseBody() = default;
};
class DescribeMonitoringAgentProcessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringAgentProcessesResponseBody> body{};

  DescribeMonitoringAgentProcessesResponse() {}

  explicit DescribeMonitoringAgentProcessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringAgentProcessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringAgentProcessesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentProcessesResponse() = default;
};
class DescribeMonitoringAgentStatusesRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostAvailabilityTaskId{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> regionId{};

  DescribeMonitoringAgentStatusesRequest() {}

  explicit DescribeMonitoringAgentStatusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostAvailabilityTaskId) {
      res["HostAvailabilityTaskId"] = boost::any(*hostAvailabilityTaskId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostAvailabilityTaskId") != m.end() && !m["HostAvailabilityTaskId"].empty()) {
      hostAvailabilityTaskId = make_shared<string>(boost::any_cast<string>(m["HostAvailabilityTaskId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitoringAgentStatusesRequest() = default;
};
class DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus : public Darabonba::Model {
public:
  shared_ptr<string> agentInstallErrorCode{};
  shared_ptr<bool> autoInstall{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> osMonitorConfig{};
  shared_ptr<string> osMonitorErrorCode{};
  shared_ptr<string> osMonitorErrorDetail{};
  shared_ptr<string> osMonitorStatus{};
  shared_ptr<string> osMonitorVersion{};
  shared_ptr<string> status{};

  DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus() {}

  explicit DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentInstallErrorCode) {
      res["AgentInstallErrorCode"] = boost::any(*agentInstallErrorCode);
    }
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (osMonitorConfig) {
      res["OsMonitorConfig"] = boost::any(*osMonitorConfig);
    }
    if (osMonitorErrorCode) {
      res["OsMonitorErrorCode"] = boost::any(*osMonitorErrorCode);
    }
    if (osMonitorErrorDetail) {
      res["OsMonitorErrorDetail"] = boost::any(*osMonitorErrorDetail);
    }
    if (osMonitorStatus) {
      res["OsMonitorStatus"] = boost::any(*osMonitorStatus);
    }
    if (osMonitorVersion) {
      res["OsMonitorVersion"] = boost::any(*osMonitorVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentInstallErrorCode") != m.end() && !m["AgentInstallErrorCode"].empty()) {
      agentInstallErrorCode = make_shared<string>(boost::any_cast<string>(m["AgentInstallErrorCode"]));
    }
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<bool>(boost::any_cast<bool>(m["AutoInstall"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OsMonitorConfig") != m.end() && !m["OsMonitorConfig"].empty()) {
      osMonitorConfig = make_shared<string>(boost::any_cast<string>(m["OsMonitorConfig"]));
    }
    if (m.find("OsMonitorErrorCode") != m.end() && !m["OsMonitorErrorCode"].empty()) {
      osMonitorErrorCode = make_shared<string>(boost::any_cast<string>(m["OsMonitorErrorCode"]));
    }
    if (m.find("OsMonitorErrorDetail") != m.end() && !m["OsMonitorErrorDetail"].empty()) {
      osMonitorErrorDetail = make_shared<string>(boost::any_cast<string>(m["OsMonitorErrorDetail"]));
    }
    if (m.find("OsMonitorStatus") != m.end() && !m["OsMonitorStatus"].empty()) {
      osMonitorStatus = make_shared<string>(boost::any_cast<string>(m["OsMonitorStatus"]));
    }
    if (m.find("OsMonitorVersion") != m.end() && !m["OsMonitorVersion"].empty()) {
      osMonitorVersion = make_shared<string>(boost::any_cast<string>(m["OsMonitorVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus() = default;
};
class DescribeMonitoringAgentStatusesResponseBodyNodeStatusList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus>> nodeStatus{};

  DescribeMonitoringAgentStatusesResponseBodyNodeStatusList() {}

  explicit DescribeMonitoringAgentStatusesResponseBodyNodeStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeStatus) {
      vector<boost::any> temp1;
      for(auto item1:*nodeStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeStatus"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeStatus"].type()) {
        vector<DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeStatus = make_shared<vector<DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus>>(expect1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentStatusesResponseBodyNodeStatusList() = default;
};
class DescribeMonitoringAgentStatusesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeMonitoringAgentStatusesResponseBodyNodeStatusList> nodeStatusList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMonitoringAgentStatusesResponseBody() {}

  explicit DescribeMonitoringAgentStatusesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeStatusList) {
      res["NodeStatusList"] = nodeStatusList ? boost::any(nodeStatusList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeStatusList") != m.end() && !m["NodeStatusList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeStatusList"].type()) {
        DescribeMonitoringAgentStatusesResponseBodyNodeStatusList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeStatusList"]));
        nodeStatusList = make_shared<DescribeMonitoringAgentStatusesResponseBodyNodeStatusList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitoringAgentStatusesResponseBody() = default;
};
class DescribeMonitoringAgentStatusesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringAgentStatusesResponseBody> body{};

  DescribeMonitoringAgentStatusesResponse() {}

  explicit DescribeMonitoringAgentStatusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringAgentStatusesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringAgentStatusesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringAgentStatusesResponse() = default;
};
class DescribeMonitoringConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeMonitoringConfigRequest() {}

  explicit DescribeMonitoringConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeMonitoringConfigRequest() = default;
};
class DescribeMonitoringConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoInstall{};
  shared_ptr<string> code{};
  shared_ptr<bool> enableInstallAgentNewECS{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeMonitoringConfigResponseBody() {}

  explicit DescribeMonitoringConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (enableInstallAgentNewECS) {
      res["EnableInstallAgentNewECS"] = boost::any(*enableInstallAgentNewECS);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<bool>(boost::any_cast<bool>(m["AutoInstall"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EnableInstallAgentNewECS") != m.end() && !m["EnableInstallAgentNewECS"].empty()) {
      enableInstallAgentNewECS = make_shared<bool>(boost::any_cast<bool>(m["EnableInstallAgentNewECS"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeMonitoringConfigResponseBody() = default;
};
class DescribeMonitoringConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMonitoringConfigResponseBody> body{};

  DescribeMonitoringConfigResponse() {}

  explicit DescribeMonitoringConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMonitoringConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMonitoringConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMonitoringConfigResponse() = default;
};
class DescribeProductResourceTagKeyListRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  DescribeProductResourceTagKeyListRequest() {}

  explicit DescribeProductResourceTagKeyListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeProductResourceTagKeyListRequest() = default;
};
class DescribeProductResourceTagKeyListResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tagKey{};

  DescribeProductResourceTagKeyListResponseBodyTagKeys() {}

  explicit DescribeProductResourceTagKeyListResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProductResourceTagKeyListResponseBodyTagKeys() = default;
};
class DescribeProductResourceTagKeyListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeProductResourceTagKeyListResponseBodyTagKeys> tagKeys{};

  DescribeProductResourceTagKeyListResponseBody() {}

  explicit DescribeProductResourceTagKeyListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagKeys) {
      res["TagKeys"] = tagKeys ? boost::any(tagKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagKeys"].type()) {
        DescribeProductResourceTagKeyListResponseBodyTagKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagKeys"]));
        tagKeys = make_shared<DescribeProductResourceTagKeyListResponseBodyTagKeys>(model1);
      }
    }
  }


  virtual ~DescribeProductResourceTagKeyListResponseBody() = default;
};
class DescribeProductResourceTagKeyListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProductResourceTagKeyListResponseBody> body{};

  DescribeProductResourceTagKeyListResponse() {}

  explicit DescribeProductResourceTagKeyListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProductResourceTagKeyListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProductResourceTagKeyListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProductResourceTagKeyListResponse() = default;
};
class DescribeProductsOfActiveMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeProductsOfActiveMetricRuleRequest() {}

  explicit DescribeProductsOfActiveMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleRequest() = default;
};
class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> evaluationCount{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig() {}

  explicit DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<string>(boost::any_cast<string>(m["EvaluationCount"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig() = default;
};
class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig>> alertInitConfig{};

  DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList() {}

  explicit DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertInitConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertInitConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertInitConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertInitConfig") != m.end() && !m["AlertInitConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertInitConfig"].type()) {
        vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertInitConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertInitConfig = make_shared<vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList() = default;
};
class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule : public Darabonba::Model {
public:
  shared_ptr<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList> alertInitConfigList{};
  shared_ptr<string> product{};

  DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule() {}

  explicit DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertInitConfigList) {
      res["AlertInitConfigList"] = alertInitConfigList ? boost::any(alertInitConfigList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertInitConfigList") != m.end() && !m["AlertInitConfigList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertInitConfigList"].type()) {
        DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertInitConfigList"]));
        alertInitConfigList = make_shared<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList>(model1);
      }
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule() = default;
};
class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule>> allProductInitMetricRule{};

  DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList() {}

  explicit DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allProductInitMetricRule) {
      vector<boost::any> temp1;
      for(auto item1:*allProductInitMetricRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllProductInitMetricRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllProductInitMetricRule") != m.end() && !m["AllProductInitMetricRule"].empty()) {
      if (typeid(vector<boost::any>) == m["AllProductInitMetricRule"].type()) {
        vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllProductInitMetricRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allProductInitMetricRule = make_shared<vector<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule>>(expect1);
      }
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList() = default;
};
class DescribeProductsOfActiveMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList> allProductInitMetricRuleList{};
  shared_ptr<long> code{};
  shared_ptr<string> datapoints{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeProductsOfActiveMetricRuleResponseBody() {}

  explicit DescribeProductsOfActiveMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allProductInitMetricRuleList) {
      res["AllProductInitMetricRuleList"] = allProductInitMetricRuleList ? boost::any(allProductInitMetricRuleList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datapoints) {
      res["Datapoints"] = boost::any(*datapoints);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllProductInitMetricRuleList") != m.end() && !m["AllProductInitMetricRuleList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllProductInitMetricRuleList"].type()) {
        DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllProductInitMetricRuleList"]));
        allProductInitMetricRuleList = make_shared<DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Datapoints") != m.end() && !m["Datapoints"].empty()) {
      datapoints = make_shared<string>(boost::any_cast<string>(m["Datapoints"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponseBody() = default;
};
class DescribeProductsOfActiveMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProductsOfActiveMetricRuleResponseBody> body{};

  DescribeProductsOfActiveMetricRuleResponse() {}

  explicit DescribeProductsOfActiveMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProductsOfActiveMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProductsOfActiveMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProductsOfActiveMetricRuleResponse() = default;
};
class DescribeProjectMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> labels{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeProjectMetaRequest() {}

  explicit DescribeProjectMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeProjectMetaRequest() = default;
};
class DescribeProjectMetaResponseBodyResourcesResource : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> labels{};
  shared_ptr<string> namespace_{};

  DescribeProjectMetaResponseBodyResourcesResource() {}

  explicit DescribeProjectMetaResponseBodyResourcesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DescribeProjectMetaResponseBodyResourcesResource() = default;
};
class DescribeProjectMetaResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProjectMetaResponseBodyResourcesResource>> resource{};

  DescribeProjectMetaResponseBodyResources() {}

  explicit DescribeProjectMetaResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeProjectMetaResponseBodyResourcesResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectMetaResponseBodyResourcesResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeProjectMetaResponseBodyResourcesResource>>(expect1);
      }
    }
  }


  virtual ~DescribeProjectMetaResponseBodyResources() = default;
};
class DescribeProjectMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeProjectMetaResponseBodyResources> resources{};
  shared_ptr<bool> success{};
  shared_ptr<string> total{};

  DescribeProjectMetaResponseBody() {}

  explicit DescribeProjectMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = resources ? boost::any(resources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resources"].type()) {
        DescribeProjectMetaResponseBodyResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resources"]));
        resources = make_shared<DescribeProjectMetaResponseBodyResources>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~DescribeProjectMetaResponseBody() = default;
};
class DescribeProjectMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectMetaResponseBody> body{};

  DescribeProjectMetaResponse() {}

  explicit DescribeProjectMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectMetaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectMetaResponse() = default;
};
class DescribeSiteMonitorAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeAlert{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeSiteMonitorAttributeRequest() {}

  explicit DescribeSiteMonitorAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeAlert) {
      res["IncludeAlert"] = boost::any(*includeAlert);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeAlert") != m.end() && !m["IncludeAlert"].empty()) {
      includeAlert = make_shared<bool>(boost::any_cast<bool>(m["IncludeAlert"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeRequest() = default;
};
class DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule : public Darabonba::Model {
public:
  shared_ptr<string> actionEnable{};
  shared_ptr<string> alarmActions{};
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> evaluationCount{};
  shared_ptr<string> expression{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> okActions{};
  shared_ptr<string> period{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> stateValue{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule() {}

  explicit DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionEnable) {
      res["ActionEnable"] = boost::any(*actionEnable);
    }
    if (alarmActions) {
      res["AlarmActions"] = boost::any(*alarmActions);
    }
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (okActions) {
      res["OkActions"] = boost::any(*okActions);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (stateValue) {
      res["StateValue"] = boost::any(*stateValue);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionEnable") != m.end() && !m["ActionEnable"].empty()) {
      actionEnable = make_shared<string>(boost::any_cast<string>(m["ActionEnable"]));
    }
    if (m.find("AlarmActions") != m.end() && !m["AlarmActions"].empty()) {
      alarmActions = make_shared<string>(boost::any_cast<string>(m["AlarmActions"]));
    }
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<string>(boost::any_cast<string>(m["EvaluationCount"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("OkActions") != m.end() && !m["OkActions"].empty()) {
      okActions = make_shared<string>(boost::any_cast<string>(m["OkActions"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StateValue") != m.end() && !m["StateValue"].empty()) {
      stateValue = make_shared<string>(boost::any_cast<string>(m["StateValue"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule() = default;
};
class DescribeSiteMonitorAttributeResponseBodyMetricRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule>> metricRule{};

  DescribeSiteMonitorAttributeResponseBodyMetricRules() {}

  explicit DescribeSiteMonitorAttributeResponseBodyMetricRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricRule) {
      vector<boost::any> temp1;
      for(auto item1:*metricRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetricRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricRule") != m.end() && !m["MetricRule"].empty()) {
      if (typeid(vector<boost::any>) == m["MetricRule"].type()) {
        vector<DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetricRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricRule = make_shared<vector<DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodyMetricRules() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays : public Darabonba::Model {
public:
  shared_ptr<vector<long>> days{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["days"] = boost::any(*days);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("days") != m.end() && !m["days"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      days = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule : public Darabonba::Model {
public:
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays> days{};
  shared_ptr<long> endHour{};
  shared_ptr<long> startHour{};
  shared_ptr<string> timeZone{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["days"] = days ? boost::any(days->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endHour) {
      res["end_hour"] = boost::any(*endHour);
    }
    if (startHour) {
      res["start_hour"] = boost::any(*startHour);
    }
    if (timeZone) {
      res["time_zone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("days") != m.end() && !m["days"].empty()) {
      if (typeid(map<string, boost::any>) == m["days"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["days"]));
        days = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays>(model1);
      }
    }
    if (m.find("end_hour") != m.end() && !m["end_hour"].empty()) {
      endHour = make_shared<long>(boost::any_cast<long>(m["end_hour"]));
    }
    if (m.find("start_hour") != m.end() && !m["start_hour"].empty()) {
      startHour = make_shared<long>(boost::any_cast<long>(m["start_hour"]));
    }
    if (m.find("time_zone") != m.end() && !m["time_zone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["time_zone"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> cityName{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispName{};
  shared_ptr<string> type{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity>> ispCity{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCity) {
      vector<boost::any> temp1;
      for(auto item1:*ispCity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCity") != m.end() && !m["IspCity"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCity"].type()) {
        vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCity = make_shared<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> property{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (property) {
      res["property"] = boost::any(*property);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("property") != m.end() && !m["property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["property"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions>> assertions{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertions) {
      vector<boost::any> temp1;
      for(auto item1:*assertions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["assertions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assertions") != m.end() && !m["assertions"].empty()) {
      if (typeid(vector<boost::any>) == m["assertions"].type()) {
        vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["assertions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assertions = make_shared<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> blockedUrlList{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockedUrlList) {
      res["blocked_url_list"] = boost::any(*blockedUrlList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("blocked_url_list") != m.end() && !m["blocked_url_list"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["blocked_url_list"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["blocked_url_list"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      blockedUrlList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> browserHeaders{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (browserHeaders) {
      res["browser_headers"] = boost::any(*browserHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("browser_headers") != m.end() && !m["browser_headers"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["browser_headers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["browser_headers"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      browserHeaders = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts : public Darabonba::Model {
public:
  shared_ptr<vector<string>> browserHosts{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (browserHosts) {
      res["browser_hosts"] = boost::any(*browserHosts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("browser_hosts") != m.end() && !m["browser_hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["browser_hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["browser_hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      browserHosts = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo : public Darabonba::Model {
public:
  shared_ptr<string> browser{};
  shared_ptr<string> device{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (browser) {
      res["browser"] = boost::any(*browser);
    }
    if (device) {
      res["device"] = boost::any(*device);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("browser") != m.end() && !m["browser"].empty()) {
      browser = make_shared<string>(boost::any_cast<string>(m["browser"]));
    }
    if (m.find("device") != m.end() && !m["device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["device"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo>> browserInfo{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (browserInfo) {
      vector<boost::any> temp1;
      for(auto item1:*browserInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["browser_info"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("browser_info") != m.end() && !m["browser_info"].empty()) {
      if (typeid(vector<boost::any>) == m["browser_info"].type()) {
        vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["browser_info"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        browserInfo = make_shared<vector<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString : public Darabonba::Model {
public:
  shared_ptr<vector<string>> expectExistString{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectExistString) {
      res["expect_exist_string"] = boost::any(*expectExistString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    vector<string> toVec1;
    if (typeid(vector<boost::any>) == m["expect_exist_string"].type()) {
      vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["expect_exist_string"]);
      for (auto item:vec1) {
         toVec1.push_back(boost::any_cast<string>(item));
      }
    }
    expect_exist_string = make_shared<vector<string>>(toVec1);
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString : public Darabonba::Model {
public:
  shared_ptr<vector<string>> expectNonExistString{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectNonExistString) {
      res["expect_non_exist_string"] = boost::any(*expectNonExistString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    vector<string> toVec1;
    if (typeid(vector<boost::any>) == m["expect_non_exist_string"].type()) {
      vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["expect_non_exist_string"]);
      for (auto item:vec1) {
         toVec1.push_back(boost::any_cast<string>(item));
      }
    }
    expect_non_exist_string = make_shared<vector<string>>(toVec1);
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget : public Darabonba::Model {
public:
  shared_ptr<vector<string>> quicTarget{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quicTarget) {
      res["quic_target"] = boost::any(*quicTarget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("quic_target") != m.end() && !m["quic_target"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["quic_target"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["quic_target"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      quicTarget = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> trafficHijackElementBlacklist{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficHijackElementBlacklist) {
      res["traffic_hijack_element_blacklist"] = boost::any(*trafficHijackElementBlacklist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("traffic_hijack_element_blacklist") != m.end() && !m["traffic_hijack_element_blacklist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["traffic_hijack_element_blacklist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["traffic_hijack_element_blacklist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficHijackElementBlacklist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist : public Darabonba::Model {
public:
  shared_ptr<vector<string>> trafficHijackElementWhitelist{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficHijackElementWhitelist) {
      res["traffic_hijack_element_whitelist"] = boost::any(*trafficHijackElementWhitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("traffic_hijack_element_whitelist") != m.end() && !m["traffic_hijack_element_whitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["traffic_hijack_element_whitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["traffic_hijack_element_whitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      trafficHijackElementWhitelist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson : public Darabonba::Model {
public:
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions> assertions{};
  shared_ptr<long> attempts{};
  shared_ptr<long> authentication{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList> blockedUrlList{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders> browserHeaders{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts> browserHosts{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo> browserInfo{};
  shared_ptr<bool> browserInsecure{};
  shared_ptr<string> browserTaskVersion{};
  shared_ptr<string> cookie{};
  shared_ptr<bool> diagnosisMtr{};
  shared_ptr<bool> diagnosisPing{};
  shared_ptr<string> dnsHijackWhitelist{};
  shared_ptr<string> dnsMatchRule{};
  shared_ptr<string> dnsServer{};
  shared_ptr<string> dnsType{};
  shared_ptr<bool> emptyMessage{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString> expectExistString{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString> expectNonExistString{};
  shared_ptr<string> expectValue{};
  shared_ptr<double> failureRate{};
  shared_ptr<string> header{};
  shared_ptr<string> hostBinding{};
  shared_ptr<long> hostBindingType{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> ipNetwork{};
  shared_ptr<string> isBase64Encode{};
  shared_ptr<long> matchRule{};
  shared_ptr<string> minTlsVersion{};
  shared_ptr<string> password{};
  shared_ptr<long> pingNum{};
  shared_ptr<long> pingPort{};
  shared_ptr<string> pingType{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> quicEnabled{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget> quicTarget{};
  shared_ptr<string> requestContent{};
  shared_ptr<string> requestFormat{};
  shared_ptr<string> responseContent{};
  shared_ptr<string> responseFormat{};
  shared_ptr<long> retryDelay{};
  shared_ptr<bool> screenShot{};
  shared_ptr<bool> scrollEnd{};
  shared_ptr<bool> strictMode{};
  shared_ptr<long> timeOut{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist> trafficHijackElementBlacklist{};
  shared_ptr<long> trafficHijackElementCount{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist> trafficHijackElementWhitelist{};
  shared_ptr<string> username{};
  shared_ptr<long> waitTimeAfterCompletion{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertions) {
      res["assertions"] = assertions ? boost::any(assertions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attempts) {
      res["attempts"] = boost::any(*attempts);
    }
    if (authentication) {
      res["authentication"] = boost::any(*authentication);
    }
    if (blockedUrlList) {
      res["blocked_url_list"] = blockedUrlList ? boost::any(blockedUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (browserHeaders) {
      res["browser_headers"] = browserHeaders ? boost::any(browserHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (browserHosts) {
      res["browser_hosts"] = browserHosts ? boost::any(browserHosts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (browserInfo) {
      res["browser_info"] = browserInfo ? boost::any(browserInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (browserInsecure) {
      res["browser_insecure"] = boost::any(*browserInsecure);
    }
    if (browserTaskVersion) {
      res["browser_task_version"] = boost::any(*browserTaskVersion);
    }
    if (cookie) {
      res["cookie"] = boost::any(*cookie);
    }
    if (diagnosisMtr) {
      res["diagnosis_mtr"] = boost::any(*diagnosisMtr);
    }
    if (diagnosisPing) {
      res["diagnosis_ping"] = boost::any(*diagnosisPing);
    }
    if (dnsHijackWhitelist) {
      res["dns_hijack_whitelist"] = boost::any(*dnsHijackWhitelist);
    }
    if (dnsMatchRule) {
      res["dns_match_rule"] = boost::any(*dnsMatchRule);
    }
    if (dnsServer) {
      res["dns_server"] = boost::any(*dnsServer);
    }
    if (dnsType) {
      res["dns_type"] = boost::any(*dnsType);
    }
    if (emptyMessage) {
      res["empty_message"] = boost::any(*emptyMessage);
    }
    if (expectExistString) {
      res["expect_exist_string"] = expectExistString ? boost::any(expectExistString->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expectNonExistString) {
      res["expect_non_exist_string"] = expectNonExistString ? boost::any(expectNonExistString->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expectValue) {
      res["expect_value"] = boost::any(*expectValue);
    }
    if (failureRate) {
      res["failure_rate"] = boost::any(*failureRate);
    }
    if (header) {
      res["header"] = boost::any(*header);
    }
    if (hostBinding) {
      res["host_binding"] = boost::any(*hostBinding);
    }
    if (hostBindingType) {
      res["host_binding_type"] = boost::any(*hostBindingType);
    }
    if (httpMethod) {
      res["http_method"] = boost::any(*httpMethod);
    }
    if (ipNetwork) {
      res["ip_network"] = boost::any(*ipNetwork);
    }
    if (isBase64Encode) {
      res["isBase64Encode"] = boost::any(*isBase64Encode);
    }
    if (matchRule) {
      res["match_rule"] = boost::any(*matchRule);
    }
    if (minTlsVersion) {
      res["min_tls_version"] = boost::any(*minTlsVersion);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (pingNum) {
      res["ping_num"] = boost::any(*pingNum);
    }
    if (pingPort) {
      res["ping_port"] = boost::any(*pingPort);
    }
    if (pingType) {
      res["ping_type"] = boost::any(*pingType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (quicEnabled) {
      res["quic_enabled"] = boost::any(*quicEnabled);
    }
    if (quicTarget) {
      res["quic_target"] = quicTarget ? boost::any(quicTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestContent) {
      res["request_content"] = boost::any(*requestContent);
    }
    if (requestFormat) {
      res["request_format"] = boost::any(*requestFormat);
    }
    if (responseContent) {
      res["response_content"] = boost::any(*responseContent);
    }
    if (responseFormat) {
      res["response_format"] = boost::any(*responseFormat);
    }
    if (retryDelay) {
      res["retry_delay"] = boost::any(*retryDelay);
    }
    if (screenShot) {
      res["screen_shot"] = boost::any(*screenShot);
    }
    if (scrollEnd) {
      res["scroll_end"] = boost::any(*scrollEnd);
    }
    if (strictMode) {
      res["strict_mode"] = boost::any(*strictMode);
    }
    if (timeOut) {
      res["time_out"] = boost::any(*timeOut);
    }
    if (trafficHijackElementBlacklist) {
      res["traffic_hijack_element_blacklist"] = trafficHijackElementBlacklist ? boost::any(trafficHijackElementBlacklist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficHijackElementCount) {
      res["traffic_hijack_element_count"] = boost::any(*trafficHijackElementCount);
    }
    if (trafficHijackElementWhitelist) {
      res["traffic_hijack_element_whitelist"] = trafficHijackElementWhitelist ? boost::any(trafficHijackElementWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (waitTimeAfterCompletion) {
      res["waitTime_after_completion"] = boost::any(*waitTimeAfterCompletion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assertions") != m.end() && !m["assertions"].empty()) {
      if (typeid(map<string, boost::any>) == m["assertions"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assertions"]));
        assertions = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions>(model1);
      }
    }
    if (m.find("attempts") != m.end() && !m["attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["attempts"]));
    }
    if (m.find("authentication") != m.end() && !m["authentication"].empty()) {
      authentication = make_shared<long>(boost::any_cast<long>(m["authentication"]));
    }
    if (m.find("blocked_url_list") != m.end() && !m["blocked_url_list"].empty()) {
      if (typeid(map<string, boost::any>) == m["blocked_url_list"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["blocked_url_list"]));
        blockedUrlList = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList>(model1);
      }
    }
    if (m.find("browser_headers") != m.end() && !m["browser_headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["browser_headers"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["browser_headers"]));
        browserHeaders = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders>(model1);
      }
    }
    if (m.find("browser_hosts") != m.end() && !m["browser_hosts"].empty()) {
      if (typeid(map<string, boost::any>) == m["browser_hosts"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["browser_hosts"]));
        browserHosts = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts>(model1);
      }
    }
    if (m.find("browser_info") != m.end() && !m["browser_info"].empty()) {
      if (typeid(map<string, boost::any>) == m["browser_info"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["browser_info"]));
        browserInfo = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo>(model1);
      }
    }
    if (m.find("browser_insecure") != m.end() && !m["browser_insecure"].empty()) {
      browserInsecure = make_shared<bool>(boost::any_cast<bool>(m["browser_insecure"]));
    }
    if (m.find("browser_task_version") != m.end() && !m["browser_task_version"].empty()) {
      browserTaskVersion = make_shared<string>(boost::any_cast<string>(m["browser_task_version"]));
    }
    if (m.find("cookie") != m.end() && !m["cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["cookie"]));
    }
    if (m.find("diagnosis_mtr") != m.end() && !m["diagnosis_mtr"].empty()) {
      diagnosisMtr = make_shared<bool>(boost::any_cast<bool>(m["diagnosis_mtr"]));
    }
    if (m.find("diagnosis_ping") != m.end() && !m["diagnosis_ping"].empty()) {
      diagnosisPing = make_shared<bool>(boost::any_cast<bool>(m["diagnosis_ping"]));
    }
    if (m.find("dns_hijack_whitelist") != m.end() && !m["dns_hijack_whitelist"].empty()) {
      dnsHijackWhitelist = make_shared<string>(boost::any_cast<string>(m["dns_hijack_whitelist"]));
    }
    if (m.find("dns_match_rule") != m.end() && !m["dns_match_rule"].empty()) {
      dnsMatchRule = make_shared<string>(boost::any_cast<string>(m["dns_match_rule"]));
    }
    if (m.find("dns_server") != m.end() && !m["dns_server"].empty()) {
      dnsServer = make_shared<string>(boost::any_cast<string>(m["dns_server"]));
    }
    if (m.find("dns_type") != m.end() && !m["dns_type"].empty()) {
      dnsType = make_shared<string>(boost::any_cast<string>(m["dns_type"]));
    }
    if (m.find("empty_message") != m.end() && !m["empty_message"].empty()) {
      emptyMessage = make_shared<bool>(boost::any_cast<bool>(m["empty_message"]));
    }
    if (typeid(map<string, boost::any>) == m["expect_exist_string"].type()) {
      DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString model1;
      model1.fromMap(boost::any_cast<map<string, boost::any>>(m["expect_exist_string"]));
      expect_exist_string = model1;
    }
    if (typeid(map<string, boost::any>) == m["expect_non_exist_string"].type()) {
      DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString model1;
      model1.fromMap(boost::any_cast<map<string, boost::any>>(m["expect_non_exist_string"]));
      expect_non_exist_string = model1;
    }
    expect_value = make_shared<string>(boost::any_cast<string>(m["expect_value"]));
    if (m.find("failure_rate") != m.end() && !m["failure_rate"].empty()) {
      failureRate = make_shared<double>(boost::any_cast<double>(m["failure_rate"]));
    }
    if (m.find("header") != m.end() && !m["header"].empty()) {
      header = make_shared<string>(boost::any_cast<string>(m["header"]));
    }
    if (m.find("host_binding") != m.end() && !m["host_binding"].empty()) {
      hostBinding = make_shared<string>(boost::any_cast<string>(m["host_binding"]));
    }
    if (m.find("host_binding_type") != m.end() && !m["host_binding_type"].empty()) {
      hostBindingType = make_shared<long>(boost::any_cast<long>(m["host_binding_type"]));
    }
    if (m.find("http_method") != m.end() && !m["http_method"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["http_method"]));
    }
    if (m.find("ip_network") != m.end() && !m["ip_network"].empty()) {
      ipNetwork = make_shared<string>(boost::any_cast<string>(m["ip_network"]));
    }
    if (m.find("isBase64Encode") != m.end() && !m["isBase64Encode"].empty()) {
      isBase64Encode = make_shared<string>(boost::any_cast<string>(m["isBase64Encode"]));
    }
    if (m.find("match_rule") != m.end() && !m["match_rule"].empty()) {
      matchRule = make_shared<long>(boost::any_cast<long>(m["match_rule"]));
    }
    if (m.find("min_tls_version") != m.end() && !m["min_tls_version"].empty()) {
      minTlsVersion = make_shared<string>(boost::any_cast<string>(m["min_tls_version"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("ping_num") != m.end() && !m["ping_num"].empty()) {
      pingNum = make_shared<long>(boost::any_cast<long>(m["ping_num"]));
    }
    if (m.find("ping_port") != m.end() && !m["ping_port"].empty()) {
      pingPort = make_shared<long>(boost::any_cast<long>(m["ping_port"]));
    }
    if (m.find("ping_type") != m.end() && !m["ping_type"].empty()) {
      pingType = make_shared<string>(boost::any_cast<string>(m["ping_type"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("quic_enabled") != m.end() && !m["quic_enabled"].empty()) {
      quicEnabled = make_shared<bool>(boost::any_cast<bool>(m["quic_enabled"]));
    }
    if (m.find("quic_target") != m.end() && !m["quic_target"].empty()) {
      if (typeid(map<string, boost::any>) == m["quic_target"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["quic_target"]));
        quicTarget = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonQuicTarget>(model1);
      }
    }
    if (m.find("request_content") != m.end() && !m["request_content"].empty()) {
      requestContent = make_shared<string>(boost::any_cast<string>(m["request_content"]));
    }
    if (m.find("request_format") != m.end() && !m["request_format"].empty()) {
      requestFormat = make_shared<string>(boost::any_cast<string>(m["request_format"]));
    }
    if (m.find("response_content") != m.end() && !m["response_content"].empty()) {
      responseContent = make_shared<string>(boost::any_cast<string>(m["response_content"]));
    }
    if (m.find("response_format") != m.end() && !m["response_format"].empty()) {
      responseFormat = make_shared<string>(boost::any_cast<string>(m["response_format"]));
    }
    if (m.find("retry_delay") != m.end() && !m["retry_delay"].empty()) {
      retryDelay = make_shared<long>(boost::any_cast<long>(m["retry_delay"]));
    }
    if (m.find("screen_shot") != m.end() && !m["screen_shot"].empty()) {
      screenShot = make_shared<bool>(boost::any_cast<bool>(m["screen_shot"]));
    }
    if (m.find("scroll_end") != m.end() && !m["scroll_end"].empty()) {
      scrollEnd = make_shared<bool>(boost::any_cast<bool>(m["scroll_end"]));
    }
    if (m.find("strict_mode") != m.end() && !m["strict_mode"].empty()) {
      strictMode = make_shared<bool>(boost::any_cast<bool>(m["strict_mode"]));
    }
    if (m.find("time_out") != m.end() && !m["time_out"].empty()) {
      timeOut = make_shared<long>(boost::any_cast<long>(m["time_out"]));
    }
    if (m.find("traffic_hijack_element_blacklist") != m.end() && !m["traffic_hijack_element_blacklist"].empty()) {
      if (typeid(map<string, boost::any>) == m["traffic_hijack_element_blacklist"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["traffic_hijack_element_blacklist"]));
        trafficHijackElementBlacklist = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist>(model1);
      }
    }
    if (m.find("traffic_hijack_element_count") != m.end() && !m["traffic_hijack_element_count"].empty()) {
      trafficHijackElementCount = make_shared<long>(boost::any_cast<long>(m["traffic_hijack_element_count"]));
    }
    if (m.find("traffic_hijack_element_whitelist") != m.end() && !m["traffic_hijack_element_whitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["traffic_hijack_element_whitelist"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["traffic_hijack_element_whitelist"]));
        trafficHijackElementWhitelist = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist>(model1);
      }
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("waitTime_after_completion") != m.end() && !m["waitTime_after_completion"].empty()) {
      waitTimeAfterCompletion = make_shared<long>(boost::any_cast<long>(m["waitTime_after_completion"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vswitchId{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig() = default;
};
class DescribeSiteMonitorAttributeResponseBodySiteMonitors : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> agentGroup{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule> customSchedule{};
  shared_ptr<string> interval{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities> ispCities{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson> optionJson{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskState{};
  shared_ptr<string> taskType{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig> vpcConfig{};

  DescribeSiteMonitorAttributeResponseBodySiteMonitors() {}

  explicit DescribeSiteMonitorAttributeResponseBodySiteMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (agentGroup) {
      res["AgentGroup"] = boost::any(*agentGroup);
    }
    if (customSchedule) {
      res["CustomSchedule"] = customSchedule ? boost::any(customSchedule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispCities) {
      res["IspCities"] = ispCities ? boost::any(ispCities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (optionJson) {
      res["OptionJson"] = optionJson ? boost::any(optionJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AgentGroup") != m.end() && !m["AgentGroup"].empty()) {
      agentGroup = make_shared<string>(boost::any_cast<string>(m["AgentGroup"]));
    }
    if (m.find("CustomSchedule") != m.end() && !m["CustomSchedule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSchedule"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSchedule"]));
        customSchedule = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspCities") != m.end() && !m["IspCities"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCities"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCities"]));
        ispCities = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities>(model1);
      }
    }
    if (m.find("OptionJson") != m.end() && !m["OptionJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["OptionJson"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OptionJson"]));
        optionJson = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitorsVpcConfig>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBodySiteMonitors() = default;
};
class DescribeSiteMonitorAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodyMetricRules> metricRules{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBodySiteMonitors> siteMonitors{};
  shared_ptr<bool> success{};

  DescribeSiteMonitorAttributeResponseBody() {}

  explicit DescribeSiteMonitorAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (metricRules) {
      res["MetricRules"] = metricRules ? boost::any(metricRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteMonitors) {
      res["SiteMonitors"] = siteMonitors ? boost::any(siteMonitors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MetricRules") != m.end() && !m["MetricRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetricRules"].type()) {
        DescribeSiteMonitorAttributeResponseBodyMetricRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetricRules"]));
        metricRules = make_shared<DescribeSiteMonitorAttributeResponseBodyMetricRules>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteMonitors") != m.end() && !m["SiteMonitors"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitors"].type()) {
        DescribeSiteMonitorAttributeResponseBodySiteMonitors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitors"]));
        siteMonitors = make_shared<DescribeSiteMonitorAttributeResponseBodySiteMonitors>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponseBody() = default;
};
class DescribeSiteMonitorAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorAttributeResponseBody> body{};

  DescribeSiteMonitorAttributeResponse() {}

  explicit DescribeSiteMonitorAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorAttributeResponse() = default;
};
class DescribeSiteMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> period{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribeSiteMonitorDataRequest() {}

  explicit DescribeSiteMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSiteMonitorDataRequest() = default;
};
class DescribeSiteMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSiteMonitorDataResponseBody() {}

  explicit DescribeSiteMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorDataResponseBody() = default;
};
class DescribeSiteMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorDataResponseBody> body{};

  DescribeSiteMonitorDataResponse() {}

  explicit DescribeSiteMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorDataResponse() = default;
};
class DescribeSiteMonitorISPCityListRequest : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<bool> IPV4{};
  shared_ptr<bool> IPV6{};
  shared_ptr<string> isp{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> viewAll{};

  DescribeSiteMonitorISPCityListRequest() {}

  explicit DescribeSiteMonitorISPCityListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (IPV4) {
      res["IPV4"] = boost::any(*IPV4);
    }
    if (IPV6) {
      res["IPV6"] = boost::any(*IPV6);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (viewAll) {
      res["ViewAll"] = boost::any(*viewAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("IPV4") != m.end() && !m["IPV4"].empty()) {
      IPV4 = make_shared<bool>(boost::any_cast<bool>(m["IPV4"]));
    }
    if (m.find("IPV6") != m.end() && !m["IPV6"].empty()) {
      IPV6 = make_shared<bool>(boost::any_cast<bool>(m["IPV6"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ViewAll") != m.end() && !m["ViewAll"].empty()) {
      viewAll = make_shared<bool>(boost::any_cast<bool>(m["ViewAll"]));
    }
  }


  virtual ~DescribeSiteMonitorISPCityListRequest() = default;
};
class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPPool{};

  DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool() {}

  explicit DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPPool) {
      res["IPPool"] = boost::any(*IPPool);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPPool") != m.end() && !m["IPPool"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPPool"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPPool"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPPool = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool() = default;
};
class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity : public Darabonba::Model {
public:
  shared_ptr<string> area_en{};
  shared_ptr<string> area_zh_cN{};
  shared_ptr<string> city{};
  shared_ptr<string> cityName_en{};
  shared_ptr<string> cityName_zh_cN{};
  shared_ptr<string> country{};
  shared_ptr<string> country_en{};
  shared_ptr<string> country_zh_cN{};
  shared_ptr<DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool> IPPool{};
  shared_ptr<string> IPV4ProbeCount{};
  shared_ptr<string> IPV6ProbeCount{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispName_en{};
  shared_ptr<string> ispName_zh_cN{};
  shared_ptr<string> region{};
  shared_ptr<string> region_en{};
  shared_ptr<string> region_zh_cN{};

  DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity() {}

  explicit DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area_en) {
      res["Area.en"] = boost::any(*area_en);
    }
    if (area_zh_cN) {
      res["Area.zh_CN"] = boost::any(*area_zh_cN);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityName_en) {
      res["CityName.en"] = boost::any(*cityName_en);
    }
    if (cityName_zh_cN) {
      res["CityName.zh_CN"] = boost::any(*cityName_zh_cN);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (country_en) {
      res["Country.en"] = boost::any(*country_en);
    }
    if (country_zh_cN) {
      res["Country.zh_CN"] = boost::any(*country_zh_cN);
    }
    if (IPPool) {
      res["IPPool"] = IPPool ? boost::any(IPPool->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (IPV4ProbeCount) {
      res["IPV4ProbeCount"] = boost::any(*IPV4ProbeCount);
    }
    if (IPV6ProbeCount) {
      res["IPV6ProbeCount"] = boost::any(*IPV6ProbeCount);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispName_en) {
      res["IspName.en"] = boost::any(*ispName_en);
    }
    if (ispName_zh_cN) {
      res["IspName.zh_CN"] = boost::any(*ispName_zh_cN);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (region_en) {
      res["Region.en"] = boost::any(*region_en);
    }
    if (region_zh_cN) {
      res["Region.zh_CN"] = boost::any(*region_zh_cN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area.en") != m.end() && !m["Area.en"].empty()) {
      area_en = make_shared<string>(boost::any_cast<string>(m["Area.en"]));
    }
    if (m.find("Area.zh_CN") != m.end() && !m["Area.zh_CN"].empty()) {
      area_zh_cN = make_shared<string>(boost::any_cast<string>(m["Area.zh_CN"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityName.en") != m.end() && !m["CityName.en"].empty()) {
      cityName_en = make_shared<string>(boost::any_cast<string>(m["CityName.en"]));
    }
    if (m.find("CityName.zh_CN") != m.end() && !m["CityName.zh_CN"].empty()) {
      cityName_zh_cN = make_shared<string>(boost::any_cast<string>(m["CityName.zh_CN"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("Country.en") != m.end() && !m["Country.en"].empty()) {
      country_en = make_shared<string>(boost::any_cast<string>(m["Country.en"]));
    }
    if (m.find("Country.zh_CN") != m.end() && !m["Country.zh_CN"].empty()) {
      country_zh_cN = make_shared<string>(boost::any_cast<string>(m["Country.zh_CN"]));
    }
    if (m.find("IPPool") != m.end() && !m["IPPool"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPPool"].type()) {
        DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPPool"]));
        IPPool = make_shared<DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool>(model1);
      }
    }
    if (m.find("IPV4ProbeCount") != m.end() && !m["IPV4ProbeCount"].empty()) {
      IPV4ProbeCount = make_shared<string>(boost::any_cast<string>(m["IPV4ProbeCount"]));
    }
    if (m.find("IPV6ProbeCount") != m.end() && !m["IPV6ProbeCount"].empty()) {
      IPV6ProbeCount = make_shared<string>(boost::any_cast<string>(m["IPV6ProbeCount"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspName.en") != m.end() && !m["IspName.en"].empty()) {
      ispName_en = make_shared<string>(boost::any_cast<string>(m["IspName.en"]));
    }
    if (m.find("IspName.zh_CN") != m.end() && !m["IspName.zh_CN"].empty()) {
      ispName_zh_cN = make_shared<string>(boost::any_cast<string>(m["IspName.zh_CN"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Region.en") != m.end() && !m["Region.en"].empty()) {
      region_en = make_shared<string>(boost::any_cast<string>(m["Region.en"]));
    }
    if (m.find("Region.zh_CN") != m.end() && !m["Region.zh_CN"].empty()) {
      region_zh_cN = make_shared<string>(boost::any_cast<string>(m["Region.zh_CN"]));
    }
  }


  virtual ~DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity() = default;
};
class DescribeSiteMonitorISPCityListResponseBodyIspCityList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity>> ispCity{};

  DescribeSiteMonitorISPCityListResponseBodyIspCityList() {}

  explicit DescribeSiteMonitorISPCityListResponseBodyIspCityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispCity) {
      vector<boost::any> temp1;
      for(auto item1:*ispCity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspCity") != m.end() && !m["IspCity"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCity"].type()) {
        vector<DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCity = make_shared<vector<DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorISPCityListResponseBodyIspCityList() = default;
};
class DescribeSiteMonitorISPCityListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSiteMonitorISPCityListResponseBodyIspCityList> ispCityList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSiteMonitorISPCityListResponseBody() {}

  explicit DescribeSiteMonitorISPCityListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ispCityList) {
      res["IspCityList"] = ispCityList ? boost::any(ispCityList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IspCityList") != m.end() && !m["IspCityList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IspCityList"].type()) {
        DescribeSiteMonitorISPCityListResponseBodyIspCityList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IspCityList"]));
        ispCityList = make_shared<DescribeSiteMonitorISPCityListResponseBodyIspCityList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorISPCityListResponseBody() = default;
};
class DescribeSiteMonitorISPCityListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorISPCityListResponseBody> body{};

  DescribeSiteMonitorISPCityListResponse() {}

  explicit DescribeSiteMonitorISPCityListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorISPCityListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorISPCityListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorISPCityListResponse() = default;
};
class DescribeSiteMonitorListRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskState{};
  shared_ptr<string> taskType{};

  DescribeSiteMonitorListRequest() {}

  explicit DescribeSiteMonitorListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeSiteMonitorListRequest() = default;
};
class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> property{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions() {}

  explicit DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (property) {
      res["property"] = boost::any(*property);
    }
    if (target) {
      res["target"] = boost::any(*target);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("property") != m.end() && !m["property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["property"]));
    }
    if (m.find("target") != m.end() && !m["target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["target"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions() = default;
};
class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions>> assertions{};

  DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions() {}

  explicit DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertions) {
      vector<boost::any> temp1;
      for(auto item1:*assertions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["assertions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assertions") != m.end() && !m["assertions"].empty()) {
      if (typeid(vector<boost::any>) == m["assertions"].type()) {
        vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["assertions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assertions = make_shared<vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions() = default;
};
class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson : public Darabonba::Model {
public:
  shared_ptr<string> acceptableResponseCode{};
  shared_ptr<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions> assertions{};
  shared_ptr<long> attempts{};
  shared_ptr<long> authentication{};
  shared_ptr<bool> certVerify{};
  shared_ptr<string> cookie{};
  shared_ptr<bool> diagnosisMtr{};
  shared_ptr<bool> diagnosisPing{};
  shared_ptr<string> dnsMatchRule{};
  shared_ptr<string> dnsServer{};
  shared_ptr<string> dnsType{};
  shared_ptr<bool> enableOperatorDns{};
  shared_ptr<double> failureRate{};
  shared_ptr<string> header{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> isBase64Encode{};
  shared_ptr<long> matchRule{};
  shared_ptr<string> password{};
  shared_ptr<long> pingNum{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> proxyProtocol{};
  shared_ptr<string> requestContent{};
  shared_ptr<string> requestFormat{};
  shared_ptr<string> responseContent{};
  shared_ptr<string> responseFormat{};
  shared_ptr<long> retryDelay{};
  shared_ptr<long> timeOut{};
  shared_ptr<bool> unfollowRedirect{};
  shared_ptr<string> username{};

  DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson() {}

  explicit DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptableResponseCode) {
      res["acceptable_response_code"] = boost::any(*acceptableResponseCode);
    }
    if (assertions) {
      res["assertions"] = assertions ? boost::any(assertions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attempts) {
      res["attempts"] = boost::any(*attempts);
    }
    if (authentication) {
      res["authentication"] = boost::any(*authentication);
    }
    if (certVerify) {
      res["cert_verify"] = boost::any(*certVerify);
    }
    if (cookie) {
      res["cookie"] = boost::any(*cookie);
    }
    if (diagnosisMtr) {
      res["diagnosis_mtr"] = boost::any(*diagnosisMtr);
    }
    if (diagnosisPing) {
      res["diagnosis_ping"] = boost::any(*diagnosisPing);
    }
    if (dnsMatchRule) {
      res["dns_match_rule"] = boost::any(*dnsMatchRule);
    }
    if (dnsServer) {
      res["dns_server"] = boost::any(*dnsServer);
    }
    if (dnsType) {
      res["dns_type"] = boost::any(*dnsType);
    }
    if (enableOperatorDns) {
      res["enable_operator_dns"] = boost::any(*enableOperatorDns);
    }
    if (failureRate) {
      res["failure_rate"] = boost::any(*failureRate);
    }
    if (header) {
      res["header"] = boost::any(*header);
    }
    if (httpMethod) {
      res["http_method"] = boost::any(*httpMethod);
    }
    if (isBase64Encode) {
      res["isBase64Encode"] = boost::any(*isBase64Encode);
    }
    if (matchRule) {
      res["match_rule"] = boost::any(*matchRule);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (pingNum) {
      res["ping_num"] = boost::any(*pingNum);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (proxyProtocol) {
      res["proxy_protocol"] = boost::any(*proxyProtocol);
    }
    if (requestContent) {
      res["request_content"] = boost::any(*requestContent);
    }
    if (requestFormat) {
      res["request_format"] = boost::any(*requestFormat);
    }
    if (responseContent) {
      res["response_content"] = boost::any(*responseContent);
    }
    if (responseFormat) {
      res["response_format"] = boost::any(*responseFormat);
    }
    if (retryDelay) {
      res["retry_delay"] = boost::any(*retryDelay);
    }
    if (timeOut) {
      res["time_out"] = boost::any(*timeOut);
    }
    if (unfollowRedirect) {
      res["unfollow_redirect"] = boost::any(*unfollowRedirect);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("acceptable_response_code") != m.end() && !m["acceptable_response_code"].empty()) {
      acceptableResponseCode = make_shared<string>(boost::any_cast<string>(m["acceptable_response_code"]));
    }
    if (m.find("assertions") != m.end() && !m["assertions"].empty()) {
      if (typeid(map<string, boost::any>) == m["assertions"].type()) {
        DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["assertions"]));
        assertions = make_shared<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions>(model1);
      }
    }
    if (m.find("attempts") != m.end() && !m["attempts"].empty()) {
      attempts = make_shared<long>(boost::any_cast<long>(m["attempts"]));
    }
    if (m.find("authentication") != m.end() && !m["authentication"].empty()) {
      authentication = make_shared<long>(boost::any_cast<long>(m["authentication"]));
    }
    if (m.find("cert_verify") != m.end() && !m["cert_verify"].empty()) {
      certVerify = make_shared<bool>(boost::any_cast<bool>(m["cert_verify"]));
    }
    if (m.find("cookie") != m.end() && !m["cookie"].empty()) {
      cookie = make_shared<string>(boost::any_cast<string>(m["cookie"]));
    }
    if (m.find("diagnosis_mtr") != m.end() && !m["diagnosis_mtr"].empty()) {
      diagnosisMtr = make_shared<bool>(boost::any_cast<bool>(m["diagnosis_mtr"]));
    }
    if (m.find("diagnosis_ping") != m.end() && !m["diagnosis_ping"].empty()) {
      diagnosisPing = make_shared<bool>(boost::any_cast<bool>(m["diagnosis_ping"]));
    }
    if (m.find("dns_match_rule") != m.end() && !m["dns_match_rule"].empty()) {
      dnsMatchRule = make_shared<string>(boost::any_cast<string>(m["dns_match_rule"]));
    }
    if (m.find("dns_server") != m.end() && !m["dns_server"].empty()) {
      dnsServer = make_shared<string>(boost::any_cast<string>(m["dns_server"]));
    }
    if (m.find("dns_type") != m.end() && !m["dns_type"].empty()) {
      dnsType = make_shared<string>(boost::any_cast<string>(m["dns_type"]));
    }
    if (m.find("enable_operator_dns") != m.end() && !m["enable_operator_dns"].empty()) {
      enableOperatorDns = make_shared<bool>(boost::any_cast<bool>(m["enable_operator_dns"]));
    }
    if (m.find("failure_rate") != m.end() && !m["failure_rate"].empty()) {
      failureRate = make_shared<double>(boost::any_cast<double>(m["failure_rate"]));
    }
    if (m.find("header") != m.end() && !m["header"].empty()) {
      header = make_shared<string>(boost::any_cast<string>(m["header"]));
    }
    if (m.find("http_method") != m.end() && !m["http_method"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["http_method"]));
    }
    if (m.find("isBase64Encode") != m.end() && !m["isBase64Encode"].empty()) {
      isBase64Encode = make_shared<string>(boost::any_cast<string>(m["isBase64Encode"]));
    }
    if (m.find("match_rule") != m.end() && !m["match_rule"].empty()) {
      matchRule = make_shared<long>(boost::any_cast<long>(m["match_rule"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("ping_num") != m.end() && !m["ping_num"].empty()) {
      pingNum = make_shared<long>(boost::any_cast<long>(m["ping_num"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("proxy_protocol") != m.end() && !m["proxy_protocol"].empty()) {
      proxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["proxy_protocol"]));
    }
    if (m.find("request_content") != m.end() && !m["request_content"].empty()) {
      requestContent = make_shared<string>(boost::any_cast<string>(m["request_content"]));
    }
    if (m.find("request_format") != m.end() && !m["request_format"].empty()) {
      requestFormat = make_shared<string>(boost::any_cast<string>(m["request_format"]));
    }
    if (m.find("response_content") != m.end() && !m["response_content"].empty()) {
      responseContent = make_shared<string>(boost::any_cast<string>(m["response_content"]));
    }
    if (m.find("response_format") != m.end() && !m["response_format"].empty()) {
      responseFormat = make_shared<string>(boost::any_cast<string>(m["response_format"]));
    }
    if (m.find("retry_delay") != m.end() && !m["retry_delay"].empty()) {
      retryDelay = make_shared<long>(boost::any_cast<long>(m["retry_delay"]));
    }
    if (m.find("time_out") != m.end() && !m["time_out"].empty()) {
      timeOut = make_shared<long>(boost::any_cast<long>(m["time_out"]));
    }
    if (m.find("unfollow_redirect") != m.end() && !m["unfollow_redirect"].empty()) {
      unfollowRedirect = make_shared<bool>(boost::any_cast<bool>(m["unfollow_redirect"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson() = default;
};
class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> agentGroup{};
  shared_ptr<string> createTime{};
  shared_ptr<string> interval{};
  shared_ptr<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson> optionsJson{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskState{};
  shared_ptr<string> taskType{};
  shared_ptr<string> updateTime{};

  DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor() {}

  explicit DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (agentGroup) {
      res["AgentGroup"] = boost::any(*agentGroup);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (optionsJson) {
      res["OptionsJson"] = optionsJson ? boost::any(optionsJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AgentGroup") != m.end() && !m["AgentGroup"].empty()) {
      agentGroup = make_shared<string>(boost::any_cast<string>(m["AgentGroup"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["OptionsJson"].type()) {
        DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OptionsJson"]));
        optionsJson = make_shared<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor() = default;
};
class DescribeSiteMonitorListResponseBodySiteMonitors : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor>> siteMonitor{};

  DescribeSiteMonitorListResponseBodySiteMonitors() {}

  explicit DescribeSiteMonitorListResponseBodySiteMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (siteMonitor) {
      vector<boost::any> temp1;
      for(auto item1:*siteMonitor){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SiteMonitor"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SiteMonitor") != m.end() && !m["SiteMonitor"].empty()) {
      if (typeid(vector<boost::any>) == m["SiteMonitor"].type()) {
        vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SiteMonitor"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        siteMonitor = make_shared<vector<DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor>>(expect1);
      }
    }
  }


  virtual ~DescribeSiteMonitorListResponseBodySiteMonitors() = default;
};
class DescribeSiteMonitorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSiteMonitorListResponseBodySiteMonitors> siteMonitors{};
  shared_ptr<string> success{};
  shared_ptr<long> totalCount{};

  DescribeSiteMonitorListResponseBody() {}

  explicit DescribeSiteMonitorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (siteMonitors) {
      res["SiteMonitors"] = siteMonitors ? boost::any(siteMonitors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SiteMonitors") != m.end() && !m["SiteMonitors"].empty()) {
      if (typeid(map<string, boost::any>) == m["SiteMonitors"].type()) {
        DescribeSiteMonitorListResponseBodySiteMonitors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SiteMonitors"]));
        siteMonitors = make_shared<DescribeSiteMonitorListResponseBodySiteMonitors>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSiteMonitorListResponseBody() = default;
};
class DescribeSiteMonitorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorListResponseBody> body{};

  DescribeSiteMonitorListResponse() {}

  explicit DescribeSiteMonitorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorListResponse() = default;
};
class DescribeSiteMonitorLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> browser{};
  shared_ptr<string> browserInfo{};
  shared_ptr<string> city{};
  shared_ptr<string> device{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filter{};
  shared_ptr<string> isp{};
  shared_ptr<long> length{};
  shared_ptr<string> metricName{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskIds{};

  DescribeSiteMonitorLogRequest() {}

  explicit DescribeSiteMonitorLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (browser) {
      res["Browser"] = boost::any(*browser);
    }
    if (browserInfo) {
      res["BrowserInfo"] = boost::any(*browserInfo);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (device) {
      res["Device"] = boost::any(*device);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filter) {
      res["Filter"] = boost::any(*filter);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Browser") != m.end() && !m["Browser"].empty()) {
      browser = make_shared<string>(boost::any_cast<string>(m["Browser"]));
    }
    if (m.find("BrowserInfo") != m.end() && !m["BrowserInfo"].empty()) {
      browserInfo = make_shared<string>(boost::any_cast<string>(m["BrowserInfo"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      device = make_shared<string>(boost::any_cast<string>(m["Device"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~DescribeSiteMonitorLogRequest() = default;
};
class DescribeSiteMonitorLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSiteMonitorLogResponseBody() {}

  explicit DescribeSiteMonitorLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorLogResponseBody() = default;
};
class DescribeSiteMonitorLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorLogResponseBody> body{};

  DescribeSiteMonitorLogResponse() {}

  explicit DescribeSiteMonitorLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorLogResponse() = default;
};
class DescribeSiteMonitorQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeSiteMonitorQuotaRequest() {}

  explicit DescribeSiteMonitorQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSiteMonitorQuotaRequest() = default;
};
class DescribeSiteMonitorQuotaResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> secondMonitor{};
  shared_ptr<long> siteMonitorIdcQuota{};
  shared_ptr<long> siteMonitorOperatorQuotaQuota{};
  shared_ptr<long> siteMonitorQuotaTaskUsed{};
  shared_ptr<long> siteMonitorTaskQuota{};
  shared_ptr<string> siteMonitorVersion{};

  DescribeSiteMonitorQuotaResponseBodyData() {}

  explicit DescribeSiteMonitorQuotaResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secondMonitor) {
      res["SecondMonitor"] = boost::any(*secondMonitor);
    }
    if (siteMonitorIdcQuota) {
      res["SiteMonitorIdcQuota"] = boost::any(*siteMonitorIdcQuota);
    }
    if (siteMonitorOperatorQuotaQuota) {
      res["SiteMonitorOperatorQuotaQuota"] = boost::any(*siteMonitorOperatorQuotaQuota);
    }
    if (siteMonitorQuotaTaskUsed) {
      res["SiteMonitorQuotaTaskUsed"] = boost::any(*siteMonitorQuotaTaskUsed);
    }
    if (siteMonitorTaskQuota) {
      res["SiteMonitorTaskQuota"] = boost::any(*siteMonitorTaskQuota);
    }
    if (siteMonitorVersion) {
      res["SiteMonitorVersion"] = boost::any(*siteMonitorVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecondMonitor") != m.end() && !m["SecondMonitor"].empty()) {
      secondMonitor = make_shared<bool>(boost::any_cast<bool>(m["SecondMonitor"]));
    }
    if (m.find("SiteMonitorIdcQuota") != m.end() && !m["SiteMonitorIdcQuota"].empty()) {
      siteMonitorIdcQuota = make_shared<long>(boost::any_cast<long>(m["SiteMonitorIdcQuota"]));
    }
    if (m.find("SiteMonitorOperatorQuotaQuota") != m.end() && !m["SiteMonitorOperatorQuotaQuota"].empty()) {
      siteMonitorOperatorQuotaQuota = make_shared<long>(boost::any_cast<long>(m["SiteMonitorOperatorQuotaQuota"]));
    }
    if (m.find("SiteMonitorQuotaTaskUsed") != m.end() && !m["SiteMonitorQuotaTaskUsed"].empty()) {
      siteMonitorQuotaTaskUsed = make_shared<long>(boost::any_cast<long>(m["SiteMonitorQuotaTaskUsed"]));
    }
    if (m.find("SiteMonitorTaskQuota") != m.end() && !m["SiteMonitorTaskQuota"].empty()) {
      siteMonitorTaskQuota = make_shared<long>(boost::any_cast<long>(m["SiteMonitorTaskQuota"]));
    }
    if (m.find("SiteMonitorVersion") != m.end() && !m["SiteMonitorVersion"].empty()) {
      siteMonitorVersion = make_shared<string>(boost::any_cast<string>(m["SiteMonitorVersion"]));
    }
  }


  virtual ~DescribeSiteMonitorQuotaResponseBodyData() = default;
};
class DescribeSiteMonitorQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeSiteMonitorQuotaResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSiteMonitorQuotaResponseBody() {}

  explicit DescribeSiteMonitorQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSiteMonitorQuotaResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSiteMonitorQuotaResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorQuotaResponseBody() = default;
};
class DescribeSiteMonitorQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorQuotaResponseBody> body{};

  DescribeSiteMonitorQuotaResponse() {}

  explicit DescribeSiteMonitorQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorQuotaResponse() = default;
};
class DescribeSiteMonitorStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> timeRange{};

  DescribeSiteMonitorStatisticsRequest() {}

  explicit DescribeSiteMonitorStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      timeRange = make_shared<string>(boost::any_cast<string>(m["TimeRange"]));
    }
  }


  virtual ~DescribeSiteMonitorStatisticsRequest() = default;
};
class DescribeSiteMonitorStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSiteMonitorStatisticsResponseBody() {}

  explicit DescribeSiteMonitorStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSiteMonitorStatisticsResponseBody() = default;
};
class DescribeSiteMonitorStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSiteMonitorStatisticsResponseBody> body{};

  DescribeSiteMonitorStatisticsResponse() {}

  explicit DescribeSiteMonitorStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSiteMonitorStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSiteMonitorStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSiteMonitorStatisticsResponse() = default;
};
class DescribeSyntheticProbeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<bool> idcProbe{};
  shared_ptr<bool> ipv4{};
  shared_ptr<bool> ipv6{};
  shared_ptr<string> isp{};
  shared_ptr<bool> lmProbe{};
  shared_ptr<bool> mbProbe{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> viewAll{};

  DescribeSyntheticProbeListRequest() {}

  explicit DescribeSyntheticProbeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (idcProbe) {
      res["IdcProbe"] = boost::any(*idcProbe);
    }
    if (ipv4) {
      res["Ipv4"] = boost::any(*ipv4);
    }
    if (ipv6) {
      res["Ipv6"] = boost::any(*ipv6);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (lmProbe) {
      res["LmProbe"] = boost::any(*lmProbe);
    }
    if (mbProbe) {
      res["MbProbe"] = boost::any(*mbProbe);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (viewAll) {
      res["ViewAll"] = boost::any(*viewAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("IdcProbe") != m.end() && !m["IdcProbe"].empty()) {
      idcProbe = make_shared<bool>(boost::any_cast<bool>(m["IdcProbe"]));
    }
    if (m.find("Ipv4") != m.end() && !m["Ipv4"].empty()) {
      ipv4 = make_shared<bool>(boost::any_cast<bool>(m["Ipv4"]));
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      ipv6 = make_shared<bool>(boost::any_cast<bool>(m["Ipv6"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("LmProbe") != m.end() && !m["LmProbe"].empty()) {
      lmProbe = make_shared<bool>(boost::any_cast<bool>(m["LmProbe"]));
    }
    if (m.find("MbProbe") != m.end() && !m["MbProbe"].empty()) {
      mbProbe = make_shared<bool>(boost::any_cast<bool>(m["MbProbe"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ViewAll") != m.end() && !m["ViewAll"].empty()) {
      viewAll = make_shared<bool>(boost::any_cast<bool>(m["ViewAll"]));
    }
  }


  virtual ~DescribeSyntheticProbeListRequest() = default;
};
class DescribeSyntheticProbeListResponseBodyIspCityList : public Darabonba::Model {
public:
  shared_ptr<string> areaCn{};
  shared_ptr<string> areaEn{};
  shared_ptr<string> city{};
  shared_ptr<string> cityCn{};
  shared_ptr<string> cityEn{};
  shared_ptr<string> country{};
  shared_ptr<string> countryCn{};
  shared_ptr<string> countryEn{};
  shared_ptr<long> idcV4ProbeCount{};
  shared_ptr<long> idcV6ProbeCount{};
  shared_ptr<vector<string>> ipPool{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispCn{};
  shared_ptr<string> ispEn{};
  shared_ptr<long> lmProbeCount{};
  shared_ptr<long> mbProbeCount{};
  shared_ptr<string> region{};
  shared_ptr<string> regionCn{};
  shared_ptr<string> regionEn{};

  DescribeSyntheticProbeListResponseBodyIspCityList() {}

  explicit DescribeSyntheticProbeListResponseBodyIspCityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaCn) {
      res["AreaCn"] = boost::any(*areaCn);
    }
    if (areaEn) {
      res["AreaEn"] = boost::any(*areaEn);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityCn) {
      res["CityCn"] = boost::any(*cityCn);
    }
    if (cityEn) {
      res["CityEn"] = boost::any(*cityEn);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (countryCn) {
      res["CountryCn"] = boost::any(*countryCn);
    }
    if (countryEn) {
      res["CountryEn"] = boost::any(*countryEn);
    }
    if (idcV4ProbeCount) {
      res["IdcV4ProbeCount"] = boost::any(*idcV4ProbeCount);
    }
    if (idcV6ProbeCount) {
      res["IdcV6ProbeCount"] = boost::any(*idcV6ProbeCount);
    }
    if (ipPool) {
      res["IpPool"] = boost::any(*ipPool);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispCn) {
      res["IspCn"] = boost::any(*ispCn);
    }
    if (ispEn) {
      res["IspEn"] = boost::any(*ispEn);
    }
    if (lmProbeCount) {
      res["LmProbeCount"] = boost::any(*lmProbeCount);
    }
    if (mbProbeCount) {
      res["MbProbeCount"] = boost::any(*mbProbeCount);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionCn) {
      res["RegionCn"] = boost::any(*regionCn);
    }
    if (regionEn) {
      res["RegionEn"] = boost::any(*regionEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaCn") != m.end() && !m["AreaCn"].empty()) {
      areaCn = make_shared<string>(boost::any_cast<string>(m["AreaCn"]));
    }
    if (m.find("AreaEn") != m.end() && !m["AreaEn"].empty()) {
      areaEn = make_shared<string>(boost::any_cast<string>(m["AreaEn"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityCn") != m.end() && !m["CityCn"].empty()) {
      cityCn = make_shared<string>(boost::any_cast<string>(m["CityCn"]));
    }
    if (m.find("CityEn") != m.end() && !m["CityEn"].empty()) {
      cityEn = make_shared<string>(boost::any_cast<string>(m["CityEn"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("CountryCn") != m.end() && !m["CountryCn"].empty()) {
      countryCn = make_shared<string>(boost::any_cast<string>(m["CountryCn"]));
    }
    if (m.find("CountryEn") != m.end() && !m["CountryEn"].empty()) {
      countryEn = make_shared<string>(boost::any_cast<string>(m["CountryEn"]));
    }
    if (m.find("IdcV4ProbeCount") != m.end() && !m["IdcV4ProbeCount"].empty()) {
      idcV4ProbeCount = make_shared<long>(boost::any_cast<long>(m["IdcV4ProbeCount"]));
    }
    if (m.find("IdcV6ProbeCount") != m.end() && !m["IdcV6ProbeCount"].empty()) {
      idcV6ProbeCount = make_shared<long>(boost::any_cast<long>(m["IdcV6ProbeCount"]));
    }
    if (m.find("IpPool") != m.end() && !m["IpPool"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpPool"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpPool"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipPool = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspCn") != m.end() && !m["IspCn"].empty()) {
      ispCn = make_shared<string>(boost::any_cast<string>(m["IspCn"]));
    }
    if (m.find("IspEn") != m.end() && !m["IspEn"].empty()) {
      ispEn = make_shared<string>(boost::any_cast<string>(m["IspEn"]));
    }
    if (m.find("LmProbeCount") != m.end() && !m["LmProbeCount"].empty()) {
      lmProbeCount = make_shared<long>(boost::any_cast<long>(m["LmProbeCount"]));
    }
    if (m.find("MbProbeCount") != m.end() && !m["MbProbeCount"].empty()) {
      mbProbeCount = make_shared<long>(boost::any_cast<long>(m["MbProbeCount"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionCn") != m.end() && !m["RegionCn"].empty()) {
      regionCn = make_shared<string>(boost::any_cast<string>(m["RegionCn"]));
    }
    if (m.find("RegionEn") != m.end() && !m["RegionEn"].empty()) {
      regionEn = make_shared<string>(boost::any_cast<string>(m["RegionEn"]));
    }
  }


  virtual ~DescribeSyntheticProbeListResponseBodyIspCityList() = default;
};
class DescribeSyntheticProbeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DescribeSyntheticProbeListResponseBodyIspCityList>> ispCityList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DescribeSyntheticProbeListResponseBody() {}

  explicit DescribeSyntheticProbeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ispCityList) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IspCityList") != m.end() && !m["IspCityList"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityList"].type()) {
        vector<DescribeSyntheticProbeListResponseBodyIspCityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSyntheticProbeListResponseBodyIspCityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityList = make_shared<vector<DescribeSyntheticProbeListResponseBodyIspCityList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DescribeSyntheticProbeListResponseBody() = default;
};
class DescribeSyntheticProbeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSyntheticProbeListResponseBody> body{};

  DescribeSyntheticProbeListResponse() {}

  explicit DescribeSyntheticProbeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSyntheticProbeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSyntheticProbeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSyntheticProbeListResponse() = default;
};
class DescribeSystemEventAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeSystemEventAttributeRequest() {}

  explicit DescribeSystemEventAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSystemEventAttributeRequest() = default;
};
class DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> status{};
  shared_ptr<long> time{};

  DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent() {}

  explicit DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent() = default;
};
class DescribeSystemEventAttributeResponseBodySystemEvents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent>> systemEvent{};

  DescribeSystemEventAttributeResponseBodySystemEvents() {}

  explicit DescribeSystemEventAttributeResponseBodySystemEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemEvent) {
      vector<boost::any> temp1;
      for(auto item1:*systemEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemEvent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemEvent") != m.end() && !m["SystemEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemEvent"].type()) {
        vector<DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemEvent = make_shared<vector<DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemEventAttributeResponseBodySystemEvents() = default;
};
class DescribeSystemEventAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<DescribeSystemEventAttributeResponseBodySystemEvents> systemEvents{};

  DescribeSystemEventAttributeResponseBody() {}

  explicit DescribeSystemEventAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (systemEvents) {
      res["SystemEvents"] = systemEvents ? boost::any(systemEvents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SystemEvents") != m.end() && !m["SystemEvents"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemEvents"].type()) {
        DescribeSystemEventAttributeResponseBodySystemEvents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemEvents"]));
        systemEvents = make_shared<DescribeSystemEventAttributeResponseBodySystemEvents>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventAttributeResponseBody() = default;
};
class DescribeSystemEventAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemEventAttributeResponseBody> body{};

  DescribeSystemEventAttributeResponse() {}

  explicit DescribeSystemEventAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemEventAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemEventAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventAttributeResponse() = default;
};
class DescribeSystemEventCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeSystemEventCountRequest() {}

  explicit DescribeSystemEventCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSystemEventCountRequest() = default;
};
class DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<long> num{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> status{};
  shared_ptr<long> time{};

  DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount() {}

  explicit DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (num) {
      res["Num"] = boost::any(*num);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Num") != m.end() && !m["Num"].empty()) {
      num = make_shared<long>(boost::any_cast<long>(m["Num"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount() = default;
};
class DescribeSystemEventCountResponseBodySystemEventCounts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount>> systemEventCount{};

  DescribeSystemEventCountResponseBodySystemEventCounts() {}

  explicit DescribeSystemEventCountResponseBodySystemEventCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemEventCount) {
      vector<boost::any> temp1;
      for(auto item1:*systemEventCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemEventCount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemEventCount") != m.end() && !m["SystemEventCount"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemEventCount"].type()) {
        vector<DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemEventCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemEventCount = make_shared<vector<DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemEventCountResponseBodySystemEventCounts() = default;
};
class DescribeSystemEventCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<DescribeSystemEventCountResponseBodySystemEventCounts> systemEventCounts{};

  DescribeSystemEventCountResponseBody() {}

  explicit DescribeSystemEventCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (systemEventCounts) {
      res["SystemEventCounts"] = systemEventCounts ? boost::any(systemEventCounts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SystemEventCounts") != m.end() && !m["SystemEventCounts"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemEventCounts"].type()) {
        DescribeSystemEventCountResponseBodySystemEventCounts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemEventCounts"]));
        systemEventCounts = make_shared<DescribeSystemEventCountResponseBodySystemEventCounts>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventCountResponseBody() = default;
};
class DescribeSystemEventCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemEventCountResponseBody> body{};

  DescribeSystemEventCountResponse() {}

  explicit DescribeSystemEventCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemEventCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemEventCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventCountResponse() = default;
};
class DescribeSystemEventHistogramRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchKeywords{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeSystemEventHistogramRequest() {}

  explicit DescribeSystemEventHistogramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      searchKeywords = make_shared<string>(boost::any_cast<string>(m["SearchKeywords"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSystemEventHistogramRequest() = default;
};
class DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram() {}

  explicit DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram() = default;
};
class DescribeSystemEventHistogramResponseBodySystemEventHistograms : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram>> systemEventHistogram{};

  DescribeSystemEventHistogramResponseBodySystemEventHistograms() {}

  explicit DescribeSystemEventHistogramResponseBodySystemEventHistograms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemEventHistogram) {
      vector<boost::any> temp1;
      for(auto item1:*systemEventHistogram){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemEventHistogram"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemEventHistogram") != m.end() && !m["SystemEventHistogram"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemEventHistogram"].type()) {
        vector<DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemEventHistogram"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemEventHistogram = make_shared<vector<DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemEventHistogramResponseBodySystemEventHistograms() = default;
};
class DescribeSystemEventHistogramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<DescribeSystemEventHistogramResponseBodySystemEventHistograms> systemEventHistograms{};

  DescribeSystemEventHistogramResponseBody() {}

  explicit DescribeSystemEventHistogramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (systemEventHistograms) {
      res["SystemEventHistograms"] = systemEventHistograms ? boost::any(systemEventHistograms->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("SystemEventHistograms") != m.end() && !m["SystemEventHistograms"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemEventHistograms"].type()) {
        DescribeSystemEventHistogramResponseBodySystemEventHistograms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemEventHistograms"]));
        systemEventHistograms = make_shared<DescribeSystemEventHistogramResponseBodySystemEventHistograms>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventHistogramResponseBody() = default;
};
class DescribeSystemEventHistogramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemEventHistogramResponseBody> body{};

  DescribeSystemEventHistogramResponse() {}

  explicit DescribeSystemEventHistogramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemEventHistogramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemEventHistogramResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventHistogramResponse() = default;
};
class DescribeSystemEventMetaListRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeSystemEventMetaListRequest() {}

  explicit DescribeSystemEventMetaListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSystemEventMetaListRequest() = default;
};
class DescribeSystemEventMetaListResponseBodyDataResource : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> nameDesc{};
  shared_ptr<string> nameDesc_en{};
  shared_ptr<string> product{};
  shared_ptr<string> status{};
  shared_ptr<string> statusDesc{};

  DescribeSystemEventMetaListResponseBodyDataResource() {}

  explicit DescribeSystemEventMetaListResponseBodyDataResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameDesc) {
      res["NameDesc"] = boost::any(*nameDesc);
    }
    if (nameDesc_en) {
      res["NameDesc.En"] = boost::any(*nameDesc_en);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameDesc") != m.end() && !m["NameDesc"].empty()) {
      nameDesc = make_shared<string>(boost::any_cast<string>(m["NameDesc"]));
    }
    if (m.find("NameDesc.En") != m.end() && !m["NameDesc.En"].empty()) {
      nameDesc_en = make_shared<string>(boost::any_cast<string>(m["NameDesc.En"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
  }


  virtual ~DescribeSystemEventMetaListResponseBodyDataResource() = default;
};
class DescribeSystemEventMetaListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemEventMetaListResponseBodyDataResource>> resource{};

  DescribeSystemEventMetaListResponseBodyData() {}

  explicit DescribeSystemEventMetaListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      vector<boost::any> temp1;
      for(auto item1:*resource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(vector<boost::any>) == m["Resource"].type()) {
        vector<DescribeSystemEventMetaListResponseBodyDataResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemEventMetaListResponseBodyDataResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resource = make_shared<vector<DescribeSystemEventMetaListResponseBodyDataResource>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemEventMetaListResponseBodyData() = default;
};
class DescribeSystemEventMetaListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<DescribeSystemEventMetaListResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeSystemEventMetaListResponseBody() {}

  explicit DescribeSystemEventMetaListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSystemEventMetaListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSystemEventMetaListResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSystemEventMetaListResponseBody() = default;
};
class DescribeSystemEventMetaListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemEventMetaListResponseBody> body{};

  DescribeSystemEventMetaListResponse() {}

  explicit DescribeSystemEventMetaListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemEventMetaListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemEventMetaListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemEventMetaListResponse() = default;
};
class DescribeTagKeyListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeTagKeyListRequest() {}

  explicit DescribeTagKeyListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeTagKeyListRequest() = default;
};
class DescribeTagKeyListResponseBodyTagKeys : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tagKey{};

  DescribeTagKeyListResponseBodyTagKeys() {}

  explicit DescribeTagKeyListResponseBodyTagKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagKeyListResponseBodyTagKeys() = default;
};
class DescribeTagKeyListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTagKeyListResponseBodyTagKeys> tagKeys{};

  DescribeTagKeyListResponseBody() {}

  explicit DescribeTagKeyListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagKeys) {
      res["TagKeys"] = tagKeys ? boost::any(tagKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagKeys"].type()) {
        DescribeTagKeyListResponseBodyTagKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagKeys"]));
        tagKeys = make_shared<DescribeTagKeyListResponseBodyTagKeys>(model1);
      }
    }
  }


  virtual ~DescribeTagKeyListResponseBody() = default;
};
class DescribeTagKeyListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagKeyListResponseBody> body{};

  DescribeTagKeyListResponse() {}

  explicit DescribeTagKeyListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagKeyListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagKeyListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagKeyListResponse() = default;
};
class DescribeTagValueListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> tagKey{};

  DescribeTagValueListRequest() {}

  explicit DescribeTagValueListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
  }


  virtual ~DescribeTagValueListRequest() = default;
};
class DescribeTagValueListResponseBodyTagValues : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tagValue{};

  DescribeTagValueListResponseBodyTagValues() {}

  explicit DescribeTagValueListResponseBodyTagValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValue = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTagValueListResponseBodyTagValues() = default;
};
class DescribeTagValueListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTagValueListResponseBodyTagValues> tagValues{};

  DescribeTagValueListResponseBody() {}

  explicit DescribeTagValueListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tagValues) {
      res["TagValues"] = tagValues ? boost::any(tagValues->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagValues"].type()) {
        DescribeTagValueListResponseBodyTagValues model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagValues"]));
        tagValues = make_shared<DescribeTagValueListResponseBodyTagValues>(model1);
      }
    }
  }


  virtual ~DescribeTagValueListResponseBody() = default;
};
class DescribeTagValueListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTagValueListResponseBody> body{};

  DescribeTagValueListResponse() {}

  explicit DescribeTagValueListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTagValueListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTagValueListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTagValueListResponse() = default;
};
class DescribeUnhealthyHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> id{};
  shared_ptr<string> regionId{};

  DescribeUnhealthyHostAvailabilityRequest() {}

  explicit DescribeUnhealthyHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Id"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Id"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      id = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityRequest() = default;
};
class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList() {}

  explicit DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList() = default;
};
class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList> instanceList{};

  DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance() {}

  explicit DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceList) {
      res["InstanceList"] = instanceList ? boost::any(instanceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceList"].type()) {
        DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceList"]));
        instanceList = make_shared<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList>(model1);
      }
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance() = default;
};
class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance>> nodeTaskInstance{};

  DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList() {}

  explicit DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeTaskInstance) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTaskInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTaskInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeTaskInstance") != m.end() && !m["NodeTaskInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTaskInstance"].type()) {
        vector<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTaskInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTaskInstance = make_shared<vector<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance>>(expect1);
      }
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList() = default;
};
class DescribeUnhealthyHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList> unhealthyList{};

  DescribeUnhealthyHostAvailabilityResponseBody() {}

  explicit DescribeUnhealthyHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (unhealthyList) {
      res["UnhealthyList"] = unhealthyList ? boost::any(unhealthyList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UnhealthyList") != m.end() && !m["UnhealthyList"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnhealthyList"].type()) {
        DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnhealthyList"]));
        unhealthyList = make_shared<DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList>(model1);
      }
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityResponseBody() = default;
};
class DescribeUnhealthyHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUnhealthyHostAvailabilityResponseBody> body{};

  DescribeUnhealthyHostAvailabilityResponse() {}

  explicit DescribeUnhealthyHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUnhealthyHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUnhealthyHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUnhealthyHostAvailabilityResponse() = default;
};
class DisableActiveMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};

  DisableActiveMetricRuleRequest() {}

  explicit DisableActiveMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableActiveMetricRuleRequest() = default;
};
class DisableActiveMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableActiveMetricRuleResponseBody() {}

  explicit DisableActiveMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableActiveMetricRuleResponseBody() = default;
};
class DisableActiveMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableActiveMetricRuleResponseBody> body{};

  DisableActiveMetricRuleResponse() {}

  explicit DisableActiveMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableActiveMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableActiveMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableActiveMetricRuleResponse() = default;
};
class DisableEventRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> ruleNames{};

  DisableEventRulesRequest() {}

  explicit DisableEventRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DisableEventRulesRequest() = default;
};
class DisableEventRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableEventRulesResponseBody() {}

  explicit DisableEventRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableEventRulesResponseBody() = default;
};
class DisableEventRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableEventRulesResponseBody> body{};

  DisableEventRulesResponse() {}

  explicit DisableEventRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableEventRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableEventRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DisableEventRulesResponse() = default;
};
class DisableHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> id{};
  shared_ptr<string> regionId{};

  DisableHostAvailabilityRequest() {}

  explicit DisableHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Id"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Id"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      id = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableHostAvailabilityRequest() = default;
};
class DisableHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableHostAvailabilityResponseBody() {}

  explicit DisableHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableHostAvailabilityResponseBody() = default;
};
class DisableHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableHostAvailabilityResponseBody> body{};

  DisableHostAvailabilityResponse() {}

  explicit DisableHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~DisableHostAvailabilityResponse() = default;
};
class DisableMetricRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> ruleId{};

  DisableMetricRulesRequest() {}

  explicit DisableMetricRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DisableMetricRulesRequest() = default;
};
class DisableMetricRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DisableMetricRulesResponseBody() {}

  explicit DisableMetricRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableMetricRulesResponseBody() = default;
};
class DisableMetricRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableMetricRulesResponseBody> body{};

  DisableMetricRulesResponse() {}

  explicit DisableMetricRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableMetricRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableMetricRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DisableMetricRulesResponse() = default;
};
class DisableSiteMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIds{};

  DisableSiteMonitorsRequest() {}

  explicit DisableSiteMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~DisableSiteMonitorsRequest() = default;
};
class DisableSiteMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  DisableSiteMonitorsResponseBodyData() {}

  explicit DisableSiteMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~DisableSiteMonitorsResponseBodyData() = default;
};
class DisableSiteMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DisableSiteMonitorsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DisableSiteMonitorsResponseBody() {}

  explicit DisableSiteMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DisableSiteMonitorsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DisableSiteMonitorsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DisableSiteMonitorsResponseBody() = default;
};
class DisableSiteMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSiteMonitorsResponseBody> body{};

  DisableSiteMonitorsResponse() {}

  explicit DisableSiteMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSiteMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSiteMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSiteMonitorsResponse() = default;
};
class EnableActiveMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};

  EnableActiveMetricRuleRequest() {}

  explicit EnableActiveMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableActiveMetricRuleRequest() = default;
};
class EnableActiveMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableActiveMetricRuleResponseBody() {}

  explicit EnableActiveMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableActiveMetricRuleResponseBody() = default;
};
class EnableActiveMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableActiveMetricRuleResponseBody> body{};

  EnableActiveMetricRuleResponse() {}

  explicit EnableActiveMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableActiveMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableActiveMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableActiveMetricRuleResponse() = default;
};
class EnableEventRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> ruleNames{};

  EnableEventRulesRequest() {}

  explicit EnableEventRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleNames) {
      res["RuleNames"] = boost::any(*ruleNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleNames") != m.end() && !m["RuleNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableEventRulesRequest() = default;
};
class EnableEventRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableEventRulesResponseBody() {}

  explicit EnableEventRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableEventRulesResponseBody() = default;
};
class EnableEventRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableEventRulesResponseBody> body{};

  EnableEventRulesResponse() {}

  explicit EnableEventRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableEventRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableEventRulesResponseBody>(model1);
      }
    }
  }


  virtual ~EnableEventRulesResponse() = default;
};
class EnableHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> id{};
  shared_ptr<string> regionId{};

  EnableHostAvailabilityRequest() {}

  explicit EnableHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Id"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Id"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      id = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableHostAvailabilityRequest() = default;
};
class EnableHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableHostAvailabilityResponseBody() {}

  explicit EnableHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableHostAvailabilityResponseBody() = default;
};
class EnableHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableHostAvailabilityResponseBody> body{};

  EnableHostAvailabilityResponse() {}

  explicit EnableHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~EnableHostAvailabilityResponse() = default;
};
class EnableMetricRuleBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<bool> isEnable{};
  shared_ptr<string> regionId{};

  EnableMetricRuleBlackListRequest() {}

  explicit EnableMetricRuleBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<bool>(boost::any_cast<bool>(m["IsEnable"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableMetricRuleBlackListRequest() = default;
};
class EnableMetricRuleBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> count{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableMetricRuleBlackListResponseBody() {}

  explicit EnableMetricRuleBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableMetricRuleBlackListResponseBody() = default;
};
class EnableMetricRuleBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableMetricRuleBlackListResponseBody> body{};

  EnableMetricRuleBlackListResponse() {}

  explicit EnableMetricRuleBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableMetricRuleBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableMetricRuleBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~EnableMetricRuleBlackListResponse() = default;
};
class EnableMetricRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> ruleId{};

  EnableMetricRulesRequest() {}

  explicit EnableMetricRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~EnableMetricRulesRequest() = default;
};
class EnableMetricRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  EnableMetricRulesResponseBody() {}

  explicit EnableMetricRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EnableMetricRulesResponseBody() = default;
};
class EnableMetricRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableMetricRulesResponseBody> body{};

  EnableMetricRulesResponse() {}

  explicit EnableMetricRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableMetricRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableMetricRulesResponseBody>(model1);
      }
    }
  }


  virtual ~EnableMetricRulesResponse() = default;
};
class EnableSiteMonitorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> taskIds{};

  EnableSiteMonitorsRequest() {}

  explicit EnableSiteMonitorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
  }


  virtual ~EnableSiteMonitorsRequest() = default;
};
class EnableSiteMonitorsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  EnableSiteMonitorsResponseBodyData() {}

  explicit EnableSiteMonitorsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~EnableSiteMonitorsResponseBodyData() = default;
};
class EnableSiteMonitorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<EnableSiteMonitorsResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  EnableSiteMonitorsResponseBody() {}

  explicit EnableSiteMonitorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        EnableSiteMonitorsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<EnableSiteMonitorsResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~EnableSiteMonitorsResponseBody() = default;
};
class EnableSiteMonitorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSiteMonitorsResponseBody> body{};

  EnableSiteMonitorsResponse() {}

  explicit EnableSiteMonitorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSiteMonitorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSiteMonitorsResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSiteMonitorsResponse() = default;
};
class InstallMonitoringAgentRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> installCommand{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> regionId{};

  InstallMonitoringAgentRequest() {}

  explicit InstallMonitoringAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (installCommand) {
      res["InstallCommand"] = boost::any(*installCommand);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstallCommand") != m.end() && !m["InstallCommand"].empty()) {
      installCommand = make_shared<string>(boost::any_cast<string>(m["InstallCommand"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~InstallMonitoringAgentRequest() = default;
};
class InstallMonitoringAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallMonitoringAgentResponseBody() {}

  explicit InstallMonitoringAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallMonitoringAgentResponseBody() = default;
};
class InstallMonitoringAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallMonitoringAgentResponseBody> body{};

  InstallMonitoringAgentResponse() {}

  explicit InstallMonitoringAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallMonitoringAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallMonitoringAgentResponseBody>(model1);
      }
    }
  }


  virtual ~InstallMonitoringAgentResponse() = default;
};
class ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList() {}

  explicit ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList() = default;
};
class ModifyGroupMonitoringAgentProcessRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> escalationsLevel{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> silenceTime{};
  shared_ptr<string> statistics{};
  shared_ptr<vector<ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList>> targetList{};
  shared_ptr<string> threshold{};
  shared_ptr<string> times{};
  shared_ptr<string> webhook{};

  ModifyGroupMonitoringAgentProcessRequestAlertConfig() {}

  explicit ModifyGroupMonitoringAgentProcessRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (escalationsLevel) {
      res["EscalationsLevel"] = boost::any(*escalationsLevel);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EscalationsLevel") != m.end() && !m["EscalationsLevel"].empty()) {
      escalationsLevel = make_shared<string>(boost::any_cast<string>(m["EscalationsLevel"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<string>(boost::any_cast<string>(m["SilenceTime"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList>>(expect1);
      }
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<string>(boost::any_cast<string>(m["Times"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~ModifyGroupMonitoringAgentProcessRequestAlertConfig() = default;
};
class ModifyGroupMonitoringAgentProcessRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyGroupMonitoringAgentProcessRequestAlertConfig>> alertConfig{};
  shared_ptr<string> groupId{};
  shared_ptr<string> id{};
  shared_ptr<string> matchExpressFilterRelation{};
  shared_ptr<string> regionId{};

  ModifyGroupMonitoringAgentProcessRequest() {}

  explicit ModifyGroupMonitoringAgentProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfig"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (matchExpressFilterRelation) {
      res["MatchExpressFilterRelation"] = boost::any(*matchExpressFilterRelation);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfig"].type()) {
        vector<ModifyGroupMonitoringAgentProcessRequestAlertConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyGroupMonitoringAgentProcessRequestAlertConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfig = make_shared<vector<ModifyGroupMonitoringAgentProcessRequestAlertConfig>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MatchExpressFilterRelation") != m.end() && !m["MatchExpressFilterRelation"].empty()) {
      matchExpressFilterRelation = make_shared<string>(boost::any_cast<string>(m["MatchExpressFilterRelation"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyGroupMonitoringAgentProcessRequest() = default;
};
class ModifyGroupMonitoringAgentProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyGroupMonitoringAgentProcessResponseBody() {}

  explicit ModifyGroupMonitoringAgentProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyGroupMonitoringAgentProcessResponseBody() = default;
};
class ModifyGroupMonitoringAgentProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGroupMonitoringAgentProcessResponseBody> body{};

  ModifyGroupMonitoringAgentProcessResponse() {}

  explicit ModifyGroupMonitoringAgentProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGroupMonitoringAgentProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGroupMonitoringAgentProcessResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGroupMonitoringAgentProcessResponse() = default;
};
class ModifyHostAvailabilityRequestAlertConfig : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> notifyType{};
  shared_ptr<long> silenceTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> webHook{};

  ModifyHostAvailabilityRequestAlertConfig() {}

  explicit ModifyHostAvailabilityRequestAlertConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (notifyType) {
      res["NotifyType"] = boost::any(*notifyType);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (webHook) {
      res["WebHook"] = boost::any(*webHook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("NotifyType") != m.end() && !m["NotifyType"].empty()) {
      notifyType = make_shared<long>(boost::any_cast<long>(m["NotifyType"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("WebHook") != m.end() && !m["WebHook"].empty()) {
      webHook = make_shared<string>(boost::any_cast<string>(m["WebHook"]));
    }
  }


  virtual ~ModifyHostAvailabilityRequestAlertConfig() = default;
};
class ModifyHostAvailabilityRequestTaskOption : public Darabonba::Model {
public:
  shared_ptr<string> httpHeader{};
  shared_ptr<string> httpMethod{};
  shared_ptr<bool> httpNegative{};
  shared_ptr<string> httpPostContent{};
  shared_ptr<string> httpResponseCharset{};
  shared_ptr<string> httpResponseMatchContent{};
  shared_ptr<string> httpURI{};
  shared_ptr<long> interval{};
  shared_ptr<string> telnetOrPingHost{};

  ModifyHostAvailabilityRequestTaskOption() {}

  explicit ModifyHostAvailabilityRequestTaskOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpHeader) {
      res["HttpHeader"] = boost::any(*httpHeader);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpNegative) {
      res["HttpNegative"] = boost::any(*httpNegative);
    }
    if (httpPostContent) {
      res["HttpPostContent"] = boost::any(*httpPostContent);
    }
    if (httpResponseCharset) {
      res["HttpResponseCharset"] = boost::any(*httpResponseCharset);
    }
    if (httpResponseMatchContent) {
      res["HttpResponseMatchContent"] = boost::any(*httpResponseMatchContent);
    }
    if (httpURI) {
      res["HttpURI"] = boost::any(*httpURI);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (telnetOrPingHost) {
      res["TelnetOrPingHost"] = boost::any(*telnetOrPingHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpHeader") != m.end() && !m["HttpHeader"].empty()) {
      httpHeader = make_shared<string>(boost::any_cast<string>(m["HttpHeader"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpNegative") != m.end() && !m["HttpNegative"].empty()) {
      httpNegative = make_shared<bool>(boost::any_cast<bool>(m["HttpNegative"]));
    }
    if (m.find("HttpPostContent") != m.end() && !m["HttpPostContent"].empty()) {
      httpPostContent = make_shared<string>(boost::any_cast<string>(m["HttpPostContent"]));
    }
    if (m.find("HttpResponseCharset") != m.end() && !m["HttpResponseCharset"].empty()) {
      httpResponseCharset = make_shared<string>(boost::any_cast<string>(m["HttpResponseCharset"]));
    }
    if (m.find("HttpResponseMatchContent") != m.end() && !m["HttpResponseMatchContent"].empty()) {
      httpResponseMatchContent = make_shared<string>(boost::any_cast<string>(m["HttpResponseMatchContent"]));
    }
    if (m.find("HttpURI") != m.end() && !m["HttpURI"].empty()) {
      httpURI = make_shared<string>(boost::any_cast<string>(m["HttpURI"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("TelnetOrPingHost") != m.end() && !m["TelnetOrPingHost"].empty()) {
      telnetOrPingHost = make_shared<string>(boost::any_cast<string>(m["TelnetOrPingHost"]));
    }
  }


  virtual ~ModifyHostAvailabilityRequestTaskOption() = default;
};
class ModifyHostAvailabilityRequestAlertConfigEscalationList : public Darabonba::Model {
public:
  shared_ptr<string> aggregate{};
  shared_ptr<string> metricName{};
  shared_ptr<string> operator_{};
  shared_ptr<long> times{};
  shared_ptr<string> value{};

  ModifyHostAvailabilityRequestAlertConfigEscalationList() {}

  explicit ModifyHostAvailabilityRequestAlertConfigEscalationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregate) {
      res["Aggregate"] = boost::any(*aggregate);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregate") != m.end() && !m["Aggregate"].empty()) {
      aggregate = make_shared<string>(boost::any_cast<string>(m["Aggregate"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyHostAvailabilityRequestAlertConfigEscalationList() = default;
};
class ModifyHostAvailabilityRequestAlertConfigTargetList : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  ModifyHostAvailabilityRequestAlertConfigTargetList() {}

  explicit ModifyHostAvailabilityRequestAlertConfigTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~ModifyHostAvailabilityRequestAlertConfigTargetList() = default;
};
class ModifyHostAvailabilityRequest : public Darabonba::Model {
public:
  shared_ptr<ModifyHostAvailabilityRequestAlertConfig> alertConfig{};
  shared_ptr<ModifyHostAvailabilityRequestTaskOption> taskOption{};
  shared_ptr<vector<ModifyHostAvailabilityRequestAlertConfigEscalationList>> alertConfigEscalationList{};
  shared_ptr<vector<ModifyHostAvailabilityRequestAlertConfigTargetList>> alertConfigTargetList{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> instanceList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskScope{};

  ModifyHostAvailabilityRequest() {}

  explicit ModifyHostAvailabilityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfig) {
      res["AlertConfig"] = alertConfig ? boost::any(alertConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskOption) {
      res["TaskOption"] = taskOption ? boost::any(taskOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertConfigEscalationList) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfigEscalationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfigEscalationList"] = boost::any(temp1);
    }
    if (alertConfigTargetList) {
      vector<boost::any> temp1;
      for(auto item1:*alertConfigTargetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertConfigTargetList"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceList) {
      res["InstanceList"] = boost::any(*instanceList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskScope) {
      res["TaskScope"] = boost::any(*taskScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfig") != m.end() && !m["AlertConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertConfig"].type()) {
        ModifyHostAvailabilityRequestAlertConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertConfig"]));
        alertConfig = make_shared<ModifyHostAvailabilityRequestAlertConfig>(model1);
      }
    }
    if (m.find("TaskOption") != m.end() && !m["TaskOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskOption"].type()) {
        ModifyHostAvailabilityRequestTaskOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskOption"]));
        taskOption = make_shared<ModifyHostAvailabilityRequestTaskOption>(model1);
      }
    }
    if (m.find("AlertConfigEscalationList") != m.end() && !m["AlertConfigEscalationList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfigEscalationList"].type()) {
        vector<ModifyHostAvailabilityRequestAlertConfigEscalationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfigEscalationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHostAvailabilityRequestAlertConfigEscalationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfigEscalationList = make_shared<vector<ModifyHostAvailabilityRequestAlertConfigEscalationList>>(expect1);
      }
    }
    if (m.find("AlertConfigTargetList") != m.end() && !m["AlertConfigTargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertConfigTargetList"].type()) {
        vector<ModifyHostAvailabilityRequestAlertConfigTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertConfigTargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHostAvailabilityRequestAlertConfigTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertConfigTargetList = make_shared<vector<ModifyHostAvailabilityRequestAlertConfigTargetList>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskScope") != m.end() && !m["TaskScope"].empty()) {
      taskScope = make_shared<string>(boost::any_cast<string>(m["TaskScope"]));
    }
  }


  virtual ~ModifyHostAvailabilityRequest() = default;
};
class ModifyHostAvailabilityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyHostAvailabilityResponseBody() {}

  explicit ModifyHostAvailabilityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyHostAvailabilityResponseBody() = default;
};
class ModifyHostAvailabilityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostAvailabilityResponseBody> body{};

  ModifyHostAvailabilityResponse() {}

  explicit ModifyHostAvailabilityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostAvailabilityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostAvailabilityResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostAvailabilityResponse() = default;
};
class ModifyHostInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  ModifyHostInfoRequest() {}

  explicit ModifyHostInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyHostInfoRequest() = default;
};
class ModifyHostInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyHostInfoResponseBody() {}

  explicit ModifyHostInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyHostInfoResponseBody() = default;
};
class ModifyHostInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHostInfoResponseBody> body{};

  ModifyHostInfoResponse() {}

  explicit ModifyHostInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHostInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHostInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHostInfoResponse() = default;
};
class ModifyHybridMonitorNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spec{};

  ModifyHybridMonitorNamespaceRequest() {}

  explicit ModifyHybridMonitorNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ModifyHybridMonitorNamespaceRequest() = default;
};
class ModifyHybridMonitorNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyHybridMonitorNamespaceResponseBody() {}

  explicit ModifyHybridMonitorNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyHybridMonitorNamespaceResponseBody() = default;
};
class ModifyHybridMonitorNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridMonitorNamespaceResponseBody> body{};

  ModifyHybridMonitorNamespaceResponse() {}

  explicit ModifyHybridMonitorNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridMonitorNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridMonitorNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridMonitorNamespaceResponse() = default;
};
class ModifyHybridMonitorSLSGroupRequestSLSGroupConfig : public Darabonba::Model {
public:
  shared_ptr<string> SLSLogstore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> SLSUserId{};

  ModifyHybridMonitorSLSGroupRequestSLSGroupConfig() {}

  explicit ModifyHybridMonitorSLSGroupRequestSLSGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SLSLogstore) {
      res["SLSLogstore"] = boost::any(*SLSLogstore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (SLSUserId) {
      res["SLSUserId"] = boost::any(*SLSUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SLSLogstore") != m.end() && !m["SLSLogstore"].empty()) {
      SLSLogstore = make_shared<string>(boost::any_cast<string>(m["SLSLogstore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SLSUserId") != m.end() && !m["SLSUserId"].empty()) {
      SLSUserId = make_shared<string>(boost::any_cast<string>(m["SLSUserId"]));
    }
  }


  virtual ~ModifyHybridMonitorSLSGroupRequestSLSGroupConfig() = default;
};
class ModifyHybridMonitorSLSGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<ModifyHybridMonitorSLSGroupRequestSLSGroupConfig>> SLSGroupConfig{};
  shared_ptr<string> SLSGroupDescription{};
  shared_ptr<string> SLSGroupName{};

  ModifyHybridMonitorSLSGroupRequest() {}

  explicit ModifyHybridMonitorSLSGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSGroupConfig) {
      vector<boost::any> temp1;
      for(auto item1:*SLSGroupConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SLSGroupConfig"] = boost::any(temp1);
    }
    if (SLSGroupDescription) {
      res["SLSGroupDescription"] = boost::any(*SLSGroupDescription);
    }
    if (SLSGroupName) {
      res["SLSGroupName"] = boost::any(*SLSGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSGroupConfig") != m.end() && !m["SLSGroupConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SLSGroupConfig"].type()) {
        vector<ModifyHybridMonitorSLSGroupRequestSLSGroupConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SLSGroupConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorSLSGroupRequestSLSGroupConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SLSGroupConfig = make_shared<vector<ModifyHybridMonitorSLSGroupRequestSLSGroupConfig>>(expect1);
      }
    }
    if (m.find("SLSGroupDescription") != m.end() && !m["SLSGroupDescription"].empty()) {
      SLSGroupDescription = make_shared<string>(boost::any_cast<string>(m["SLSGroupDescription"]));
    }
    if (m.find("SLSGroupName") != m.end() && !m["SLSGroupName"].empty()) {
      SLSGroupName = make_shared<string>(boost::any_cast<string>(m["SLSGroupName"]));
    }
  }


  virtual ~ModifyHybridMonitorSLSGroupRequest() = default;
};
class ModifyHybridMonitorSLSGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyHybridMonitorSLSGroupResponseBody() {}

  explicit ModifyHybridMonitorSLSGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyHybridMonitorSLSGroupResponseBody() = default;
};
class ModifyHybridMonitorSLSGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridMonitorSLSGroupResponseBody> body{};

  ModifyHybridMonitorSLSGroupResponse() {}

  explicit ModifyHybridMonitorSLSGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridMonitorSLSGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridMonitorSLSGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridMonitorSLSGroupResponse() = default;
};
class ModifyHybridMonitorTaskRequestAttachLabels : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  ModifyHybridMonitorTaskRequestAttachLabels() {}

  explicit ModifyHybridMonitorTaskRequestAttachLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestAttachLabels() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfigExpress : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> express{};

  ModifyHybridMonitorTaskRequestSLSProcessConfigExpress() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfigExpress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (express) {
      res["Express"] = boost::any(*express);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      express = make_shared<string>(boost::any_cast<string>(m["Express"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfigExpress() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<string> SLSKeyName{};
  shared_ptr<string> value{};

  ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfigFilter : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters>> filters{};
  shared_ptr<string> relation{};

  ModifyHybridMonitorTaskRequestSLSProcessConfigFilter() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfigFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (relation) {
      res["Relation"] = boost::any(*relation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters>>(expect1);
      }
    }
    if (m.find("Relation") != m.end() && !m["Relation"].empty()) {
      relation = make_shared<string>(boost::any_cast<string>(m["Relation"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfigFilter() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> SLSKeyName{};

  ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> function{};
  shared_ptr<string> parameter1{};
  shared_ptr<string> parameter2{};
  shared_ptr<string> SLSKeyName{};

  ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (parameter1) {
      res["Parameter1"] = boost::any(*parameter1);
    }
    if (parameter2) {
      res["Parameter2"] = boost::any(*parameter2);
    }
    if (SLSKeyName) {
      res["SLSKeyName"] = boost::any(*SLSKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Parameter1") != m.end() && !m["Parameter1"].empty()) {
      parameter1 = make_shared<string>(boost::any_cast<string>(m["Parameter1"]));
    }
    if (m.find("Parameter2") != m.end() && !m["Parameter2"].empty()) {
      parameter2 = make_shared<string>(boost::any_cast<string>(m["Parameter2"]));
    }
    if (m.find("SLSKeyName") != m.end() && !m["SLSKeyName"].empty()) {
      SLSKeyName = make_shared<string>(boost::any_cast<string>(m["SLSKeyName"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics() = default;
};
class ModifyHybridMonitorTaskRequestSLSProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigExpress>> express{};
  shared_ptr<ModifyHybridMonitorTaskRequestSLSProcessConfigFilter> filter{};
  shared_ptr<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy>> groupBy{};
  shared_ptr<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics>> statistics{};

  ModifyHybridMonitorTaskRequestSLSProcessConfig() {}

  explicit ModifyHybridMonitorTaskRequestSLSProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (express) {
      vector<boost::any> temp1;
      for(auto item1:*express){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Express"] = boost::any(temp1);
    }
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupBy) {
      vector<boost::any> temp1;
      for(auto item1:*groupBy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupBy"] = boost::any(temp1);
    }
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Express") != m.end() && !m["Express"].empty()) {
      if (typeid(vector<boost::any>) == m["Express"].type()) {
        vector<ModifyHybridMonitorTaskRequestSLSProcessConfigExpress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Express"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorTaskRequestSLSProcessConfigExpress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        express = make_shared<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigExpress>>(expect1);
      }
    }
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        ModifyHybridMonitorTaskRequestSLSProcessConfigFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<ModifyHybridMonitorTaskRequestSLSProcessConfigFilter>(model1);
      }
    }
    if (m.find("GroupBy") != m.end() && !m["GroupBy"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupBy"].type()) {
        vector<ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupBy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupBy = make_shared<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy>>(expect1);
      }
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics>>(expect1);
      }
    }
  }


  virtual ~ModifyHybridMonitorTaskRequestSLSProcessConfig() = default;
};
class ModifyHybridMonitorTaskRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyHybridMonitorTaskRequestAttachLabels>> attachLabels{};
  shared_ptr<string> collectInterval{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<ModifyHybridMonitorTaskRequestSLSProcessConfig> SLSProcessConfig{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ModifyHybridMonitorTaskRequest() {}

  explicit ModifyHybridMonitorTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachLabels) {
      vector<boost::any> temp1;
      for(auto item1:*attachLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachLabels"] = boost::any(temp1);
    }
    if (collectInterval) {
      res["CollectInterval"] = boost::any(*collectInterval);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (SLSProcessConfig) {
      res["SLSProcessConfig"] = SLSProcessConfig ? boost::any(SLSProcessConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachLabels") != m.end() && !m["AttachLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachLabels"].type()) {
        vector<ModifyHybridMonitorTaskRequestAttachLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyHybridMonitorTaskRequestAttachLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachLabels = make_shared<vector<ModifyHybridMonitorTaskRequestAttachLabels>>(expect1);
      }
    }
    if (m.find("CollectInterval") != m.end() && !m["CollectInterval"].empty()) {
      collectInterval = make_shared<string>(boost::any_cast<string>(m["CollectInterval"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SLSProcessConfig") != m.end() && !m["SLSProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SLSProcessConfig"].type()) {
        ModifyHybridMonitorTaskRequestSLSProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SLSProcessConfig"]));
        SLSProcessConfig = make_shared<ModifyHybridMonitorTaskRequestSLSProcessConfig>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskRequest() = default;
};
class ModifyHybridMonitorTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifyHybridMonitorTaskResponseBody() {}

  explicit ModifyHybridMonitorTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifyHybridMonitorTaskResponseBody() = default;
};
class ModifyHybridMonitorTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridMonitorTaskResponseBody> body{};

  ModifyHybridMonitorTaskResponse() {}

  explicit ModifyHybridMonitorTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridMonitorTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridMonitorTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridMonitorTaskResponse() = default;
};
class ModifyMetricRuleBlackListRequestMetrics : public Darabonba::Model {
public:
  shared_ptr<string> metricName{};
  shared_ptr<string> resource{};

  ModifyMetricRuleBlackListRequestMetrics() {}

  explicit ModifyMetricRuleBlackListRequestMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~ModifyMetricRuleBlackListRequestMetrics() = default;
};
class ModifyMetricRuleBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> effectiveTime{};
  shared_ptr<string> enableEndTime{};
  shared_ptr<string> enableStartTime{};
  shared_ptr<string> id{};
  shared_ptr<vector<string>> instances{};
  shared_ptr<vector<ModifyMetricRuleBlackListRequestMetrics>> metrics{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> scopeType{};
  shared_ptr<string> scopeValue{};

  ModifyMetricRuleBlackListRequest() {}

  explicit ModifyMetricRuleBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (effectiveTime) {
      res["EffectiveTime"] = boost::any(*effectiveTime);
    }
    if (enableEndTime) {
      res["EnableEndTime"] = boost::any(*enableEndTime);
    }
    if (enableStartTime) {
      res["EnableStartTime"] = boost::any(*enableStartTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instances) {
      res["Instances"] = boost::any(*instances);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (scopeValue) {
      res["ScopeValue"] = boost::any(*scopeValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EffectiveTime") != m.end() && !m["EffectiveTime"].empty()) {
      effectiveTime = make_shared<string>(boost::any_cast<string>(m["EffectiveTime"]));
    }
    if (m.find("EnableEndTime") != m.end() && !m["EnableEndTime"].empty()) {
      enableEndTime = make_shared<string>(boost::any_cast<string>(m["EnableEndTime"]));
    }
    if (m.find("EnableStartTime") != m.end() && !m["EnableStartTime"].empty()) {
      enableStartTime = make_shared<string>(boost::any_cast<string>(m["EnableStartTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Instances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<ModifyMetricRuleBlackListRequestMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyMetricRuleBlackListRequestMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<ModifyMetricRuleBlackListRequestMetrics>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("ScopeValue") != m.end() && !m["ScopeValue"].empty()) {
      scopeValue = make_shared<string>(boost::any_cast<string>(m["ScopeValue"]));
    }
  }


  virtual ~ModifyMetricRuleBlackListRequest() = default;
};
class ModifyMetricRuleBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyMetricRuleBlackListResponseBody() {}

  explicit ModifyMetricRuleBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyMetricRuleBlackListResponseBody() = default;
};
class ModifyMetricRuleBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMetricRuleBlackListResponseBody> body{};

  ModifyMetricRuleBlackListResponse() {}

  explicit ModifyMetricRuleBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMetricRuleBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMetricRuleBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMetricRuleBlackListResponse() = default;
};
class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical() {}

  explicit ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical() = default;
};
class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo() {}

  explicit ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo() = default;
};
class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn() {}

  explicit ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn() = default;
};
class ModifyMetricRuleTemplateRequestAlertTemplatesEscalations : public Darabonba::Model {
public:
  shared_ptr<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical> critical{};
  shared_ptr<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo> info{};
  shared_ptr<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn> warn{};

  ModifyMetricRuleTemplateRequestAlertTemplatesEscalations() {}

  explicit ModifyMetricRuleTemplateRequestAlertTemplatesEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn>(model1);
      }
    }
  }


  virtual ~ModifyMetricRuleTemplateRequestAlertTemplatesEscalations() = default;
};
class ModifyMetricRuleTemplateRequestAlertTemplates : public Darabonba::Model {
public:
  shared_ptr<ModifyMetricRuleTemplateRequestAlertTemplatesEscalations> escalations{};
  shared_ptr<string> category{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> period{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> selector{};
  shared_ptr<string> webhook{};

  ModifyMetricRuleTemplateRequestAlertTemplates() {}

  explicit ModifyMetricRuleTemplateRequestAlertTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (selector) {
      res["Selector"] = boost::any(*selector);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        ModifyMetricRuleTemplateRequestAlertTemplatesEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<ModifyMetricRuleTemplateRequestAlertTemplatesEscalations>(model1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Selector") != m.end() && !m["Selector"].empty()) {
      selector = make_shared<string>(boost::any_cast<string>(m["Selector"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateRequestAlertTemplates() = default;
};
class ModifyMetricRuleTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyMetricRuleTemplateRequestAlertTemplates>> alertTemplates{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<long> restVersion{};
  shared_ptr<long> templateId{};

  ModifyMetricRuleTemplateRequest() {}

  explicit ModifyMetricRuleTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*alertTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertTemplates"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (restVersion) {
      res["RestVersion"] = boost::any(*restVersion);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertTemplates") != m.end() && !m["AlertTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertTemplates"].type()) {
        vector<ModifyMetricRuleTemplateRequestAlertTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyMetricRuleTemplateRequestAlertTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertTemplates = make_shared<vector<ModifyMetricRuleTemplateRequestAlertTemplates>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RestVersion") != m.end() && !m["RestVersion"].empty()) {
      restVersion = make_shared<long>(boost::any_cast<long>(m["RestVersion"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateRequest() = default;
};
class ModifyMetricRuleTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyMetricRuleTemplateResponseBody() {}

  explicit ModifyMetricRuleTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyMetricRuleTemplateResponseBody() = default;
};
class ModifyMetricRuleTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMetricRuleTemplateResponseBody> body{};

  ModifyMetricRuleTemplateResponse() {}

  explicit ModifyMetricRuleTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMetricRuleTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMetricRuleTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMetricRuleTemplateResponse() = default;
};
class ModifyMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroups{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};

  ModifyMonitorGroupRequest() {}

  explicit ModifyMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyMonitorGroupRequest() = default;
};
class ModifyMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyMonitorGroupResponseBody() {}

  explicit ModifyMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyMonitorGroupResponseBody() = default;
};
class ModifyMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMonitorGroupResponseBody> body{};

  ModifyMonitorGroupResponse() {}

  explicit ModifyMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMonitorGroupResponse() = default;
};
class ModifyMonitorGroupInstancesRequestInstances : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  ModifyMonitorGroupInstancesRequestInstances() {}

  explicit ModifyMonitorGroupInstancesRequestInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyMonitorGroupInstancesRequestInstances() = default;
};
class ModifyMonitorGroupInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<vector<ModifyMonitorGroupInstancesRequestInstances>> instances{};
  shared_ptr<string> regionId{};

  ModifyMonitorGroupInstancesRequest() {}

  explicit ModifyMonitorGroupInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ModifyMonitorGroupInstancesRequestInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyMonitorGroupInstancesRequestInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ModifyMonitorGroupInstancesRequestInstances>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyMonitorGroupInstancesRequest() = default;
};
class ModifyMonitorGroupInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyMonitorGroupInstancesResponseBody() {}

  explicit ModifyMonitorGroupInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyMonitorGroupInstancesResponseBody() = default;
};
class ModifyMonitorGroupInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMonitorGroupInstancesResponseBody> body{};

  ModifyMonitorGroupInstancesResponse() {}

  explicit ModifyMonitorGroupInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMonitorGroupInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMonitorGroupInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMonitorGroupInstancesResponse() = default;
};
class ModifySiteMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> alertIds{};
  shared_ptr<string> customSchedule{};
  shared_ptr<string> interval{};
  shared_ptr<string> intervalUnit{};
  shared_ptr<string> ispCities{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ModifySiteMonitorRequest() {}

  explicit ModifySiteMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (alertIds) {
      res["AlertIds"] = boost::any(*alertIds);
    }
    if (customSchedule) {
      res["CustomSchedule"] = boost::any(*customSchedule);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (intervalUnit) {
      res["IntervalUnit"] = boost::any(*intervalUnit);
    }
    if (ispCities) {
      res["IspCities"] = boost::any(*ispCities);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("AlertIds") != m.end() && !m["AlertIds"].empty()) {
      alertIds = make_shared<string>(boost::any_cast<string>(m["AlertIds"]));
    }
    if (m.find("CustomSchedule") != m.end() && !m["CustomSchedule"].empty()) {
      customSchedule = make_shared<string>(boost::any_cast<string>(m["CustomSchedule"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IntervalUnit") != m.end() && !m["IntervalUnit"].empty()) {
      intervalUnit = make_shared<string>(boost::any_cast<string>(m["IntervalUnit"]));
    }
    if (m.find("IspCities") != m.end() && !m["IspCities"].empty()) {
      ispCities = make_shared<string>(boost::any_cast<string>(m["IspCities"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ModifySiteMonitorRequest() = default;
};
class ModifySiteMonitorResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};

  ModifySiteMonitorResponseBodyData() {}

  explicit ModifySiteMonitorResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
  }


  virtual ~ModifySiteMonitorResponseBodyData() = default;
};
class ModifySiteMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ModifySiteMonitorResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  ModifySiteMonitorResponseBody() {}

  explicit ModifySiteMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifySiteMonitorResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifySiteMonitorResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~ModifySiteMonitorResponseBody() = default;
};
class ModifySiteMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySiteMonitorResponseBody> body{};

  ModifySiteMonitorResponse() {}

  explicit ModifySiteMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySiteMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySiteMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySiteMonitorResponse() = default;
};
class OpenCmsServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenCmsServiceResponseBody() {}

  explicit OpenCmsServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenCmsServiceResponseBody() = default;
};
class OpenCmsServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenCmsServiceResponseBody> body{};

  OpenCmsServiceResponse() {}

  explicit OpenCmsServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenCmsServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenCmsServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenCmsServiceResponse() = default;
};
class PutContactRequestChannels : public Darabonba::Model {
public:
  shared_ptr<string> aliIM{};
  shared_ptr<string> dingWebHook{};
  shared_ptr<string> mail{};
  shared_ptr<string> SMS{};

  PutContactRequestChannels() {}

  explicit PutContactRequestChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliIM) {
      res["AliIM"] = boost::any(*aliIM);
    }
    if (dingWebHook) {
      res["DingWebHook"] = boost::any(*dingWebHook);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (SMS) {
      res["SMS"] = boost::any(*SMS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliIM") != m.end() && !m["AliIM"].empty()) {
      aliIM = make_shared<string>(boost::any_cast<string>(m["AliIM"]));
    }
    if (m.find("DingWebHook") != m.end() && !m["DingWebHook"].empty()) {
      dingWebHook = make_shared<string>(boost::any_cast<string>(m["DingWebHook"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("SMS") != m.end() && !m["SMS"].empty()) {
      SMS = make_shared<string>(boost::any_cast<string>(m["SMS"]));
    }
  }


  virtual ~PutContactRequestChannels() = default;
};
class PutContactRequest : public Darabonba::Model {
public:
  shared_ptr<PutContactRequestChannels> channels{};
  shared_ptr<string> contactName{};
  shared_ptr<string> describe{};
  shared_ptr<string> lang{};

  PutContactRequest() {}

  explicit PutContactRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = channels ? boost::any(channels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channels"].type()) {
        PutContactRequestChannels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channels"]));
        channels = make_shared<PutContactRequestChannels>(model1);
      }
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~PutContactRequest() = default;
};
class PutContactResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutContactResponseBody() {}

  explicit PutContactResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutContactResponseBody() = default;
};
class PutContactResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutContactResponseBody> body{};

  PutContactResponse() {}

  explicit PutContactResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutContactResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutContactResponseBody>(model1);
      }
    }
  }


  virtual ~PutContactResponse() = default;
};
class PutContactGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<vector<string>> contactNames{};
  shared_ptr<string> describe{};
  shared_ptr<bool> enableSubscribed{};

  PutContactGroupRequest() {}

  explicit PutContactGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (contactNames) {
      res["ContactNames"] = boost::any(*contactNames);
    }
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (enableSubscribed) {
      res["EnableSubscribed"] = boost::any(*enableSubscribed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("ContactNames") != m.end() && !m["ContactNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContactNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContactNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contactNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("EnableSubscribed") != m.end() && !m["EnableSubscribed"].empty()) {
      enableSubscribed = make_shared<bool>(boost::any_cast<bool>(m["EnableSubscribed"]));
    }
  }


  virtual ~PutContactGroupRequest() = default;
};
class PutContactGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutContactGroupResponseBody() {}

  explicit PutContactGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutContactGroupResponseBody() = default;
};
class PutContactGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutContactGroupResponseBody> body{};

  PutContactGroupResponse() {}

  explicit PutContactGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutContactGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutContactGroupResponseBody>(model1);
      }
    }
  }


  virtual ~PutContactGroupResponse() = default;
};
class PutCustomEventRequestEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> eventName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> time{};

  PutCustomEventRequestEventInfo() {}

  explicit PutCustomEventRequestEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~PutCustomEventRequestEventInfo() = default;
};
class PutCustomEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutCustomEventRequestEventInfo>> eventInfo{};
  shared_ptr<string> regionId{};

  PutCustomEventRequest() {}

  explicit PutCustomEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventInfo) {
      vector<boost::any> temp1;
      for(auto item1:*eventInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventInfo"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["EventInfo"].type()) {
        vector<PutCustomEventRequestEventInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutCustomEventRequestEventInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventInfo = make_shared<vector<PutCustomEventRequestEventInfo>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutCustomEventRequest() = default;
};
class PutCustomEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PutCustomEventResponseBody() {}

  explicit PutCustomEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutCustomEventResponseBody() = default;
};
class PutCustomEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutCustomEventResponseBody> body{};

  PutCustomEventResponse() {}

  explicit PutCustomEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutCustomEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutCustomEventResponseBody>(model1);
      }
    }
  }


  virtual ~PutCustomEventResponse() = default;
};
class PutCustomEventRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactGroups{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> eventName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> period{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> threshold{};
  shared_ptr<string> webhook{};

  PutCustomEventRuleRequest() {}

  explicit PutCustomEventRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutCustomEventRuleRequest() = default;
};
class PutCustomEventRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutCustomEventRuleResponseBody() {}

  explicit PutCustomEventRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutCustomEventRuleResponseBody() = default;
};
class PutCustomEventRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutCustomEventRuleResponseBody> body{};

  PutCustomEventRuleResponse() {}

  explicit PutCustomEventRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutCustomEventRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutCustomEventRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutCustomEventRuleResponse() = default;
};
class PutCustomMetricRequestMetricList : public Darabonba::Model {
public:
  shared_ptr<string> dimensions{};
  shared_ptr<string> groupId{};
  shared_ptr<string> metricName{};
  shared_ptr<string> period{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  PutCustomMetricRequestMetricList() {}

  explicit PutCustomMetricRequestMetricList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~PutCustomMetricRequestMetricList() = default;
};
class PutCustomMetricRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutCustomMetricRequestMetricList>> metricList{};
  shared_ptr<string> regionId{};

  PutCustomMetricRequest() {}

  explicit PutCustomMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricList) {
      vector<boost::any> temp1;
      for(auto item1:*metricList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetricList"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricList") != m.end() && !m["MetricList"].empty()) {
      if (typeid(vector<boost::any>) == m["MetricList"].type()) {
        vector<PutCustomMetricRequestMetricList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetricList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutCustomMetricRequestMetricList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricList = make_shared<vector<PutCustomMetricRequestMetricList>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutCustomMetricRequest() = default;
};
class PutCustomMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PutCustomMetricResponseBody() {}

  explicit PutCustomMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutCustomMetricResponseBody() = default;
};
class PutCustomMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutCustomMetricResponseBody> body{};

  PutCustomMetricResponse() {}

  explicit PutCustomMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutCustomMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutCustomMetricResponseBody>(model1);
      }
    }
  }


  virtual ~PutCustomMetricResponse() = default;
};
class PutCustomMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<long> evaluationCount{};
  shared_ptr<string> groupId{};
  shared_ptr<string> level{};
  shared_ptr<string> metricName{};
  shared_ptr<string> period{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<string> webhook{};

  PutCustomMetricRuleRequest() {}

  explicit PutCustomMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (evaluationCount) {
      res["EvaluationCount"] = boost::any(*evaluationCount);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("EvaluationCount") != m.end() && !m["EvaluationCount"].empty()) {
      evaluationCount = make_shared<long>(boost::any_cast<long>(m["EvaluationCount"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutCustomMetricRuleRequest() = default;
};
class PutCustomMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutCustomMetricRuleResponseBody() {}

  explicit PutCustomMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutCustomMetricRuleResponseBody() = default;
};
class PutCustomMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutCustomMetricRuleResponseBody> body{};

  PutCustomMetricRuleResponse() {}

  explicit PutCustomMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutCustomMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutCustomMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutCustomMetricRuleResponse() = default;
};
class PutEventRuleRequestEventPattern : public Darabonba::Model {
public:
  shared_ptr<string> customFilters{};
  shared_ptr<vector<string>> eventTypeList{};
  shared_ptr<vector<string>> levelList{};
  shared_ptr<vector<string>> nameList{};
  shared_ptr<string> product{};
  shared_ptr<string> SQLFilter{};
  shared_ptr<vector<string>> statusList{};

  PutEventRuleRequestEventPattern() {}

  explicit PutEventRuleRequestEventPattern(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customFilters) {
      res["CustomFilters"] = boost::any(*customFilters);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    if (levelList) {
      res["LevelList"] = boost::any(*levelList);
    }
    if (nameList) {
      res["NameList"] = boost::any(*nameList);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (SQLFilter) {
      res["SQLFilter"] = boost::any(*SQLFilter);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomFilters") != m.end() && !m["CustomFilters"].empty()) {
      customFilters = make_shared<string>(boost::any_cast<string>(m["CustomFilters"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NameList") != m.end() && !m["NameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("SQLFilter") != m.end() && !m["SQLFilter"].empty()) {
      SQLFilter = make_shared<string>(boost::any_cast<string>(m["SQLFilter"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PutEventRuleRequestEventPattern() = default;
};
class PutEventRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<PutEventRuleRequestEventPattern>> eventPattern{};
  shared_ptr<string> eventType{};
  shared_ptr<string> groupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> state{};

  PutEventRuleRequest() {}

  explicit PutEventRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (eventPattern) {
      vector<boost::any> temp1;
      for(auto item1:*eventPattern){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventPattern"] = boost::any(temp1);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EventPattern") != m.end() && !m["EventPattern"].empty()) {
      if (typeid(vector<boost::any>) == m["EventPattern"].type()) {
        vector<PutEventRuleRequestEventPattern> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventPattern"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleRequestEventPattern model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventPattern = make_shared<vector<PutEventRuleRequestEventPattern>>(expect1);
      }
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~PutEventRuleRequest() = default;
};
class PutEventRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutEventRuleResponseBody() {}

  explicit PutEventRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutEventRuleResponseBody() = default;
};
class PutEventRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutEventRuleResponseBody> body{};

  PutEventRuleResponse() {}

  explicit PutEventRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutEventRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutEventRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutEventRuleResponse() = default;
};
class PutEventRuleTargetsRequestContactParameters : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<string> id{};
  shared_ptr<string> level{};

  PutEventRuleTargetsRequestContactParameters() {}

  explicit PutEventRuleTargetsRequestContactParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestContactParameters() = default;
};
class PutEventRuleTargetsRequestFcParameters : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> id{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};

  PutEventRuleTargetsRequestFcParameters() {}

  explicit PutEventRuleTargetsRequestFcParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestFcParameters() = default;
};
class PutEventRuleTargetsRequestMnsParameters : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> queue{};
  shared_ptr<string> region{};
  shared_ptr<string> topic{};

  PutEventRuleTargetsRequestMnsParameters() {}

  explicit PutEventRuleTargetsRequestMnsParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestMnsParameters() = default;
};
class PutEventRuleTargetsRequestOpenApiParameters : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> product{};
  shared_ptr<string> region{};
  shared_ptr<string> role{};
  shared_ptr<string> version{};

  PutEventRuleTargetsRequestOpenApiParameters() {}

  explicit PutEventRuleTargetsRequestOpenApiParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestOpenApiParameters() = default;
};
class PutEventRuleTargetsRequestSlsParameters : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  PutEventRuleTargetsRequestSlsParameters() {}

  explicit PutEventRuleTargetsRequestSlsParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestSlsParameters() = default;
};
class PutEventRuleTargetsRequestWebhookParameters : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> method{};
  shared_ptr<string> protocol{};
  shared_ptr<string> url{};

  PutEventRuleTargetsRequestWebhookParameters() {}

  explicit PutEventRuleTargetsRequestWebhookParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~PutEventRuleTargetsRequestWebhookParameters() = default;
};
class PutEventRuleTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutEventRuleTargetsRequestContactParameters>> contactParameters{};
  shared_ptr<vector<PutEventRuleTargetsRequestFcParameters>> fcParameters{};
  shared_ptr<vector<PutEventRuleTargetsRequestMnsParameters>> mnsParameters{};
  shared_ptr<vector<PutEventRuleTargetsRequestOpenApiParameters>> openApiParameters{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<PutEventRuleTargetsRequestSlsParameters>> slsParameters{};
  shared_ptr<vector<PutEventRuleTargetsRequestWebhookParameters>> webhookParameters{};

  PutEventRuleTargetsRequest() {}

  explicit PutEventRuleTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactParameters) {
      vector<boost::any> temp1;
      for(auto item1:*contactParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactParameters"] = boost::any(temp1);
    }
    if (fcParameters) {
      vector<boost::any> temp1;
      for(auto item1:*fcParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FcParameters"] = boost::any(temp1);
    }
    if (mnsParameters) {
      vector<boost::any> temp1;
      for(auto item1:*mnsParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MnsParameters"] = boost::any(temp1);
    }
    if (openApiParameters) {
      vector<boost::any> temp1;
      for(auto item1:*openApiParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpenApiParameters"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (slsParameters) {
      vector<boost::any> temp1;
      for(auto item1:*slsParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlsParameters"] = boost::any(temp1);
    }
    if (webhookParameters) {
      vector<boost::any> temp1;
      for(auto item1:*webhookParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WebhookParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactParameters") != m.end() && !m["ContactParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactParameters"].type()) {
        vector<PutEventRuleTargetsRequestContactParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestContactParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactParameters = make_shared<vector<PutEventRuleTargetsRequestContactParameters>>(expect1);
      }
    }
    if (m.find("FcParameters") != m.end() && !m["FcParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["FcParameters"].type()) {
        vector<PutEventRuleTargetsRequestFcParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FcParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestFcParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fcParameters = make_shared<vector<PutEventRuleTargetsRequestFcParameters>>(expect1);
      }
    }
    if (m.find("MnsParameters") != m.end() && !m["MnsParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["MnsParameters"].type()) {
        vector<PutEventRuleTargetsRequestMnsParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MnsParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestMnsParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mnsParameters = make_shared<vector<PutEventRuleTargetsRequestMnsParameters>>(expect1);
      }
    }
    if (m.find("OpenApiParameters") != m.end() && !m["OpenApiParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["OpenApiParameters"].type()) {
        vector<PutEventRuleTargetsRequestOpenApiParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpenApiParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestOpenApiParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        openApiParameters = make_shared<vector<PutEventRuleTargetsRequestOpenApiParameters>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SlsParameters") != m.end() && !m["SlsParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["SlsParameters"].type()) {
        vector<PutEventRuleTargetsRequestSlsParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlsParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestSlsParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slsParameters = make_shared<vector<PutEventRuleTargetsRequestSlsParameters>>(expect1);
      }
    }
    if (m.find("WebhookParameters") != m.end() && !m["WebhookParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WebhookParameters"].type()) {
        vector<PutEventRuleTargetsRequestWebhookParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WebhookParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsRequestWebhookParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        webhookParameters = make_shared<vector<PutEventRuleTargetsRequestWebhookParameters>>(expect1);
      }
    }
  }


  virtual ~PutEventRuleTargetsRequest() = default;
};
class PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter : public Darabonba::Model {
public:
  shared_ptr<string> contactGroupName{};
  shared_ptr<long> id{};
  shared_ptr<string> level{};

  PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter() {}

  explicit PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactGroupName) {
      res["ContactGroupName"] = boost::any(*contactGroupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactGroupName") != m.end() && !m["ContactGroupName"].empty()) {
      contactGroupName = make_shared<string>(boost::any_cast<string>(m["ContactGroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter() = default;
};
class PutEventRuleTargetsResponseBodyFailedContactParameters : public Darabonba::Model {
public:
  shared_ptr<vector<PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter>> contactParameter{};

  PutEventRuleTargetsResponseBodyFailedContactParameters() {}

  explicit PutEventRuleTargetsResponseBodyFailedContactParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactParameter) {
      vector<boost::any> temp1;
      for(auto item1:*contactParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactParameter") != m.end() && !m["ContactParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactParameter"].type()) {
        vector<PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactParameter = make_shared<vector<PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter>>(expect1);
      }
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedContactParameters() = default;
};
class PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<long> id{};
  shared_ptr<string> region{};
  shared_ptr<string> serviceName{};

  PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter() {}

  explicit PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter() = default;
};
class PutEventRuleTargetsResponseBodyFailedFcParameters : public Darabonba::Model {
public:
  shared_ptr<vector<PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter>> fcParameter{};

  PutEventRuleTargetsResponseBodyFailedFcParameters() {}

  explicit PutEventRuleTargetsResponseBodyFailedFcParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcParameter) {
      vector<boost::any> temp1;
      for(auto item1:*fcParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FcParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcParameter") != m.end() && !m["FcParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["FcParameter"].type()) {
        vector<PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FcParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fcParameter = make_shared<vector<PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter>>(expect1);
      }
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedFcParameters() = default;
};
class PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> queue{};
  shared_ptr<string> region{};

  PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter() {}

  explicit PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (queue) {
      res["Queue"] = boost::any(*queue);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Queue") != m.end() && !m["Queue"].empty()) {
      queue = make_shared<string>(boost::any_cast<string>(m["Queue"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter() = default;
};
class PutEventRuleTargetsResponseBodyFailedMnsParameters : public Darabonba::Model {
public:
  shared_ptr<vector<PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter>> mnsParameter{};

  PutEventRuleTargetsResponseBodyFailedMnsParameters() {}

  explicit PutEventRuleTargetsResponseBodyFailedMnsParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mnsParameter) {
      vector<boost::any> temp1;
      for(auto item1:*mnsParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MnsParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MnsParameter") != m.end() && !m["MnsParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["MnsParameter"].type()) {
        vector<PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MnsParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mnsParameter = make_shared<vector<PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter>>(expect1);
      }
    }
  }


  virtual ~PutEventRuleTargetsResponseBodyFailedMnsParameters() = default;
};
class PutEventRuleTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PutEventRuleTargetsResponseBodyFailedContactParameters> failedContactParameters{};
  shared_ptr<PutEventRuleTargetsResponseBodyFailedFcParameters> failedFcParameters{};
  shared_ptr<PutEventRuleTargetsResponseBodyFailedMnsParameters> failedMnsParameters{};
  shared_ptr<string> failedParameterCount{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutEventRuleTargetsResponseBody() {}

  explicit PutEventRuleTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failedContactParameters) {
      res["FailedContactParameters"] = failedContactParameters ? boost::any(failedContactParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedFcParameters) {
      res["FailedFcParameters"] = failedFcParameters ? boost::any(failedFcParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedMnsParameters) {
      res["FailedMnsParameters"] = failedMnsParameters ? boost::any(failedMnsParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedParameterCount) {
      res["FailedParameterCount"] = boost::any(*failedParameterCount);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailedContactParameters") != m.end() && !m["FailedContactParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedContactParameters"].type()) {
        PutEventRuleTargetsResponseBodyFailedContactParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedContactParameters"]));
        failedContactParameters = make_shared<PutEventRuleTargetsResponseBodyFailedContactParameters>(model1);
      }
    }
    if (m.find("FailedFcParameters") != m.end() && !m["FailedFcParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedFcParameters"].type()) {
        PutEventRuleTargetsResponseBodyFailedFcParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedFcParameters"]));
        failedFcParameters = make_shared<PutEventRuleTargetsResponseBodyFailedFcParameters>(model1);
      }
    }
    if (m.find("FailedMnsParameters") != m.end() && !m["FailedMnsParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedMnsParameters"].type()) {
        PutEventRuleTargetsResponseBodyFailedMnsParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedMnsParameters"]));
        failedMnsParameters = make_shared<PutEventRuleTargetsResponseBodyFailedMnsParameters>(model1);
      }
    }
    if (m.find("FailedParameterCount") != m.end() && !m["FailedParameterCount"].empty()) {
      failedParameterCount = make_shared<string>(boost::any_cast<string>(m["FailedParameterCount"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutEventRuleTargetsResponseBody() = default;
};
class PutEventRuleTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutEventRuleTargetsResponseBody> body{};

  PutEventRuleTargetsResponse() {}

  explicit PutEventRuleTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutEventRuleTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutEventRuleTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~PutEventRuleTargetsResponse() = default;
};
class PutExporterOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> configJson{};
  shared_ptr<string> desc{};
  shared_ptr<string> destName{};
  shared_ptr<string> destType{};
  shared_ptr<string> regionId{};

  PutExporterOutputRequest() {}

  explicit PutExporterOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configJson) {
      res["ConfigJson"] = boost::any(*configJson);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigJson") != m.end() && !m["ConfigJson"].empty()) {
      configJson = make_shared<string>(boost::any_cast<string>(m["ConfigJson"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutExporterOutputRequest() = default;
};
class PutExporterOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutExporterOutputResponseBody() {}

  explicit PutExporterOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutExporterOutputResponseBody() = default;
};
class PutExporterOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutExporterOutputResponseBody> body{};

  PutExporterOutputResponse() {}

  explicit PutExporterOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutExporterOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutExporterOutputResponseBody>(model1);
      }
    }
  }


  virtual ~PutExporterOutputResponse() = default;
};
class PutExporterRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> describe{};
  shared_ptr<vector<string>> dstNames{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> targetWindows{};

  PutExporterRuleRequest() {}

  explicit PutExporterRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (describe) {
      res["Describe"] = boost::any(*describe);
    }
    if (dstNames) {
      res["DstNames"] = boost::any(*dstNames);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (targetWindows) {
      res["TargetWindows"] = boost::any(*targetWindows);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Describe") != m.end() && !m["Describe"].empty()) {
      describe = make_shared<string>(boost::any_cast<string>(m["Describe"]));
    }
    if (m.find("DstNames") != m.end() && !m["DstNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DstNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DstNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dstNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TargetWindows") != m.end() && !m["TargetWindows"].empty()) {
      targetWindows = make_shared<string>(boost::any_cast<string>(m["TargetWindows"]));
    }
  }


  virtual ~PutExporterRuleRequest() = default;
};
class PutExporterRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutExporterRuleResponseBody() {}

  explicit PutExporterRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutExporterRuleResponseBody() = default;
};
class PutExporterRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutExporterRuleResponseBody> body{};

  PutExporterRuleResponse() {}

  explicit PutExporterRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutExporterRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutExporterRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutExporterRuleResponse() = default;
};
class PutGroupMetricRuleRequestEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutGroupMetricRuleRequestEscalationsCritical() {}

  explicit PutGroupMetricRuleRequestEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutGroupMetricRuleRequestEscalationsCritical() = default;
};
class PutGroupMetricRuleRequestEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutGroupMetricRuleRequestEscalationsInfo() {}

  explicit PutGroupMetricRuleRequestEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutGroupMetricRuleRequestEscalationsInfo() = default;
};
class PutGroupMetricRuleRequestEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutGroupMetricRuleRequestEscalationsWarn() {}

  explicit PutGroupMetricRuleRequestEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutGroupMetricRuleRequestEscalationsWarn() = default;
};
class PutGroupMetricRuleRequestEscalations : public Darabonba::Model {
public:
  shared_ptr<PutGroupMetricRuleRequestEscalationsCritical> critical{};
  shared_ptr<PutGroupMetricRuleRequestEscalationsInfo> info{};
  shared_ptr<PutGroupMetricRuleRequestEscalationsWarn> warn{};

  PutGroupMetricRuleRequestEscalations() {}

  explicit PutGroupMetricRuleRequestEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        PutGroupMetricRuleRequestEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<PutGroupMetricRuleRequestEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        PutGroupMetricRuleRequestEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<PutGroupMetricRuleRequestEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        PutGroupMetricRuleRequestEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<PutGroupMetricRuleRequestEscalationsWarn>(model1);
      }
    }
  }


  virtual ~PutGroupMetricRuleRequestEscalations() = default;
};
class PutGroupMetricRuleRequestLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutGroupMetricRuleRequestLabels() {}

  explicit PutGroupMetricRuleRequestLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutGroupMetricRuleRequestLabels() = default;
};
class PutGroupMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<PutGroupMetricRuleRequestEscalations> escalations{};
  shared_ptr<string> category{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> dimensions{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> extraDimensionJson{};
  shared_ptr<string> groupId{};
  shared_ptr<string> interval{};
  shared_ptr<vector<PutGroupMetricRuleRequestLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> options{};
  shared_ptr<string> period{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> webhook{};

  PutGroupMetricRuleRequest() {}

  explicit PutGroupMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (dimensions) {
      res["Dimensions"] = boost::any(*dimensions);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (extraDimensionJson) {
      res["ExtraDimensionJson"] = boost::any(*extraDimensionJson);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        PutGroupMetricRuleRequestEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<PutGroupMetricRuleRequestEscalations>(model1);
      }
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("Dimensions") != m.end() && !m["Dimensions"].empty()) {
      dimensions = make_shared<string>(boost::any_cast<string>(m["Dimensions"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("ExtraDimensionJson") != m.end() && !m["ExtraDimensionJson"].empty()) {
      extraDimensionJson = make_shared<string>(boost::any_cast<string>(m["ExtraDimensionJson"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<PutGroupMetricRuleRequestLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutGroupMetricRuleRequestLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<PutGroupMetricRuleRequestLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutGroupMetricRuleRequest() = default;
};
class PutGroupMetricRuleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};

  PutGroupMetricRuleResponseBodyResult() {}

  explicit PutGroupMetricRuleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~PutGroupMetricRuleResponseBodyResult() = default;
};
class PutGroupMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<PutGroupMetricRuleResponseBodyResult> result{};
  shared_ptr<bool> success{};

  PutGroupMetricRuleResponseBody() {}

  explicit PutGroupMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        PutGroupMetricRuleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<PutGroupMetricRuleResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutGroupMetricRuleResponseBody() = default;
};
class PutGroupMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutGroupMetricRuleResponseBody> body{};

  PutGroupMetricRuleResponse() {}

  explicit PutGroupMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutGroupMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutGroupMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutGroupMetricRuleResponse() = default;
};
class PutHybridMonitorMetricDataRequestMetricListLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutHybridMonitorMetricDataRequestMetricListLabels() {}

  explicit PutHybridMonitorMetricDataRequestMetricListLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutHybridMonitorMetricDataRequestMetricListLabels() = default;
};
class PutHybridMonitorMetricDataRequestMetricList : public Darabonba::Model {
public:
  shared_ptr<vector<PutHybridMonitorMetricDataRequestMetricListLabels>> labels{};
  shared_ptr<string> name{};
  shared_ptr<long> TS{};
  shared_ptr<string> value{};

  PutHybridMonitorMetricDataRequestMetricList() {}

  explicit PutHybridMonitorMetricDataRequestMetricList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (TS) {
      res["TS"] = boost::any(*TS);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<PutHybridMonitorMetricDataRequestMetricListLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutHybridMonitorMetricDataRequestMetricListLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<PutHybridMonitorMetricDataRequestMetricListLabels>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TS") != m.end() && !m["TS"].empty()) {
      TS = make_shared<long>(boost::any_cast<long>(m["TS"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutHybridMonitorMetricDataRequestMetricList() = default;
};
class PutHybridMonitorMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutHybridMonitorMetricDataRequestMetricList>> metricList{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> regionId{};

  PutHybridMonitorMetricDataRequest() {}

  explicit PutHybridMonitorMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metricList) {
      vector<boost::any> temp1;
      for(auto item1:*metricList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MetricList"] = boost::any(temp1);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetricList") != m.end() && !m["MetricList"].empty()) {
      if (typeid(vector<boost::any>) == m["MetricList"].type()) {
        vector<PutHybridMonitorMetricDataRequestMetricList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MetricList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutHybridMonitorMetricDataRequestMetricList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metricList = make_shared<vector<PutHybridMonitorMetricDataRequestMetricList>>(expect1);
      }
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutHybridMonitorMetricDataRequest() = default;
};
class PutHybridMonitorMetricDataResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<long> index{};

  PutHybridMonitorMetricDataResponseBodyErrorDetail() {}

  explicit PutHybridMonitorMetricDataResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
  }


  virtual ~PutHybridMonitorMetricDataResponseBodyErrorDetail() = default;
};
class PutHybridMonitorMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<PutHybridMonitorMetricDataResponseBodyErrorDetail>> errorDetail{};
  shared_ptr<string> requestId{};

  PutHybridMonitorMetricDataResponseBody() {}

  explicit PutHybridMonitorMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (errorDetail) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetail"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetail"].type()) {
        vector<PutHybridMonitorMetricDataResponseBodyErrorDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutHybridMonitorMetricDataResponseBodyErrorDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetail = make_shared<vector<PutHybridMonitorMetricDataResponseBodyErrorDetail>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PutHybridMonitorMetricDataResponseBody() = default;
};
class PutHybridMonitorMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutHybridMonitorMetricDataResponseBody> body{};

  PutHybridMonitorMetricDataResponse() {}

  explicit PutHybridMonitorMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutHybridMonitorMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutHybridMonitorMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~PutHybridMonitorMetricDataResponse() = default;
};
class PutLogMonitorRequestAggregates : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> function{};

  PutLogMonitorRequestAggregates() {}

  explicit PutLogMonitorRequestAggregates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (function) {
      res["Function"] = boost::any(*function);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
  }


  virtual ~PutLogMonitorRequestAggregates() = default;
};
class PutLogMonitorRequestGroupbys : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> fieldName{};

  PutLogMonitorRequestGroupbys() {}

  explicit PutLogMonitorRequestGroupbys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
  }


  virtual ~PutLogMonitorRequestGroupbys() = default;
};
class PutLogMonitorRequestValueFilter : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operator_{};
  shared_ptr<string> value{};

  PutLogMonitorRequestValueFilter() {}

  explicit PutLogMonitorRequestValueFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutLogMonitorRequestValueFilter() = default;
};
class PutLogMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutLogMonitorRequestAggregates>> aggregates{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<PutLogMonitorRequestGroupbys>> groupbys{};
  shared_ptr<string> logId{};
  shared_ptr<string> metricExpress{};
  shared_ptr<string> metricName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogstore{};
  shared_ptr<string> slsProject{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<string> tumblingwindows{};
  shared_ptr<string> unit{};
  shared_ptr<vector<PutLogMonitorRequestValueFilter>> valueFilter{};
  shared_ptr<string> valueFilterRelation{};

  PutLogMonitorRequest() {}

  explicit PutLogMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregates) {
      vector<boost::any> temp1;
      for(auto item1:*aggregates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregates"] = boost::any(temp1);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupbys) {
      vector<boost::any> temp1;
      for(auto item1:*groupbys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groupbys"] = boost::any(temp1);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (metricExpress) {
      res["MetricExpress"] = boost::any(*metricExpress);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogstore) {
      res["SlsLogstore"] = boost::any(*slsLogstore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (tumblingwindows) {
      res["Tumblingwindows"] = boost::any(*tumblingwindows);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (valueFilter) {
      vector<boost::any> temp1;
      for(auto item1:*valueFilter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ValueFilter"] = boost::any(temp1);
    }
    if (valueFilterRelation) {
      res["ValueFilterRelation"] = boost::any(*valueFilterRelation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregates") != m.end() && !m["Aggregates"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregates"].type()) {
        vector<PutLogMonitorRequestAggregates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutLogMonitorRequestAggregates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregates = make_shared<vector<PutLogMonitorRequestAggregates>>(expect1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Groupbys") != m.end() && !m["Groupbys"].empty()) {
      if (typeid(vector<boost::any>) == m["Groupbys"].type()) {
        vector<PutLogMonitorRequestGroupbys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groupbys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutLogMonitorRequestGroupbys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupbys = make_shared<vector<PutLogMonitorRequestGroupbys>>(expect1);
      }
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<string>(boost::any_cast<string>(m["LogId"]));
    }
    if (m.find("MetricExpress") != m.end() && !m["MetricExpress"].empty()) {
      metricExpress = make_shared<string>(boost::any_cast<string>(m["MetricExpress"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogstore") != m.end() && !m["SlsLogstore"].empty()) {
      slsLogstore = make_shared<string>(boost::any_cast<string>(m["SlsLogstore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("Tumblingwindows") != m.end() && !m["Tumblingwindows"].empty()) {
      tumblingwindows = make_shared<string>(boost::any_cast<string>(m["Tumblingwindows"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("ValueFilter") != m.end() && !m["ValueFilter"].empty()) {
      if (typeid(vector<boost::any>) == m["ValueFilter"].type()) {
        vector<PutLogMonitorRequestValueFilter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ValueFilter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutLogMonitorRequestValueFilter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        valueFilter = make_shared<vector<PutLogMonitorRequestValueFilter>>(expect1);
      }
    }
    if (m.find("ValueFilterRelation") != m.end() && !m["ValueFilterRelation"].empty()) {
      valueFilterRelation = make_shared<string>(boost::any_cast<string>(m["ValueFilterRelation"]));
    }
  }


  virtual ~PutLogMonitorRequest() = default;
};
class PutLogMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> logId{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutLogMonitorResponseBody() {}

  explicit PutLogMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (logId) {
      res["LogId"] = boost::any(*logId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("LogId") != m.end() && !m["LogId"].empty()) {
      logId = make_shared<string>(boost::any_cast<string>(m["LogId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutLogMonitorResponseBody() = default;
};
class PutLogMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutLogMonitorResponseBody> body{};

  PutLogMonitorResponse() {}

  explicit PutLogMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutLogMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutLogMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~PutLogMonitorResponse() = default;
};
class PutMetricRuleTargetsRequestTargets : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> jsonParams{};
  shared_ptr<string> level{};

  PutMetricRuleTargetsRequestTargets() {}

  explicit PutMetricRuleTargetsRequestTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jsonParams) {
      res["JsonParams"] = boost::any(*jsonParams);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JsonParams") != m.end() && !m["JsonParams"].empty()) {
      jsonParams = make_shared<string>(boost::any_cast<string>(m["JsonParams"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~PutMetricRuleTargetsRequestTargets() = default;
};
class PutMetricRuleTargetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> ruleId{};
  shared_ptr<vector<PutMetricRuleTargetsRequestTargets>> targets{};

  PutMetricRuleTargetsRequest() {}

  explicit PutMetricRuleTargetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<PutMetricRuleTargetsRequestTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutMetricRuleTargetsRequestTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<PutMetricRuleTargetsRequestTargets>>(expect1);
      }
    }
  }


  virtual ~PutMetricRuleTargetsRequest() = default;
};
class PutMetricRuleTargetsResponseBodyFailDataTargetsTarget : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> id{};
  shared_ptr<string> level{};

  PutMetricRuleTargetsResponseBodyFailDataTargetsTarget() {}

  explicit PutMetricRuleTargetsResponseBodyFailDataTargetsTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~PutMetricRuleTargetsResponseBodyFailDataTargetsTarget() = default;
};
class PutMetricRuleTargetsResponseBodyFailDataTargets : public Darabonba::Model {
public:
  shared_ptr<vector<PutMetricRuleTargetsResponseBodyFailDataTargetsTarget>> target{};

  PutMetricRuleTargetsResponseBodyFailDataTargets() {}

  explicit PutMetricRuleTargetsResponseBodyFailDataTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      vector<boost::any> temp1;
      for(auto item1:*target){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Target"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(vector<boost::any>) == m["Target"].type()) {
        vector<PutMetricRuleTargetsResponseBodyFailDataTargetsTarget> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Target"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutMetricRuleTargetsResponseBodyFailDataTargetsTarget model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        target = make_shared<vector<PutMetricRuleTargetsResponseBodyFailDataTargetsTarget>>(expect1);
      }
    }
  }


  virtual ~PutMetricRuleTargetsResponseBodyFailDataTargets() = default;
};
class PutMetricRuleTargetsResponseBodyFailData : public Darabonba::Model {
public:
  shared_ptr<PutMetricRuleTargetsResponseBodyFailDataTargets> targets{};

  PutMetricRuleTargetsResponseBodyFailData() {}

  explicit PutMetricRuleTargetsResponseBodyFailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targets) {
      res["Targets"] = targets ? boost::any(targets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(map<string, boost::any>) == m["Targets"].type()) {
        PutMetricRuleTargetsResponseBodyFailDataTargets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Targets"]));
        targets = make_shared<PutMetricRuleTargetsResponseBodyFailDataTargets>(model1);
      }
    }
  }


  virtual ~PutMetricRuleTargetsResponseBodyFailData() = default;
};
class PutMetricRuleTargetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PutMetricRuleTargetsResponseBodyFailData> failData{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutMetricRuleTargetsResponseBody() {}

  explicit PutMetricRuleTargetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failData) {
      res["FailData"] = failData ? boost::any(failData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailData") != m.end() && !m["FailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailData"].type()) {
        PutMetricRuleTargetsResponseBodyFailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailData"]));
        failData = make_shared<PutMetricRuleTargetsResponseBodyFailData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutMetricRuleTargetsResponseBody() = default;
};
class PutMetricRuleTargetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutMetricRuleTargetsResponseBody> body{};

  PutMetricRuleTargetsResponse() {}

  explicit PutMetricRuleTargetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutMetricRuleTargetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutMetricRuleTargetsResponseBody>(model1);
      }
    }
  }


  virtual ~PutMetricRuleTargetsResponse() = default;
};
class PutMonitorGroupDynamicRuleRequestGroupRulesFilters : public Darabonba::Model {
public:
  shared_ptr<string> function{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  PutMonitorGroupDynamicRuleRequestGroupRulesFilters() {}

  explicit PutMonitorGroupDynamicRuleRequestGroupRulesFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = boost::any(*function);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      function = make_shared<string>(boost::any_cast<string>(m["Function"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutMonitorGroupDynamicRuleRequestGroupRulesFilters() = default;
};
class PutMonitorGroupDynamicRuleRequestGroupRules : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> filterRelation{};
  shared_ptr<vector<PutMonitorGroupDynamicRuleRequestGroupRulesFilters>> filters{};

  PutMonitorGroupDynamicRuleRequestGroupRules() {}

  explicit PutMonitorGroupDynamicRuleRequestGroupRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (filterRelation) {
      res["FilterRelation"] = boost::any(*filterRelation);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("FilterRelation") != m.end() && !m["FilterRelation"].empty()) {
      filterRelation = make_shared<string>(boost::any_cast<string>(m["FilterRelation"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<PutMonitorGroupDynamicRuleRequestGroupRulesFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutMonitorGroupDynamicRuleRequestGroupRulesFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<PutMonitorGroupDynamicRuleRequestGroupRulesFilters>>(expect1);
      }
    }
  }


  virtual ~PutMonitorGroupDynamicRuleRequestGroupRules() = default;
};
class PutMonitorGroupDynamicRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<vector<PutMonitorGroupDynamicRuleRequestGroupRules>> groupRules{};
  shared_ptr<bool> isAsync{};
  shared_ptr<string> regionId{};

  PutMonitorGroupDynamicRuleRequest() {}

  explicit PutMonitorGroupDynamicRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupRules) {
      vector<boost::any> temp1;
      for(auto item1:*groupRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupRules"] = boost::any(temp1);
    }
    if (isAsync) {
      res["IsAsync"] = boost::any(*isAsync);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupRules") != m.end() && !m["GroupRules"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupRules"].type()) {
        vector<PutMonitorGroupDynamicRuleRequestGroupRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutMonitorGroupDynamicRuleRequestGroupRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupRules = make_shared<vector<PutMonitorGroupDynamicRuleRequestGroupRules>>(expect1);
      }
    }
    if (m.find("IsAsync") != m.end() && !m["IsAsync"].empty()) {
      isAsync = make_shared<bool>(boost::any_cast<bool>(m["IsAsync"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutMonitorGroupDynamicRuleRequest() = default;
};
class PutMonitorGroupDynamicRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutMonitorGroupDynamicRuleResponseBody() {}

  explicit PutMonitorGroupDynamicRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutMonitorGroupDynamicRuleResponseBody() = default;
};
class PutMonitorGroupDynamicRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutMonitorGroupDynamicRuleResponseBody> body{};

  PutMonitorGroupDynamicRuleResponse() {}

  explicit PutMonitorGroupDynamicRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutMonitorGroupDynamicRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutMonitorGroupDynamicRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutMonitorGroupDynamicRuleResponse() = default;
};
class PutMonitoringConfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoInstall{};
  shared_ptr<bool> enableInstallAgentNewECS{};
  shared_ptr<string> regionId{};

  PutMonitoringConfigRequest() {}

  explicit PutMonitoringConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoInstall) {
      res["AutoInstall"] = boost::any(*autoInstall);
    }
    if (enableInstallAgentNewECS) {
      res["EnableInstallAgentNewECS"] = boost::any(*enableInstallAgentNewECS);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoInstall") != m.end() && !m["AutoInstall"].empty()) {
      autoInstall = make_shared<bool>(boost::any_cast<bool>(m["AutoInstall"]));
    }
    if (m.find("EnableInstallAgentNewECS") != m.end() && !m["EnableInstallAgentNewECS"].empty()) {
      enableInstallAgentNewECS = make_shared<bool>(boost::any_cast<bool>(m["EnableInstallAgentNewECS"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~PutMonitoringConfigRequest() = default;
};
class PutMonitoringConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutMonitoringConfigResponseBody() {}

  explicit PutMonitoringConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutMonitoringConfigResponseBody() = default;
};
class PutMonitoringConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutMonitoringConfigResponseBody> body{};

  PutMonitoringConfigResponse() {}

  explicit PutMonitoringConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutMonitoringConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutMonitoringConfigResponseBody>(model1);
      }
    }
  }


  virtual ~PutMonitoringConfigResponse() = default;
};
class PutResourceMetricRuleRequestEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleRequestEscalationsCritical() {}

  explicit PutResourceMetricRuleRequestEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestEscalationsCritical() = default;
};
class PutResourceMetricRuleRequestEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleRequestEscalationsInfo() {}

  explicit PutResourceMetricRuleRequestEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestEscalationsInfo() = default;
};
class PutResourceMetricRuleRequestEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleRequestEscalationsWarn() {}

  explicit PutResourceMetricRuleRequestEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestEscalationsWarn() = default;
};
class PutResourceMetricRuleRequestEscalations : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRuleRequestEscalationsCritical> critical{};
  shared_ptr<PutResourceMetricRuleRequestEscalationsInfo> info{};
  shared_ptr<PutResourceMetricRuleRequestEscalationsWarn> warn{};

  PutResourceMetricRuleRequestEscalations() {}

  explicit PutResourceMetricRuleRequestEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        PutResourceMetricRuleRequestEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<PutResourceMetricRuleRequestEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        PutResourceMetricRuleRequestEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<PutResourceMetricRuleRequestEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        PutResourceMetricRuleRequestEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<PutResourceMetricRuleRequestEscalationsWarn>(model1);
      }
    }
  }


  virtual ~PutResourceMetricRuleRequestEscalations() = default;
};
class PutResourceMetricRuleRequestCompositeExpressionExpressionList : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> metricName{};
  shared_ptr<long> period{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};

  PutResourceMetricRuleRequestCompositeExpressionExpressionList() {}

  explicit PutResourceMetricRuleRequestCompositeExpressionExpressionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestCompositeExpressionExpressionList() = default;
};
class PutResourceMetricRuleRequestCompositeExpression : public Darabonba::Model {
public:
  shared_ptr<vector<PutResourceMetricRuleRequestCompositeExpressionExpressionList>> expressionList{};
  shared_ptr<string> expressionListJoin{};
  shared_ptr<string> expressionRaw{};
  shared_ptr<string> level{};
  shared_ptr<long> times{};

  PutResourceMetricRuleRequestCompositeExpression() {}

  explicit PutResourceMetricRuleRequestCompositeExpression(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionList) {
      vector<boost::any> temp1;
      for(auto item1:*expressionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExpressionList"] = boost::any(temp1);
    }
    if (expressionListJoin) {
      res["ExpressionListJoin"] = boost::any(*expressionListJoin);
    }
    if (expressionRaw) {
      res["ExpressionRaw"] = boost::any(*expressionRaw);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpressionList") != m.end() && !m["ExpressionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ExpressionList"].type()) {
        vector<PutResourceMetricRuleRequestCompositeExpressionExpressionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExpressionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRuleRequestCompositeExpressionExpressionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressionList = make_shared<vector<PutResourceMetricRuleRequestCompositeExpressionExpressionList>>(expect1);
      }
    }
    if (m.find("ExpressionListJoin") != m.end() && !m["ExpressionListJoin"].empty()) {
      expressionListJoin = make_shared<string>(boost::any_cast<string>(m["ExpressionListJoin"]));
    }
    if (m.find("ExpressionRaw") != m.end() && !m["ExpressionRaw"].empty()) {
      expressionRaw = make_shared<string>(boost::any_cast<string>(m["ExpressionRaw"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestCompositeExpression() = default;
};
class PutResourceMetricRuleRequestLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutResourceMetricRuleRequestLabels() {}

  explicit PutResourceMetricRuleRequestLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestLabels() = default;
};
class PutResourceMetricRuleRequestPrometheusAnnotations : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutResourceMetricRuleRequestPrometheusAnnotations() {}

  explicit PutResourceMetricRuleRequestPrometheusAnnotations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestPrometheusAnnotations() = default;
};
class PutResourceMetricRuleRequestPrometheus : public Darabonba::Model {
public:
  shared_ptr<vector<PutResourceMetricRuleRequestPrometheusAnnotations>> annotations{};
  shared_ptr<string> level{};
  shared_ptr<string> promQL{};
  shared_ptr<long> times{};

  PutResourceMetricRuleRequestPrometheus() {}

  explicit PutResourceMetricRuleRequestPrometheus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      vector<boost::any> temp1;
      for(auto item1:*annotations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Annotations"] = boost::any(temp1);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (promQL) {
      res["PromQL"] = boost::any(*promQL);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      if (typeid(vector<boost::any>) == m["Annotations"].type()) {
        vector<PutResourceMetricRuleRequestPrometheusAnnotations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Annotations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRuleRequestPrometheusAnnotations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        annotations = make_shared<vector<PutResourceMetricRuleRequestPrometheusAnnotations>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("PromQL") != m.end() && !m["PromQL"].empty()) {
      promQL = make_shared<string>(boost::any_cast<string>(m["PromQL"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleRequestPrometheus() = default;
};
class PutResourceMetricRuleRequest : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRuleRequestEscalations> escalations{};
  shared_ptr<PutResourceMetricRuleRequestCompositeExpression> compositeExpression{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> interval{};
  shared_ptr<vector<PutResourceMetricRuleRequestLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> period{};
  shared_ptr<PutResourceMetricRuleRequestPrometheus> prometheus{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> webhook{};

  PutResourceMetricRuleRequest() {}

  explicit PutResourceMetricRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (compositeExpression) {
      res["CompositeExpression"] = compositeExpression ? boost::any(compositeExpression->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (prometheus) {
      res["Prometheus"] = prometheus ? boost::any(prometheus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        PutResourceMetricRuleRequestEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<PutResourceMetricRuleRequestEscalations>(model1);
      }
    }
    if (m.find("CompositeExpression") != m.end() && !m["CompositeExpression"].empty()) {
      if (typeid(map<string, boost::any>) == m["CompositeExpression"].type()) {
        PutResourceMetricRuleRequestCompositeExpression model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CompositeExpression"]));
        compositeExpression = make_shared<PutResourceMetricRuleRequestCompositeExpression>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<PutResourceMetricRuleRequestLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRuleRequestLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<PutResourceMetricRuleRequestLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Prometheus") != m.end() && !m["Prometheus"].empty()) {
      if (typeid(map<string, boost::any>) == m["Prometheus"].type()) {
        PutResourceMetricRuleRequestPrometheus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Prometheus"]));
        prometheus = make_shared<PutResourceMetricRuleRequestPrometheus>(model1);
      }
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutResourceMetricRuleRequest() = default;
};
class PutResourceMetricRuleShrinkRequestEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleShrinkRequestEscalationsCritical() {}

  explicit PutResourceMetricRuleShrinkRequestEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequestEscalationsCritical() = default;
};
class PutResourceMetricRuleShrinkRequestEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleShrinkRequestEscalationsInfo() {}

  explicit PutResourceMetricRuleShrinkRequestEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequestEscalationsInfo() = default;
};
class PutResourceMetricRuleShrinkRequestEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRuleShrinkRequestEscalationsWarn() {}

  explicit PutResourceMetricRuleShrinkRequestEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequestEscalationsWarn() = default;
};
class PutResourceMetricRuleShrinkRequestEscalations : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRuleShrinkRequestEscalationsCritical> critical{};
  shared_ptr<PutResourceMetricRuleShrinkRequestEscalationsInfo> info{};
  shared_ptr<PutResourceMetricRuleShrinkRequestEscalationsWarn> warn{};

  PutResourceMetricRuleShrinkRequestEscalations() {}

  explicit PutResourceMetricRuleShrinkRequestEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        PutResourceMetricRuleShrinkRequestEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<PutResourceMetricRuleShrinkRequestEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        PutResourceMetricRuleShrinkRequestEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<PutResourceMetricRuleShrinkRequestEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        PutResourceMetricRuleShrinkRequestEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<PutResourceMetricRuleShrinkRequestEscalationsWarn>(model1);
      }
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequestEscalations() = default;
};
class PutResourceMetricRuleShrinkRequestLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutResourceMetricRuleShrinkRequestLabels() {}

  explicit PutResourceMetricRuleShrinkRequestLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequestLabels() = default;
};
class PutResourceMetricRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRuleShrinkRequestEscalations> escalations{};
  shared_ptr<string> compositeExpressionShrink{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> interval{};
  shared_ptr<vector<PutResourceMetricRuleShrinkRequestLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> period{};
  shared_ptr<string> prometheusShrink{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> webhook{};

  PutResourceMetricRuleShrinkRequest() {}

  explicit PutResourceMetricRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (compositeExpressionShrink) {
      res["CompositeExpression"] = boost::any(*compositeExpressionShrink);
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (prometheusShrink) {
      res["Prometheus"] = boost::any(*prometheusShrink);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        PutResourceMetricRuleShrinkRequestEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<PutResourceMetricRuleShrinkRequestEscalations>(model1);
      }
    }
    if (m.find("CompositeExpression") != m.end() && !m["CompositeExpression"].empty()) {
      compositeExpressionShrink = make_shared<string>(boost::any_cast<string>(m["CompositeExpression"]));
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<PutResourceMetricRuleShrinkRequestLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRuleShrinkRequestLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<PutResourceMetricRuleShrinkRequestLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Prometheus") != m.end() && !m["Prometheus"].empty()) {
      prometheusShrink = make_shared<string>(boost::any_cast<string>(m["Prometheus"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutResourceMetricRuleShrinkRequest() = default;
};
class PutResourceMetricRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutResourceMetricRuleResponseBody() {}

  explicit PutResourceMetricRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutResourceMetricRuleResponseBody() = default;
};
class PutResourceMetricRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutResourceMetricRuleResponseBody> body{};

  PutResourceMetricRuleResponse() {}

  explicit PutResourceMetricRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutResourceMetricRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutResourceMetricRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PutResourceMetricRuleResponse() = default;
};
class PutResourceMetricRulesRequestRulesEscalationsCritical : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRulesRequestRulesEscalationsCritical() {}

  explicit PutResourceMetricRulesRequestRulesEscalationsCritical(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRulesRequestRulesEscalationsCritical() = default;
};
class PutResourceMetricRulesRequestRulesEscalationsInfo : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRulesRequestRulesEscalationsInfo() {}

  explicit PutResourceMetricRulesRequestRulesEscalationsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRulesRequestRulesEscalationsInfo() = default;
};
class PutResourceMetricRulesRequestRulesEscalationsWarn : public Darabonba::Model {
public:
  shared_ptr<string> comparisonOperator{};
  shared_ptr<long> n{};
  shared_ptr<string> preCondition{};
  shared_ptr<string> statistics{};
  shared_ptr<string> threshold{};
  shared_ptr<long> times{};

  PutResourceMetricRulesRequestRulesEscalationsWarn() {}

  explicit PutResourceMetricRulesRequestRulesEscalationsWarn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comparisonOperator) {
      res["ComparisonOperator"] = boost::any(*comparisonOperator);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    if (preCondition) {
      res["PreCondition"] = boost::any(*preCondition);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComparisonOperator") != m.end() && !m["ComparisonOperator"].empty()) {
      comparisonOperator = make_shared<string>(boost::any_cast<string>(m["ComparisonOperator"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
    if (m.find("PreCondition") != m.end() && !m["PreCondition"].empty()) {
      preCondition = make_shared<string>(boost::any_cast<string>(m["PreCondition"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<string>(boost::any_cast<string>(m["Threshold"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      times = make_shared<long>(boost::any_cast<long>(m["Times"]));
    }
  }


  virtual ~PutResourceMetricRulesRequestRulesEscalationsWarn() = default;
};
class PutResourceMetricRulesRequestRulesEscalations : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRulesRequestRulesEscalationsCritical> critical{};
  shared_ptr<PutResourceMetricRulesRequestRulesEscalationsInfo> info{};
  shared_ptr<PutResourceMetricRulesRequestRulesEscalationsWarn> warn{};

  PutResourceMetricRulesRequestRulesEscalations() {}

  explicit PutResourceMetricRulesRequestRulesEscalations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (critical) {
      res["Critical"] = critical ? boost::any(critical->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (info) {
      res["Info"] = info ? boost::any(info->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warn) {
      res["Warn"] = warn ? boost::any(warn->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Critical") != m.end() && !m["Critical"].empty()) {
      if (typeid(map<string, boost::any>) == m["Critical"].type()) {
        PutResourceMetricRulesRequestRulesEscalationsCritical model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Critical"]));
        critical = make_shared<PutResourceMetricRulesRequestRulesEscalationsCritical>(model1);
      }
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      if (typeid(map<string, boost::any>) == m["Info"].type()) {
        PutResourceMetricRulesRequestRulesEscalationsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Info"]));
        info = make_shared<PutResourceMetricRulesRequestRulesEscalationsInfo>(model1);
      }
    }
    if (m.find("Warn") != m.end() && !m["Warn"].empty()) {
      if (typeid(map<string, boost::any>) == m["Warn"].type()) {
        PutResourceMetricRulesRequestRulesEscalationsWarn model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Warn"]));
        warn = make_shared<PutResourceMetricRulesRequestRulesEscalationsWarn>(model1);
      }
    }
  }


  virtual ~PutResourceMetricRulesRequestRulesEscalations() = default;
};
class PutResourceMetricRulesRequestRulesLabels : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  PutResourceMetricRulesRequestRulesLabels() {}

  explicit PutResourceMetricRulesRequestRulesLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutResourceMetricRulesRequestRulesLabels() = default;
};
class PutResourceMetricRulesRequestRules : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRulesRequestRulesEscalations> escalations{};
  shared_ptr<string> contactGroups{};
  shared_ptr<string> effectiveInterval{};
  shared_ptr<string> emailSubject{};
  shared_ptr<string> interval{};
  shared_ptr<vector<PutResourceMetricRulesRequestRulesLabels>> labels{};
  shared_ptr<string> metricName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> noDataPolicy{};
  shared_ptr<string> noEffectiveInterval{};
  shared_ptr<string> period{};
  shared_ptr<string> resources{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> webhook{};

  PutResourceMetricRulesRequestRules() {}

  explicit PutResourceMetricRulesRequestRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalations) {
      res["Escalations"] = escalations ? boost::any(escalations->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactGroups) {
      res["ContactGroups"] = boost::any(*contactGroups);
    }
    if (effectiveInterval) {
      res["EffectiveInterval"] = boost::any(*effectiveInterval);
    }
    if (emailSubject) {
      res["EmailSubject"] = boost::any(*emailSubject);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (metricName) {
      res["MetricName"] = boost::any(*metricName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noDataPolicy) {
      res["NoDataPolicy"] = boost::any(*noDataPolicy);
    }
    if (noEffectiveInterval) {
      res["NoEffectiveInterval"] = boost::any(*noEffectiveInterval);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (webhook) {
      res["Webhook"] = boost::any(*webhook);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Escalations") != m.end() && !m["Escalations"].empty()) {
      if (typeid(map<string, boost::any>) == m["Escalations"].type()) {
        PutResourceMetricRulesRequestRulesEscalations model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Escalations"]));
        escalations = make_shared<PutResourceMetricRulesRequestRulesEscalations>(model1);
      }
    }
    if (m.find("ContactGroups") != m.end() && !m["ContactGroups"].empty()) {
      contactGroups = make_shared<string>(boost::any_cast<string>(m["ContactGroups"]));
    }
    if (m.find("EffectiveInterval") != m.end() && !m["EffectiveInterval"].empty()) {
      effectiveInterval = make_shared<string>(boost::any_cast<string>(m["EffectiveInterval"]));
    }
    if (m.find("EmailSubject") != m.end() && !m["EmailSubject"].empty()) {
      emailSubject = make_shared<string>(boost::any_cast<string>(m["EmailSubject"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<PutResourceMetricRulesRequestRulesLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRulesRequestRulesLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<PutResourceMetricRulesRequestRulesLabels>>(expect1);
      }
    }
    if (m.find("MetricName") != m.end() && !m["MetricName"].empty()) {
      metricName = make_shared<string>(boost::any_cast<string>(m["MetricName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoDataPolicy") != m.end() && !m["NoDataPolicy"].empty()) {
      noDataPolicy = make_shared<string>(boost::any_cast<string>(m["NoDataPolicy"]));
    }
    if (m.find("NoEffectiveInterval") != m.end() && !m["NoEffectiveInterval"].empty()) {
      noEffectiveInterval = make_shared<string>(boost::any_cast<string>(m["NoEffectiveInterval"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("Webhook") != m.end() && !m["Webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["Webhook"]));
    }
  }


  virtual ~PutResourceMetricRulesRequestRules() = default;
};
class PutResourceMetricRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<PutResourceMetricRulesRequestRules>> rules{};

  PutResourceMetricRulesRequest() {}

  explicit PutResourceMetricRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<PutResourceMetricRulesRequestRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRulesRequestRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<PutResourceMetricRulesRequestRules>>(expect1);
      }
    }
  }


  virtual ~PutResourceMetricRulesRequest() = default;
};
class PutResourceMetricRulesResponseBodyFailedListResultTargetResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  PutResourceMetricRulesResponseBodyFailedListResultTargetResult() {}

  explicit PutResourceMetricRulesResponseBodyFailedListResultTargetResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutResourceMetricRulesResponseBodyFailedListResultTargetResult() = default;
};
class PutResourceMetricRulesResponseBodyFailedListResultTarget : public Darabonba::Model {
public:
  shared_ptr<PutResourceMetricRulesResponseBodyFailedListResultTargetResult> result{};
  shared_ptr<string> ruleId{};

  PutResourceMetricRulesResponseBodyFailedListResultTarget() {}

  explicit PutResourceMetricRulesResponseBodyFailedListResultTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        PutResourceMetricRulesResponseBodyFailedListResultTargetResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<PutResourceMetricRulesResponseBodyFailedListResultTargetResult>(model1);
      }
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~PutResourceMetricRulesResponseBodyFailedListResultTarget() = default;
};
class PutResourceMetricRulesResponseBodyFailedListResult : public Darabonba::Model {
public:
  shared_ptr<vector<PutResourceMetricRulesResponseBodyFailedListResultTarget>> target{};

  PutResourceMetricRulesResponseBodyFailedListResult() {}

  explicit PutResourceMetricRulesResponseBodyFailedListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      vector<boost::any> temp1;
      for(auto item1:*target){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Target"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      if (typeid(vector<boost::any>) == m["Target"].type()) {
        vector<PutResourceMetricRulesResponseBodyFailedListResultTarget> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Target"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PutResourceMetricRulesResponseBodyFailedListResultTarget model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        target = make_shared<vector<PutResourceMetricRulesResponseBodyFailedListResultTarget>>(expect1);
      }
    }
  }


  virtual ~PutResourceMetricRulesResponseBodyFailedListResult() = default;
};
class PutResourceMetricRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PutResourceMetricRulesResponseBodyFailedListResult> failedListResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PutResourceMetricRulesResponseBody() {}

  explicit PutResourceMetricRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (failedListResult) {
      res["FailedListResult"] = failedListResult ? boost::any(failedListResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FailedListResult") != m.end() && !m["FailedListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedListResult"].type()) {
        PutResourceMetricRulesResponseBodyFailedListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedListResult"]));
        failedListResult = make_shared<PutResourceMetricRulesResponseBodyFailedListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PutResourceMetricRulesResponseBody() = default;
};
class PutResourceMetricRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutResourceMetricRulesResponseBody> body{};

  PutResourceMetricRulesResponse() {}

  explicit PutResourceMetricRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutResourceMetricRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutResourceMetricRulesResponseBody>(model1);
      }
    }
  }


  virtual ~PutResourceMetricRulesResponse() = default;
};
class RemoveTagsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  RemoveTagsRequestTag() {}

  explicit RemoveTagsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~RemoveTagsRequestTag() = default;
};
class RemoveTagsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<RemoveTagsRequestTag>> tag{};

  RemoveTagsRequest() {}

  explicit RemoveTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<RemoveTagsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveTagsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<RemoveTagsRequestTag>>(expect1);
      }
    }
  }


  virtual ~RemoveTagsRequest() = default;
};
class RemoveTagsResponseBodyTag : public Darabonba::Model {
public:
  shared_ptr<vector<string>> tags{};

  RemoveTagsResponseBodyTag() {}

  explicit RemoveTagsResponseBodyTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveTagsResponseBodyTag() = default;
};
class RemoveTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<RemoveTagsResponseBodyTag> tag{};

  RemoveTagsResponseBody() {}

  explicit RemoveTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tag) {
      res["Tag"] = tag ? boost::any(tag->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tag"].type()) {
        RemoveTagsResponseBodyTag model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tag"]));
        tag = make_shared<RemoveTagsResponseBodyTag>(model1);
      }
    }
  }


  virtual ~RemoveTagsResponseBody() = default;
};
class RemoveTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTagsResponseBody> body{};

  RemoveTagsResponse() {}

  explicit RemoveTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTagsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTagsResponse() = default;
};
class SendDryRunSystemEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventContent{};
  shared_ptr<string> eventName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};

  SendDryRunSystemEventRequest() {}

  explicit SendDryRunSystemEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventContent) {
      res["EventContent"] = boost::any(*eventContent);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventContent") != m.end() && !m["EventContent"].empty()) {
      eventContent = make_shared<string>(boost::any_cast<string>(m["EventContent"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~SendDryRunSystemEventRequest() = default;
};
class SendDryRunSystemEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SendDryRunSystemEventResponseBody() {}

  explicit SendDryRunSystemEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SendDryRunSystemEventResponseBody() = default;
};
class SendDryRunSystemEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendDryRunSystemEventResponseBody> body{};

  SendDryRunSystemEventResponse() {}

  explicit SendDryRunSystemEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendDryRunSystemEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendDryRunSystemEventResponseBody>(model1);
      }
    }
  }


  virtual ~SendDryRunSystemEventResponse() = default;
};
class UninstallMonitoringAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  UninstallMonitoringAgentRequest() {}

  explicit UninstallMonitoringAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UninstallMonitoringAgentRequest() = default;
};
class UninstallMonitoringAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UninstallMonitoringAgentResponseBody() {}

  explicit UninstallMonitoringAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UninstallMonitoringAgentResponseBody() = default;
};
class UninstallMonitoringAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallMonitoringAgentResponseBody> body{};

  UninstallMonitoringAgentResponse() {}

  explicit UninstallMonitoringAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallMonitoringAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallMonitoringAgentResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallMonitoringAgentResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddTagsResponse addTagsWithOptions(shared_ptr<AddTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTagsResponse addTags(shared_ptr<AddTagsRequest> request);
  ApplyMetricRuleTemplateResponse applyMetricRuleTemplateWithOptions(shared_ptr<ApplyMetricRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyMetricRuleTemplateResponse applyMetricRuleTemplate(shared_ptr<ApplyMetricRuleTemplateRequest> request);
  BatchCreateInstantSiteMonitorResponse batchCreateInstantSiteMonitorWithOptions(shared_ptr<BatchCreateInstantSiteMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateInstantSiteMonitorResponse batchCreateInstantSiteMonitor(shared_ptr<BatchCreateInstantSiteMonitorRequest> request);
  BatchExportResponse batchExportWithOptions(shared_ptr<BatchExportRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchExportResponse batchExport(shared_ptr<BatchExportRequest> request);
  CreateDynamicTagGroupResponse createDynamicTagGroupWithOptions(shared_ptr<CreateDynamicTagGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDynamicTagGroupResponse createDynamicTagGroup(shared_ptr<CreateDynamicTagGroupRequest> request);
  CreateGroupMetricRulesResponse createGroupMetricRulesWithOptions(shared_ptr<CreateGroupMetricRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGroupMetricRulesResponse createGroupMetricRules(shared_ptr<CreateGroupMetricRulesRequest> request);
  CreateGroupMonitoringAgentProcessResponse createGroupMonitoringAgentProcessWithOptions(shared_ptr<CreateGroupMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGroupMonitoringAgentProcessResponse createGroupMonitoringAgentProcess(shared_ptr<CreateGroupMonitoringAgentProcessRequest> request);
  CreateHostAvailabilityResponse createHostAvailabilityWithOptions(shared_ptr<CreateHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHostAvailabilityResponse createHostAvailability(shared_ptr<CreateHostAvailabilityRequest> request);
  CreateHybridMonitorNamespaceResponse createHybridMonitorNamespaceWithOptions(shared_ptr<CreateHybridMonitorNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHybridMonitorNamespaceResponse createHybridMonitorNamespace(shared_ptr<CreateHybridMonitorNamespaceRequest> request);
  CreateHybridMonitorSLSGroupResponse createHybridMonitorSLSGroupWithOptions(shared_ptr<CreateHybridMonitorSLSGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHybridMonitorSLSGroupResponse createHybridMonitorSLSGroup(shared_ptr<CreateHybridMonitorSLSGroupRequest> request);
  CreateHybridMonitorTaskResponse createHybridMonitorTaskWithOptions(shared_ptr<CreateHybridMonitorTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHybridMonitorTaskResponse createHybridMonitorTask(shared_ptr<CreateHybridMonitorTaskRequest> request);
  CreateInstantSiteMonitorResponse createInstantSiteMonitorWithOptions(shared_ptr<CreateInstantSiteMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstantSiteMonitorResponse createInstantSiteMonitor(shared_ptr<CreateInstantSiteMonitorRequest> request);
  CreateMetricRuleBlackListResponse createMetricRuleBlackListWithOptions(shared_ptr<CreateMetricRuleBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetricRuleBlackListResponse createMetricRuleBlackList(shared_ptr<CreateMetricRuleBlackListRequest> request);
  CreateMetricRuleResourcesResponse createMetricRuleResourcesWithOptions(shared_ptr<CreateMetricRuleResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetricRuleResourcesResponse createMetricRuleResources(shared_ptr<CreateMetricRuleResourcesRequest> request);
  CreateMetricRuleTemplateResponse createMetricRuleTemplateWithOptions(shared_ptr<CreateMetricRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetricRuleTemplateResponse createMetricRuleTemplate(shared_ptr<CreateMetricRuleTemplateRequest> request);
  CreateMonitorAgentProcessResponse createMonitorAgentProcessWithOptions(shared_ptr<CreateMonitorAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorAgentProcessResponse createMonitorAgentProcess(shared_ptr<CreateMonitorAgentProcessRequest> request);
  CreateMonitorGroupResponse createMonitorGroupWithOptions(shared_ptr<CreateMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupResponse createMonitorGroup(shared_ptr<CreateMonitorGroupRequest> request);
  CreateMonitorGroupByResourceGroupIdResponse createMonitorGroupByResourceGroupIdWithOptions(shared_ptr<CreateMonitorGroupByResourceGroupIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupByResourceGroupIdResponse createMonitorGroupByResourceGroupId(shared_ptr<CreateMonitorGroupByResourceGroupIdRequest> request);
  CreateMonitorGroupInstancesResponse createMonitorGroupInstancesWithOptions(shared_ptr<CreateMonitorGroupInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupInstancesResponse createMonitorGroupInstances(shared_ptr<CreateMonitorGroupInstancesRequest> request);
  CreateMonitorGroupNotifyPolicyResponse createMonitorGroupNotifyPolicyWithOptions(shared_ptr<CreateMonitorGroupNotifyPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupNotifyPolicyResponse createMonitorGroupNotifyPolicy(shared_ptr<CreateMonitorGroupNotifyPolicyRequest> request);
  CreateMonitoringAgentProcessResponse createMonitoringAgentProcessWithOptions(shared_ptr<CreateMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitoringAgentProcessResponse createMonitoringAgentProcess(shared_ptr<CreateMonitoringAgentProcessRequest> request);
  CreateSiteMonitorResponse createSiteMonitorWithOptions(shared_ptr<CreateSiteMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSiteMonitorResponse createSiteMonitor(shared_ptr<CreateSiteMonitorRequest> request);
  CursorResponse cursorWithOptions(shared_ptr<CursorRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CursorResponse cursor(shared_ptr<CursorRequest> request);
  DeleteContactResponse deleteContactWithOptions(shared_ptr<DeleteContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactResponse deleteContact(shared_ptr<DeleteContactRequest> request);
  DeleteContactGroupResponse deleteContactGroupWithOptions(shared_ptr<DeleteContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteContactGroupResponse deleteContactGroup(shared_ptr<DeleteContactGroupRequest> request);
  DeleteCustomMetricResponse deleteCustomMetricWithOptions(shared_ptr<DeleteCustomMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomMetricResponse deleteCustomMetric(shared_ptr<DeleteCustomMetricRequest> request);
  DeleteDynamicTagGroupResponse deleteDynamicTagGroupWithOptions(shared_ptr<DeleteDynamicTagGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDynamicTagGroupResponse deleteDynamicTagGroup(shared_ptr<DeleteDynamicTagGroupRequest> request);
  DeleteEventRuleTargetsResponse deleteEventRuleTargetsWithOptions(shared_ptr<DeleteEventRuleTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventRuleTargetsResponse deleteEventRuleTargets(shared_ptr<DeleteEventRuleTargetsRequest> request);
  DeleteEventRulesResponse deleteEventRulesWithOptions(shared_ptr<DeleteEventRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEventRulesResponse deleteEventRules(shared_ptr<DeleteEventRulesRequest> request);
  DeleteExporterOutputResponse deleteExporterOutputWithOptions(shared_ptr<DeleteExporterOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExporterOutputResponse deleteExporterOutput(shared_ptr<DeleteExporterOutputRequest> request);
  DeleteExporterRuleResponse deleteExporterRuleWithOptions(shared_ptr<DeleteExporterRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteExporterRuleResponse deleteExporterRule(shared_ptr<DeleteExporterRuleRequest> request);
  DeleteGroupMonitoringAgentProcessResponse deleteGroupMonitoringAgentProcessWithOptions(shared_ptr<DeleteGroupMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupMonitoringAgentProcessResponse deleteGroupMonitoringAgentProcess(shared_ptr<DeleteGroupMonitoringAgentProcessRequest> request);
  DeleteHostAvailabilityResponse deleteHostAvailabilityWithOptions(shared_ptr<DeleteHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHostAvailabilityResponse deleteHostAvailability(shared_ptr<DeleteHostAvailabilityRequest> request);
  DeleteHybridMonitorNamespaceResponse deleteHybridMonitorNamespaceWithOptions(shared_ptr<DeleteHybridMonitorNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHybridMonitorNamespaceResponse deleteHybridMonitorNamespace(shared_ptr<DeleteHybridMonitorNamespaceRequest> request);
  DeleteHybridMonitorSLSGroupResponse deleteHybridMonitorSLSGroupWithOptions(shared_ptr<DeleteHybridMonitorSLSGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHybridMonitorSLSGroupResponse deleteHybridMonitorSLSGroup(shared_ptr<DeleteHybridMonitorSLSGroupRequest> request);
  DeleteHybridMonitorTaskResponse deleteHybridMonitorTaskWithOptions(shared_ptr<DeleteHybridMonitorTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHybridMonitorTaskResponse deleteHybridMonitorTask(shared_ptr<DeleteHybridMonitorTaskRequest> request);
  DeleteLogMonitorResponse deleteLogMonitorWithOptions(shared_ptr<DeleteLogMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogMonitorResponse deleteLogMonitor(shared_ptr<DeleteLogMonitorRequest> request);
  DeleteMetricRuleBlackListResponse deleteMetricRuleBlackListWithOptions(shared_ptr<DeleteMetricRuleBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetricRuleBlackListResponse deleteMetricRuleBlackList(shared_ptr<DeleteMetricRuleBlackListRequest> request);
  DeleteMetricRuleResourcesResponse deleteMetricRuleResourcesWithOptions(shared_ptr<DeleteMetricRuleResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetricRuleResourcesResponse deleteMetricRuleResources(shared_ptr<DeleteMetricRuleResourcesRequest> request);
  DeleteMetricRuleTargetsResponse deleteMetricRuleTargetsWithOptions(shared_ptr<DeleteMetricRuleTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetricRuleTargetsResponse deleteMetricRuleTargets(shared_ptr<DeleteMetricRuleTargetsRequest> request);
  DeleteMetricRuleTemplateResponse deleteMetricRuleTemplateWithOptions(shared_ptr<DeleteMetricRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetricRuleTemplateResponse deleteMetricRuleTemplate(shared_ptr<DeleteMetricRuleTemplateRequest> request);
  DeleteMetricRulesResponse deleteMetricRulesWithOptions(shared_ptr<DeleteMetricRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetricRulesResponse deleteMetricRules(shared_ptr<DeleteMetricRulesRequest> request);
  DeleteMonitorGroupResponse deleteMonitorGroupWithOptions(shared_ptr<DeleteMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitorGroupResponse deleteMonitorGroup(shared_ptr<DeleteMonitorGroupRequest> request);
  DeleteMonitorGroupDynamicRuleResponse deleteMonitorGroupDynamicRuleWithOptions(shared_ptr<DeleteMonitorGroupDynamicRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitorGroupDynamicRuleResponse deleteMonitorGroupDynamicRule(shared_ptr<DeleteMonitorGroupDynamicRuleRequest> request);
  DeleteMonitorGroupInstancesResponse deleteMonitorGroupInstancesWithOptions(shared_ptr<DeleteMonitorGroupInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitorGroupInstancesResponse deleteMonitorGroupInstances(shared_ptr<DeleteMonitorGroupInstancesRequest> request);
  DeleteMonitorGroupNotifyPolicyResponse deleteMonitorGroupNotifyPolicyWithOptions(shared_ptr<DeleteMonitorGroupNotifyPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitorGroupNotifyPolicyResponse deleteMonitorGroupNotifyPolicy(shared_ptr<DeleteMonitorGroupNotifyPolicyRequest> request);
  DeleteMonitoringAgentProcessResponse deleteMonitoringAgentProcessWithOptions(shared_ptr<DeleteMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitoringAgentProcessResponse deleteMonitoringAgentProcess(shared_ptr<DeleteMonitoringAgentProcessRequest> request);
  DeleteSiteMonitorsResponse deleteSiteMonitorsWithOptions(shared_ptr<DeleteSiteMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSiteMonitorsResponse deleteSiteMonitors(shared_ptr<DeleteSiteMonitorsRequest> request);
  DescribeActiveMetricRuleListResponse describeActiveMetricRuleListWithOptions(shared_ptr<DescribeActiveMetricRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeActiveMetricRuleListResponse describeActiveMetricRuleList(shared_ptr<DescribeActiveMetricRuleListRequest> request);
  DescribeAlertHistoryListResponse describeAlertHistoryListWithOptions(shared_ptr<DescribeAlertHistoryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertHistoryListResponse describeAlertHistoryList(shared_ptr<DescribeAlertHistoryListRequest> request);
  DescribeAlertLogCountResponse describeAlertLogCountWithOptions(shared_ptr<DescribeAlertLogCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertLogCountResponse describeAlertLogCount(shared_ptr<DescribeAlertLogCountRequest> request);
  DescribeAlertLogHistogramResponse describeAlertLogHistogramWithOptions(shared_ptr<DescribeAlertLogHistogramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertLogHistogramResponse describeAlertLogHistogram(shared_ptr<DescribeAlertLogHistogramRequest> request);
  DescribeAlertLogListResponse describeAlertLogListWithOptions(shared_ptr<DescribeAlertLogListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertLogListResponse describeAlertLogList(shared_ptr<DescribeAlertLogListRequest> request);
  DescribeAlertingMetricRuleResourcesResponse describeAlertingMetricRuleResourcesWithOptions(shared_ptr<DescribeAlertingMetricRuleResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlertingMetricRuleResourcesResponse describeAlertingMetricRuleResources(shared_ptr<DescribeAlertingMetricRuleResourcesRequest> request);
  DescribeContactGroupListResponse describeContactGroupListWithOptions(shared_ptr<DescribeContactGroupListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactGroupListResponse describeContactGroupList(shared_ptr<DescribeContactGroupListRequest> request);
  DescribeContactListResponse describeContactListWithOptions(shared_ptr<DescribeContactListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactListResponse describeContactList(shared_ptr<DescribeContactListRequest> request);
  DescribeContactListByContactGroupResponse describeContactListByContactGroupWithOptions(shared_ptr<DescribeContactListByContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContactListByContactGroupResponse describeContactListByContactGroup(shared_ptr<DescribeContactListByContactGroupRequest> request);
  DescribeCustomEventAttributeResponse describeCustomEventAttributeWithOptions(shared_ptr<DescribeCustomEventAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomEventAttributeResponse describeCustomEventAttribute(shared_ptr<DescribeCustomEventAttributeRequest> request);
  DescribeCustomEventCountResponse describeCustomEventCountWithOptions(shared_ptr<DescribeCustomEventCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomEventCountResponse describeCustomEventCount(shared_ptr<DescribeCustomEventCountRequest> request);
  DescribeCustomEventHistogramResponse describeCustomEventHistogramWithOptions(shared_ptr<DescribeCustomEventHistogramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomEventHistogramResponse describeCustomEventHistogram(shared_ptr<DescribeCustomEventHistogramRequest> request);
  DescribeCustomMetricListResponse describeCustomMetricListWithOptions(shared_ptr<DescribeCustomMetricListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomMetricListResponse describeCustomMetricList(shared_ptr<DescribeCustomMetricListRequest> request);
  DescribeDynamicTagRuleListResponse describeDynamicTagRuleListWithOptions(shared_ptr<DescribeDynamicTagRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDynamicTagRuleListResponse describeDynamicTagRuleList(shared_ptr<DescribeDynamicTagRuleListRequest> request);
  DescribeEventRuleAttributeResponse describeEventRuleAttributeWithOptions(shared_ptr<DescribeEventRuleAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventRuleAttributeResponse describeEventRuleAttribute(shared_ptr<DescribeEventRuleAttributeRequest> request);
  DescribeEventRuleListResponse describeEventRuleListWithOptions(shared_ptr<DescribeEventRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventRuleListResponse describeEventRuleList(shared_ptr<DescribeEventRuleListRequest> request);
  DescribeEventRuleTargetListResponse describeEventRuleTargetListWithOptions(shared_ptr<DescribeEventRuleTargetListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventRuleTargetListResponse describeEventRuleTargetList(shared_ptr<DescribeEventRuleTargetListRequest> request);
  DescribeExporterOutputListResponse describeExporterOutputListWithOptions(shared_ptr<DescribeExporterOutputListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExporterOutputListResponse describeExporterOutputList(shared_ptr<DescribeExporterOutputListRequest> request);
  DescribeExporterRuleListResponse describeExporterRuleListWithOptions(shared_ptr<DescribeExporterRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExporterRuleListResponse describeExporterRuleList(shared_ptr<DescribeExporterRuleListRequest> request);
  DescribeGroupMonitoringAgentProcessResponse describeGroupMonitoringAgentProcessWithOptions(shared_ptr<DescribeGroupMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupMonitoringAgentProcessResponse describeGroupMonitoringAgentProcess(shared_ptr<DescribeGroupMonitoringAgentProcessRequest> request);
  DescribeHostAvailabilityListResponse describeHostAvailabilityListWithOptions(shared_ptr<DescribeHostAvailabilityListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHostAvailabilityListResponse describeHostAvailabilityList(shared_ptr<DescribeHostAvailabilityListRequest> request);
  DescribeHybridMonitorDataListResponse describeHybridMonitorDataListWithOptions(shared_ptr<DescribeHybridMonitorDataListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridMonitorDataListResponse describeHybridMonitorDataList(shared_ptr<DescribeHybridMonitorDataListRequest> request);
  DescribeHybridMonitorNamespaceListResponse describeHybridMonitorNamespaceListWithOptions(shared_ptr<DescribeHybridMonitorNamespaceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridMonitorNamespaceListResponse describeHybridMonitorNamespaceList(shared_ptr<DescribeHybridMonitorNamespaceListRequest> request);
  DescribeHybridMonitorSLSGroupResponse describeHybridMonitorSLSGroupWithOptions(shared_ptr<DescribeHybridMonitorSLSGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridMonitorSLSGroupResponse describeHybridMonitorSLSGroup(shared_ptr<DescribeHybridMonitorSLSGroupRequest> request);
  DescribeHybridMonitorTaskListResponse describeHybridMonitorTaskListWithOptions(shared_ptr<DescribeHybridMonitorTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridMonitorTaskListResponse describeHybridMonitorTaskList(shared_ptr<DescribeHybridMonitorTaskListRequest> request);
  DescribeLogMonitorAttributeResponse describeLogMonitorAttributeWithOptions(shared_ptr<DescribeLogMonitorAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogMonitorAttributeResponse describeLogMonitorAttribute(shared_ptr<DescribeLogMonitorAttributeRequest> request);
  DescribeLogMonitorListResponse describeLogMonitorListWithOptions(shared_ptr<DescribeLogMonitorListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogMonitorListResponse describeLogMonitorList(shared_ptr<DescribeLogMonitorListRequest> request);
  DescribeMetricDataResponse describeMetricDataWithOptions(shared_ptr<DescribeMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricDataResponse describeMetricData(shared_ptr<DescribeMetricDataRequest> request);
  DescribeMetricLastResponse describeMetricLastWithOptions(shared_ptr<DescribeMetricLastRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricLastResponse describeMetricLast(shared_ptr<DescribeMetricLastRequest> request);
  DescribeMetricListResponse describeMetricListWithOptions(shared_ptr<DescribeMetricListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricListResponse describeMetricList(shared_ptr<DescribeMetricListRequest> request);
  DescribeMetricMetaListResponse describeMetricMetaListWithOptions(shared_ptr<DescribeMetricMetaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricMetaListResponse describeMetricMetaList(shared_ptr<DescribeMetricMetaListRequest> request);
  DescribeMetricRuleBlackListResponse describeMetricRuleBlackListWithOptions(shared_ptr<DescribeMetricRuleBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleBlackListResponse describeMetricRuleBlackList(shared_ptr<DescribeMetricRuleBlackListRequest> request);
  DescribeMetricRuleCountResponse describeMetricRuleCountWithOptions(shared_ptr<DescribeMetricRuleCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleCountResponse describeMetricRuleCount(shared_ptr<DescribeMetricRuleCountRequest> request);
  DescribeMetricRuleListResponse describeMetricRuleListWithOptions(shared_ptr<DescribeMetricRuleListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleListResponse describeMetricRuleList(shared_ptr<DescribeMetricRuleListRequest> request);
  DescribeMetricRuleTargetsResponse describeMetricRuleTargetsWithOptions(shared_ptr<DescribeMetricRuleTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleTargetsResponse describeMetricRuleTargets(shared_ptr<DescribeMetricRuleTargetsRequest> request);
  DescribeMetricRuleTemplateAttributeResponse describeMetricRuleTemplateAttributeWithOptions(shared_ptr<DescribeMetricRuleTemplateAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleTemplateAttributeResponse describeMetricRuleTemplateAttribute(shared_ptr<DescribeMetricRuleTemplateAttributeRequest> request);
  DescribeMetricRuleTemplateListResponse describeMetricRuleTemplateListWithOptions(shared_ptr<DescribeMetricRuleTemplateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricRuleTemplateListResponse describeMetricRuleTemplateList(shared_ptr<DescribeMetricRuleTemplateListRequest> request);
  DescribeMetricTopResponse describeMetricTopWithOptions(shared_ptr<DescribeMetricTopRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricTopResponse describeMetricTop(shared_ptr<DescribeMetricTopRequest> request);
  DescribeMonitorGroupCategoriesResponse describeMonitorGroupCategoriesWithOptions(shared_ptr<DescribeMonitorGroupCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupCategoriesResponse describeMonitorGroupCategories(shared_ptr<DescribeMonitorGroupCategoriesRequest> request);
  DescribeMonitorGroupDynamicRulesResponse describeMonitorGroupDynamicRulesWithOptions(shared_ptr<DescribeMonitorGroupDynamicRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupDynamicRulesResponse describeMonitorGroupDynamicRules(shared_ptr<DescribeMonitorGroupDynamicRulesRequest> request);
  DescribeMonitorGroupInstanceAttributeResponse describeMonitorGroupInstanceAttributeWithOptions(shared_ptr<DescribeMonitorGroupInstanceAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupInstanceAttributeResponse describeMonitorGroupInstanceAttribute(shared_ptr<DescribeMonitorGroupInstanceAttributeRequest> request);
  DescribeMonitorGroupInstancesResponse describeMonitorGroupInstancesWithOptions(shared_ptr<DescribeMonitorGroupInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupInstancesResponse describeMonitorGroupInstances(shared_ptr<DescribeMonitorGroupInstancesRequest> request);
  DescribeMonitorGroupNotifyPolicyListResponse describeMonitorGroupNotifyPolicyListWithOptions(shared_ptr<DescribeMonitorGroupNotifyPolicyListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupNotifyPolicyListResponse describeMonitorGroupNotifyPolicyList(shared_ptr<DescribeMonitorGroupNotifyPolicyListRequest> request);
  DescribeMonitorGroupsResponse describeMonitorGroupsWithOptions(shared_ptr<DescribeMonitorGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorGroupsResponse describeMonitorGroups(shared_ptr<DescribeMonitorGroupsRequest> request);
  DescribeMonitorResourceQuotaAttributeResponse describeMonitorResourceQuotaAttributeWithOptions(shared_ptr<DescribeMonitorResourceQuotaAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitorResourceQuotaAttributeResponse describeMonitorResourceQuotaAttribute(shared_ptr<DescribeMonitorResourceQuotaAttributeRequest> request);
  DescribeMonitoringAgentAccessKeyResponse describeMonitoringAgentAccessKeyWithOptions(shared_ptr<DescribeMonitoringAgentAccessKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringAgentAccessKeyResponse describeMonitoringAgentAccessKey(shared_ptr<DescribeMonitoringAgentAccessKeyRequest> request);
  DescribeMonitoringAgentConfigResponse describeMonitoringAgentConfigWithOptions(shared_ptr<DescribeMonitoringAgentConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringAgentConfigResponse describeMonitoringAgentConfig(shared_ptr<DescribeMonitoringAgentConfigRequest> request);
  DescribeMonitoringAgentHostsResponse describeMonitoringAgentHostsWithOptions(shared_ptr<DescribeMonitoringAgentHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringAgentHostsResponse describeMonitoringAgentHosts(shared_ptr<DescribeMonitoringAgentHostsRequest> request);
  DescribeMonitoringAgentProcessesResponse describeMonitoringAgentProcessesWithOptions(shared_ptr<DescribeMonitoringAgentProcessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringAgentProcessesResponse describeMonitoringAgentProcesses(shared_ptr<DescribeMonitoringAgentProcessesRequest> request);
  DescribeMonitoringAgentStatusesResponse describeMonitoringAgentStatusesWithOptions(shared_ptr<DescribeMonitoringAgentStatusesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringAgentStatusesResponse describeMonitoringAgentStatuses(shared_ptr<DescribeMonitoringAgentStatusesRequest> request);
  DescribeMonitoringConfigResponse describeMonitoringConfigWithOptions(shared_ptr<DescribeMonitoringConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMonitoringConfigResponse describeMonitoringConfig(shared_ptr<DescribeMonitoringConfigRequest> request);
  DescribeProductResourceTagKeyListResponse describeProductResourceTagKeyListWithOptions(shared_ptr<DescribeProductResourceTagKeyListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProductResourceTagKeyListResponse describeProductResourceTagKeyList(shared_ptr<DescribeProductResourceTagKeyListRequest> request);
  DescribeProductsOfActiveMetricRuleResponse describeProductsOfActiveMetricRuleWithOptions(shared_ptr<DescribeProductsOfActiveMetricRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProductsOfActiveMetricRuleResponse describeProductsOfActiveMetricRule(shared_ptr<DescribeProductsOfActiveMetricRuleRequest> request);
  DescribeProjectMetaResponse describeProjectMetaWithOptions(shared_ptr<DescribeProjectMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectMetaResponse describeProjectMeta(shared_ptr<DescribeProjectMetaRequest> request);
  DescribeSiteMonitorAttributeResponse describeSiteMonitorAttributeWithOptions(shared_ptr<DescribeSiteMonitorAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorAttributeResponse describeSiteMonitorAttribute(shared_ptr<DescribeSiteMonitorAttributeRequest> request);
  DescribeSiteMonitorDataResponse describeSiteMonitorDataWithOptions(shared_ptr<DescribeSiteMonitorDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorDataResponse describeSiteMonitorData(shared_ptr<DescribeSiteMonitorDataRequest> request);
  DescribeSiteMonitorISPCityListResponse describeSiteMonitorISPCityListWithOptions(shared_ptr<DescribeSiteMonitorISPCityListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorISPCityListResponse describeSiteMonitorISPCityList(shared_ptr<DescribeSiteMonitorISPCityListRequest> request);
  DescribeSiteMonitorListResponse describeSiteMonitorListWithOptions(shared_ptr<DescribeSiteMonitorListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorListResponse describeSiteMonitorList(shared_ptr<DescribeSiteMonitorListRequest> request);
  DescribeSiteMonitorLogResponse describeSiteMonitorLogWithOptions(shared_ptr<DescribeSiteMonitorLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorLogResponse describeSiteMonitorLog(shared_ptr<DescribeSiteMonitorLogRequest> request);
  DescribeSiteMonitorQuotaResponse describeSiteMonitorQuotaWithOptions(shared_ptr<DescribeSiteMonitorQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorQuotaResponse describeSiteMonitorQuota(shared_ptr<DescribeSiteMonitorQuotaRequest> request);
  DescribeSiteMonitorStatisticsResponse describeSiteMonitorStatisticsWithOptions(shared_ptr<DescribeSiteMonitorStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSiteMonitorStatisticsResponse describeSiteMonitorStatistics(shared_ptr<DescribeSiteMonitorStatisticsRequest> request);
  DescribeSyntheticProbeListResponse describeSyntheticProbeListWithOptions(shared_ptr<DescribeSyntheticProbeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSyntheticProbeListResponse describeSyntheticProbeList(shared_ptr<DescribeSyntheticProbeListRequest> request);
  DescribeSystemEventAttributeResponse describeSystemEventAttributeWithOptions(shared_ptr<DescribeSystemEventAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemEventAttributeResponse describeSystemEventAttribute(shared_ptr<DescribeSystemEventAttributeRequest> request);
  DescribeSystemEventCountResponse describeSystemEventCountWithOptions(shared_ptr<DescribeSystemEventCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemEventCountResponse describeSystemEventCount(shared_ptr<DescribeSystemEventCountRequest> request);
  DescribeSystemEventHistogramResponse describeSystemEventHistogramWithOptions(shared_ptr<DescribeSystemEventHistogramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemEventHistogramResponse describeSystemEventHistogram(shared_ptr<DescribeSystemEventHistogramRequest> request);
  DescribeSystemEventMetaListResponse describeSystemEventMetaListWithOptions(shared_ptr<DescribeSystemEventMetaListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemEventMetaListResponse describeSystemEventMetaList(shared_ptr<DescribeSystemEventMetaListRequest> request);
  DescribeTagKeyListResponse describeTagKeyListWithOptions(shared_ptr<DescribeTagKeyListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagKeyListResponse describeTagKeyList(shared_ptr<DescribeTagKeyListRequest> request);
  DescribeTagValueListResponse describeTagValueListWithOptions(shared_ptr<DescribeTagValueListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTagValueListResponse describeTagValueList(shared_ptr<DescribeTagValueListRequest> request);
  DescribeUnhealthyHostAvailabilityResponse describeUnhealthyHostAvailabilityWithOptions(shared_ptr<DescribeUnhealthyHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUnhealthyHostAvailabilityResponse describeUnhealthyHostAvailability(shared_ptr<DescribeUnhealthyHostAvailabilityRequest> request);
  DisableActiveMetricRuleResponse disableActiveMetricRuleWithOptions(shared_ptr<DisableActiveMetricRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableActiveMetricRuleResponse disableActiveMetricRule(shared_ptr<DisableActiveMetricRuleRequest> request);
  DisableEventRulesResponse disableEventRulesWithOptions(shared_ptr<DisableEventRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableEventRulesResponse disableEventRules(shared_ptr<DisableEventRulesRequest> request);
  DisableHostAvailabilityResponse disableHostAvailabilityWithOptions(shared_ptr<DisableHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableHostAvailabilityResponse disableHostAvailability(shared_ptr<DisableHostAvailabilityRequest> request);
  DisableMetricRulesResponse disableMetricRulesWithOptions(shared_ptr<DisableMetricRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableMetricRulesResponse disableMetricRules(shared_ptr<DisableMetricRulesRequest> request);
  DisableSiteMonitorsResponse disableSiteMonitorsWithOptions(shared_ptr<DisableSiteMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSiteMonitorsResponse disableSiteMonitors(shared_ptr<DisableSiteMonitorsRequest> request);
  EnableActiveMetricRuleResponse enableActiveMetricRuleWithOptions(shared_ptr<EnableActiveMetricRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableActiveMetricRuleResponse enableActiveMetricRule(shared_ptr<EnableActiveMetricRuleRequest> request);
  EnableEventRulesResponse enableEventRulesWithOptions(shared_ptr<EnableEventRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableEventRulesResponse enableEventRules(shared_ptr<EnableEventRulesRequest> request);
  EnableHostAvailabilityResponse enableHostAvailabilityWithOptions(shared_ptr<EnableHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableHostAvailabilityResponse enableHostAvailability(shared_ptr<EnableHostAvailabilityRequest> request);
  EnableMetricRuleBlackListResponse enableMetricRuleBlackListWithOptions(shared_ptr<EnableMetricRuleBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableMetricRuleBlackListResponse enableMetricRuleBlackList(shared_ptr<EnableMetricRuleBlackListRequest> request);
  EnableMetricRulesResponse enableMetricRulesWithOptions(shared_ptr<EnableMetricRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableMetricRulesResponse enableMetricRules(shared_ptr<EnableMetricRulesRequest> request);
  EnableSiteMonitorsResponse enableSiteMonitorsWithOptions(shared_ptr<EnableSiteMonitorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSiteMonitorsResponse enableSiteMonitors(shared_ptr<EnableSiteMonitorsRequest> request);
  InstallMonitoringAgentResponse installMonitoringAgentWithOptions(shared_ptr<InstallMonitoringAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallMonitoringAgentResponse installMonitoringAgent(shared_ptr<InstallMonitoringAgentRequest> request);
  ModifyGroupMonitoringAgentProcessResponse modifyGroupMonitoringAgentProcessWithOptions(shared_ptr<ModifyGroupMonitoringAgentProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGroupMonitoringAgentProcessResponse modifyGroupMonitoringAgentProcess(shared_ptr<ModifyGroupMonitoringAgentProcessRequest> request);
  ModifyHostAvailabilityResponse modifyHostAvailabilityWithOptions(shared_ptr<ModifyHostAvailabilityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostAvailabilityResponse modifyHostAvailability(shared_ptr<ModifyHostAvailabilityRequest> request);
  ModifyHostInfoResponse modifyHostInfoWithOptions(shared_ptr<ModifyHostInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHostInfoResponse modifyHostInfo(shared_ptr<ModifyHostInfoRequest> request);
  ModifyHybridMonitorNamespaceResponse modifyHybridMonitorNamespaceWithOptions(shared_ptr<ModifyHybridMonitorNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridMonitorNamespaceResponse modifyHybridMonitorNamespace(shared_ptr<ModifyHybridMonitorNamespaceRequest> request);
  ModifyHybridMonitorSLSGroupResponse modifyHybridMonitorSLSGroupWithOptions(shared_ptr<ModifyHybridMonitorSLSGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridMonitorSLSGroupResponse modifyHybridMonitorSLSGroup(shared_ptr<ModifyHybridMonitorSLSGroupRequest> request);
  ModifyHybridMonitorTaskResponse modifyHybridMonitorTaskWithOptions(shared_ptr<ModifyHybridMonitorTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridMonitorTaskResponse modifyHybridMonitorTask(shared_ptr<ModifyHybridMonitorTaskRequest> request);
  ModifyMetricRuleBlackListResponse modifyMetricRuleBlackListWithOptions(shared_ptr<ModifyMetricRuleBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMetricRuleBlackListResponse modifyMetricRuleBlackList(shared_ptr<ModifyMetricRuleBlackListRequest> request);
  ModifyMetricRuleTemplateResponse modifyMetricRuleTemplateWithOptions(shared_ptr<ModifyMetricRuleTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMetricRuleTemplateResponse modifyMetricRuleTemplate(shared_ptr<ModifyMetricRuleTemplateRequest> request);
  ModifyMonitorGroupResponse modifyMonitorGroupWithOptions(shared_ptr<ModifyMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMonitorGroupResponse modifyMonitorGroup(shared_ptr<ModifyMonitorGroupRequest> request);
  ModifyMonitorGroupInstancesResponse modifyMonitorGroupInstancesWithOptions(shared_ptr<ModifyMonitorGroupInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMonitorGroupInstancesResponse modifyMonitorGroupInstances(shared_ptr<ModifyMonitorGroupInstancesRequest> request);
  ModifySiteMonitorResponse modifySiteMonitorWithOptions(shared_ptr<ModifySiteMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySiteMonitorResponse modifySiteMonitor(shared_ptr<ModifySiteMonitorRequest> request);
  OpenCmsServiceResponse openCmsServiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenCmsServiceResponse openCmsService();
  PutContactResponse putContactWithOptions(shared_ptr<PutContactRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutContactResponse putContact(shared_ptr<PutContactRequest> request);
  PutContactGroupResponse putContactGroupWithOptions(shared_ptr<PutContactGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutContactGroupResponse putContactGroup(shared_ptr<PutContactGroupRequest> request);
  PutCustomEventResponse putCustomEventWithOptions(shared_ptr<PutCustomEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutCustomEventResponse putCustomEvent(shared_ptr<PutCustomEventRequest> request);
  PutCustomEventRuleResponse putCustomEventRuleWithOptions(shared_ptr<PutCustomEventRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutCustomEventRuleResponse putCustomEventRule(shared_ptr<PutCustomEventRuleRequest> request);
  PutCustomMetricResponse putCustomMetricWithOptions(shared_ptr<PutCustomMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutCustomMetricResponse putCustomMetric(shared_ptr<PutCustomMetricRequest> request);
  PutCustomMetricRuleResponse putCustomMetricRuleWithOptions(shared_ptr<PutCustomMetricRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutCustomMetricRuleResponse putCustomMetricRule(shared_ptr<PutCustomMetricRuleRequest> request);
  PutEventRuleResponse putEventRuleWithOptions(shared_ptr<PutEventRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutEventRuleResponse putEventRule(shared_ptr<PutEventRuleRequest> request);
  PutEventRuleTargetsResponse putEventRuleTargetsWithOptions(shared_ptr<PutEventRuleTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutEventRuleTargetsResponse putEventRuleTargets(shared_ptr<PutEventRuleTargetsRequest> request);
  PutExporterOutputResponse putExporterOutputWithOptions(shared_ptr<PutExporterOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutExporterOutputResponse putExporterOutput(shared_ptr<PutExporterOutputRequest> request);
  PutExporterRuleResponse putExporterRuleWithOptions(shared_ptr<PutExporterRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutExporterRuleResponse putExporterRule(shared_ptr<PutExporterRuleRequest> request);
  PutGroupMetricRuleResponse putGroupMetricRuleWithOptions(shared_ptr<PutGroupMetricRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutGroupMetricRuleResponse putGroupMetricRule(shared_ptr<PutGroupMetricRuleRequest> request);
  PutHybridMonitorMetricDataResponse putHybridMonitorMetricDataWithOptions(shared_ptr<PutHybridMonitorMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutHybridMonitorMetricDataResponse putHybridMonitorMetricData(shared_ptr<PutHybridMonitorMetricDataRequest> request);
  PutLogMonitorResponse putLogMonitorWithOptions(shared_ptr<PutLogMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutLogMonitorResponse putLogMonitor(shared_ptr<PutLogMonitorRequest> request);
  PutMetricRuleTargetsResponse putMetricRuleTargetsWithOptions(shared_ptr<PutMetricRuleTargetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutMetricRuleTargetsResponse putMetricRuleTargets(shared_ptr<PutMetricRuleTargetsRequest> request);
  PutMonitorGroupDynamicRuleResponse putMonitorGroupDynamicRuleWithOptions(shared_ptr<PutMonitorGroupDynamicRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutMonitorGroupDynamicRuleResponse putMonitorGroupDynamicRule(shared_ptr<PutMonitorGroupDynamicRuleRequest> request);
  PutMonitoringConfigResponse putMonitoringConfigWithOptions(shared_ptr<PutMonitoringConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutMonitoringConfigResponse putMonitoringConfig(shared_ptr<PutMonitoringConfigRequest> request);
  PutResourceMetricRuleResponse putResourceMetricRuleWithOptions(shared_ptr<PutResourceMetricRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutResourceMetricRuleResponse putResourceMetricRule(shared_ptr<PutResourceMetricRuleRequest> request);
  PutResourceMetricRulesResponse putResourceMetricRulesWithOptions(shared_ptr<PutResourceMetricRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutResourceMetricRulesResponse putResourceMetricRules(shared_ptr<PutResourceMetricRulesRequest> request);
  RemoveTagsResponse removeTagsWithOptions(shared_ptr<RemoveTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTagsResponse removeTags(shared_ptr<RemoveTagsRequest> request);
  SendDryRunSystemEventResponse sendDryRunSystemEventWithOptions(shared_ptr<SendDryRunSystemEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendDryRunSystemEventResponse sendDryRunSystemEvent(shared_ptr<SendDryRunSystemEventRequest> request);
  UninstallMonitoringAgentResponse uninstallMonitoringAgentWithOptions(shared_ptr<UninstallMonitoringAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallMonitoringAgentResponse uninstallMonitoringAgent(shared_ptr<UninstallMonitoringAgentRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Cms20190101

#endif
